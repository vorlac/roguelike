/**
 * Loader generated by glad 2.0.4 on Sat Nov 25 05:52:39 2023
 *
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 *
 * Generator: C/C++
 * Specification: gl
 * Extensions: 619
 *
 * APIs:
 *  - gl:core=4.6
 *
 * Options:
 *  - ALIAS = True
 *  - DEBUG = True
 *  - HEADER_ONLY = False
 *  - LOADER = False
 *  - MX = False
 *  - ON_DEMAND = False
 *
 * Commandline:
 *    --api='gl:core=4.6'
 * --extensions='GL_3DFX_multisample,GL_3DFX_tbuffer,GL_3DFX_texture_compression_FXT1,GL_AMD_blend_minmax_factor,GL_AMD_conservative_depth,GL_AMD_debug_output,GL_AMD_depth_clamp_separate,GL_AMD_draw_buffers_blend,GL_AMD_framebuffer_multisample_advanced,GL_AMD_framebuffer_sample_positions,GL_AMD_gcn_shader,GL_AMD_gpu_shader_half_float,GL_AMD_gpu_shader_int16,GL_AMD_gpu_shader_int64,GL_AMD_interleaved_elements,GL_AMD_multi_draw_indirect,GL_AMD_name_gen_delete,GL_AMD_occlusion_query_event,GL_AMD_performance_monitor,GL_AMD_pinned_memory,GL_AMD_query_buffer_object,GL_AMD_sample_positions,GL_AMD_seamless_cubemap_per_texture,GL_AMD_shader_atomic_counter_ops,GL_AMD_shader_ballot,GL_AMD_shader_explicit_vertex_parameter,GL_AMD_shader_gpu_shader_half_float_fetch,GL_AMD_shader_image_load_store_lod,GL_AMD_shader_stencil_export,GL_AMD_shader_trinary_minmax,GL_AMD_sparse_texture,GL_AMD_stencil_operation_extended,GL_AMD_texture_gather_bias_lod,GL_AMD_texture_texture4,GL_AMD_transform_feedback3_lines_triangles,GL_AMD_transform_feedback4,GL_AMD_vertex_shader_layer,GL_AMD_vertex_shader_tessellator,GL_AMD_vertex_shader_viewport_index,GL_APPLE_aux_depth_stencil,GL_APPLE_client_storage,GL_APPLE_element_array,GL_APPLE_fence,GL_APPLE_float_pixels,GL_APPLE_flush_buffer_range,GL_APPLE_object_purgeable,GL_APPLE_rgb_422,GL_APPLE_row_bytes,GL_APPLE_specular_vector,GL_APPLE_texture_range,GL_APPLE_transform_hint,GL_APPLE_vertex_array_object,GL_APPLE_vertex_array_range,GL_APPLE_vertex_program_evaluators,GL_APPLE_ycbcr_422,GL_ARB_ES2_compatibility,GL_ARB_ES3_1_compatibility,GL_ARB_ES3_2_compatibility,GL_ARB_ES3_compatibility,GL_ARB_arrays_of_arrays,GL_ARB_base_instance,GL_ARB_bindless_texture,GL_ARB_blend_func_extended,GL_ARB_buffer_storage,GL_ARB_cl_event,GL_ARB_clear_buffer_object,GL_ARB_clear_texture,GL_ARB_clip_control,GL_ARB_color_buffer_float,GL_ARB_compatibility,GL_ARB_compressed_texture_pixel_storage,GL_ARB_compute_shader,GL_ARB_compute_variable_group_size,GL_ARB_conditional_render_inverted,GL_ARB_conservative_depth,GL_ARB_copy_buffer,GL_ARB_copy_image,GL_ARB_cull_distance,GL_ARB_debug_output,GL_ARB_depth_buffer_float,GL_ARB_depth_clamp,GL_ARB_depth_texture,GL_ARB_derivative_control,GL_ARB_direct_state_access,GL_ARB_draw_buffers,GL_ARB_draw_buffers_blend,GL_ARB_draw_elements_base_vertex,GL_ARB_draw_indirect,GL_ARB_draw_instanced,GL_ARB_enhanced_layouts,GL_ARB_explicit_attrib_location,GL_ARB_explicit_uniform_location,GL_ARB_fragment_coord_conventions,GL_ARB_fragment_layer_viewport,GL_ARB_fragment_program,GL_ARB_fragment_program_shadow,GL_ARB_fragment_shader,GL_ARB_fragment_shader_interlock,GL_ARB_framebuffer_no_attachments,GL_ARB_framebuffer_object,GL_ARB_framebuffer_sRGB,GL_ARB_geometry_shader4,GL_ARB_get_program_binary,GL_ARB_get_texture_sub_image,GL_ARB_gl_spirv,GL_ARB_gpu_shader5,GL_ARB_gpu_shader_fp64,GL_ARB_gpu_shader_int64,GL_ARB_half_float_pixel,GL_ARB_half_float_vertex,GL_ARB_imaging,GL_ARB_indirect_parameters,GL_ARB_instanced_arrays,GL_ARB_internalformat_query,GL_ARB_internalformat_query2,GL_ARB_invalidate_subdata,GL_ARB_map_buffer_alignment,GL_ARB_map_buffer_range,GL_ARB_matrix_palette,GL_ARB_multi_bind,GL_ARB_multi_draw_indirect,GL_ARB_multisample,GL_ARB_multitexture,GL_ARB_occlusion_query,GL_ARB_occlusion_query2,GL_ARB_parallel_shader_compile,GL_ARB_pipeline_statistics_query,GL_ARB_pixel_buffer_object,GL_ARB_point_parameters,GL_ARB_point_sprite,GL_ARB_polygon_offset_clamp,GL_ARB_post_depth_coverage,GL_ARB_program_interface_query,GL_ARB_provoking_vertex,GL_ARB_query_buffer_object,GL_ARB_robust_buffer_access_behavior,GL_ARB_robustness,GL_ARB_robustness_isolation,GL_ARB_sample_locations,GL_ARB_sample_shading,GL_ARB_sampler_objects,GL_ARB_seamless_cube_map,GL_ARB_seamless_cubemap_per_texture,GL_ARB_separate_shader_objects,GL_ARB_shader_atomic_counter_ops,GL_ARB_shader_atomic_counters,GL_ARB_shader_ballot,GL_ARB_shader_bit_encoding,GL_ARB_shader_clock,GL_ARB_shader_draw_parameters,GL_ARB_shader_group_vote,GL_ARB_shader_image_load_store,GL_ARB_shader_image_size,GL_ARB_shader_objects,GL_ARB_shader_precision,GL_ARB_shader_stencil_export,GL_ARB_shader_storage_buffer_object,GL_ARB_shader_subroutine,GL_ARB_shader_texture_image_samples,GL_ARB_shader_texture_lod,GL_ARB_shader_viewport_layer_array,GL_ARB_shading_language_100,GL_ARB_shading_language_420pack,GL_ARB_shading_language_include,GL_ARB_shading_language_packing,GL_ARB_shadow,GL_ARB_shadow_ambient,GL_ARB_sparse_buffer,GL_ARB_sparse_texture,GL_ARB_sparse_texture2,GL_ARB_sparse_texture_clamp,GL_ARB_spirv_extensions,GL_ARB_stencil_texturing,GL_ARB_sync,GL_ARB_tessellation_shader,GL_ARB_texture_barrier,GL_ARB_texture_border_clamp,GL_ARB_texture_buffer_object,GL_ARB_texture_buffer_object_rgb32,GL_ARB_texture_buffer_range,GL_ARB_texture_compression,GL_ARB_texture_compression_bptc,GL_ARB_texture_compression_rgtc,GL_ARB_texture_cube_map,GL_ARB_texture_cube_map_array,GL_ARB_texture_env_add,GL_ARB_texture_env_combine,GL_ARB_texture_env_crossbar,GL_ARB_texture_env_dot3,GL_ARB_texture_filter_anisotropic,GL_ARB_texture_filter_minmax,GL_ARB_texture_float,GL_ARB_texture_gather,GL_ARB_texture_mirror_clamp_to_edge,GL_ARB_texture_mirrored_repeat,GL_ARB_texture_multisample,GL_ARB_texture_non_power_of_two,GL_ARB_texture_query_levels,GL_ARB_texture_query_lod,GL_ARB_texture_rectangle,GL_ARB_texture_rg,GL_ARB_texture_rgb10_a2ui,GL_ARB_texture_stencil8,GL_ARB_texture_storage,GL_ARB_texture_storage_multisample,GL_ARB_texture_swizzle,GL_ARB_texture_view,GL_ARB_timer_query,GL_ARB_transform_feedback2,GL_ARB_transform_feedback3,GL_ARB_transform_feedback_instanced,GL_ARB_transform_feedback_overflow_query,GL_ARB_transpose_matrix,GL_ARB_uniform_buffer_object,GL_ARB_vertex_array_bgra,GL_ARB_vertex_array_object,GL_ARB_vertex_attrib_64bit,GL_ARB_vertex_attrib_binding,GL_ARB_vertex_blend,GL_ARB_vertex_buffer_object,GL_ARB_vertex_program,GL_ARB_vertex_shader,GL_ARB_vertex_type_10f_11f_11f_rev,GL_ARB_vertex_type_2_10_10_10_rev,GL_ARB_viewport_array,GL_ARB_window_pos,GL_ATI_draw_buffers,GL_ATI_element_array,GL_ATI_envmap_bumpmap,GL_ATI_fragment_shader,GL_ATI_map_object_buffer,GL_ATI_meminfo,GL_ATI_pixel_format_float,GL_ATI_pn_triangles,GL_ATI_separate_stencil,GL_ATI_text_fragment_shader,GL_ATI_texture_env_combine3,GL_ATI_texture_float,GL_ATI_texture_mirror_once,GL_ATI_vertex_array_object,GL_ATI_vertex_attrib_array_object,GL_ATI_vertex_streams,GL_EXT_422_pixels,GL_EXT_EGL_image_storage,GL_EXT_EGL_sync,GL_EXT_abgr,GL_EXT_bgra,GL_EXT_bindable_uniform,GL_EXT_blend_color,GL_EXT_blend_equation_separate,GL_EXT_blend_func_separate,GL_EXT_blend_logic_op,GL_EXT_blend_minmax,GL_EXT_blend_subtract,GL_EXT_clip_volume_hint,GL_EXT_cmyka,GL_EXT_color_subtable,GL_EXT_compiled_vertex_array,GL_EXT_convolution,GL_EXT_coordinate_frame,GL_EXT_copy_texture,GL_EXT_cull_vertex,GL_EXT_debug_label,GL_EXT_debug_marker,GL_EXT_depth_bounds_test,GL_EXT_direct_state_access,GL_EXT_draw_buffers2,GL_EXT_draw_instanced,GL_EXT_draw_range_elements,GL_EXT_external_buffer,GL_EXT_fog_coord,GL_EXT_framebuffer_blit,GL_EXT_framebuffer_blit_layers,GL_EXT_framebuffer_multisample,GL_EXT_framebuffer_multisample_blit_scaled,GL_EXT_framebuffer_object,GL_EXT_framebuffer_sRGB,GL_EXT_geometry_shader4,GL_EXT_gpu_program_parameters,GL_EXT_gpu_shader4,GL_EXT_histogram,GL_EXT_index_array_formats,GL_EXT_index_func,GL_EXT_index_material,GL_EXT_index_texture,GL_EXT_light_texture,GL_EXT_memory_object,GL_EXT_memory_object_fd,GL_EXT_memory_object_win32,GL_EXT_misc_attribute,GL_EXT_multi_draw_arrays,GL_EXT_multisample,GL_EXT_multiview_tessellation_geometry_shader,GL_EXT_multiview_texture_multisample,GL_EXT_multiview_timer_query,GL_EXT_packed_depth_stencil,GL_EXT_packed_float,GL_EXT_packed_pixels,GL_EXT_paletted_texture,GL_EXT_pixel_buffer_object,GL_EXT_pixel_transform,GL_EXT_pixel_transform_color_table,GL_EXT_point_parameters,GL_EXT_polygon_offset,GL_EXT_polygon_offset_clamp,GL_EXT_post_depth_coverage,GL_EXT_provoking_vertex,GL_EXT_raster_multisample,GL_EXT_rescale_normal,GL_EXT_secondary_color,GL_EXT_semaphore,GL_EXT_semaphore_fd,GL_EXT_semaphore_win32,GL_EXT_separate_shader_objects,GL_EXT_separate_specular_color,GL_EXT_shader_framebuffer_fetch,GL_EXT_shader_framebuffer_fetch_non_coherent,GL_EXT_shader_image_load_formatted,GL_EXT_shader_image_load_store,GL_EXT_shader_integer_mix,GL_EXT_shader_samples_identical,GL_EXT_shadow_funcs,GL_EXT_shared_texture_palette,GL_EXT_sparse_texture2,GL_EXT_stencil_clear_tag,GL_EXT_stencil_two_side,GL_EXT_stencil_wrap,GL_EXT_subtexture,GL_EXT_texture,GL_EXT_texture3D,GL_EXT_texture_array,GL_EXT_texture_buffer_object,GL_EXT_texture_compression_latc,GL_EXT_texture_compression_rgtc,GL_EXT_texture_compression_s3tc,GL_EXT_texture_cube_map,GL_EXT_texture_env_add,GL_EXT_texture_env_combine,GL_EXT_texture_env_dot3,GL_EXT_texture_filter_anisotropic,GL_EXT_texture_filter_minmax,GL_EXT_texture_integer,GL_EXT_texture_lod_bias,GL_EXT_texture_mirror_clamp,GL_EXT_texture_object,GL_EXT_texture_perturb_normal,GL_EXT_texture_sRGB,GL_EXT_texture_sRGB_R8,GL_EXT_texture_sRGB_RG8,GL_EXT_texture_sRGB_decode,GL_EXT_texture_shadow_lod,GL_EXT_texture_shared_exponent,GL_EXT_texture_snorm,GL_EXT_texture_storage,GL_EXT_texture_swizzle,GL_EXT_timer_query,GL_EXT_transform_feedback,GL_EXT_vertex_array,GL_EXT_vertex_array_bgra,GL_EXT_vertex_attrib_64bit,GL_EXT_vertex_shader,GL_EXT_vertex_weighting,GL_EXT_win32_keyed_mutex,GL_EXT_window_rectangles,GL_EXT_x11_sync_object,GL_GREMEDY_frame_terminator,GL_GREMEDY_string_marker,GL_HP_convolution_border_modes,GL_HP_image_transform,GL_HP_occlusion_test,GL_HP_texture_lighting,GL_IBM_cull_vertex,GL_IBM_multimode_draw_arrays,GL_IBM_rasterpos_clip,GL_IBM_static_data,GL_IBM_texture_mirrored_repeat,GL_IBM_vertex_array_lists,GL_INGR_blend_func_separate,GL_INGR_color_clamp,GL_INGR_interlace_read,GL_INTEL_blackhole_render,GL_INTEL_conservative_rasterization,GL_INTEL_fragment_shader_ordering,GL_INTEL_framebuffer_CMAA,GL_INTEL_map_texture,GL_INTEL_parallel_arrays,GL_INTEL_performance_query,GL_KHR_blend_equation_advanced,GL_KHR_blend_equation_advanced_coherent,GL_KHR_context_flush_control,GL_KHR_debug,GL_KHR_no_error,GL_KHR_parallel_shader_compile,GL_KHR_robust_buffer_access_behavior,GL_KHR_robustness,GL_KHR_shader_subgroup,GL_KHR_texture_compression_astc_hdr,GL_KHR_texture_compression_astc_ldr,GL_KHR_texture_compression_astc_sliced_3d,GL_MESAX_texture_stack,GL_MESA_framebuffer_flip_x,GL_MESA_framebuffer_flip_y,GL_MESA_framebuffer_swap_xy,GL_MESA_pack_invert,GL_MESA_program_binary_formats,GL_MESA_resize_buffers,GL_MESA_shader_integer_functions,GL_MESA_tile_raster_order,GL_MESA_window_pos,GL_MESA_ycbcr_texture,GL_NVX_blend_equation_advanced_multi_draw_buffers,GL_NVX_conditional_render,GL_NVX_gpu_memory_info,GL_NVX_gpu_multicast2,GL_NVX_linked_gpu_multicast,GL_NVX_progress_fence,GL_NV_alpha_to_coverage_dither_control,GL_NV_bindless_multi_draw_indirect,GL_NV_bindless_multi_draw_indirect_count,GL_NV_bindless_texture,GL_NV_blend_equation_advanced,GL_NV_blend_equation_advanced_coherent,GL_NV_blend_minmax_factor,GL_NV_blend_square,GL_NV_clip_space_w_scaling,GL_NV_command_list,GL_NV_compute_program5,GL_NV_compute_shader_derivatives,GL_NV_conditional_render,GL_NV_conservative_raster,GL_NV_conservative_raster_dilate,GL_NV_conservative_raster_pre_snap,GL_NV_conservative_raster_pre_snap_triangles,GL_NV_conservative_raster_underestimation,GL_NV_copy_depth_to_color,GL_NV_copy_image,GL_NV_deep_texture3D,GL_NV_depth_buffer_float,GL_NV_depth_clamp,GL_NV_draw_texture,GL_NV_draw_vulkan_image,GL_NV_evaluators,GL_NV_explicit_multisample,GL_NV_fence,GL_NV_fill_rectangle,GL_NV_float_buffer,GL_NV_fog_distance,GL_NV_fragment_coverage_to_color,GL_NV_fragment_program,GL_NV_fragment_program2,GL_NV_fragment_program4,GL_NV_fragment_program_option,GL_NV_fragment_shader_barycentric,GL_NV_fragment_shader_interlock,GL_NV_framebuffer_mixed_samples,GL_NV_framebuffer_multisample_coverage,GL_NV_geometry_program4,GL_NV_geometry_shader4,GL_NV_geometry_shader_passthrough,GL_NV_gpu_multicast,GL_NV_gpu_program4,GL_NV_gpu_program5,GL_NV_gpu_program5_mem_extended,GL_NV_gpu_shader5,GL_NV_half_float,GL_NV_internalformat_sample_query,GL_NV_light_max_exponent,GL_NV_memory_attachment,GL_NV_memory_object_sparse,GL_NV_mesh_shader,GL_NV_multisample_coverage,GL_NV_multisample_filter_hint,GL_NV_occlusion_query,GL_NV_packed_depth_stencil,GL_NV_parameter_buffer_object,GL_NV_parameter_buffer_object2,GL_NV_path_rendering,GL_NV_path_rendering_shared_edge,GL_NV_pixel_data_range,GL_NV_point_sprite,GL_NV_present_video,GL_NV_primitive_restart,GL_NV_primitive_shading_rate,GL_NV_query_resource,GL_NV_query_resource_tag,GL_NV_register_combiners,GL_NV_register_combiners2,GL_NV_representative_fragment_test,GL_NV_robustness_video_memory_purge,GL_NV_sample_locations,GL_NV_sample_mask_override_coverage,GL_NV_scissor_exclusive,GL_NV_shader_atomic_counters,GL_NV_shader_atomic_float,GL_NV_shader_atomic_float64,GL_NV_shader_atomic_fp16_vector,GL_NV_shader_atomic_int64,GL_NV_shader_buffer_load,GL_NV_shader_buffer_store,GL_NV_shader_storage_buffer_object,GL_NV_shader_subgroup_partitioned,GL_NV_shader_texture_footprint,GL_NV_shader_thread_group,GL_NV_shader_thread_shuffle,GL_NV_shading_rate_image,GL_NV_stereo_view_rendering,GL_NV_tessellation_program5,GL_NV_texgen_emboss,GL_NV_texgen_reflection,GL_NV_texture_barrier,GL_NV_texture_compression_vtc,GL_NV_texture_env_combine4,GL_NV_texture_expand_normal,GL_NV_texture_multisample,GL_NV_texture_rectangle,GL_NV_texture_rectangle_compressed,GL_NV_texture_shader,GL_NV_texture_shader2,GL_NV_texture_shader3,GL_NV_timeline_semaphore,GL_NV_transform_feedback,GL_NV_transform_feedback2,GL_NV_uniform_buffer_std430_layout,GL_NV_uniform_buffer_unified_memory,GL_NV_vdpau_interop,GL_NV_vdpau_interop2,GL_NV_vertex_array_range,GL_NV_vertex_array_range2,GL_NV_vertex_attrib_integer_64bit,GL_NV_vertex_buffer_unified_memory,GL_NV_vertex_program,GL_NV_vertex_program1_1,GL_NV_vertex_program2,GL_NV_vertex_program2_option,GL_NV_vertex_program3,GL_NV_vertex_program4,GL_NV_video_capture,GL_NV_viewport_array2,GL_NV_viewport_swizzle,GL_OES_byte_coordinates,GL_OES_compressed_paletted_texture,GL_OES_fixed_point,GL_OES_query_matrix,GL_OES_read_format,GL_OES_single_precision,GL_OML_interlace,GL_OML_resample,GL_OML_subsample,GL_OVR_multiview,GL_OVR_multiview2,GL_PGI_misc_hints,GL_PGI_vertex_hints,GL_REND_screen_coordinates,GL_S3_s3tc,GL_SGIS_detail_texture,GL_SGIS_fog_function,GL_SGIS_generate_mipmap,GL_SGIS_multisample,GL_SGIS_pixel_texture,GL_SGIS_point_line_texgen,GL_SGIS_point_parameters,GL_SGIS_sharpen_texture,GL_SGIS_texture4D,GL_SGIS_texture_border_clamp,GL_SGIS_texture_color_mask,GL_SGIS_texture_edge_clamp,GL_SGIS_texture_filter4,GL_SGIS_texture_lod,GL_SGIS_texture_select,GL_SGIX_async,GL_SGIX_async_histogram,GL_SGIX_async_pixel,GL_SGIX_blend_alpha_minmax,GL_SGIX_calligraphic_fragment,GL_SGIX_clipmap,GL_SGIX_convolution_accuracy,GL_SGIX_depth_pass_instrument,GL_SGIX_depth_texture,GL_SGIX_flush_raster,GL_SGIX_fog_offset,GL_SGIX_fragment_lighting,GL_SGIX_framezoom,GL_SGIX_igloo_interface,GL_SGIX_instruments,GL_SGIX_interlace,GL_SGIX_ir_instrument1,GL_SGIX_list_priority,GL_SGIX_pixel_texture,GL_SGIX_pixel_tiles,GL_SGIX_polynomial_ffd,GL_SGIX_reference_plane,GL_SGIX_resample,GL_SGIX_scalebias_hint,GL_SGIX_shadow,GL_SGIX_shadow_ambient,GL_SGIX_sprite,GL_SGIX_subsample,GL_SGIX_tag_sample_buffer,GL_SGIX_texture_add_env,GL_SGIX_texture_coordinate_clamp,GL_SGIX_texture_lod_bias,GL_SGIX_texture_multi_buffer,GL_SGIX_texture_scale_bias,GL_SGIX_vertex_preclip,GL_SGIX_ycrcb,GL_SGIX_ycrcb_subsample,GL_SGIX_ycrcba,GL_SGI_color_matrix,GL_SGI_color_table,GL_SGI_texture_color_table,GL_SUNX_constant_data,GL_SUN_convolution_border_modes,GL_SUN_global_alpha,GL_SUN_mesh_array,GL_SUN_slice_accum,GL_SUN_triangle_list,GL_SUN_vertex,GL_WIN_phong_shading,GL_WIN_specular_fog'
 * c --alias --debug
 *
 * Online:
 *    http://glad.sh/#api=gl%3Acore%3D4.6&generator=c&options=ALIAS%2CDEBUG
 *
 */

#ifndef GLAD_GL_H_
#define GLAD_GL_H_

#ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifdef __gl_h_
  #error OpenGL (gl.h) header already included (API: gl), remove previous include!
#endif
#define __gl_h_ 1
#ifdef __gl3_h_
  #error OpenGL (gl3.h) header already included (API: gl), remove previous include!
#endif
#define __gl3_h_ 1
#ifdef __glext_h_
  #error OpenGL (glext.h) header already included (API: gl), remove previous include!
#endif
#define __glext_h_ 1
#ifdef __gl3ext_h_
  #error OpenGL (gl3ext.h) header already included (API: gl), remove previous include!
#endif
#define __gl3ext_h_ 1
#ifdef __clang__
  #pragma clang diagnostic pop
#endif

#define GLAD_GL
#define GLAD_OPTION_GL_ALIAS
#define GLAD_OPTION_GL_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef GLAD_PLATFORM_H_
  #define GLAD_PLATFORM_H_

  #ifndef GLAD_PLATFORM_WIN32
    #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
      #define GLAD_PLATFORM_WIN32 1
    #else
      #define GLAD_PLATFORM_WIN32 0
    #endif
  #endif

  #ifndef GLAD_PLATFORM_APPLE
    #ifdef __APPLE__
      #define GLAD_PLATFORM_APPLE 1
    #else
      #define GLAD_PLATFORM_APPLE 0
    #endif
  #endif

  #ifndef GLAD_PLATFORM_EMSCRIPTEN
    #ifdef __EMSCRIPTEN__
      #define GLAD_PLATFORM_EMSCRIPTEN 1
    #else
      #define GLAD_PLATFORM_EMSCRIPTEN 0
    #endif
  #endif

  #ifndef GLAD_PLATFORM_UWP
    #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
      #ifdef __has_include
        #if __has_include(<winapifamily.h>)
          #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
        #endif
      #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
      #endif
    #endif

    #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
      #include <winapifamily.h>
      #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && \
          WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
        #define GLAD_PLATFORM_UWP 1
      #endif
    #endif

    #ifndef GLAD_PLATFORM_UWP
      #define GLAD_PLATFORM_UWP 0
    #endif
  #endif

  #ifdef __GNUC__
    #define GLAD_GNUC_EXTENSION __extension__
  #else
    #define GLAD_GNUC_EXTENSION
  #endif

  #define GLAD_UNUSED(x) (void)(x)

  #ifndef GLAD_API_CALL
    #if defined(GLAD_API_CALL_EXPORT)
      #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
        #if defined(GLAD_API_CALL_EXPORT_BUILD)
          #if defined(__GNUC__)
            #define GLAD_API_CALL __attribute__((dllexport)) extern
          #else
            #define GLAD_API_CALL __declspec(dllexport) extern
          #endif
        #else
          #if defined(__GNUC__)
            #define GLAD_API_CALL __attribute__((dllimport)) extern
          #else
            #define GLAD_API_CALL __declspec(dllimport) extern
          #endif
        #endif
      #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
        #define GLAD_API_CALL __attribute__((visibility("default"))) extern
      #else
        #define GLAD_API_CALL extern
      #endif
    #else
      #define GLAD_API_CALL extern
    #endif
  #endif

  #ifdef APIENTRY
    #define GLAD_API_PTR APIENTRY
  #elif GLAD_PLATFORM_WIN32
    #define GLAD_API_PTR __stdcall
  #else
    #define GLAD_API_PTR
  #endif

  #ifndef GLAPI
    #define GLAPI GLAD_API_CALL
  #endif

  #ifndef GLAPIENTRY
    #define GLAPIENTRY GLAD_API_PTR
  #endif

  #define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
  #define GLAD_VERSION_MAJOR(version)     (version / 10000)
  #define GLAD_VERSION_MINOR(version)     (version % 10000)

  #define GLAD_GENERATOR_VERSION "2.0.4"

    typedef void (*GLADapiproc)(void);

    typedef GLADapiproc (*GLADloadfunc)(const char* name);
    typedef GLADapiproc (*GLADuserptrloadfunc)(void* userptr, const char* name);

    typedef void (*GLADprecallback)(const char* name, GLADapiproc apiproc, int len_args, ...);
    typedef void (*GLADpostcallback)(void* ret, const char* name, GLADapiproc apiproc, int len_args,
                                     ...);

#endif /* GLAD_PLATFORM_H_ */

#define GL_1PASS_EXT                                                  0x80A1
#define GL_1PASS_SGIS                                                 0x80A1
#define GL_2PASS_0_EXT                                                0x80A2
#define GL_2PASS_0_SGIS                                               0x80A2
#define GL_2PASS_1_EXT                                                0x80A3
#define GL_2PASS_1_SGIS                                               0x80A3
#define GL_2X_BIT_ATI                                                 0x00000001
#define GL_422_AVERAGE_EXT                                            0x80CE
#define GL_422_EXT                                                    0x80CC
#define GL_422_REV_AVERAGE_EXT                                        0x80CF
#define GL_422_REV_EXT                                                0x80CD
#define GL_4PASS_0_EXT                                                0x80A4
#define GL_4PASS_0_SGIS                                               0x80A4
#define GL_4PASS_1_EXT                                                0x80A5
#define GL_4PASS_1_SGIS                                               0x80A5
#define GL_4PASS_2_EXT                                                0x80A6
#define GL_4PASS_2_SGIS                                               0x80A6
#define GL_4PASS_3_EXT                                                0x80A7
#define GL_4PASS_3_SGIS                                               0x80A7
#define GL_4X_BIT_ATI                                                 0x00000002
#define GL_8X_BIT_ATI                                                 0x00000004
#define GL_ABGR_EXT                                                   0x8000
#define GL_ACCUM_ADJACENT_PAIRS_NV                                    0x90AD
#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS                              0x92D9
#define GL_ACTIVE_ATTRIBUTES                                          0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH                                0x8B8A
#define GL_ACTIVE_PROGRAM                                             0x8259
#define GL_ACTIVE_PROGRAM_EXT                                         0x8B8D
#define GL_ACTIVE_RESOURCES                                           0x92F5
#define GL_ACTIVE_STENCIL_FACE_EXT                                    0x8911
#define GL_ACTIVE_SUBROUTINES                                         0x8DE5
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH                               0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORMS                                 0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS                        0x8E47
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH                       0x8E49
#define GL_ACTIVE_TEXTURE                                             0x84E0
#define GL_ACTIVE_TEXTURE_ARB                                         0x84E0
#define GL_ACTIVE_UNIFORMS                                            0x8B86
#define GL_ACTIVE_UNIFORM_BLOCKS                                      0x8A36
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH                       0x8A35
#define GL_ACTIVE_UNIFORM_MAX_LENGTH                                  0x8B87
#define GL_ACTIVE_VARIABLES                                           0x9305
#define GL_ACTIVE_VARYINGS_NV                                         0x8C81
#define GL_ACTIVE_VARYING_MAX_LENGTH_NV                               0x8C82
#define GL_ACTIVE_VERTEX_UNITS_ARB                                    0x86A5
#define GL_ADD_ATI                                                    0x8963
#define GL_ADD_SIGNED_ARB                                             0x8574
#define GL_ADD_SIGNED_EXT                                             0x8574
#define GL_ADJACENT_PAIRS_NV                                          0x90AE
#define GL_AFFINE_2D_NV                                               0x9092
#define GL_AFFINE_3D_NV                                               0x9094
#define GL_ALIASED_LINE_WIDTH_RANGE                                   0x846E
#define GL_ALLOW_DRAW_FRG_HINT_PGI                                    0x1A210
#define GL_ALLOW_DRAW_MEM_HINT_PGI                                    0x1A211
#define GL_ALLOW_DRAW_OBJ_HINT_PGI                                    0x1A20E
#define GL_ALLOW_DRAW_WIN_HINT_PGI                                    0x1A20F
#define GL_ALL_BARRIER_BITS                                           0xFFFFFFFF
#define GL_ALL_BARRIER_BITS_EXT                                       0xFFFFFFFF
#define GL_ALL_COMPLETED_NV                                           0x84F2
#define GL_ALL_PIXELS_AMD                                             0xFFFFFFFF
#define GL_ALL_SHADER_BITS                                            0xFFFFFFFF
#define GL_ALL_STATIC_DATA_IBM                                        103060
#define GL_ALPHA                                                      0x1906
#define GL_ALPHA12_EXT                                                0x803D
#define GL_ALPHA16F_ARB                                               0x881C
#define GL_ALPHA16F_EXT                                               0x881C
#define GL_ALPHA16I_EXT                                               0x8D8A
#define GL_ALPHA16UI_EXT                                              0x8D78
#define GL_ALPHA16_EXT                                                0x803E
#define GL_ALPHA16_SNORM                                              0x9018
#define GL_ALPHA32F_ARB                                               0x8816
#define GL_ALPHA32F_EXT                                               0x8816
#define GL_ALPHA32I_EXT                                               0x8D84
#define GL_ALPHA32UI_EXT                                              0x8D72
#define GL_ALPHA4_EXT                                                 0x803B
#define GL_ALPHA8I_EXT                                                0x8D90
#define GL_ALPHA8UI_EXT                                               0x8D7E
#define GL_ALPHA8_EXT                                                 0x803C
#define GL_ALPHA8_SNORM                                               0x9014
#define GL_ALPHA_FLOAT16_APPLE                                        0x881C
#define GL_ALPHA_FLOAT16_ATI                                          0x881C
#define GL_ALPHA_FLOAT32_APPLE                                        0x8816
#define GL_ALPHA_FLOAT32_ATI                                          0x8816
#define GL_ALPHA_INTEGER_EXT                                          0x8D97
#define GL_ALPHA_MAX_CLAMP_INGR                                       0x8567
#define GL_ALPHA_MAX_SGIX                                             0x8321
#define GL_ALPHA_MIN_CLAMP_INGR                                       0x8563
#define GL_ALPHA_MIN_SGIX                                             0x8320
#define GL_ALPHA_REF_COMMAND_NV                                       0x000F
#define GL_ALPHA_SNORM                                                0x9010
#define GL_ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV                        0x934D
#define GL_ALPHA_TO_COVERAGE_DITHER_DISABLE_NV                        0x934F
#define GL_ALPHA_TO_COVERAGE_DITHER_ENABLE_NV                         0x934E
#define GL_ALPHA_TO_COVERAGE_DITHER_MODE_NV                           0x92BF
#define GL_ALREADY_SIGNALED                                           0x911A
#define GL_ALWAYS                                                     0x0207
#define GL_ALWAYS_FAST_HINT_PGI                                       0x1A20C
#define GL_ALWAYS_SOFT_HINT_PGI                                       0x1A20D
#define GL_AND                                                        0x1501
#define GL_AND_INVERTED                                               0x1504
#define GL_AND_REVERSE                                                0x1502
#define GL_ANY_SAMPLES_PASSED                                         0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE                            0x8D6A
#define GL_ARC_TO_NV                                                  0xFE
#define GL_ARRAY_BUFFER                                               0x8892
#define GL_ARRAY_BUFFER_ARB                                           0x8892
#define GL_ARRAY_BUFFER_BINDING                                       0x8894
#define GL_ARRAY_BUFFER_BINDING_ARB                                   0x8894
#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT                               0x81A9
#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT                               0x81A8
#define GL_ARRAY_OBJECT_BUFFER_ATI                                    0x8766
#define GL_ARRAY_OBJECT_OFFSET_ATI                                    0x8767
#define GL_ARRAY_SIZE                                                 0x92FB
#define GL_ARRAY_STRIDE                                               0x92FE
#define GL_ASYNC_DRAW_PIXELS_SGIX                                     0x835D
#define GL_ASYNC_HISTOGRAM_SGIX                                       0x832C
#define GL_ASYNC_MARKER_SGIX                                          0x8329
#define GL_ASYNC_READ_PIXELS_SGIX                                     0x835E
#define GL_ASYNC_TEX_IMAGE_SGIX                                       0x835C
#define GL_ATOMIC_COUNTER_BARRIER_BIT                                 0x00001000
#define GL_ATOMIC_COUNTER_BARRIER_BIT_EXT                             0x00001000
#define GL_ATOMIC_COUNTER_BUFFER                                      0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS               0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES        0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_BINDING                              0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE                            0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_INDEX                                0x9301
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER         0x90ED
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER        0x92CB
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER        0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV         0x959E
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV         0x959F
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER    0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER          0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_SIZE                                 0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_START                                0x92C2
#define GL_ATTACHED_MEMORY_OBJECT_NV                                  0x95A4
#define GL_ATTACHED_MEMORY_OFFSET_NV                                  0x95A5
#define GL_ATTACHED_SHADERS                                           0x8B85
#define GL_ATTENUATION_EXT                                            0x834D
#define GL_ATTRIBUTE_ADDRESS_COMMAND_NV                               0x0009
#define GL_ATTRIB_ARRAY_POINTER_NV                                    0x8645
#define GL_ATTRIB_ARRAY_SIZE_NV                                       0x8623
#define GL_ATTRIB_ARRAY_STRIDE_NV                                     0x8624
#define GL_ATTRIB_ARRAY_TYPE_NV                                       0x8625
#define GL_AUTO_GENERATE_MIPMAP                                       0x8295
#define GL_AUX_DEPTH_STENCIL_APPLE                                    0x8A14
#define GL_AVERAGE_EXT                                                0x8335
#define GL_AVERAGE_HP                                                 0x8160
#define GL_BACK                                                       0x0405
#define GL_BACK_LEFT                                                  0x0402
#define GL_BACK_NORMALS_HINT_PGI                                      0x1A223
#define GL_BACK_PRIMARY_COLOR_NV                                      0x8C77
#define GL_BACK_RIGHT                                                 0x0403
#define GL_BACK_SECONDARY_COLOR_NV                                    0x8C78
#define GL_BEVEL_NV                                                   0x90A6
#define GL_BGR                                                        0x80E0
#define GL_BGRA                                                       0x80E1
#define GL_BGRA8_EXT                                                  0x93A1
#define GL_BGRA_EXT                                                   0x80E1
#define GL_BGRA_INTEGER                                               0x8D9B
#define GL_BGRA_INTEGER_EXT                                           0x8D9B
#define GL_BGR_EXT                                                    0x80E0
#define GL_BGR_INTEGER                                                0x8D9A
#define GL_BGR_INTEGER_EXT                                            0x8D9A
#define GL_BIAS_BIT_ATI                                               0x00000008
#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV                               0x8541
#define GL_BINORMAL_ARRAY_EXT                                         0x843A
#define GL_BINORMAL_ARRAY_POINTER_EXT                                 0x8443
#define GL_BINORMAL_ARRAY_STRIDE_EXT                                  0x8441
#define GL_BINORMAL_ARRAY_TYPE_EXT                                    0x8440
#define GL_BLACKHOLE_RENDER_INTEL                                     0x83FC
#define GL_BLEND                                                      0x0BE2
#define GL_BLEND_ADVANCED_COHERENT_KHR                                0x9285
#define GL_BLEND_ADVANCED_COHERENT_NV                                 0x9285
#define GL_BLEND_COLOR                                                0x8005
#define GL_BLEND_COLOR_COMMAND_NV                                     0x000B
#define GL_BLEND_COLOR_EXT                                            0x8005
#define GL_BLEND_DST                                                  0x0BE0
#define GL_BLEND_DST_ALPHA                                            0x80CA
#define GL_BLEND_DST_ALPHA_EXT                                        0x80CA
#define GL_BLEND_DST_RGB                                              0x80C8
#define GL_BLEND_DST_RGB_EXT                                          0x80C8
#define GL_BLEND_EQUATION                                             0x8009
#define GL_BLEND_EQUATION_ALPHA                                       0x883D
#define GL_BLEND_EQUATION_ALPHA_EXT                                   0x883D
#define GL_BLEND_EQUATION_EXT                                         0x8009
#define GL_BLEND_EQUATION_RGB                                         0x8009
#define GL_BLEND_EQUATION_RGB_EXT                                     0x8009
#define GL_BLEND_OVERLAP_NV                                           0x9281
#define GL_BLEND_PREMULTIPLIED_SRC_NV                                 0x9280
#define GL_BLEND_SRC                                                  0x0BE1
#define GL_BLEND_SRC_ALPHA                                            0x80CB
#define GL_BLEND_SRC_ALPHA_EXT                                        0x80CB
#define GL_BLEND_SRC_RGB                                              0x80C9
#define GL_BLEND_SRC_RGB_EXT                                          0x80C9
#define GL_BLOCK_INDEX                                                0x92FD
#define GL_BLUE                                                       0x1905
#define GL_BLUE_BIT_ATI                                               0x00000004
#define GL_BLUE_INTEGER                                               0x8D96
#define GL_BLUE_INTEGER_EXT                                           0x8D96
#define GL_BLUE_MAX_CLAMP_INGR                                        0x8566
#define GL_BLUE_MIN_CLAMP_INGR                                        0x8562
#define GL_BLUE_NV                                                    0x1905
#define GL_BOLD_BIT_NV                                                0x01
#define GL_BOOL                                                       0x8B56
#define GL_BOOL_ARB                                                   0x8B56
#define GL_BOOL_VEC2                                                  0x8B57
#define GL_BOOL_VEC2_ARB                                              0x8B57
#define GL_BOOL_VEC3                                                  0x8B58
#define GL_BOOL_VEC3_ARB                                              0x8B58
#define GL_BOOL_VEC4                                                  0x8B59
#define GL_BOOL_VEC4_ARB                                              0x8B59
#define GL_BOUNDING_BOX_NV                                            0x908D
#define GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV                          0x909C
#define GL_BUFFER                                                     0x82E0
#define GL_BUFFER_ACCESS                                              0x88BB
#define GL_BUFFER_ACCESS_ARB                                          0x88BB
#define GL_BUFFER_ACCESS_FLAGS                                        0x911F
#define GL_BUFFER_BINDING                                             0x9302
#define GL_BUFFER_DATA_SIZE                                           0x9303
#define GL_BUFFER_FLUSHING_UNMAP_APPLE                                0x8A13
#define GL_BUFFER_GPU_ADDRESS_NV                                      0x8F1D
#define GL_BUFFER_IMMUTABLE_STORAGE                                   0x821F
#define GL_BUFFER_MAPPED                                              0x88BC
#define GL_BUFFER_MAPPED_ARB                                          0x88BC
#define GL_BUFFER_MAP_LENGTH                                          0x9120
#define GL_BUFFER_MAP_OFFSET                                          0x9121
#define GL_BUFFER_MAP_POINTER                                         0x88BD
#define GL_BUFFER_MAP_POINTER_ARB                                     0x88BD
#define GL_BUFFER_OBJECT_APPLE                                        0x85B3
#define GL_BUFFER_OBJECT_EXT                                          0x9151
#define GL_BUFFER_SERIALIZED_MODIFY_APPLE                             0x8A12
#define GL_BUFFER_SIZE                                                0x8764
#define GL_BUFFER_SIZE_ARB                                            0x8764
#define GL_BUFFER_STORAGE_FLAGS                                       0x8220
#define GL_BUFFER_UPDATE_BARRIER_BIT                                  0x00000200
#define GL_BUFFER_UPDATE_BARRIER_BIT_EXT                              0x00000200
#define GL_BUFFER_USAGE                                               0x8765
#define GL_BUFFER_USAGE_ARB                                           0x8765
#define GL_BUFFER_VARIABLE                                            0x92E5
#define GL_BUMP_ENVMAP_ATI                                            0x877B
#define GL_BUMP_NUM_TEX_UNITS_ATI                                     0x8777
#define GL_BUMP_ROT_MATRIX_ATI                                        0x8775
#define GL_BUMP_ROT_MATRIX_SIZE_ATI                                   0x8776
#define GL_BUMP_TARGET_ATI                                            0x877C
#define GL_BUMP_TEX_UNITS_ATI                                         0x8778
#define GL_BYTE                                                       0x1400
#define GL_CALLIGRAPHIC_FRAGMENT_SGIX                                 0x8183
#define GL_CAVEAT_SUPPORT                                             0x82B8
#define GL_CCW                                                        0x0901
#define GL_CIRCULAR_CCW_ARC_TO_NV                                     0xF8
#define GL_CIRCULAR_CW_ARC_TO_NV                                      0xFA
#define GL_CIRCULAR_TANGENT_ARC_TO_NV                                 0xFC
#define GL_CLAMP_FRAGMENT_COLOR_ARB                                   0x891B
#define GL_CLAMP_READ_COLOR                                           0x891C
#define GL_CLAMP_READ_COLOR_ARB                                       0x891C
#define GL_CLAMP_TO_BORDER                                            0x812D
#define GL_CLAMP_TO_BORDER_ARB                                        0x812D
#define GL_CLAMP_TO_BORDER_SGIS                                       0x812D
#define GL_CLAMP_TO_EDGE                                              0x812F
#define GL_CLAMP_TO_EDGE_SGIS                                         0x812F
#define GL_CLAMP_VERTEX_COLOR_ARB                                     0x891A
#define GL_CLEAR                                                      0x1500
#define GL_CLEAR_BUFFER                                               0x82B4
#define GL_CLEAR_TEXTURE                                              0x9365
#define GL_CLIENT_ACTIVE_TEXTURE_ARB                                  0x84E1
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT                           0x00004000
#define GL_CLIENT_STORAGE_BIT                                         0x0200
#define GL_CLIPPING_INPUT_PRIMITIVES                                  0x82F6
#define GL_CLIPPING_INPUT_PRIMITIVES_ARB                              0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES                                 0x82F7
#define GL_CLIPPING_OUTPUT_PRIMITIVES_ARB                             0x82F7
#define GL_CLIP_DEPTH_MODE                                            0x935D
#define GL_CLIP_DISTANCE0                                             0x3000
#define GL_CLIP_DISTANCE1                                             0x3001
#define GL_CLIP_DISTANCE2                                             0x3002
#define GL_CLIP_DISTANCE3                                             0x3003
#define GL_CLIP_DISTANCE4                                             0x3004
#define GL_CLIP_DISTANCE5                                             0x3005
#define GL_CLIP_DISTANCE6                                             0x3006
#define GL_CLIP_DISTANCE7                                             0x3007
#define GL_CLIP_DISTANCE_NV                                           0x8C7A
#define GL_CLIP_FAR_HINT_PGI                                          0x1A221
#define GL_CLIP_NEAR_HINT_PGI                                         0x1A220
#define GL_CLIP_ORIGIN                                                0x935C
#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT                              0x80F0
#define GL_CLOSE_PATH_NV                                              0x00
#define GL_CMYKA_EXT                                                  0x800D
#define GL_CMYK_EXT                                                   0x800C
#define GL_CND0_ATI                                                   0x896B
#define GL_CND_ATI                                                    0x896A
#define GL_COLOR                                                      0x1800
#define GL_COLOR3_BIT_PGI                                             0x00010000
#define GL_COLOR4_BIT_PGI                                             0x00020000
#define GL_COLORBURN_KHR                                              0x929A
#define GL_COLORBURN_NV                                               0x929A
#define GL_COLORDODGE_KHR                                             0x9299
#define GL_COLORDODGE_NV                                              0x9299
#define GL_COLOR_ALPHA_PAIRING_ATI                                    0x8975
#define GL_COLOR_ARRAY_ADDRESS_NV                                     0x8F23
#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB                             0x8898
#define GL_COLOR_ARRAY_COUNT_EXT                                      0x8084
#define GL_COLOR_ARRAY_EXT                                            0x8076
#define GL_COLOR_ARRAY_LENGTH_NV                                      0x8F2D
#define GL_COLOR_ARRAY_LIST_IBM                                       103072
#define GL_COLOR_ARRAY_LIST_STRIDE_IBM                                103082
#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL                        0x83F7
#define GL_COLOR_ARRAY_POINTER_EXT                                    0x8090
#define GL_COLOR_ARRAY_SIZE_EXT                                       0x8081
#define GL_COLOR_ARRAY_STRIDE_EXT                                     0x8083
#define GL_COLOR_ARRAY_TYPE_EXT                                       0x8082
#define GL_COLOR_ATTACHMENT0                                          0x8CE0
#define GL_COLOR_ATTACHMENT0_EXT                                      0x8CE0
#define GL_COLOR_ATTACHMENT1                                          0x8CE1
#define GL_COLOR_ATTACHMENT10                                         0x8CEA
#define GL_COLOR_ATTACHMENT10_EXT                                     0x8CEA
#define GL_COLOR_ATTACHMENT11                                         0x8CEB
#define GL_COLOR_ATTACHMENT11_EXT                                     0x8CEB
#define GL_COLOR_ATTACHMENT12                                         0x8CEC
#define GL_COLOR_ATTACHMENT12_EXT                                     0x8CEC
#define GL_COLOR_ATTACHMENT13                                         0x8CED
#define GL_COLOR_ATTACHMENT13_EXT                                     0x8CED
#define GL_COLOR_ATTACHMENT14                                         0x8CEE
#define GL_COLOR_ATTACHMENT14_EXT                                     0x8CEE
#define GL_COLOR_ATTACHMENT15                                         0x8CEF
#define GL_COLOR_ATTACHMENT15_EXT                                     0x8CEF
#define GL_COLOR_ATTACHMENT16                                         0x8CF0
#define GL_COLOR_ATTACHMENT17                                         0x8CF1
#define GL_COLOR_ATTACHMENT18                                         0x8CF2
#define GL_COLOR_ATTACHMENT19                                         0x8CF3
#define GL_COLOR_ATTACHMENT1_EXT                                      0x8CE1
#define GL_COLOR_ATTACHMENT2                                          0x8CE2
#define GL_COLOR_ATTACHMENT20                                         0x8CF4
#define GL_COLOR_ATTACHMENT21                                         0x8CF5
#define GL_COLOR_ATTACHMENT22                                         0x8CF6
#define GL_COLOR_ATTACHMENT23                                         0x8CF7
#define GL_COLOR_ATTACHMENT24                                         0x8CF8
#define GL_COLOR_ATTACHMENT25                                         0x8CF9
#define GL_COLOR_ATTACHMENT26                                         0x8CFA
#define GL_COLOR_ATTACHMENT27                                         0x8CFB
#define GL_COLOR_ATTACHMENT28                                         0x8CFC
#define GL_COLOR_ATTACHMENT29                                         0x8CFD
#define GL_COLOR_ATTACHMENT2_EXT                                      0x8CE2
#define GL_COLOR_ATTACHMENT3                                          0x8CE3
#define GL_COLOR_ATTACHMENT30                                         0x8CFE
#define GL_COLOR_ATTACHMENT31                                         0x8CFF
#define GL_COLOR_ATTACHMENT3_EXT                                      0x8CE3
#define GL_COLOR_ATTACHMENT4                                          0x8CE4
#define GL_COLOR_ATTACHMENT4_EXT                                      0x8CE4
#define GL_COLOR_ATTACHMENT5                                          0x8CE5
#define GL_COLOR_ATTACHMENT5_EXT                                      0x8CE5
#define GL_COLOR_ATTACHMENT6                                          0x8CE6
#define GL_COLOR_ATTACHMENT6_EXT                                      0x8CE6
#define GL_COLOR_ATTACHMENT7                                          0x8CE7
#define GL_COLOR_ATTACHMENT7_EXT                                      0x8CE7
#define GL_COLOR_ATTACHMENT8                                          0x8CE8
#define GL_COLOR_ATTACHMENT8_EXT                                      0x8CE8
#define GL_COLOR_ATTACHMENT9                                          0x8CE9
#define GL_COLOR_ATTACHMENT9_EXT                                      0x8CE9
#define GL_COLOR_BUFFER_BIT                                           0x00004000
#define GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI                            0x8835
#define GL_COLOR_CLEAR_VALUE                                          0x0C22
#define GL_COLOR_COMPONENTS                                           0x8283
#define GL_COLOR_ENCODING                                             0x8296
#define GL_COLOR_FLOAT_APPLE                                          0x8A0F
#define GL_COLOR_INDEX12_EXT                                          0x80E6
#define GL_COLOR_INDEX16_EXT                                          0x80E7
#define GL_COLOR_INDEX1_EXT                                           0x80E2
#define GL_COLOR_INDEX2_EXT                                           0x80E3
#define GL_COLOR_INDEX4_EXT                                           0x80E4
#define GL_COLOR_INDEX8_EXT                                           0x80E5
#define GL_COLOR_LOGIC_OP                                             0x0BF2
#define GL_COLOR_MATRIX_SGI                                           0x80B1
#define GL_COLOR_MATRIX_STACK_DEPTH_SGI                               0x80B2
#define GL_COLOR_RENDERABLE                                           0x8286
#define GL_COLOR_SAMPLES_NV                                           0x8E20
#define GL_COLOR_SUM_ARB                                              0x8458
#define GL_COLOR_SUM_CLAMP_NV                                         0x854F
#define GL_COLOR_SUM_EXT                                              0x8458
#define GL_COLOR_TABLE_ALPHA_SIZE_SGI                                 0x80DD
#define GL_COLOR_TABLE_BIAS_SGI                                       0x80D7
#define GL_COLOR_TABLE_BLUE_SIZE_SGI                                  0x80DC
#define GL_COLOR_TABLE_FORMAT_SGI                                     0x80D8
#define GL_COLOR_TABLE_GREEN_SIZE_SGI                                 0x80DB
#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI                             0x80DF
#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI                             0x80DE
#define GL_COLOR_TABLE_RED_SIZE_SGI                                   0x80DA
#define GL_COLOR_TABLE_SCALE_SGI                                      0x80D6
#define GL_COLOR_TABLE_SGI                                            0x80D0
#define GL_COLOR_TABLE_WIDTH_SGI                                      0x80D9
#define GL_COLOR_WRITEMASK                                            0x0C23
#define GL_COMBINE4_NV                                                0x8503
#define GL_COMBINER0_NV                                               0x8550
#define GL_COMBINER1_NV                                               0x8551
#define GL_COMBINER2_NV                                               0x8552
#define GL_COMBINER3_NV                                               0x8553
#define GL_COMBINER4_NV                                               0x8554
#define GL_COMBINER5_NV                                               0x8555
#define GL_COMBINER6_NV                                               0x8556
#define GL_COMBINER7_NV                                               0x8557
#define GL_COMBINER_AB_DOT_PRODUCT_NV                                 0x8545
#define GL_COMBINER_AB_OUTPUT_NV                                      0x854A
#define GL_COMBINER_BIAS_NV                                           0x8549
#define GL_COMBINER_CD_DOT_PRODUCT_NV                                 0x8546
#define GL_COMBINER_CD_OUTPUT_NV                                      0x854B
#define GL_COMBINER_COMPONENT_USAGE_NV                                0x8544
#define GL_COMBINER_INPUT_NV                                          0x8542
#define GL_COMBINER_MAPPING_NV                                        0x8543
#define GL_COMBINER_MUX_SUM_NV                                        0x8547
#define GL_COMBINER_SCALE_NV                                          0x8548
#define GL_COMBINER_SUM_OUTPUT_NV                                     0x854C
#define GL_COMBINE_ALPHA_ARB                                          0x8572
#define GL_COMBINE_ALPHA_EXT                                          0x8572
#define GL_COMBINE_ARB                                                0x8570
#define GL_COMBINE_EXT                                                0x8570
#define GL_COMBINE_RGB_ARB                                            0x8571
#define GL_COMBINE_RGB_EXT                                            0x8571
#define GL_COMMAND_BARRIER_BIT                                        0x00000040
#define GL_COMMAND_BARRIER_BIT_EXT                                    0x00000040
#define GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT                           0x884E
#define GL_COMPARE_REF_TO_TEXTURE                                     0x884E
#define GL_COMPARE_R_TO_TEXTURE_ARB                                   0x884E
#define GL_COMPATIBLE_SUBROUTINES                                     0x8E4B
#define GL_COMPILE_STATUS                                             0x8B81
#define GL_COMPLETION_STATUS_ARB                                      0x91B1
#define GL_COMPLETION_STATUS_KHR                                      0x91B1
#define GL_COMPRESSED_ALPHA_ARB                                       0x84E9
#define GL_COMPRESSED_INTENSITY_ARB                                   0x84EC
#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB                             0x84EB
#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT                       0x8C72
#define GL_COMPRESSED_LUMINANCE_ARB                                   0x84EA
#define GL_COMPRESSED_LUMINANCE_LATC1_EXT                             0x8C70
#define GL_COMPRESSED_R11_EAC                                         0x9270
#define GL_COMPRESSED_RED                                             0x8225
#define GL_COMPRESSED_RED_GREEN_RGTC2_EXT                             0x8DBD
#define GL_COMPRESSED_RED_RGTC1                                       0x8DBB
#define GL_COMPRESSED_RED_RGTC1_EXT                                   0x8DBB
#define GL_COMPRESSED_RG                                              0x8226
#define GL_COMPRESSED_RG11_EAC                                        0x9272
#define GL_COMPRESSED_RGB                                             0x84ED
#define GL_COMPRESSED_RGB8_ETC2                                       0x9274
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2                   0x9276
#define GL_COMPRESSED_RGBA                                            0x84EE
#define GL_COMPRESSED_RGBA8_ETC2_EAC                                  0x9278
#define GL_COMPRESSED_RGBA_ARB                                        0x84EE
#define GL_COMPRESSED_RGBA_ASTC_10x10_KHR                             0x93BB
#define GL_COMPRESSED_RGBA_ASTC_10x5_KHR                              0x93B8
#define GL_COMPRESSED_RGBA_ASTC_10x6_KHR                              0x93B9
#define GL_COMPRESSED_RGBA_ASTC_10x8_KHR                              0x93BA
#define GL_COMPRESSED_RGBA_ASTC_12x10_KHR                             0x93BC
#define GL_COMPRESSED_RGBA_ASTC_12x12_KHR                             0x93BD
#define GL_COMPRESSED_RGBA_ASTC_4x4_KHR                               0x93B0
#define GL_COMPRESSED_RGBA_ASTC_5x4_KHR                               0x93B1
#define GL_COMPRESSED_RGBA_ASTC_5x5_KHR                               0x93B2
#define GL_COMPRESSED_RGBA_ASTC_6x5_KHR                               0x93B3
#define GL_COMPRESSED_RGBA_ASTC_6x6_KHR                               0x93B4
#define GL_COMPRESSED_RGBA_ASTC_8x5_KHR                               0x93B5
#define GL_COMPRESSED_RGBA_ASTC_8x6_KHR                               0x93B6
#define GL_COMPRESSED_RGBA_ASTC_8x8_KHR                               0x93B7
#define GL_COMPRESSED_RGBA_BPTC_UNORM                                 0x8E8C
#define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB                             0x8E8C
#define GL_COMPRESSED_RGBA_FXT1_3DFX                                  0x86B1
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT                              0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT                              0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT                              0x83F3
#define GL_COMPRESSED_RGB_ARB                                         0x84ED
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT                           0x8E8E
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB                       0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT                         0x8E8F
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB                     0x8E8F
#define GL_COMPRESSED_RGB_FXT1_3DFX                                   0x86B0
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT                               0x83F0
#define GL_COMPRESSED_RG_RGTC2                                        0x8DBD
#define GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT                0x8C73
#define GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT                      0x8C71
#define GL_COMPRESSED_SIGNED_R11_EAC                                  0x9271
#define GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT                      0x8DBE
#define GL_COMPRESSED_SIGNED_RED_RGTC1                                0x8DBC
#define GL_COMPRESSED_SIGNED_RED_RGTC1_EXT                            0x8DBC
#define GL_COMPRESSED_SIGNED_RG11_EAC                                 0x9273
#define GL_COMPRESSED_SIGNED_RG_RGTC2                                 0x8DBE
#define GL_COMPRESSED_SLUMINANCE_ALPHA_EXT                            0x8C4B
#define GL_COMPRESSED_SLUMINANCE_EXT                                  0x8C4A
#define GL_COMPRESSED_SRGB                                            0x8C48
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR                     0x93DB
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR                      0x93D8
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR                      0x93D9
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR                      0x93DA
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR                     0x93DC
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR                     0x93DD
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR                       0x93D0
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR                       0x93D1
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR                       0x93D2
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR                       0x93D3
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR                       0x93D4
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR                       0x93D5
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR                       0x93D6
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR                       0x93D7
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC                           0x9279
#define GL_COMPRESSED_SRGB8_ETC2                                      0x9275
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2                  0x9277
#define GL_COMPRESSED_SRGB_ALPHA                                      0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM                           0x8E8D
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB                       0x8E8D
#define GL_COMPRESSED_SRGB_ALPHA_EXT                                  0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT                        0x8C4D
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT                        0x8C4E
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT                        0x8C4F
#define GL_COMPRESSED_SRGB_EXT                                        0x8C48
#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT                              0x8C4C
#define GL_COMPRESSED_TEXTURE_FORMATS                                 0x86A3
#define GL_COMPRESSED_TEXTURE_FORMATS_ARB                             0x86A3
#define GL_COMPUTE_PROGRAM_NV                                         0x90FB
#define GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV                        0x90FC
#define GL_COMPUTE_SHADER                                             0x91B9
#define GL_COMPUTE_SHADER_BIT                                         0x00000020
#define GL_COMPUTE_SHADER_INVOCATIONS                                 0x82F5
#define GL_COMPUTE_SHADER_INVOCATIONS_ARB                             0x82F5
#define GL_COMPUTE_SUBROUTINE                                         0x92ED
#define GL_COMPUTE_SUBROUTINE_UNIFORM                                 0x92F3
#define GL_COMPUTE_TEXTURE                                            0x82A0
#define GL_COMPUTE_WORK_GROUP_SIZE                                    0x8267
#define GL_COMP_BIT_ATI                                               0x00000002
#define GL_CONDITION_SATISFIED                                        0x911C
#define GL_CONFORMANT_NV                                              0x9374
#define GL_CONIC_CURVE_TO_NV                                          0x1A
#define GL_CONJOINT_NV                                                0x9284
#define GL_CONSERVATIVE_RASTERIZATION_INTEL                           0x83FE
#define GL_CONSERVATIVE_RASTERIZATION_NV                              0x9346
#define GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV                  0x937B
#define GL_CONSERVATIVE_RASTER_DILATE_NV                              0x9379
#define GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV                        0x937A
#define GL_CONSERVATIVE_RASTER_MODE_NV                                0x954D
#define GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV                      0x954E
#define GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV                       0x9550
#define GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV             0x954F
#define GL_CONSERVE_MEMORY_HINT_PGI                                   0x1A1FD
#define GL_CONSTANT_ALPHA                                             0x8003
#define GL_CONSTANT_ALPHA_EXT                                         0x8003
#define GL_CONSTANT_ARB                                               0x8576
#define GL_CONSTANT_BORDER_HP                                         0x8151
#define GL_CONSTANT_COLOR                                             0x8001
#define GL_CONSTANT_COLOR0_NV                                         0x852A
#define GL_CONSTANT_COLOR1_NV                                         0x852B
#define GL_CONSTANT_COLOR_EXT                                         0x8001
#define GL_CONSTANT_EXT                                               0x8576
#define GL_CONST_EYE_NV                                               0x86E5
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT                          0x00000002
#define GL_CONTEXT_CORE_PROFILE_BIT                                   0x00000001
#define GL_CONTEXT_FLAGS                                              0x821E
#define GL_CONTEXT_FLAG_DEBUG_BIT                                     0x00000002
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT                        0x00000001
#define GL_CONTEXT_FLAG_NO_ERROR_BIT                                  0x00000008
#define GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR                              0x00000008
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT                             0x00000004
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB                         0x00000004
#define GL_CONTEXT_LOST                                               0x0507
#define GL_CONTEXT_PROFILE_MASK                                       0x9126
#define GL_CONTEXT_RELEASE_BEHAVIOR                                   0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH                             0x82FC
#define GL_CONTEXT_ROBUST_ACCESS                                      0x90F3
#define GL_CONTINUOUS_AMD                                             0x9007
#define GL_CONTRAST_NV                                                0x92A1
#define GL_CONVEX_HULL_NV                                             0x908B
#define GL_CONVOLUTION_1D_EXT                                         0x8010
#define GL_CONVOLUTION_2D_EXT                                         0x8011
#define GL_CONVOLUTION_BORDER_COLOR_HP                                0x8154
#define GL_CONVOLUTION_BORDER_MODE_EXT                                0x8013
#define GL_CONVOLUTION_FILTER_BIAS_EXT                                0x8015
#define GL_CONVOLUTION_FILTER_SCALE_EXT                               0x8014
#define GL_CONVOLUTION_FORMAT_EXT                                     0x8017
#define GL_CONVOLUTION_HEIGHT_EXT                                     0x8019
#define GL_CONVOLUTION_HINT_SGIX                                      0x8316
#define GL_CONVOLUTION_WIDTH_EXT                                      0x8018
#define GL_CON_0_ATI                                                  0x8941
#define GL_CON_10_ATI                                                 0x894B
#define GL_CON_11_ATI                                                 0x894C
#define GL_CON_12_ATI                                                 0x894D
#define GL_CON_13_ATI                                                 0x894E
#define GL_CON_14_ATI                                                 0x894F
#define GL_CON_15_ATI                                                 0x8950
#define GL_CON_16_ATI                                                 0x8951
#define GL_CON_17_ATI                                                 0x8952
#define GL_CON_18_ATI                                                 0x8953
#define GL_CON_19_ATI                                                 0x8954
#define GL_CON_1_ATI                                                  0x8942
#define GL_CON_20_ATI                                                 0x8955
#define GL_CON_21_ATI                                                 0x8956
#define GL_CON_22_ATI                                                 0x8957
#define GL_CON_23_ATI                                                 0x8958
#define GL_CON_24_ATI                                                 0x8959
#define GL_CON_25_ATI                                                 0x895A
#define GL_CON_26_ATI                                                 0x895B
#define GL_CON_27_ATI                                                 0x895C
#define GL_CON_28_ATI                                                 0x895D
#define GL_CON_29_ATI                                                 0x895E
#define GL_CON_2_ATI                                                  0x8943
#define GL_CON_30_ATI                                                 0x895F
#define GL_CON_31_ATI                                                 0x8960
#define GL_CON_3_ATI                                                  0x8944
#define GL_CON_4_ATI                                                  0x8945
#define GL_CON_5_ATI                                                  0x8946
#define GL_CON_6_ATI                                                  0x8947
#define GL_CON_7_ATI                                                  0x8948
#define GL_CON_8_ATI                                                  0x8949
#define GL_CON_9_ATI                                                  0x894A
#define GL_COORD_REPLACE_ARB                                          0x8862
#define GL_COORD_REPLACE_NV                                           0x8862
#define GL_COPY                                                       0x1503
#define GL_COPY_INVERTED                                              0x150C
#define GL_COPY_READ_BUFFER                                           0x8F36
#define GL_COPY_READ_BUFFER_BINDING                                   0x8F36
#define GL_COPY_WRITE_BUFFER                                          0x8F37
#define GL_COPY_WRITE_BUFFER_BINDING                                  0x8F37
#define GL_COUNTER_RANGE_AMD                                          0x8BC1
#define GL_COUNTER_TYPE_AMD                                           0x8BC0
#define GL_COUNT_DOWN_NV                                              0x9089
#define GL_COUNT_UP_NV                                                0x9088
#define GL_COVERAGE_MODULATION_NV                                     0x9332
#define GL_COVERAGE_MODULATION_TABLE_NV                               0x9331
#define GL_COVERAGE_MODULATION_TABLE_SIZE_NV                          0x9333
#define GL_CUBIC_CURVE_TO_NV                                          0x0C
#define GL_CUBIC_EXT                                                  0x8334
#define GL_CUBIC_HP                                                   0x815F
#define GL_CULL_FACE                                                  0x0B44
#define GL_CULL_FACE_MODE                                             0x0B45
#define GL_CULL_FRAGMENT_NV                                           0x86E7
#define GL_CULL_MODES_NV                                              0x86E0
#define GL_CULL_VERTEX_EXT                                            0x81AA
#define GL_CULL_VERTEX_EYE_POSITION_EXT                               0x81AB
#define GL_CULL_VERTEX_IBM                                            103050
#define GL_CULL_VERTEX_OBJECT_POSITION_EXT                            0x81AC
#define GL_CURRENT_ATTRIB_NV                                          0x8626
#define GL_CURRENT_BINORMAL_EXT                                       0x843C
#define GL_CURRENT_FOG_COORDINATE_EXT                                 0x8453
#define GL_CURRENT_MATRIX_ARB                                         0x8641
#define GL_CURRENT_MATRIX_INDEX_ARB                                   0x8845
#define GL_CURRENT_MATRIX_NV                                          0x8641
#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB                             0x8640
#define GL_CURRENT_MATRIX_STACK_DEPTH_NV                              0x8640
#define GL_CURRENT_OCCLUSION_QUERY_ID_NV                              0x8865
#define GL_CURRENT_PALETTE_MATRIX_ARB                                 0x8843
#define GL_CURRENT_PROGRAM                                            0x8B8D
#define GL_CURRENT_QUERY                                              0x8865
#define GL_CURRENT_QUERY_ARB                                          0x8865
#define GL_CURRENT_RASTER_NORMAL_SGIX                                 0x8406
#define GL_CURRENT_SECONDARY_COLOR_EXT                                0x8459
#define GL_CURRENT_TANGENT_EXT                                        0x843B
#define GL_CURRENT_TIME_NV                                            0x8E28
#define GL_CURRENT_VERTEX_ATTRIB                                      0x8626
#define GL_CURRENT_VERTEX_ATTRIB_ARB                                  0x8626
#define GL_CURRENT_VERTEX_EXT                                         0x87E2
#define GL_CURRENT_VERTEX_WEIGHT_EXT                                  0x850B
#define GL_CURRENT_WEIGHT_ARB                                         0x86A8
#define GL_CW                                                         0x0900
#define GL_D3D12_FENCE_VALUE_EXT                                      0x9595
#define GL_DARKEN_KHR                                                 0x9297
#define GL_DARKEN_NV                                                  0x9297
#define GL_DATA_BUFFER_AMD                                            0x9151
#define GL_DEBUG_CALLBACK_FUNCTION                                    0x8244
#define GL_DEBUG_CALLBACK_FUNCTION_ARB                                0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM                                  0x8245
#define GL_DEBUG_CALLBACK_USER_PARAM_ARB                              0x8245
#define GL_DEBUG_CATEGORY_API_ERROR_AMD                               0x9149
#define GL_DEBUG_CATEGORY_APPLICATION_AMD                             0x914F
#define GL_DEBUG_CATEGORY_DEPRECATION_AMD                             0x914B
#define GL_DEBUG_CATEGORY_OTHER_AMD                                   0x9150
#define GL_DEBUG_CATEGORY_PERFORMANCE_AMD                             0x914D
#define GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD                         0x914E
#define GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD                      0x914C
#define GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD                           0x914A
#define GL_DEBUG_GROUP_STACK_DEPTH                                    0x826D
#define GL_DEBUG_LOGGED_MESSAGES                                      0x9145
#define GL_DEBUG_LOGGED_MESSAGES_AMD                                  0x9145
#define GL_DEBUG_LOGGED_MESSAGES_ARB                                  0x9145
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH                           0x8243
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB                       0x8243
#define GL_DEBUG_OUTPUT                                               0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS                                   0x8242
#define GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB                               0x8242
#define GL_DEBUG_SEVERITY_HIGH                                        0x9146
#define GL_DEBUG_SEVERITY_HIGH_AMD                                    0x9146
#define GL_DEBUG_SEVERITY_HIGH_ARB                                    0x9146
#define GL_DEBUG_SEVERITY_LOW                                         0x9148
#define GL_DEBUG_SEVERITY_LOW_AMD                                     0x9148
#define GL_DEBUG_SEVERITY_LOW_ARB                                     0x9148
#define GL_DEBUG_SEVERITY_MEDIUM                                      0x9147
#define GL_DEBUG_SEVERITY_MEDIUM_AMD                                  0x9147
#define GL_DEBUG_SEVERITY_MEDIUM_ARB                                  0x9147
#define GL_DEBUG_SEVERITY_NOTIFICATION                                0x826B
#define GL_DEBUG_SOURCE_API                                           0x8246
#define GL_DEBUG_SOURCE_API_ARB                                       0x8246
#define GL_DEBUG_SOURCE_APPLICATION                                   0x824A
#define GL_DEBUG_SOURCE_APPLICATION_ARB                               0x824A
#define GL_DEBUG_SOURCE_OTHER                                         0x824B
#define GL_DEBUG_SOURCE_OTHER_ARB                                     0x824B
#define GL_DEBUG_SOURCE_SHADER_COMPILER                               0x8248
#define GL_DEBUG_SOURCE_SHADER_COMPILER_ARB                           0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY                                   0x8249
#define GL_DEBUG_SOURCE_THIRD_PARTY_ARB                               0x8249
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM                                 0x8247
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB                             0x8247
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR                             0x824D
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB                         0x824D
#define GL_DEBUG_TYPE_ERROR                                           0x824C
#define GL_DEBUG_TYPE_ERROR_ARB                                       0x824C
#define GL_DEBUG_TYPE_MARKER                                          0x8268
#define GL_DEBUG_TYPE_OTHER                                           0x8251
#define GL_DEBUG_TYPE_OTHER_ARB                                       0x8251
#define GL_DEBUG_TYPE_PERFORMANCE                                     0x8250
#define GL_DEBUG_TYPE_PERFORMANCE_ARB                                 0x8250
#define GL_DEBUG_TYPE_POP_GROUP                                       0x826A
#define GL_DEBUG_TYPE_PORTABILITY                                     0x824F
#define GL_DEBUG_TYPE_PORTABILITY_ARB                                 0x824F
#define GL_DEBUG_TYPE_PUSH_GROUP                                      0x8269
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR                              0x824E
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB                          0x824E
#define GL_DECODE_EXT                                                 0x8A49
#define GL_DECR                                                       0x1E03
#define GL_DECR_WRAP                                                  0x8508
#define GL_DECR_WRAP_EXT                                              0x8508
#define GL_DEDICATED_MEMORY_OBJECT_EXT                                0x9581
#define GL_DEFORMATIONS_MASK_SGIX                                     0x8196
#define GL_DELETE_STATUS                                              0x8B80
#define GL_DEPENDENT_AR_TEXTURE_2D_NV                                 0x86E9
#define GL_DEPENDENT_GB_TEXTURE_2D_NV                                 0x86EA
#define GL_DEPENDENT_HILO_TEXTURE_2D_NV                               0x8858
#define GL_DEPENDENT_RGB_TEXTURE_3D_NV                                0x8859
#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV                          0x885A
#define GL_DEPTH                                                      0x1801
#define GL_DEPTH24_STENCIL8                                           0x88F0
#define GL_DEPTH24_STENCIL8_EXT                                       0x88F0
#define GL_DEPTH32F_STENCIL8                                          0x8CAD
#define GL_DEPTH32F_STENCIL8_NV                                       0x8DAC
#define GL_DEPTH_ATTACHMENT                                           0x8D00
#define GL_DEPTH_ATTACHMENT_EXT                                       0x8D00
#define GL_DEPTH_BOUNDS_EXT                                           0x8891
#define GL_DEPTH_BOUNDS_TEST_EXT                                      0x8890
#define GL_DEPTH_BUFFER_BIT                                           0x00000100
#define GL_DEPTH_BUFFER_FLOAT_MODE_NV                                 0x8DAF
#define GL_DEPTH_CLAMP                                                0x864F
#define GL_DEPTH_CLAMP_FAR_AMD                                        0x901F
#define GL_DEPTH_CLAMP_NEAR_AMD                                       0x901E
#define GL_DEPTH_CLAMP_NV                                             0x864F
#define GL_DEPTH_CLEAR_VALUE                                          0x0B73
#define GL_DEPTH_COMPONENT                                            0x1902
#define GL_DEPTH_COMPONENT16                                          0x81A5
#define GL_DEPTH_COMPONENT16_ARB                                      0x81A5
#define GL_DEPTH_COMPONENT16_SGIX                                     0x81A5
#define GL_DEPTH_COMPONENT24                                          0x81A6
#define GL_DEPTH_COMPONENT24_ARB                                      0x81A6
#define GL_DEPTH_COMPONENT24_SGIX                                     0x81A6
#define GL_DEPTH_COMPONENT32                                          0x81A7
#define GL_DEPTH_COMPONENT32F                                         0x8CAC
#define GL_DEPTH_COMPONENT32F_NV                                      0x8DAB
#define GL_DEPTH_COMPONENT32_ARB                                      0x81A7
#define GL_DEPTH_COMPONENT32_SGIX                                     0x81A7
#define GL_DEPTH_COMPONENTS                                           0x8284
#define GL_DEPTH_FUNC                                                 0x0B74
#define GL_DEPTH_RANGE                                                0x0B70
#define GL_DEPTH_RENDERABLE                                           0x8287
#define GL_DEPTH_SAMPLES_NV                                           0x932D
#define GL_DEPTH_STENCIL                                              0x84F9
#define GL_DEPTH_STENCIL_ATTACHMENT                                   0x821A
#define GL_DEPTH_STENCIL_EXT                                          0x84F9
#define GL_DEPTH_STENCIL_NV                                           0x84F9
#define GL_DEPTH_STENCIL_TEXTURE_MODE                                 0x90EA
#define GL_DEPTH_STENCIL_TO_BGRA_NV                                   0x886F
#define GL_DEPTH_STENCIL_TO_RGBA_NV                                   0x886E
#define GL_DEPTH_TEST                                                 0x0B71
#define GL_DEPTH_TEXTURE_MODE_ARB                                     0x884B
#define GL_DEPTH_WRITEMASK                                            0x0B72
#define GL_DETACHED_BUFFERS_NV                                        0x95AB
#define GL_DETACHED_MEMORY_INCARNATION_NV                             0x95A9
#define GL_DETACHED_TEXTURES_NV                                       0x95AA
#define GL_DETAIL_TEXTURE_2D_BINDING_SGIS                             0x8096
#define GL_DETAIL_TEXTURE_2D_SGIS                                     0x8095
#define GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS                            0x809C
#define GL_DETAIL_TEXTURE_LEVEL_SGIS                                  0x809A
#define GL_DETAIL_TEXTURE_MODE_SGIS                                   0x809B
#define GL_DEVICE_LUID_EXT                                            0x9599
#define GL_DEVICE_NODE_MASK_EXT                                       0x959A
#define GL_DEVICE_UUID_EXT                                            0x9597
#define GL_DIFFERENCE_KHR                                             0x929E
#define GL_DIFFERENCE_NV                                              0x929E
#define GL_DISCARD_ATI                                                0x8763
#define GL_DISCARD_NV                                                 0x8530
#define GL_DISCRETE_AMD                                               0x9006
#define GL_DISJOINT_NV                                                0x9283
#define GL_DISPATCH_INDIRECT_BUFFER                                   0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING                           0x90EF
#define GL_DISTANCE_ATTENUATION_EXT                                   0x8129
#define GL_DISTANCE_ATTENUATION_SGIS                                  0x8129
#define GL_DITHER                                                     0x0BD0
#define GL_DONT_CARE                                                  0x1100
#define GL_DOT2_ADD_ATI                                               0x896C
#define GL_DOT3_ATI                                                   0x8966
#define GL_DOT3_RGBA_ARB                                              0x86AF
#define GL_DOT3_RGBA_EXT                                              0x8741
#define GL_DOT3_RGB_ARB                                               0x86AE
#define GL_DOT3_RGB_EXT                                               0x8740
#define GL_DOT4_ATI                                                   0x8967
#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV                        0x885D
#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV                  0x86F3
#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV                               0x86ED
#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV                            0x86F1
#define GL_DOT_PRODUCT_NV                                             0x86EC
#define GL_DOT_PRODUCT_PASS_THROUGH_NV                                0x885B
#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV                            0x86F2
#define GL_DOT_PRODUCT_TEXTURE_1D_NV                                  0x885C
#define GL_DOT_PRODUCT_TEXTURE_2D_NV                                  0x86EE
#define GL_DOT_PRODUCT_TEXTURE_3D_NV                                  0x86EF
#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV                            0x86F0
#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV                           0x864E
#define GL_DOUBLE                                                     0x140A
#define GL_DOUBLEBUFFER                                               0x0C32
#define GL_DOUBLE_MAT2                                                0x8F46
#define GL_DOUBLE_MAT2_EXT                                            0x8F46
#define GL_DOUBLE_MAT2x3                                              0x8F49
#define GL_DOUBLE_MAT2x3_EXT                                          0x8F49
#define GL_DOUBLE_MAT2x4                                              0x8F4A
#define GL_DOUBLE_MAT2x4_EXT                                          0x8F4A
#define GL_DOUBLE_MAT3                                                0x8F47
#define GL_DOUBLE_MAT3_EXT                                            0x8F47
#define GL_DOUBLE_MAT3x2                                              0x8F4B
#define GL_DOUBLE_MAT3x2_EXT                                          0x8F4B
#define GL_DOUBLE_MAT3x4                                              0x8F4C
#define GL_DOUBLE_MAT3x4_EXT                                          0x8F4C
#define GL_DOUBLE_MAT4                                                0x8F48
#define GL_DOUBLE_MAT4_EXT                                            0x8F48
#define GL_DOUBLE_MAT4x2                                              0x8F4D
#define GL_DOUBLE_MAT4x2_EXT                                          0x8F4D
#define GL_DOUBLE_MAT4x3                                              0x8F4E
#define GL_DOUBLE_MAT4x3_EXT                                          0x8F4E
#define GL_DOUBLE_VEC2                                                0x8FFC
#define GL_DOUBLE_VEC2_EXT                                            0x8FFC
#define GL_DOUBLE_VEC3                                                0x8FFD
#define GL_DOUBLE_VEC3_EXT                                            0x8FFD
#define GL_DOUBLE_VEC4                                                0x8FFE
#define GL_DOUBLE_VEC4_EXT                                            0x8FFE
#define GL_DRAW_ARRAYS_COMMAND_NV                                     0x0003
#define GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV                           0x0007
#define GL_DRAW_ARRAYS_STRIP_COMMAND_NV                               0x0005
#define GL_DRAW_BUFFER                                                0x0C01
#define GL_DRAW_BUFFER0                                               0x8825
#define GL_DRAW_BUFFER0_ARB                                           0x8825
#define GL_DRAW_BUFFER0_ATI                                           0x8825
#define GL_DRAW_BUFFER1                                               0x8826
#define GL_DRAW_BUFFER10                                              0x882F
#define GL_DRAW_BUFFER10_ARB                                          0x882F
#define GL_DRAW_BUFFER10_ATI                                          0x882F
#define GL_DRAW_BUFFER11                                              0x8830
#define GL_DRAW_BUFFER11_ARB                                          0x8830
#define GL_DRAW_BUFFER11_ATI                                          0x8830
#define GL_DRAW_BUFFER12                                              0x8831
#define GL_DRAW_BUFFER12_ARB                                          0x8831
#define GL_DRAW_BUFFER12_ATI                                          0x8831
#define GL_DRAW_BUFFER13                                              0x8832
#define GL_DRAW_BUFFER13_ARB                                          0x8832
#define GL_DRAW_BUFFER13_ATI                                          0x8832
#define GL_DRAW_BUFFER14                                              0x8833
#define GL_DRAW_BUFFER14_ARB                                          0x8833
#define GL_DRAW_BUFFER14_ATI                                          0x8833
#define GL_DRAW_BUFFER15                                              0x8834
#define GL_DRAW_BUFFER15_ARB                                          0x8834
#define GL_DRAW_BUFFER15_ATI                                          0x8834
#define GL_DRAW_BUFFER1_ARB                                           0x8826
#define GL_DRAW_BUFFER1_ATI                                           0x8826
#define GL_DRAW_BUFFER2                                               0x8827
#define GL_DRAW_BUFFER2_ARB                                           0x8827
#define GL_DRAW_BUFFER2_ATI                                           0x8827
#define GL_DRAW_BUFFER3                                               0x8828
#define GL_DRAW_BUFFER3_ARB                                           0x8828
#define GL_DRAW_BUFFER3_ATI                                           0x8828
#define GL_DRAW_BUFFER4                                               0x8829
#define GL_DRAW_BUFFER4_ARB                                           0x8829
#define GL_DRAW_BUFFER4_ATI                                           0x8829
#define GL_DRAW_BUFFER5                                               0x882A
#define GL_DRAW_BUFFER5_ARB                                           0x882A
#define GL_DRAW_BUFFER5_ATI                                           0x882A
#define GL_DRAW_BUFFER6                                               0x882B
#define GL_DRAW_BUFFER6_ARB                                           0x882B
#define GL_DRAW_BUFFER6_ATI                                           0x882B
#define GL_DRAW_BUFFER7                                               0x882C
#define GL_DRAW_BUFFER7_ARB                                           0x882C
#define GL_DRAW_BUFFER7_ATI                                           0x882C
#define GL_DRAW_BUFFER8                                               0x882D
#define GL_DRAW_BUFFER8_ARB                                           0x882D
#define GL_DRAW_BUFFER8_ATI                                           0x882D
#define GL_DRAW_BUFFER9                                               0x882E
#define GL_DRAW_BUFFER9_ARB                                           0x882E
#define GL_DRAW_BUFFER9_ATI                                           0x882E
#define GL_DRAW_ELEMENTS_COMMAND_NV                                   0x0002
#define GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV                         0x0006
#define GL_DRAW_ELEMENTS_STRIP_COMMAND_NV                             0x0004
#define GL_DRAW_FRAMEBUFFER                                           0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING                                   0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING_EXT                               0x8CA6
#define GL_DRAW_FRAMEBUFFER_EXT                                       0x8CA9
#define GL_DRAW_INDIRECT_ADDRESS_NV                                   0x8F41
#define GL_DRAW_INDIRECT_BUFFER                                       0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING                               0x8F43
#define GL_DRAW_INDIRECT_LENGTH_NV                                    0x8F42
#define GL_DRAW_INDIRECT_UNIFIED_NV                                   0x8F40
#define GL_DRAW_PIXELS_APPLE                                          0x8A0A
#define GL_DRIVER_UUID_EXT                                            0x9598
#define GL_DSDT8_MAG8_INTENSITY8_NV                                   0x870B
#define GL_DSDT8_MAG8_NV                                              0x870A
#define GL_DSDT8_NV                                                   0x8709
#define GL_DSDT_MAG_INTENSITY_NV                                      0x86DC
#define GL_DSDT_MAG_NV                                                0x86F6
#define GL_DSDT_MAG_VIB_NV                                            0x86F7
#define GL_DSDT_NV                                                    0x86F5
#define GL_DST_ALPHA                                                  0x0304
#define GL_DST_ATOP_NV                                                0x928F
#define GL_DST_COLOR                                                  0x0306
#define GL_DST_IN_NV                                                  0x928B
#define GL_DST_NV                                                     0x9287
#define GL_DST_OUT_NV                                                 0x928D
#define GL_DST_OVER_NV                                                0x9289
#define GL_DS_BIAS_NV                                                 0x8716
#define GL_DS_SCALE_NV                                                0x8710
#define GL_DT_BIAS_NV                                                 0x8717
#define GL_DT_SCALE_NV                                                0x8711
#define GL_DU8DV8_ATI                                                 0x877A
#define GL_DUAL_ALPHA12_SGIS                                          0x8112
#define GL_DUAL_ALPHA16_SGIS                                          0x8113
#define GL_DUAL_ALPHA4_SGIS                                           0x8110
#define GL_DUAL_ALPHA8_SGIS                                           0x8111
#define GL_DUAL_INTENSITY12_SGIS                                      0x811A
#define GL_DUAL_INTENSITY16_SGIS                                      0x811B
#define GL_DUAL_INTENSITY4_SGIS                                       0x8118
#define GL_DUAL_INTENSITY8_SGIS                                       0x8119
#define GL_DUAL_LUMINANCE12_SGIS                                      0x8116
#define GL_DUAL_LUMINANCE16_SGIS                                      0x8117
#define GL_DUAL_LUMINANCE4_SGIS                                       0x8114
#define GL_DUAL_LUMINANCE8_SGIS                                       0x8115
#define GL_DUAL_LUMINANCE_ALPHA4_SGIS                                 0x811C
#define GL_DUAL_LUMINANCE_ALPHA8_SGIS                                 0x811D
#define GL_DUAL_TEXTURE_SELECT_SGIS                                   0x8124
#define GL_DUDV_ATI                                                   0x8779
#define GL_DUP_FIRST_CUBIC_CURVE_TO_NV                                0xF2
#define GL_DUP_LAST_CUBIC_CURVE_TO_NV                                 0xF4
#define GL_DYNAMIC_ATI                                                0x8761
#define GL_DYNAMIC_COPY                                               0x88EA
#define GL_DYNAMIC_COPY_ARB                                           0x88EA
#define GL_DYNAMIC_DRAW                                               0x88E8
#define GL_DYNAMIC_DRAW_ARB                                           0x88E8
#define GL_DYNAMIC_READ                                               0x88E9
#define GL_DYNAMIC_READ_ARB                                           0x88E9
#define GL_DYNAMIC_STORAGE_BIT                                        0x0100
#define GL_EDGEFLAG_BIT_PGI                                           0x00040000
#define GL_EDGE_FLAG_ARRAY_ADDRESS_NV                                 0x8F26
#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB                         0x889B
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT                                  0x808D
#define GL_EDGE_FLAG_ARRAY_EXT                                        0x8079
#define GL_EDGE_FLAG_ARRAY_LENGTH_NV                                  0x8F30
#define GL_EDGE_FLAG_ARRAY_LIST_IBM                                   103075
#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM                            103085
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT                                0x8093
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT                                 0x808C
#define GL_EFFECTIVE_RASTER_SAMPLES_EXT                               0x932C
#define GL_EIGHTH_BIT_ATI                                             0x00000020
#define GL_ELEMENT_ADDRESS_COMMAND_NV                                 0x0008
#define GL_ELEMENT_ARRAY_ADDRESS_NV                                   0x8F29
#define GL_ELEMENT_ARRAY_APPLE                                        0x8A0C
#define GL_ELEMENT_ARRAY_ATI                                          0x8768
#define GL_ELEMENT_ARRAY_BARRIER_BIT                                  0x00000002
#define GL_ELEMENT_ARRAY_BARRIER_BIT_EXT                              0x00000002
#define GL_ELEMENT_ARRAY_BUFFER                                       0x8893
#define GL_ELEMENT_ARRAY_BUFFER_ARB                                   0x8893
#define GL_ELEMENT_ARRAY_BUFFER_BINDING                               0x8895
#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB                           0x8895
#define GL_ELEMENT_ARRAY_LENGTH_NV                                    0x8F33
#define GL_ELEMENT_ARRAY_POINTER_APPLE                                0x8A0E
#define GL_ELEMENT_ARRAY_POINTER_ATI                                  0x876A
#define GL_ELEMENT_ARRAY_TYPE_APPLE                                   0x8A0D
#define GL_ELEMENT_ARRAY_TYPE_ATI                                     0x8769
#define GL_ELEMENT_ARRAY_UNIFIED_NV                                   0x8F1F
#define GL_EMBOSS_CONSTANT_NV                                         0x855E
#define GL_EMBOSS_LIGHT_NV                                            0x855D
#define GL_EMBOSS_MAP_NV                                              0x855F
#define GL_EQUAL                                                      0x0202
#define GL_EQUIV                                                      0x1509
#define GL_EVAL_2D_NV                                                 0x86C0
#define GL_EVAL_FRACTIONAL_TESSELLATION_NV                            0x86C5
#define GL_EVAL_TRIANGULAR_2D_NV                                      0x86C1
#define GL_EVAL_VERTEX_ATTRIB0_NV                                     0x86C6
#define GL_EVAL_VERTEX_ATTRIB10_NV                                    0x86D0
#define GL_EVAL_VERTEX_ATTRIB11_NV                                    0x86D1
#define GL_EVAL_VERTEX_ATTRIB12_NV                                    0x86D2
#define GL_EVAL_VERTEX_ATTRIB13_NV                                    0x86D3
#define GL_EVAL_VERTEX_ATTRIB14_NV                                    0x86D4
#define GL_EVAL_VERTEX_ATTRIB15_NV                                    0x86D5
#define GL_EVAL_VERTEX_ATTRIB1_NV                                     0x86C7
#define GL_EVAL_VERTEX_ATTRIB2_NV                                     0x86C8
#define GL_EVAL_VERTEX_ATTRIB3_NV                                     0x86C9
#define GL_EVAL_VERTEX_ATTRIB4_NV                                     0x86CA
#define GL_EVAL_VERTEX_ATTRIB5_NV                                     0x86CB
#define GL_EVAL_VERTEX_ATTRIB6_NV                                     0x86CC
#define GL_EVAL_VERTEX_ATTRIB7_NV                                     0x86CD
#define GL_EVAL_VERTEX_ATTRIB8_NV                                     0x86CE
#define GL_EVAL_VERTEX_ATTRIB9_NV                                     0x86CF
#define GL_EXCLUSION_KHR                                              0x92A0
#define GL_EXCLUSION_NV                                               0x92A0
#define GL_EXCLUSIVE_EXT                                              0x8F11
#define GL_EXPAND_NEGATE_NV                                           0x8539
#define GL_EXPAND_NORMAL_NV                                           0x8538
#define GL_EXTENSIONS                                                 0x1F03
#define GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD                         0x9160
#define GL_EYE_DISTANCE_TO_LINE_SGIS                                  0x81F2
#define GL_EYE_DISTANCE_TO_POINT_SGIS                                 0x81F0
#define GL_EYE_LINE_SGIS                                              0x81F6
#define GL_EYE_PLANE                                                  0x2502
#define GL_EYE_PLANE_ABSOLUTE_NV                                      0x855C
#define GL_EYE_POINT_SGIS                                             0x81F4
#define GL_EYE_RADIAL_NV                                              0x855B
#define GL_E_TIMES_F_NV                                               0x8531
#define GL_FACTOR_MAX_AMD                                             0x901D
#define GL_FACTOR_MIN_AMD                                             0x901C
#define GL_FAILURE_NV                                                 0x9030
#define GL_FALSE                                                      0
#define GL_FASTEST                                                    0x1101
#define GL_FENCE_APPLE                                                0x8A0B
#define GL_FENCE_CONDITION_NV                                         0x84F4
#define GL_FENCE_STATUS_NV                                            0x84F3
#define GL_FIELDS_NV                                                  0x8E27
#define GL_FIELD_LOWER_NV                                             0x9023
#define GL_FIELD_UPPER_NV                                             0x9022
#define GL_FILE_NAME_NV                                               0x9074
#define GL_FILL                                                       0x1B02
#define GL_FILL_RECTANGLE_NV                                          0x933C
#define GL_FILTER                                                     0x829A
#define GL_FILTER4_SGIS                                               0x8146
#define GL_FIRST_TO_REST_NV                                           0x90AF
#define GL_FIRST_VERTEX_CONVENTION                                    0x8E4D
#define GL_FIRST_VERTEX_CONVENTION_EXT                                0x8E4D
#define GL_FIXED                                                      0x140C
#define GL_FIXED_OES                                                  0x140C
#define GL_FIXED_ONLY                                                 0x891D
#define GL_FIXED_ONLY_ARB                                             0x891D
#define GL_FLOAT                                                      0x1406
#define GL_FLOAT16_MAT2_AMD                                           0x91C5
#define GL_FLOAT16_MAT2x3_AMD                                         0x91C8
#define GL_FLOAT16_MAT2x4_AMD                                         0x91C9
#define GL_FLOAT16_MAT3_AMD                                           0x91C6
#define GL_FLOAT16_MAT3x2_AMD                                         0x91CA
#define GL_FLOAT16_MAT3x4_AMD                                         0x91CB
#define GL_FLOAT16_MAT4_AMD                                           0x91C7
#define GL_FLOAT16_MAT4x2_AMD                                         0x91CC
#define GL_FLOAT16_MAT4x3_AMD                                         0x91CD
#define GL_FLOAT16_NV                                                 0x8FF8
#define GL_FLOAT16_VEC2_NV                                            0x8FF9
#define GL_FLOAT16_VEC3_NV                                            0x8FFA
#define GL_FLOAT16_VEC4_NV                                            0x8FFB
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV                             0x8DAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV                          0x8DAD
#define GL_FLOAT_CLEAR_COLOR_VALUE_NV                                 0x888D
#define GL_FLOAT_MAT2                                                 0x8B5A
#define GL_FLOAT_MAT2_ARB                                             0x8B5A
#define GL_FLOAT_MAT2x3                                               0x8B65
#define GL_FLOAT_MAT2x4                                               0x8B66
#define GL_FLOAT_MAT3                                                 0x8B5B
#define GL_FLOAT_MAT3_ARB                                             0x8B5B
#define GL_FLOAT_MAT3x2                                               0x8B67
#define GL_FLOAT_MAT3x4                                               0x8B68
#define GL_FLOAT_MAT4                                                 0x8B5C
#define GL_FLOAT_MAT4_ARB                                             0x8B5C
#define GL_FLOAT_MAT4x2                                               0x8B69
#define GL_FLOAT_MAT4x3                                               0x8B6A
#define GL_FLOAT_R16_NV                                               0x8884
#define GL_FLOAT_R32_NV                                               0x8885
#define GL_FLOAT_RG16_NV                                              0x8886
#define GL_FLOAT_RG32_NV                                              0x8887
#define GL_FLOAT_RGB16_NV                                             0x8888
#define GL_FLOAT_RGB32_NV                                             0x8889
#define GL_FLOAT_RGBA16_NV                                            0x888A
#define GL_FLOAT_RGBA32_NV                                            0x888B
#define GL_FLOAT_RGBA_MODE_NV                                         0x888E
#define GL_FLOAT_RGBA_NV                                              0x8883
#define GL_FLOAT_RGB_NV                                               0x8882
#define GL_FLOAT_RG_NV                                                0x8881
#define GL_FLOAT_R_NV                                                 0x8880
#define GL_FLOAT_VEC2                                                 0x8B50
#define GL_FLOAT_VEC2_ARB                                             0x8B50
#define GL_FLOAT_VEC3                                                 0x8B51
#define GL_FLOAT_VEC3_ARB                                             0x8B51
#define GL_FLOAT_VEC4                                                 0x8B52
#define GL_FLOAT_VEC4_ARB                                             0x8B52
#define GL_FOG                                                        0x0B60
#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB                    0x889D
#define GL_FOG_COORDINATE_ARRAY_EXT                                   0x8457
#define GL_FOG_COORDINATE_ARRAY_LIST_IBM                              103076
#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM                       103086
#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT                           0x8456
#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT                            0x8455
#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT                              0x8454
#define GL_FOG_COORDINATE_EXT                                         0x8451
#define GL_FOG_COORDINATE_SOURCE_EXT                                  0x8450
#define GL_FOG_COORD_ARRAY_ADDRESS_NV                                 0x8F28
#define GL_FOG_COORD_ARRAY_LENGTH_NV                                  0x8F32
#define GL_FOG_DISTANCE_MODE_NV                                       0x855A
#define GL_FOG_FUNC_POINTS_SGIS                                       0x812B
#define GL_FOG_FUNC_SGIS                                              0x812A
#define GL_FOG_OFFSET_SGIX                                            0x8198
#define GL_FOG_OFFSET_VALUE_SGIX                                      0x8199
#define GL_FOG_SPECULAR_TEXTURE_WIN                                   0x80EC
#define GL_FONT_ASCENDER_BIT_NV                                       0x00200000
#define GL_FONT_DESCENDER_BIT_NV                                      0x00400000
#define GL_FONT_GLYPHS_AVAILABLE_NV                                   0x9368
#define GL_FONT_HAS_KERNING_BIT_NV                                    0x10000000
#define GL_FONT_HEIGHT_BIT_NV                                         0x00800000
#define GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV                             0x02000000
#define GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV                              0x01000000
#define GL_FONT_NUM_GLYPH_INDICES_BIT_NV                              0x20000000
#define GL_FONT_TARGET_UNAVAILABLE_NV                                 0x9369
#define GL_FONT_UNAVAILABLE_NV                                        0x936A
#define GL_FONT_UNDERLINE_POSITION_BIT_NV                             0x04000000
#define GL_FONT_UNDERLINE_THICKNESS_BIT_NV                            0x08000000
#define GL_FONT_UNINTELLIGIBLE_NV                                     0x936B
#define GL_FONT_UNITS_PER_EM_BIT_NV                                   0x00100000
#define GL_FONT_X_MAX_BOUNDS_BIT_NV                                   0x00040000
#define GL_FONT_X_MIN_BOUNDS_BIT_NV                                   0x00010000
#define GL_FONT_Y_MAX_BOUNDS_BIT_NV                                   0x00080000
#define GL_FONT_Y_MIN_BOUNDS_BIT_NV                                   0x00020000
#define GL_FORCE_BLUE_TO_ONE_NV                                       0x8860
#define GL_FORMAT_SUBSAMPLE_244_244_OML                               0x8983
#define GL_FORMAT_SUBSAMPLE_24_24_OML                                 0x8982
#define GL_FRACTIONAL_EVEN                                            0x8E7C
#define GL_FRACTIONAL_ODD                                             0x8E7B
#define GL_FRAGMENT_COLOR_EXT                                         0x834C
#define GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX                          0x8402
#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX                     0x8403
#define GL_FRAGMENT_COLOR_MATERIAL_SGIX                               0x8401
#define GL_FRAGMENT_COVERAGE_COLOR_NV                                 0x92DE
#define GL_FRAGMENT_COVERAGE_TO_COLOR_NV                              0x92DD
#define GL_FRAGMENT_DEPTH_EXT                                         0x8452
#define GL_FRAGMENT_INPUT_NV                                          0x936D
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS                         0x8E5D
#define GL_FRAGMENT_LIGHT0_SGIX                                       0x840C
#define GL_FRAGMENT_LIGHT1_SGIX                                       0x840D
#define GL_FRAGMENT_LIGHT2_SGIX                                       0x840E
#define GL_FRAGMENT_LIGHT3_SGIX                                       0x840F
#define GL_FRAGMENT_LIGHT4_SGIX                                       0x8410
#define GL_FRAGMENT_LIGHT5_SGIX                                       0x8411
#define GL_FRAGMENT_LIGHT6_SGIX                                       0x8412
#define GL_FRAGMENT_LIGHT7_SGIX                                       0x8413
#define GL_FRAGMENT_LIGHTING_SGIX                                     0x8400
#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX                          0x840A
#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX                     0x8408
#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX             0x840B
#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX                         0x8409
#define GL_FRAGMENT_MATERIAL_EXT                                      0x8349
#define GL_FRAGMENT_NORMAL_EXT                                        0x834A
#define GL_FRAGMENT_PROGRAM_ARB                                       0x8804
#define GL_FRAGMENT_PROGRAM_BINDING_NV                                0x8873
#define GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV              0x8E5D
#define GL_FRAGMENT_PROGRAM_NV                                        0x8870
#define GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV                       0x8DA4
#define GL_FRAGMENT_SHADER                                            0x8B30
#define GL_FRAGMENT_SHADER_ARB                                        0x8B30
#define GL_FRAGMENT_SHADER_ATI                                        0x8920
#define GL_FRAGMENT_SHADER_BIT                                        0x00000002
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT                            0x8B8B
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB                        0x8B8B
#define GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT                       0x8A52
#define GL_FRAGMENT_SHADER_INVOCATIONS                                0x82F4
#define GL_FRAGMENT_SHADER_INVOCATIONS_ARB                            0x82F4
#define GL_FRAGMENT_SUBROUTINE                                        0x92EC
#define GL_FRAGMENT_SUBROUTINE_UNIFORM                                0x92F2
#define GL_FRAGMENT_TEXTURE                                           0x829F
#define GL_FRAMEBUFFER                                                0x8D40
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE                          0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE                           0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING                      0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE                      0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE                          0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE                          0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED                             0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB                         0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT                         0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME                         0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT                     0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                         0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT                     0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE                            0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE                        0x8217
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT              0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR         0x9632
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE               0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT           0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER                       0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT                   0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL                       0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT                   0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR               0x9630
#define GL_FRAMEBUFFER_BARRIER_BIT                                    0x00000400
#define GL_FRAMEBUFFER_BARRIER_BIT_EXT                                0x00000400
#define GL_FRAMEBUFFER_BINDING                                        0x8CA6
#define GL_FRAMEBUFFER_BINDING_EXT                                    0x8CA6
#define GL_FRAMEBUFFER_BLEND                                          0x828B
#define GL_FRAMEBUFFER_COMPLETE                                       0x8CD5
#define GL_FRAMEBUFFER_COMPLETE_EXT                                   0x8CD5
#define GL_FRAMEBUFFER_DEFAULT                                        0x8218
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS                 0x9314
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT                                 0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS                                 0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES                                0x9313
#define GL_FRAMEBUFFER_DEFAULT_WIDTH                                  0x9310
#define GL_FRAMEBUFFER_EXT                                            0x8D40
#define GL_FRAMEBUFFER_FLIP_X_MESA                                    0x8BBC
#define GL_FRAMEBUFFER_FLIP_Y_MESA                                    0x8BBB
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT                          0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT                      0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT                      0x8CD9
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER                         0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT                     0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT                         0x8CDA
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB                     0x8DA9
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT                     0x8DA9
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS                       0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB                   0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT                   0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT                  0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT              0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE                         0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT                     0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER                         0x8CDC
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT                     0x8CDC
#define GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR                    0x9633
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB              0x9342
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV               0x9342
#define GL_FRAMEBUFFER_RENDERABLE                                     0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED                             0x828A
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB                 0x9343
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV                  0x9343
#define GL_FRAMEBUFFER_SRGB                                           0x8DB9
#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT                               0x8DBA
#define GL_FRAMEBUFFER_SRGB_EXT                                       0x8DB9
#define GL_FRAMEBUFFER_SWAP_XY_MESA                                   0x8BBD
#define GL_FRAMEBUFFER_UNDEFINED                                      0x8219
#define GL_FRAMEBUFFER_UNSUPPORTED                                    0x8CDD
#define GL_FRAMEBUFFER_UNSUPPORTED_EXT                                0x8CDD
#define GL_FRAMEZOOM_FACTOR_SGIX                                      0x818C
#define GL_FRAMEZOOM_SGIX                                             0x818B
#define GL_FRAME_NV                                                   0x8E26
#define GL_FRONT                                                      0x0404
#define GL_FRONT_AND_BACK                                             0x0408
#define GL_FRONT_FACE                                                 0x0B46
#define GL_FRONT_FACE_COMMAND_NV                                      0x0012
#define GL_FRONT_LEFT                                                 0x0400
#define GL_FRONT_RIGHT                                                0x0401
#define GL_FULL_RANGE_EXT                                             0x87E1
#define GL_FULL_STIPPLE_HINT_PGI                                      0x1A219
#define GL_FULL_SUPPORT                                               0x82B7
#define GL_FUNC_ADD                                                   0x8006
#define GL_FUNC_ADD_EXT                                               0x8006
#define GL_FUNC_REVERSE_SUBTRACT                                      0x800B
#define GL_FUNC_REVERSE_SUBTRACT_EXT                                  0x800B
#define GL_FUNC_SUBTRACT                                              0x800A
#define GL_FUNC_SUBTRACT_EXT                                          0x800A
#define GL_GENERATE_MIPMAP_HINT_SGIS                                  0x8192
#define GL_GENERATE_MIPMAP_SGIS                                       0x8191
#define GL_GENERIC_ATTRIB_NV                                          0x8C7D
#define GL_GEOMETRY_DEFORMATION_BIT_SGIX                              0x00000002
#define GL_GEOMETRY_DEFORMATION_SGIX                                  0x8194
#define GL_GEOMETRY_INPUT_TYPE                                        0x8917
#define GL_GEOMETRY_INPUT_TYPE_ARB                                    0x8DDB
#define GL_GEOMETRY_INPUT_TYPE_EXT                                    0x8DDB
#define GL_GEOMETRY_OUTPUT_TYPE                                       0x8918
#define GL_GEOMETRY_OUTPUT_TYPE_ARB                                   0x8DDC
#define GL_GEOMETRY_OUTPUT_TYPE_EXT                                   0x8DDC
#define GL_GEOMETRY_PROGRAM_NV                                        0x8C26
#define GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV                       0x8DA3
#define GL_GEOMETRY_SHADER                                            0x8DD9
#define GL_GEOMETRY_SHADER_ARB                                        0x8DD9
#define GL_GEOMETRY_SHADER_BIT                                        0x00000004
#define GL_GEOMETRY_SHADER_EXT                                        0x8DD9
#define GL_GEOMETRY_SHADER_INVOCATIONS                                0x887F
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED                         0x82F3
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB                     0x82F3
#define GL_GEOMETRY_SUBROUTINE                                        0x92EB
#define GL_GEOMETRY_SUBROUTINE_UNIFORM                                0x92F1
#define GL_GEOMETRY_TEXTURE                                           0x829E
#define GL_GEOMETRY_VERTICES_OUT                                      0x8916
#define GL_GEOMETRY_VERTICES_OUT_ARB                                  0x8DDA
#define GL_GEOMETRY_VERTICES_OUT_EXT                                  0x8DDA
#define GL_GEQUAL                                                     0x0206
#define GL_GET_TEXTURE_IMAGE_FORMAT                                   0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE                                     0x8292
#define GL_GLOBAL_ALPHA_FACTOR_SUN                                    0x81DA
#define GL_GLOBAL_ALPHA_SUN                                           0x81D9
#define GL_GLYPH_HAS_KERNING_BIT_NV                                   0x100
#define GL_GLYPH_HEIGHT_BIT_NV                                        0x02
#define GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV                    0x10
#define GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV                          0x04
#define GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV                          0x08
#define GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV                      0x80
#define GL_GLYPH_VERTICAL_BEARING_X_BIT_NV                            0x20
#define GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV                            0x40
#define GL_GLYPH_WIDTH_BIT_NV                                         0x01
#define GL_GPU_ADDRESS_NV                                             0x8F34
#define GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX               0x9049
#define GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX                       0x9047
#define GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX                         0x904B
#define GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX                         0x904A
#define GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX                 0x9048
#define GL_GREATER                                                    0x0204
#define GL_GREEN                                                      0x1904
#define GL_GREEN_BIT_ATI                                              0x00000002
#define GL_GREEN_INTEGER                                              0x8D95
#define GL_GREEN_INTEGER_EXT                                          0x8D95
#define GL_GREEN_MAX_CLAMP_INGR                                       0x8565
#define GL_GREEN_MIN_CLAMP_INGR                                       0x8561
#define GL_GREEN_NV                                                   0x1904
#define GL_GUILTY_CONTEXT_RESET                                       0x8253
#define GL_GUILTY_CONTEXT_RESET_ARB                                   0x8253
#define GL_HALF_APPLE                                                 0x140B
#define GL_HALF_BIAS_NEGATE_NV                                        0x853B
#define GL_HALF_BIAS_NORMAL_NV                                        0x853A
#define GL_HALF_BIT_ATI                                               0x00000008
#define GL_HALF_FLOAT                                                 0x140B
#define GL_HALF_FLOAT_ARB                                             0x140B
#define GL_HALF_FLOAT_NV                                              0x140B
#define GL_HANDLE_TYPE_D3D11_IMAGE_EXT                                0x958B
#define GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT                            0x958C
#define GL_HANDLE_TYPE_D3D12_FENCE_EXT                                0x9594
#define GL_HANDLE_TYPE_D3D12_RESOURCE_EXT                             0x958A
#define GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT                             0x9589
#define GL_HANDLE_TYPE_OPAQUE_FD_EXT                                  0x9586
#define GL_HANDLE_TYPE_OPAQUE_WIN32_EXT                               0x9587
#define GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT                           0x9588
#define GL_HARDLIGHT_KHR                                              0x929B
#define GL_HARDLIGHT_NV                                               0x929B
#define GL_HARDMIX_NV                                                 0x92A9
#define GL_HIGH_FLOAT                                                 0x8DF2
#define GL_HIGH_INT                                                   0x8DF5
#define GL_HILO16_NV                                                  0x86F8
#define GL_HILO8_NV                                                   0x885E
#define GL_HILO_NV                                                    0x86F4
#define GL_HISTOGRAM_ALPHA_SIZE_EXT                                   0x802B
#define GL_HISTOGRAM_BLUE_SIZE_EXT                                    0x802A
#define GL_HISTOGRAM_EXT                                              0x8024
#define GL_HISTOGRAM_FORMAT_EXT                                       0x8027
#define GL_HISTOGRAM_GREEN_SIZE_EXT                                   0x8029
#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT                               0x802C
#define GL_HISTOGRAM_RED_SIZE_EXT                                     0x8028
#define GL_HISTOGRAM_SINK_EXT                                         0x802D
#define GL_HISTOGRAM_WIDTH_EXT                                        0x8026
#define GL_HI_BIAS_NV                                                 0x8714
#define GL_HI_SCALE_NV                                                0x870E
#define GL_HORIZONTAL_LINE_TO_NV                                      0x06
#define GL_HSL_COLOR_KHR                                              0x92AF
#define GL_HSL_COLOR_NV                                               0x92AF
#define GL_HSL_HUE_KHR                                                0x92AD
#define GL_HSL_HUE_NV                                                 0x92AD
#define GL_HSL_LUMINOSITY_KHR                                         0x92B0
#define GL_HSL_LUMINOSITY_NV                                          0x92B0
#define GL_HSL_SATURATION_KHR                                         0x92AE
#define GL_HSL_SATURATION_NV                                          0x92AE
#define GL_IDENTITY_NV                                                0x862A
#define GL_IGNORE_BORDER_HP                                           0x8150
#define GL_IMAGE_1D                                                   0x904C
#define GL_IMAGE_1D_ARRAY                                             0x9052
#define GL_IMAGE_1D_ARRAY_EXT                                         0x9052
#define GL_IMAGE_1D_EXT                                               0x904C
#define GL_IMAGE_2D                                                   0x904D
#define GL_IMAGE_2D_ARRAY                                             0x9053
#define GL_IMAGE_2D_ARRAY_EXT                                         0x9053
#define GL_IMAGE_2D_EXT                                               0x904D
#define GL_IMAGE_2D_MULTISAMPLE                                       0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY                                 0x9056
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT                             0x9056
#define GL_IMAGE_2D_MULTISAMPLE_EXT                                   0x9055
#define GL_IMAGE_2D_RECT                                              0x904F
#define GL_IMAGE_2D_RECT_EXT                                          0x904F
#define GL_IMAGE_3D                                                   0x904E
#define GL_IMAGE_3D_EXT                                               0x904E
#define GL_IMAGE_BINDING_ACCESS                                       0x8F3E
#define GL_IMAGE_BINDING_ACCESS_EXT                                   0x8F3E
#define GL_IMAGE_BINDING_FORMAT                                       0x906E
#define GL_IMAGE_BINDING_FORMAT_EXT                                   0x906E
#define GL_IMAGE_BINDING_LAYER                                        0x8F3D
#define GL_IMAGE_BINDING_LAYERED                                      0x8F3C
#define GL_IMAGE_BINDING_LAYERED_EXT                                  0x8F3C
#define GL_IMAGE_BINDING_LAYER_EXT                                    0x8F3D
#define GL_IMAGE_BINDING_LEVEL                                        0x8F3B
#define GL_IMAGE_BINDING_LEVEL_EXT                                    0x8F3B
#define GL_IMAGE_BINDING_NAME                                         0x8F3A
#define GL_IMAGE_BINDING_NAME_EXT                                     0x8F3A
#define GL_IMAGE_BUFFER                                               0x9051
#define GL_IMAGE_BUFFER_EXT                                           0x9051
#define GL_IMAGE_CLASS_10_10_10_2                                     0x82C3
#define GL_IMAGE_CLASS_11_11_10                                       0x82C2
#define GL_IMAGE_CLASS_1_X_16                                         0x82BE
#define GL_IMAGE_CLASS_1_X_32                                         0x82BB
#define GL_IMAGE_CLASS_1_X_8                                          0x82C1
#define GL_IMAGE_CLASS_2_X_16                                         0x82BD
#define GL_IMAGE_CLASS_2_X_32                                         0x82BA
#define GL_IMAGE_CLASS_2_X_8                                          0x82C0
#define GL_IMAGE_CLASS_4_X_16                                         0x82BC
#define GL_IMAGE_CLASS_4_X_32                                         0x82B9
#define GL_IMAGE_CLASS_4_X_8                                          0x82BF
#define GL_IMAGE_COMPATIBILITY_CLASS                                  0x82A8
#define GL_IMAGE_CUBE                                                 0x9050
#define GL_IMAGE_CUBE_EXT                                             0x9050
#define GL_IMAGE_CUBE_MAP_ARRAY                                       0x9054
#define GL_IMAGE_CUBE_MAP_ARRAY_EXT                                   0x9054
#define GL_IMAGE_CUBIC_WEIGHT_HP                                      0x815E
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS                        0x90C9
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE                         0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE                            0x90C7
#define GL_IMAGE_MAG_FILTER_HP                                        0x815C
#define GL_IMAGE_MIN_FILTER_HP                                        0x815D
#define GL_IMAGE_PIXEL_FORMAT                                         0x82A9
#define GL_IMAGE_PIXEL_TYPE                                           0x82AA
#define GL_IMAGE_ROTATE_ANGLE_HP                                      0x8159
#define GL_IMAGE_ROTATE_ORIGIN_X_HP                                   0x815A
#define GL_IMAGE_ROTATE_ORIGIN_Y_HP                                   0x815B
#define GL_IMAGE_SCALE_X_HP                                           0x8155
#define GL_IMAGE_SCALE_Y_HP                                           0x8156
#define GL_IMAGE_TEXEL_SIZE                                           0x82A7
#define GL_IMAGE_TRANSFORM_2D_HP                                      0x8161
#define GL_IMAGE_TRANSLATE_X_HP                                       0x8157
#define GL_IMAGE_TRANSLATE_Y_HP                                       0x8158
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT                           0x8B9B
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES                       0x8B9B
#define GL_IMPLEMENTATION_COLOR_READ_TYPE                             0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES                         0x8B9A
#define GL_INCLUSIVE_EXT                                              0x8F10
#define GL_INCR                                                       0x1E02
#define GL_INCR_WRAP                                                  0x8507
#define GL_INCR_WRAP_EXT                                              0x8507
#define GL_INDEX_ARRAY_ADDRESS_NV                                     0x8F24
#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB                             0x8899
#define GL_INDEX_ARRAY_COUNT_EXT                                      0x8087
#define GL_INDEX_ARRAY_EXT                                            0x8077
#define GL_INDEX_ARRAY_LENGTH_NV                                      0x8F2E
#define GL_INDEX_ARRAY_LIST_IBM                                       103073
#define GL_INDEX_ARRAY_LIST_STRIDE_IBM                                103083
#define GL_INDEX_ARRAY_POINTER_EXT                                    0x8091
#define GL_INDEX_ARRAY_STRIDE_EXT                                     0x8086
#define GL_INDEX_ARRAY_TYPE_EXT                                       0x8085
#define GL_INDEX_BIT_PGI                                              0x00080000
#define GL_INDEX_MATERIAL_EXT                                         0x81B8
#define GL_INDEX_MATERIAL_FACE_EXT                                    0x81BA
#define GL_INDEX_MATERIAL_PARAMETER_EXT                               0x81B9
#define GL_INDEX_TEST_EXT                                             0x81B5
#define GL_INDEX_TEST_FUNC_EXT                                        0x81B6
#define GL_INDEX_TEST_REF_EXT                                         0x81B7
#define GL_INFO_LOG_LENGTH                                            0x8B84
#define GL_INNOCENT_CONTEXT_RESET                                     0x8254
#define GL_INNOCENT_CONTEXT_RESET_ARB                                 0x8254
#define GL_INSTRUMENT_BUFFER_POINTER_SGIX                             0x8180
#define GL_INSTRUMENT_MEASUREMENTS_SGIX                               0x8181
#define GL_INT                                                        0x1404
#define GL_INT16_NV                                                   0x8FE4
#define GL_INT16_VEC2_NV                                              0x8FE5
#define GL_INT16_VEC3_NV                                              0x8FE6
#define GL_INT16_VEC4_NV                                              0x8FE7
#define GL_INT64_ARB                                                  0x140E
#define GL_INT64_NV                                                   0x140E
#define GL_INT64_VEC2_ARB                                             0x8FE9
#define GL_INT64_VEC2_NV                                              0x8FE9
#define GL_INT64_VEC3_ARB                                             0x8FEA
#define GL_INT64_VEC3_NV                                              0x8FEA
#define GL_INT64_VEC4_ARB                                             0x8FEB
#define GL_INT64_VEC4_NV                                              0x8FEB
#define GL_INT8_NV                                                    0x8FE0
#define GL_INT8_VEC2_NV                                               0x8FE1
#define GL_INT8_VEC3_NV                                               0x8FE2
#define GL_INT8_VEC4_NV                                               0x8FE3
#define GL_INTENSITY12_EXT                                            0x804C
#define GL_INTENSITY16F_ARB                                           0x881D
#define GL_INTENSITY16I_EXT                                           0x8D8B
#define GL_INTENSITY16UI_EXT                                          0x8D79
#define GL_INTENSITY16_EXT                                            0x804D
#define GL_INTENSITY16_SNORM                                          0x901B
#define GL_INTENSITY32F_ARB                                           0x8817
#define GL_INTENSITY32I_EXT                                           0x8D85
#define GL_INTENSITY32UI_EXT                                          0x8D73
#define GL_INTENSITY4_EXT                                             0x804A
#define GL_INTENSITY8I_EXT                                            0x8D91
#define GL_INTENSITY8UI_EXT                                           0x8D7F
#define GL_INTENSITY8_EXT                                             0x804B
#define GL_INTENSITY8_SNORM                                           0x9017
#define GL_INTENSITY_EXT                                              0x8049
#define GL_INTENSITY_FLOAT16_APPLE                                    0x881D
#define GL_INTENSITY_FLOAT16_ATI                                      0x881D
#define GL_INTENSITY_FLOAT32_APPLE                                    0x8817
#define GL_INTENSITY_FLOAT32_ATI                                      0x8817
#define GL_INTENSITY_SNORM                                            0x9013
#define GL_INTERLACE_OML                                              0x8980
#define GL_INTERLACE_READ_INGR                                        0x8568
#define GL_INTERLACE_READ_OML                                         0x8981
#define GL_INTERLACE_SGIX                                             0x8094
#define GL_INTERLEAVED_ATTRIBS                                        0x8C8C
#define GL_INTERLEAVED_ATTRIBS_EXT                                    0x8C8C
#define GL_INTERLEAVED_ATTRIBS_NV                                     0x8C8C
#define GL_INTERNALFORMAT_ALPHA_SIZE                                  0x8274
#define GL_INTERNALFORMAT_ALPHA_TYPE                                  0x827B
#define GL_INTERNALFORMAT_BLUE_SIZE                                   0x8273
#define GL_INTERNALFORMAT_BLUE_TYPE                                   0x827A
#define GL_INTERNALFORMAT_DEPTH_SIZE                                  0x8275
#define GL_INTERNALFORMAT_DEPTH_TYPE                                  0x827C
#define GL_INTERNALFORMAT_GREEN_SIZE                                  0x8272
#define GL_INTERNALFORMAT_GREEN_TYPE                                  0x8279
#define GL_INTERNALFORMAT_PREFERRED                                   0x8270
#define GL_INTERNALFORMAT_RED_SIZE                                    0x8271
#define GL_INTERNALFORMAT_RED_TYPE                                    0x8278
#define GL_INTERNALFORMAT_SHARED_SIZE                                 0x8277
#define GL_INTERNALFORMAT_STENCIL_SIZE                                0x8276
#define GL_INTERNALFORMAT_STENCIL_TYPE                                0x827D
#define GL_INTERNALFORMAT_SUPPORTED                                   0x826F
#define GL_INTERPOLATE_ARB                                            0x8575
#define GL_INTERPOLATE_EXT                                            0x8575
#define GL_INT_2_10_10_10_REV                                         0x8D9F
#define GL_INT_IMAGE_1D                                               0x9057
#define GL_INT_IMAGE_1D_ARRAY                                         0x905D
#define GL_INT_IMAGE_1D_ARRAY_EXT                                     0x905D
#define GL_INT_IMAGE_1D_EXT                                           0x9057
#define GL_INT_IMAGE_2D                                               0x9058
#define GL_INT_IMAGE_2D_ARRAY                                         0x905E
#define GL_INT_IMAGE_2D_ARRAY_EXT                                     0x905E
#define GL_INT_IMAGE_2D_EXT                                           0x9058
#define GL_INT_IMAGE_2D_MULTISAMPLE                                   0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY                             0x9061
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT                         0x9061
#define GL_INT_IMAGE_2D_MULTISAMPLE_EXT                               0x9060
#define GL_INT_IMAGE_2D_RECT                                          0x905A
#define GL_INT_IMAGE_2D_RECT_EXT                                      0x905A
#define GL_INT_IMAGE_3D                                               0x9059
#define GL_INT_IMAGE_3D_EXT                                           0x9059
#define GL_INT_IMAGE_BUFFER                                           0x905C
#define GL_INT_IMAGE_BUFFER_EXT                                       0x905C
#define GL_INT_IMAGE_CUBE                                             0x905B
#define GL_INT_IMAGE_CUBE_EXT                                         0x905B
#define GL_INT_IMAGE_CUBE_MAP_ARRAY                                   0x905F
#define GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT                               0x905F
#define GL_INT_SAMPLER_1D                                             0x8DC9
#define GL_INT_SAMPLER_1D_ARRAY                                       0x8DCE
#define GL_INT_SAMPLER_1D_ARRAY_EXT                                   0x8DCE
#define GL_INT_SAMPLER_1D_EXT                                         0x8DC9
#define GL_INT_SAMPLER_2D                                             0x8DCA
#define GL_INT_SAMPLER_2D_ARRAY                                       0x8DCF
#define GL_INT_SAMPLER_2D_ARRAY_EXT                                   0x8DCF
#define GL_INT_SAMPLER_2D_EXT                                         0x8DCA
#define GL_INT_SAMPLER_2D_MULTISAMPLE                                 0x9109
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY                           0x910C
#define GL_INT_SAMPLER_2D_RECT                                        0x8DCD
#define GL_INT_SAMPLER_2D_RECT_EXT                                    0x8DCD
#define GL_INT_SAMPLER_3D                                             0x8DCB
#define GL_INT_SAMPLER_3D_EXT                                         0x8DCB
#define GL_INT_SAMPLER_BUFFER                                         0x8DD0
#define GL_INT_SAMPLER_BUFFER_AMD                                     0x9002
#define GL_INT_SAMPLER_BUFFER_EXT                                     0x8DD0
#define GL_INT_SAMPLER_CUBE                                           0x8DCC
#define GL_INT_SAMPLER_CUBE_EXT                                       0x8DCC
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY                                 0x900E
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB                             0x900E
#define GL_INT_SAMPLER_RENDERBUFFER_NV                                0x8E57
#define GL_INT_VEC2                                                   0x8B53
#define GL_INT_VEC2_ARB                                               0x8B53
#define GL_INT_VEC3                                                   0x8B54
#define GL_INT_VEC3_ARB                                               0x8B54
#define GL_INT_VEC4                                                   0x8B55
#define GL_INT_VEC4_ARB                                               0x8B55
#define GL_INVALID_ENUM                                               0x0500
#define GL_INVALID_FRAMEBUFFER_OPERATION                              0x0506
#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT                          0x0506
#define GL_INVALID_INDEX                                              0xFFFFFFFF
#define GL_INVALID_OPERATION                                          0x0502
#define GL_INVALID_VALUE                                              0x0501
#define GL_INVARIANT_DATATYPE_EXT                                     0x87EB
#define GL_INVARIANT_EXT                                              0x87C2
#define GL_INVARIANT_VALUE_EXT                                        0x87EA
#define GL_INVERSE_NV                                                 0x862B
#define GL_INVERSE_TRANSPOSE_NV                                       0x862D
#define GL_INVERT                                                     0x150A
#define GL_INVERTED_SCREEN_W_REND                                     0x8491
#define GL_INVERT_OVG_NV                                              0x92B4
#define GL_INVERT_RGB_NV                                              0x92A3
#define GL_IR_INSTRUMENT1_SGIX                                        0x817F
#define GL_ISOLINES                                                   0x8E7A
#define GL_IS_PER_PATCH                                               0x92E7
#define GL_IS_ROW_MAJOR                                               0x9300
#define GL_ITALIC_BIT_NV                                              0x02
#define GL_IUI_N3F_V2F_EXT                                            0x81AF
#define GL_IUI_N3F_V3F_EXT                                            0x81B0
#define GL_IUI_V2F_EXT                                                0x81AD
#define GL_IUI_V3F_EXT                                                0x81AE
#define GL_KEEP                                                       0x1E00
#define GL_LARGE_CCW_ARC_TO_NV                                        0x16
#define GL_LARGE_CW_ARC_TO_NV                                         0x18
#define GL_LAST_VERTEX_CONVENTION                                     0x8E4E
#define GL_LAST_VERTEX_CONVENTION_EXT                                 0x8E4E
#define GL_LAST_VIDEO_CAPTURE_STATUS_NV                               0x9027
#define GL_LAYER_NV                                                   0x8DAA
#define GL_LAYER_PROVOKING_VERTEX                                     0x825E
#define GL_LAYOUT_COLOR_ATTACHMENT_EXT                                0x958E
#define GL_LAYOUT_DEFAULT_INTEL                                       0
#define GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT              0x9531
#define GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT              0x9530
#define GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT                        0x958F
#define GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT                         0x9590
#define GL_LAYOUT_GENERAL_EXT                                         0x958D
#define GL_LAYOUT_LINEAR_CPU_CACHED_INTEL                             2
#define GL_LAYOUT_LINEAR_INTEL                                        1
#define GL_LAYOUT_SHADER_READ_ONLY_EXT                                0x9591
#define GL_LAYOUT_TRANSFER_DST_EXT                                    0x9593
#define GL_LAYOUT_TRANSFER_SRC_EXT                                    0x9592
#define GL_LEFT                                                       0x0406
#define GL_LEQUAL                                                     0x0203
#define GL_LERP_ATI                                                   0x8969
#define GL_LESS                                                       0x0201
#define GL_LGPU_SEPARATE_STORAGE_BIT_NVX                              0x0800
#define GL_LIGHTEN_KHR                                                0x9298
#define GL_LIGHTEN_NV                                                 0x9298
#define GL_LIGHT_ENV_MODE_SGIX                                        0x8407
#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT                              0x81F8
#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE                          0x85B0
#define GL_LINE                                                       0x1B01
#define GL_LINEAR                                                     0x2601
#define GL_LINEARBURN_NV                                              0x92A5
#define GL_LINEARDODGE_NV                                             0x92A4
#define GL_LINEARLIGHT_NV                                             0x92A7
#define GL_LINEAR_CLIPMAP_LINEAR_SGIX                                 0x8170
#define GL_LINEAR_CLIPMAP_NEAREST_SGIX                                0x844F
#define GL_LINEAR_DETAIL_ALPHA_SGIS                                   0x8098
#define GL_LINEAR_DETAIL_COLOR_SGIS                                   0x8099
#define GL_LINEAR_DETAIL_SGIS                                         0x8097
#define GL_LINEAR_MIPMAP_LINEAR                                       0x2703
#define GL_LINEAR_MIPMAP_NEAREST                                      0x2701
#define GL_LINEAR_SHARPEN_ALPHA_SGIS                                  0x80AE
#define GL_LINEAR_SHARPEN_COLOR_SGIS                                  0x80AF
#define GL_LINEAR_SHARPEN_SGIS                                        0x80AD
#define GL_LINEAR_TILING_EXT                                          0x9585
#define GL_LINES                                                      0x0001
#define GL_LINES_ADJACENCY                                            0x000A
#define GL_LINES_ADJACENCY_ARB                                        0x000A
#define GL_LINES_ADJACENCY_EXT                                        0x000A
#define GL_LINE_LOOP                                                  0x0002
#define GL_LINE_SMOOTH                                                0x0B20
#define GL_LINE_SMOOTH_HINT                                           0x0C52
#define GL_LINE_STRIP                                                 0x0003
#define GL_LINE_STRIP_ADJACENCY                                       0x000B
#define GL_LINE_STRIP_ADJACENCY_ARB                                   0x000B
#define GL_LINE_STRIP_ADJACENCY_EXT                                   0x000B
#define GL_LINE_TO_NV                                                 0x04
#define GL_LINE_WIDTH                                                 0x0B21
#define GL_LINE_WIDTH_COMMAND_NV                                      0x000D
#define GL_LINE_WIDTH_GRANULARITY                                     0x0B23
#define GL_LINE_WIDTH_RANGE                                           0x0B22
#define GL_LINK_STATUS                                                0x8B82
#define GL_LIST_PRIORITY_SGIX                                         0x8182
#define GL_LOCAL_CONSTANT_DATATYPE_EXT                                0x87ED
#define GL_LOCAL_CONSTANT_EXT                                         0x87C3
#define GL_LOCAL_CONSTANT_VALUE_EXT                                   0x87EC
#define GL_LOCAL_EXT                                                  0x87C4
#define GL_LOCATION                                                   0x930E
#define GL_LOCATION_COMPONENT                                         0x934A
#define GL_LOCATION_INDEX                                             0x930F
#define GL_LOGIC_OP_MODE                                              0x0BF0
#define GL_LOSE_CONTEXT_ON_RESET                                      0x8252
#define GL_LOSE_CONTEXT_ON_RESET_ARB                                  0x8252
#define GL_LOWER_LEFT                                                 0x8CA1
#define GL_LOW_FLOAT                                                  0x8DF0
#define GL_LOW_INT                                                    0x8DF3
#define GL_LO_BIAS_NV                                                 0x8715
#define GL_LO_SCALE_NV                                                0x870F
#define GL_LUID_SIZE_EXT                                              8
#define GL_LUMINANCE12_ALPHA12_EXT                                    0x8047
#define GL_LUMINANCE12_ALPHA4_EXT                                     0x8046
#define GL_LUMINANCE12_EXT                                            0x8041
#define GL_LUMINANCE16F_ARB                                           0x881E
#define GL_LUMINANCE16F_EXT                                           0x881E
#define GL_LUMINANCE16I_EXT                                           0x8D8C
#define GL_LUMINANCE16UI_EXT                                          0x8D7A
#define GL_LUMINANCE16_ALPHA16_EXT                                    0x8048
#define GL_LUMINANCE16_ALPHA16_SNORM                                  0x901A
#define GL_LUMINANCE16_EXT                                            0x8042
#define GL_LUMINANCE16_SNORM                                          0x9019
#define GL_LUMINANCE32F_ARB                                           0x8818
#define GL_LUMINANCE32F_EXT                                           0x8818
#define GL_LUMINANCE32I_EXT                                           0x8D86
#define GL_LUMINANCE32UI_EXT                                          0x8D74
#define GL_LUMINANCE4_ALPHA4_EXT                                      0x8043
#define GL_LUMINANCE4_EXT                                             0x803F
#define GL_LUMINANCE6_ALPHA2_EXT                                      0x8044
#define GL_LUMINANCE8I_EXT                                            0x8D92
#define GL_LUMINANCE8UI_EXT                                           0x8D80
#define GL_LUMINANCE8_ALPHA8_EXT                                      0x8045
#define GL_LUMINANCE8_ALPHA8_SNORM                                    0x9016
#define GL_LUMINANCE8_EXT                                             0x8040
#define GL_LUMINANCE8_SNORM                                           0x9015
#define GL_LUMINANCE_ALPHA16F_ARB                                     0x881F
#define GL_LUMINANCE_ALPHA16F_EXT                                     0x881F
#define GL_LUMINANCE_ALPHA16I_EXT                                     0x8D8D
#define GL_LUMINANCE_ALPHA16UI_EXT                                    0x8D7B
#define GL_LUMINANCE_ALPHA32F_ARB                                     0x8819
#define GL_LUMINANCE_ALPHA32F_EXT                                     0x8819
#define GL_LUMINANCE_ALPHA32I_EXT                                     0x8D87
#define GL_LUMINANCE_ALPHA32UI_EXT                                    0x8D75
#define GL_LUMINANCE_ALPHA8I_EXT                                      0x8D93
#define GL_LUMINANCE_ALPHA8UI_EXT                                     0x8D81
#define GL_LUMINANCE_ALPHA_FLOAT16_APPLE                              0x881F
#define GL_LUMINANCE_ALPHA_FLOAT16_ATI                                0x881F
#define GL_LUMINANCE_ALPHA_FLOAT32_APPLE                              0x8819
#define GL_LUMINANCE_ALPHA_FLOAT32_ATI                                0x8819
#define GL_LUMINANCE_ALPHA_INTEGER_EXT                                0x8D9D
#define GL_LUMINANCE_ALPHA_SNORM                                      0x9012
#define GL_LUMINANCE_FLOAT16_APPLE                                    0x881E
#define GL_LUMINANCE_FLOAT16_ATI                                      0x881E
#define GL_LUMINANCE_FLOAT32_APPLE                                    0x8818
#define GL_LUMINANCE_FLOAT32_ATI                                      0x8818
#define GL_LUMINANCE_INTEGER_EXT                                      0x8D9C
#define GL_LUMINANCE_SNORM                                            0x9011
#define GL_MAD_ATI                                                    0x8968
#define GL_MAGNITUDE_BIAS_NV                                          0x8718
#define GL_MAGNITUDE_SCALE_NV                                         0x8712
#define GL_MAJOR_VERSION                                              0x821B
#define GL_MANUAL_GENERATE_MIPMAP                                     0x8294
#define GL_MAP1_BINORMAL_EXT                                          0x8446
#define GL_MAP1_TANGENT_EXT                                           0x8444
#define GL_MAP1_VERTEX_ATTRIB0_4_NV                                   0x8660
#define GL_MAP1_VERTEX_ATTRIB10_4_NV                                  0x866A
#define GL_MAP1_VERTEX_ATTRIB11_4_NV                                  0x866B
#define GL_MAP1_VERTEX_ATTRIB12_4_NV                                  0x866C
#define GL_MAP1_VERTEX_ATTRIB13_4_NV                                  0x866D
#define GL_MAP1_VERTEX_ATTRIB14_4_NV                                  0x866E
#define GL_MAP1_VERTEX_ATTRIB15_4_NV                                  0x866F
#define GL_MAP1_VERTEX_ATTRIB1_4_NV                                   0x8661
#define GL_MAP1_VERTEX_ATTRIB2_4_NV                                   0x8662
#define GL_MAP1_VERTEX_ATTRIB3_4_NV                                   0x8663
#define GL_MAP1_VERTEX_ATTRIB4_4_NV                                   0x8664
#define GL_MAP1_VERTEX_ATTRIB5_4_NV                                   0x8665
#define GL_MAP1_VERTEX_ATTRIB6_4_NV                                   0x8666
#define GL_MAP1_VERTEX_ATTRIB7_4_NV                                   0x8667
#define GL_MAP1_VERTEX_ATTRIB8_4_NV                                   0x8668
#define GL_MAP1_VERTEX_ATTRIB9_4_NV                                   0x8669
#define GL_MAP2_BINORMAL_EXT                                          0x8447
#define GL_MAP2_TANGENT_EXT                                           0x8445
#define GL_MAP2_VERTEX_ATTRIB0_4_NV                                   0x8670
#define GL_MAP2_VERTEX_ATTRIB10_4_NV                                  0x867A
#define GL_MAP2_VERTEX_ATTRIB11_4_NV                                  0x867B
#define GL_MAP2_VERTEX_ATTRIB12_4_NV                                  0x867C
#define GL_MAP2_VERTEX_ATTRIB13_4_NV                                  0x867D
#define GL_MAP2_VERTEX_ATTRIB14_4_NV                                  0x867E
#define GL_MAP2_VERTEX_ATTRIB15_4_NV                                  0x867F
#define GL_MAP2_VERTEX_ATTRIB1_4_NV                                   0x8671
#define GL_MAP2_VERTEX_ATTRIB2_4_NV                                   0x8672
#define GL_MAP2_VERTEX_ATTRIB3_4_NV                                   0x8673
#define GL_MAP2_VERTEX_ATTRIB4_4_NV                                   0x8674
#define GL_MAP2_VERTEX_ATTRIB5_4_NV                                   0x8675
#define GL_MAP2_VERTEX_ATTRIB6_4_NV                                   0x8676
#define GL_MAP2_VERTEX_ATTRIB7_4_NV                                   0x8677
#define GL_MAP2_VERTEX_ATTRIB8_4_NV                                   0x8678
#define GL_MAP2_VERTEX_ATTRIB9_4_NV                                   0x8679
#define GL_MAP_ATTRIB_U_ORDER_NV                                      0x86C3
#define GL_MAP_ATTRIB_V_ORDER_NV                                      0x86C4
#define GL_MAP_COHERENT_BIT                                           0x0080
#define GL_MAP_FLUSH_EXPLICIT_BIT                                     0x0010
#define GL_MAP_INVALIDATE_BUFFER_BIT                                  0x0008
#define GL_MAP_INVALIDATE_RANGE_BIT                                   0x0004
#define GL_MAP_PERSISTENT_BIT                                         0x0040
#define GL_MAP_READ_BIT                                               0x0001
#define GL_MAP_TESSELLATION_NV                                        0x86C2
#define GL_MAP_UNSYNCHRONIZED_BIT                                     0x0020
#define GL_MAP_WRITE_BIT                                              0x0002
#define GL_MATERIAL_SIDE_HINT_PGI                                     0x1A22C
#define GL_MATRIX0_ARB                                                0x88C0
#define GL_MATRIX0_NV                                                 0x8630
#define GL_MATRIX10_ARB                                               0x88CA
#define GL_MATRIX11_ARB                                               0x88CB
#define GL_MATRIX12_ARB                                               0x88CC
#define GL_MATRIX13_ARB                                               0x88CD
#define GL_MATRIX14_ARB                                               0x88CE
#define GL_MATRIX15_ARB                                               0x88CF
#define GL_MATRIX16_ARB                                               0x88D0
#define GL_MATRIX17_ARB                                               0x88D1
#define GL_MATRIX18_ARB                                               0x88D2
#define GL_MATRIX19_ARB                                               0x88D3
#define GL_MATRIX1_ARB                                                0x88C1
#define GL_MATRIX1_NV                                                 0x8631
#define GL_MATRIX20_ARB                                               0x88D4
#define GL_MATRIX21_ARB                                               0x88D5
#define GL_MATRIX22_ARB                                               0x88D6
#define GL_MATRIX23_ARB                                               0x88D7
#define GL_MATRIX24_ARB                                               0x88D8
#define GL_MATRIX25_ARB                                               0x88D9
#define GL_MATRIX26_ARB                                               0x88DA
#define GL_MATRIX27_ARB                                               0x88DB
#define GL_MATRIX28_ARB                                               0x88DC
#define GL_MATRIX29_ARB                                               0x88DD
#define GL_MATRIX2_ARB                                                0x88C2
#define GL_MATRIX2_NV                                                 0x8632
#define GL_MATRIX30_ARB                                               0x88DE
#define GL_MATRIX31_ARB                                               0x88DF
#define GL_MATRIX3_ARB                                                0x88C3
#define GL_MATRIX3_NV                                                 0x8633
#define GL_MATRIX4_ARB                                                0x88C4
#define GL_MATRIX4_NV                                                 0x8634
#define GL_MATRIX5_ARB                                                0x88C5
#define GL_MATRIX5_NV                                                 0x8635
#define GL_MATRIX6_ARB                                                0x88C6
#define GL_MATRIX6_NV                                                 0x8636
#define GL_MATRIX7_ARB                                                0x88C7
#define GL_MATRIX7_NV                                                 0x8637
#define GL_MATRIX8_ARB                                                0x88C8
#define GL_MATRIX9_ARB                                                0x88C9
#define GL_MATRIX_EXT                                                 0x87C0
#define GL_MATRIX_INDEX_ARRAY_ARB                                     0x8844
#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB                             0x8849
#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB                                0x8846
#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB                              0x8848
#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB                                0x8847
#define GL_MATRIX_PALETTE_ARB                                         0x8840
#define GL_MATRIX_STRIDE                                              0x92FF
#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI                            0x00200000
#define GL_MAT_AMBIENT_BIT_PGI                                        0x00100000
#define GL_MAT_COLOR_INDEXES_BIT_PGI                                  0x01000000
#define GL_MAT_DIFFUSE_BIT_PGI                                        0x00400000
#define GL_MAT_EMISSION_BIT_PGI                                       0x00800000
#define GL_MAT_SHININESS_BIT_PGI                                      0x02000000
#define GL_MAT_SPECULAR_BIT_PGI                                       0x04000000
#define GL_MAX                                                        0x8008
#define GL_MAX_3D_TEXTURE_SIZE                                        0x8073
#define GL_MAX_3D_TEXTURE_SIZE_EXT                                    0x8073
#define GL_MAX_4D_TEXTURE_SIZE_SGIS                                   0x8138
#define GL_MAX_ACTIVE_LIGHTS_SGIX                                     0x8405
#define GL_MAX_ARRAY_TEXTURE_LAYERS                                   0x88FF
#define GL_MAX_ARRAY_TEXTURE_LAYERS_EXT                               0x88FF
#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX                                 0x8360
#define GL_MAX_ASYNC_HISTOGRAM_SGIX                                   0x832D
#define GL_MAX_ASYNC_READ_PIXELS_SGIX                                 0x8361
#define GL_MAX_ASYNC_TEX_IMAGE_SGIX                                   0x835F
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS                         0x92DC
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE                             0x92D8
#define GL_MAX_BINDABLE_UNIFORM_SIZE_EXT                              0x8DED
#define GL_MAX_CLIPMAP_DEPTH_SGIX                                     0x8177
#define GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX                             0x8178
#define GL_MAX_CLIP_DISTANCES                                         0x0D32
#define GL_MAX_COARSE_FRAGMENT_SAMPLES_NV                             0x955F
#define GL_MAX_COLOR_ATTACHMENTS                                      0x8CDF
#define GL_MAX_COLOR_ATTACHMENTS_EXT                                  0x8CDF
#define GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD                          0x91B3
#define GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD                  0x91B4
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI                           0x80B3
#define GL_MAX_COLOR_TEXTURE_SAMPLES                                  0x910E
#define GL_MAX_COMBINED_ATOMIC_COUNTERS                               0x92D7
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS                        0x92D1
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES                       0x82FA
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS                    0x8266
#define GL_MAX_COMBINED_DIMENSIONS                                    0x8282
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS                   0x8A33
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS                   0x8A32
#define GL_MAX_COMBINED_IMAGE_UNIFORMS                                0x90CF
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS              0x8F39
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT          0x8F39
#define GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV                    0x8E67
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES                       0x8F39
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS                         0x90DC
#define GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV                    0x8E6F
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS               0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS            0x8E1F
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS                           0x8B4D
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB                       0x8B4D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS                                0x8A2E
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS                     0x8A31
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS                                0x8265
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS                         0x8264
#define GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB                    0x90EB
#define GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB                           0x91BF
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS                                 0x91BD
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS                          0x90DB
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE                             0x8262
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS                            0x91BC
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS                                 0x91BB
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS                             0x8263
#define GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB                 0x9344
#define GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB                        0x9345
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT                               0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS                         0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE                                0x91BF
#define GL_MAX_CONVOLUTION_HEIGHT_EXT                                 0x801B
#define GL_MAX_CONVOLUTION_WIDTH_EXT                                  0x801A
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE                                  0x851C
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB                              0x851C
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT                              0x851C
#define GL_MAX_CULL_DISTANCES                                         0x82F9
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH                                0x826C
#define GL_MAX_DEBUG_LOGGED_MESSAGES                                  0x9144
#define GL_MAX_DEBUG_LOGGED_MESSAGES_AMD                              0x9144
#define GL_MAX_DEBUG_LOGGED_MESSAGES_ARB                              0x9144
#define GL_MAX_DEBUG_MESSAGE_LENGTH                                   0x9143
#define GL_MAX_DEBUG_MESSAGE_LENGTH_AMD                               0x9143
#define GL_MAX_DEBUG_MESSAGE_LENGTH_ARB                               0x9143
#define GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV                               0x90D1
#define GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV                        0x90D0
#define GL_MAX_DEFORMATION_ORDER_SGIX                                 0x8197
#define GL_MAX_DEPTH                                                  0x8280
#define GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD                  0x91B5
#define GL_MAX_DEPTH_TEXTURE_SAMPLES                                  0x910F
#define GL_MAX_DETACHED_BUFFERS_NV                                    0x95AD
#define GL_MAX_DETACHED_TEXTURES_NV                                   0x95AC
#define GL_MAX_DRAW_BUFFERS                                           0x8824
#define GL_MAX_DRAW_BUFFERS_ARB                                       0x8824
#define GL_MAX_DRAW_BUFFERS_ATI                                       0x8824
#define GL_MAX_DRAW_MESH_TASKS_COUNT_NV                               0x953D
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS                               0x88FC
#define GL_MAX_ELEMENTS_INDICES                                       0x80E9
#define GL_MAX_ELEMENTS_INDICES_EXT                                   0x80E9
#define GL_MAX_ELEMENTS_VERTICES                                      0x80E8
#define GL_MAX_ELEMENTS_VERTICES_EXT                                  0x80E8
#define GL_MAX_ELEMENT_INDEX                                          0x8D6B
#define GL_MAX_EXT                                                    0x8008
#define GL_MAX_FOG_FUNC_POINTS_SGIS                                   0x812C
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS                               0x92D6
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS                        0x92D0
#define GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT                         0x8DE3
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS                                0x90CE
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS                              0x9125
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET                          0x8E5C
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV                       0x8E5C
#define GL_MAX_FRAGMENT_LIGHTS_SGIX                                   0x8404
#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV                   0x8868
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS                         0x90DA
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS                                0x8A2D
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS                            0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB                        0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS                               0x8DFD
#define GL_MAX_FRAMEBUFFER_HEIGHT                                     0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS                                     0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES                                    0x9318
#define GL_MAX_FRAMEBUFFER_WIDTH                                      0x9315
#define GL_MAX_FRAMEZOOM_FACTOR_SGIX                                  0x818D
#define GL_MAX_GENERAL_COMBINERS_NV                                   0x854D
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS                               0x92D5
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS                        0x92CF
#define GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT                         0x8DE4
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS                                0x90CD
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS                              0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS                             0x9124
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES                               0x8DE0
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB                           0x8DE0
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT                           0x8DE0
#define GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV                        0x8E5A
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS                            0x8E5A
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS                         0x90D7
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS                           0x8C29
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB                       0x8C29
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT                       0x8C29
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS                       0x8DE1
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB                   0x8DE1
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT                   0x8DE1
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS                                0x8A2C
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS                            0x8DDF
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB                        0x8DDF
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT                        0x8DDF
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB                        0x8DDD
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT                        0x8DDD
#define GL_MAX_HEIGHT                                                 0x827F
#define GL_MAX_IMAGE_SAMPLES                                          0x906D
#define GL_MAX_IMAGE_SAMPLES_EXT                                      0x906D
#define GL_MAX_IMAGE_UNITS                                            0x8F38
#define GL_MAX_IMAGE_UNITS_EXT                                        0x8F38
#define GL_MAX_INTEGER_SAMPLES                                        0x9110
#define GL_MAX_LABEL_LENGTH                                           0x82E8
#define GL_MAX_LAYERS                                                 0x8281
#define GL_MAX_LGPU_GPUS_NVX                                          0x92BA
#define GL_MAX_MAP_TESSELLATION_NV                                    0x86D6
#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB                         0x8841
#define GL_MAX_MESH_ATOMIC_COUNTERS_NV                                0x8E65
#define GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV                         0x8E64
#define GL_MAX_MESH_IMAGE_UNIFORMS_NV                                 0x8E62
#define GL_MAX_MESH_OUTPUT_PRIMITIVES_NV                              0x9539
#define GL_MAX_MESH_OUTPUT_VERTICES_NV                                0x9538
#define GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV                          0x8E66
#define GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV                            0x8E61
#define GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV                              0x9536
#define GL_MAX_MESH_UNIFORM_BLOCKS_NV                                 0x8E60
#define GL_MAX_MESH_UNIFORM_COMPONENTS_NV                             0x8E63
#define GL_MAX_MESH_VIEWS_NV                                          0x9557
#define GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV                         0x95A2
#define GL_MAX_MESH_WORK_GROUP_SIZE_NV                                0x953B
#define GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV                          0x8E11
#define GL_MAX_NAME_LENGTH                                            0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES                                   0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES                             0x92F8
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT               0x87CA
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT                 0x87CD
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT                     0x87CE
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT            0x87CC
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT                   0x87CB
#define GL_MAX_PALETTE_MATRICES_ARB                                   0x8842
#define GL_MAX_PATCH_VERTICES                                         0x8E7D
#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT                     0x8337
#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI                     0x87F1
#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB                          0x88B1
#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB                           0x880B
#define GL_MAX_PROGRAM_ATTRIBS_ARB                                    0x88AD
#define GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV                           0x8908
#define GL_MAX_PROGRAM_CALL_DEPTH_NV                                  0x88F5
#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB                             0x88B5
#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV                           0x88F4
#define GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV                             0x8DA5
#define GL_MAX_PROGRAM_GENERIC_RESULTS_NV                             0x8DA6
#define GL_MAX_PROGRAM_IF_DEPTH_NV                                    0x88F6
#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB                               0x88A1
#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB                           0x88B4
#define GL_MAX_PROGRAM_LOOP_COUNT_NV                                  0x88F8
#define GL_MAX_PROGRAM_LOOP_DEPTH_NV                                  0x88F7
#define GL_MAX_PROGRAM_MATRICES_ARB                                   0x862F
#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB                         0x862E
#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB                   0x88B3
#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB                    0x880E
#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB                             0x88AF
#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB                        0x88A3
#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB                          0x88AB
#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB                         0x88A7
#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB                    0x8810
#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB                    0x880F
#define GL_MAX_PROGRAM_OUTPUT_VERTICES_NV                             0x8C27
#define GL_MAX_PROGRAM_PARAMETERS_ARB                                 0x88A9
#define GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV                   0x8DA0
#define GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV                       0x8DA1
#define GL_MAX_PROGRAM_PATCH_ATTRIBS_NV                               0x86D8
#define GL_MAX_PROGRAM_RESULT_COMPONENTS_NV                           0x8909
#define GL_MAX_PROGRAM_SUBROUTINE_NUM_NV                              0x8F45
#define GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV                       0x8F44
#define GL_MAX_PROGRAM_TEMPORARIES_ARB                                0x88A5
#define GL_MAX_PROGRAM_TEXEL_OFFSET                                   0x8905
#define GL_MAX_PROGRAM_TEXEL_OFFSET_EXT                               0x8905
#define GL_MAX_PROGRAM_TEXEL_OFFSET_NV                                0x8905
#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB                  0x8F9F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET                          0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB                      0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV                       0x8E5F
#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB                           0x880D
#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB                           0x880C
#define GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV                     0x8C28
#define GL_MAX_RASTER_SAMPLES_EXT                                     0x9329
#define GL_MAX_RATIONAL_EVAL_ORDER_NV                                 0x86D7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE                                 0x84F8
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB                             0x84F8
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV                              0x84F8
#define GL_MAX_RENDERBUFFER_SIZE                                      0x84E8
#define GL_MAX_RENDERBUFFER_SIZE_EXT                                  0x84E8
#define GL_MAX_SAMPLES                                                0x8D57
#define GL_MAX_SAMPLES_EXT                                            0x8D57
#define GL_MAX_SAMPLE_MASK_WORDS                                      0x8E59
#define GL_MAX_SAMPLE_MASK_WORDS_NV                                   0x8E59
#define GL_MAX_SERVER_WAIT_TIMEOUT                                    0x9111
#define GL_MAX_SHADER_BUFFER_ADDRESS_NV                               0x8F35
#define GL_MAX_SHADER_COMPILER_THREADS_ARB                            0x91B0
#define GL_MAX_SHADER_COMPILER_THREADS_KHR                            0x91B0
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE                              0x90DE
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS                         0x90DD
#define GL_MAX_SHININESS_NV                                           0x8504
#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD                             0x9199
#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB                             0x9199
#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS                            0x919A
#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB                        0x919A
#define GL_MAX_SPARSE_TEXTURE_SIZE_AMD                                0x9198
#define GL_MAX_SPARSE_TEXTURE_SIZE_ARB                                0x9198
#define GL_MAX_SPOT_EXPONENT_NV                                       0x8505
#define GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV                        0x9349
#define GL_MAX_SUBROUTINES                                            0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS                           0x8DE8
#define GL_MAX_TASK_ATOMIC_COUNTERS_NV                                0x8E6D
#define GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV                         0x8E6C
#define GL_MAX_TASK_IMAGE_UNIFORMS_NV                                 0x8E6A
#define GL_MAX_TASK_OUTPUT_COUNT_NV                                   0x953A
#define GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV                          0x8E6E
#define GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV                            0x8E69
#define GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV                              0x9537
#define GL_MAX_TASK_UNIFORM_BLOCKS_NV                                 0x8E68
#define GL_MAX_TASK_UNIFORM_COMPONENTS_NV                             0x8E6B
#define GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV                         0x95A3
#define GL_MAX_TASK_WORK_GROUP_SIZE_NV                                0x953C
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS                           0x92D3
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS                    0x92CD
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS                            0x90CB
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS                          0x886C
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS                         0x8E83
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS                     0x90D8
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS                       0x8E81
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS                   0x8E85
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS                            0x8E89
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS                        0x8E7F
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS                        0x92D4
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS                 0x92CE
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS                         0x90CC
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS                       0x886D
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS                      0x8E86
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS                  0x90D9
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS                    0x8E82
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS                         0x8E8A
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS                     0x8E80
#define GL_MAX_TESS_GEN_LEVEL                                         0x8E7E
#define GL_MAX_TESS_PATCH_COMPONENTS                                  0x8E84
#define GL_MAX_TEXTURE_BUFFER_SIZE                                    0x8C2B
#define GL_MAX_TEXTURE_BUFFER_SIZE_ARB                                0x8C2B
#define GL_MAX_TEXTURE_BUFFER_SIZE_EXT                                0x8C2B
#define GL_MAX_TEXTURE_COORDS_ARB                                     0x8871
#define GL_MAX_TEXTURE_COORDS_NV                                      0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS                                    0x8872
#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB                                0x8872
#define GL_MAX_TEXTURE_IMAGE_UNITS_NV                                 0x8872
#define GL_MAX_TEXTURE_LOD_BIAS                                       0x84FD
#define GL_MAX_TEXTURE_LOD_BIAS_EXT                                   0x84FD
#define GL_MAX_TEXTURE_MAX_ANISOTROPY                                 0x84FF
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT                             0x84FF
#define GL_MAX_TEXTURE_SIZE                                           0x0D33
#define GL_MAX_TEXTURE_UNITS_ARB                                      0x84E2
#define GL_MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE_NV                 0x95B6
#define GL_MAX_TRACK_MATRICES_NV                                      0x862F
#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV                            0x862E
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS                             0x8E70
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS              0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT          0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV           0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS                    0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT                0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV                 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS                 0x8C80
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT             0x8C80
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV              0x8C80
#define GL_MAX_UNIFORM_BLOCK_SIZE                                     0x8A30
#define GL_MAX_UNIFORM_BUFFER_BINDINGS                                0x8A2F
#define GL_MAX_UNIFORM_LOCATIONS                                      0x826E
#define GL_MAX_VARYING_COMPONENTS                                     0x8B4B
#define GL_MAX_VARYING_COMPONENTS_EXT                                 0x8B4B
#define GL_MAX_VARYING_FLOATS                                         0x8B4B
#define GL_MAX_VARYING_FLOATS_ARB                                     0x8B4B
#define GL_MAX_VARYING_VECTORS                                        0x8DFC
#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV                          0x8520
#define GL_MAX_VERTEX_ATOMIC_COUNTERS                                 0x92D2
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS                          0x92CC
#define GL_MAX_VERTEX_ATTRIBS                                         0x8869
#define GL_MAX_VERTEX_ATTRIBS_ARB                                     0x8869
#define GL_MAX_VERTEX_ATTRIB_BINDINGS                                 0x82DA
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET                          0x82D9
#define GL_MAX_VERTEX_ATTRIB_STRIDE                                   0x82E5
#define GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT                           0x8DE2
#define GL_MAX_VERTEX_HINT_PGI                                        0x1A22D
#define GL_MAX_VERTEX_IMAGE_UNIFORMS                                  0x90CA
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS                               0x9122
#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT                         0x87C5
#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT                           0x87C7
#define GL_MAX_VERTEX_SHADER_LOCALS_EXT                               0x87C9
#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT                      0x87C8
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS                           0x90D6
#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT                             0x87C6
#define GL_MAX_VERTEX_STREAMS                                         0x8E71
#define GL_MAX_VERTEX_STREAMS_ATI                                     0x876B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS                             0x8B4C
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB                         0x8B4C
#define GL_MAX_VERTEX_UNIFORM_BLOCKS                                  0x8A2B
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS                              0x8B4A
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB                          0x8B4A
#define GL_MAX_VERTEX_UNIFORM_VECTORS                                 0x8DFB
#define GL_MAX_VERTEX_UNITS_ARB                                       0x86A4
#define GL_MAX_VERTEX_VARYING_COMPONENTS_ARB                          0x8DDE
#define GL_MAX_VERTEX_VARYING_COMPONENTS_EXT                          0x8DDE
#define GL_MAX_VIEWPORTS                                              0x825B
#define GL_MAX_VIEWPORT_DIMS                                          0x0D3A
#define GL_MAX_VIEWS_OVR                                              0x9631
#define GL_MAX_WIDTH                                                  0x827E
#define GL_MAX_WINDOW_RECTANGLES_EXT                                  0x8F14
#define GL_MEDIUM_FLOAT                                               0x8DF1
#define GL_MEDIUM_INT                                                 0x8DF4
#define GL_MEMORY_ATTACHABLE_ALIGNMENT_NV                             0x95A6
#define GL_MEMORY_ATTACHABLE_NV                                       0x95A8
#define GL_MEMORY_ATTACHABLE_SIZE_NV                                  0x95A7
#define GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV                   0x9543
#define GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV                      0x92DF
#define GL_MESH_OUTPUT_TYPE_NV                                        0x957B
#define GL_MESH_PRIMITIVES_OUT_NV                                     0x957A
#define GL_MESH_SHADER_BIT_NV                                         0x00000040
#define GL_MESH_SHADER_NV                                             0x9559
#define GL_MESH_SUBROUTINE_NV                                         0x957C
#define GL_MESH_SUBROUTINE_UNIFORM_NV                                 0x957E
#define GL_MESH_VERTICES_OUT_NV                                       0x9579
#define GL_MESH_WORK_GROUP_SIZE_NV                                    0x953E
#define GL_MIN                                                        0x8007
#define GL_MINMAX_EXT                                                 0x802E
#define GL_MINMAX_FORMAT_EXT                                          0x802F
#define GL_MINMAX_SINK_EXT                                            0x8030
#define GL_MINOR_VERSION                                              0x821C
#define GL_MINUS_CLAMPED_NV                                           0x92B3
#define GL_MINUS_NV                                                   0x929F
#define GL_MIN_EXT                                                    0x8007
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET                          0x8E5B
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV                       0x8E5B
#define GL_MIN_LOD_WARNING_AMD                                        0x919C
#define GL_MIN_MAP_BUFFER_ALIGNMENT                                   0x90BC
#define GL_MIN_PROGRAM_TEXEL_OFFSET                                   0x8904
#define GL_MIN_PROGRAM_TEXEL_OFFSET_EXT                               0x8904
#define GL_MIN_PROGRAM_TEXEL_OFFSET_NV                                0x8904
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET                          0x8E5E
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB                      0x8E5E
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV                       0x8E5E
#define GL_MIN_SAMPLE_SHADING_VALUE                                   0x8C37
#define GL_MIN_SAMPLE_SHADING_VALUE_ARB                               0x8C37
#define GL_MIN_SPARSE_LEVEL_AMD                                       0x919B
#define GL_MIPMAP                                                     0x8293
#define GL_MIRRORED_REPEAT                                            0x8370
#define GL_MIRRORED_REPEAT_ARB                                        0x8370
#define GL_MIRRORED_REPEAT_IBM                                        0x8370
#define GL_MIRROR_CLAMP_ATI                                           0x8742
#define GL_MIRROR_CLAMP_EXT                                           0x8742
#define GL_MIRROR_CLAMP_TO_BORDER_EXT                                 0x8912
#define GL_MIRROR_CLAMP_TO_EDGE                                       0x8743
#define GL_MIRROR_CLAMP_TO_EDGE_ATI                                   0x8743
#define GL_MIRROR_CLAMP_TO_EDGE_EXT                                   0x8743
#define GL_MITER_REVERT_NV                                            0x90A7
#define GL_MITER_TRUNCATE_NV                                          0x90A8
#define GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV                           0x932F
#define GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV                         0x9330
#define GL_MODELVIEW0_ARB                                             0x1700
#define GL_MODELVIEW0_EXT                                             0x1700
#define GL_MODELVIEW0_MATRIX_EXT                                      0x0BA6
#define GL_MODELVIEW0_STACK_DEPTH_EXT                                 0x0BA3
#define GL_MODELVIEW10_ARB                                            0x872A
#define GL_MODELVIEW11_ARB                                            0x872B
#define GL_MODELVIEW12_ARB                                            0x872C
#define GL_MODELVIEW13_ARB                                            0x872D
#define GL_MODELVIEW14_ARB                                            0x872E
#define GL_MODELVIEW15_ARB                                            0x872F
#define GL_MODELVIEW16_ARB                                            0x8730
#define GL_MODELVIEW17_ARB                                            0x8731
#define GL_MODELVIEW18_ARB                                            0x8732
#define GL_MODELVIEW19_ARB                                            0x8733
#define GL_MODELVIEW1_ARB                                             0x850A
#define GL_MODELVIEW1_EXT                                             0x850A
#define GL_MODELVIEW1_MATRIX_EXT                                      0x8506
#define GL_MODELVIEW1_STACK_DEPTH_EXT                                 0x8502
#define GL_MODELVIEW20_ARB                                            0x8734
#define GL_MODELVIEW21_ARB                                            0x8735
#define GL_MODELVIEW22_ARB                                            0x8736
#define GL_MODELVIEW23_ARB                                            0x8737
#define GL_MODELVIEW24_ARB                                            0x8738
#define GL_MODELVIEW25_ARB                                            0x8739
#define GL_MODELVIEW26_ARB                                            0x873A
#define GL_MODELVIEW27_ARB                                            0x873B
#define GL_MODELVIEW28_ARB                                            0x873C
#define GL_MODELVIEW29_ARB                                            0x873D
#define GL_MODELVIEW2_ARB                                             0x8722
#define GL_MODELVIEW30_ARB                                            0x873E
#define GL_MODELVIEW31_ARB                                            0x873F
#define GL_MODELVIEW3_ARB                                             0x8723
#define GL_MODELVIEW4_ARB                                             0x8724
#define GL_MODELVIEW5_ARB                                             0x8725
#define GL_MODELVIEW6_ARB                                             0x8726
#define GL_MODELVIEW7_ARB                                             0x8727
#define GL_MODELVIEW8_ARB                                             0x8728
#define GL_MODELVIEW9_ARB                                             0x8729
#define GL_MODELVIEW_PROJECTION_NV                                    0x8629
#define GL_MODULATE_ADD_ATI                                           0x8744
#define GL_MODULATE_SIGNED_ADD_ATI                                    0x8745
#define GL_MODULATE_SUBTRACT_ATI                                      0x8746
#define GL_MOVE_TO_CONTINUES_NV                                       0x90B6
#define GL_MOVE_TO_NV                                                 0x02
#define GL_MOVE_TO_RESETS_NV                                          0x90B5
#define GL_MOV_ATI                                                    0x8961
#define GL_MULTICAST_GPUS_NV                                          0x92BA
#define GL_MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV                  0x9549
#define GL_MULTIPLY_KHR                                               0x9294
#define GL_MULTIPLY_NV                                                0x9294
#define GL_MULTISAMPLE                                                0x809D
#define GL_MULTISAMPLES_NV                                            0x9371
#define GL_MULTISAMPLE_3DFX                                           0x86B2
#define GL_MULTISAMPLE_ARB                                            0x809D
#define GL_MULTISAMPLE_BIT_3DFX                                       0x20000000
#define GL_MULTISAMPLE_BIT_ARB                                        0x20000000
#define GL_MULTISAMPLE_BIT_EXT                                        0x20000000
#define GL_MULTISAMPLE_COVERAGE_MODES_NV                              0x8E12
#define GL_MULTISAMPLE_EXT                                            0x809D
#define GL_MULTISAMPLE_FILTER_HINT_NV                                 0x8534
#define GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB                     0x9382
#define GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB                           0x9381
#define GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT                      0x932B
#define GL_MULTISAMPLE_SGIS                                           0x809D
#define GL_MUL_ATI                                                    0x8964
#define GL_MVP_MATRIX_EXT                                             0x87E3
#define GL_NAMED_STRING_LENGTH_ARB                                    0x8DE9
#define GL_NAMED_STRING_TYPE_ARB                                      0x8DEA
#define GL_NAME_LENGTH                                                0x92F9
#define GL_NAND                                                       0x150E
#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI                             0x1A203
#define GL_NATIVE_GRAPHICS_END_HINT_PGI                               0x1A204
#define GL_NATIVE_GRAPHICS_HANDLE_PGI                                 0x1A202
#define GL_NEAREST                                                    0x2600
#define GL_NEAREST_CLIPMAP_LINEAR_SGIX                                0x844E
#define GL_NEAREST_CLIPMAP_NEAREST_SGIX                               0x844D
#define GL_NEAREST_MIPMAP_LINEAR                                      0x2702
#define GL_NEAREST_MIPMAP_NEAREST                                     0x2700
#define GL_NEGATE_BIT_ATI                                             0x00000004
#define GL_NEGATIVE_ONE_EXT                                           0x87DF
#define GL_NEGATIVE_ONE_TO_ONE                                        0x935E
#define GL_NEGATIVE_W_EXT                                             0x87DC
#define GL_NEGATIVE_X_EXT                                             0x87D9
#define GL_NEGATIVE_Y_EXT                                             0x87DA
#define GL_NEGATIVE_Z_EXT                                             0x87DB
#define GL_NEVER                                                      0x0200
#define GL_NEXT_BUFFER_NV                                             -2
#define GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV                        0x9025
#define GL_NICEST                                                     0x1102
#define GL_NONE                                                       0
#define GL_NOOP                                                       0x1505
#define GL_NOP_COMMAND_NV                                             0x0001
#define GL_NOR                                                        0x1508
#define GL_NORMALIZED_RANGE_EXT                                       0x87E0
#define GL_NORMAL_ARRAY_ADDRESS_NV                                    0x8F22
#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB                            0x8897
#define GL_NORMAL_ARRAY_COUNT_EXT                                     0x8080
#define GL_NORMAL_ARRAY_EXT                                           0x8075
#define GL_NORMAL_ARRAY_LENGTH_NV                                     0x8F2C
#define GL_NORMAL_ARRAY_LIST_IBM                                      103071
#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM                               103081
#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL                       0x83F6
#define GL_NORMAL_ARRAY_POINTER_EXT                                   0x808F
#define GL_NORMAL_ARRAY_STRIDE_EXT                                    0x807F
#define GL_NORMAL_ARRAY_TYPE_EXT                                      0x807E
#define GL_NORMAL_BIT_PGI                                             0x08000000
#define GL_NORMAL_MAP_ARB                                             0x8511
#define GL_NORMAL_MAP_EXT                                             0x8511
#define GL_NORMAL_MAP_NV                                              0x8511
#define GL_NOTEQUAL                                                   0x0205
#define GL_NO_ERROR                                                   0
#define GL_NO_RESET_NOTIFICATION                                      0x8261
#define GL_NO_RESET_NOTIFICATION_ARB                                  0x8261
#define GL_NUM_ACTIVE_VARIABLES                                       0x9304
#define GL_NUM_COMPATIBLE_SUBROUTINES                                 0x8E4A
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS                             0x86A2
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB                         0x86A2
#define GL_NUM_DEVICE_UUIDS_EXT                                       0x9596
#define GL_NUM_EXTENSIONS                                             0x821D
#define GL_NUM_FILL_STREAMS_NV                                        0x8E29
#define GL_NUM_FRAGMENT_CONSTANTS_ATI                                 0x896F
#define GL_NUM_FRAGMENT_REGISTERS_ATI                                 0x896E
#define GL_NUM_GENERAL_COMBINERS_NV                                   0x854E
#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI                      0x8973
#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI                              0x8971
#define GL_NUM_INSTRUCTIONS_TOTAL_ATI                                 0x8972
#define GL_NUM_LOOPBACK_COMPONENTS_ATI                                0x8974
#define GL_NUM_PASSES_ATI                                             0x8970
#define GL_NUM_PROGRAM_BINARY_FORMATS                                 0x87FE
#define GL_NUM_SAMPLE_COUNTS                                          0x9380
#define GL_NUM_SHADER_BINARY_FORMATS                                  0x8DF9
#define GL_NUM_SHADING_LANGUAGE_VERSIONS                              0x82E9
#define GL_NUM_SPARSE_LEVELS_ARB                                      0x91AA
#define GL_NUM_SPIR_V_EXTENSIONS                                      0x9554
#define GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD                        0x91B6
#define GL_NUM_TILING_TYPES_EXT                                       0x9582
#define GL_NUM_VIDEO_CAPTURE_STREAMS_NV                               0x9024
#define GL_NUM_VIRTUAL_PAGE_SIZES_ARB                                 0x91A8
#define GL_NUM_WINDOW_RECTANGLES_EXT                                  0x8F15
#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB                               0x8B89
#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB                     0x8B8A
#define GL_OBJECT_ACTIVE_UNIFORMS_ARB                                 0x8B86
#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB                       0x8B87
#define GL_OBJECT_ATTACHED_OBJECTS_ARB                                0x8B85
#define GL_OBJECT_BUFFER_SIZE_ATI                                     0x8764
#define GL_OBJECT_BUFFER_USAGE_ATI                                    0x8765
#define GL_OBJECT_COMPILE_STATUS_ARB                                  0x8B81
#define GL_OBJECT_DELETE_STATUS_ARB                                   0x8B80
#define GL_OBJECT_DISTANCE_TO_LINE_SGIS                               0x81F3
#define GL_OBJECT_DISTANCE_TO_POINT_SGIS                              0x81F1
#define GL_OBJECT_INFO_LOG_LENGTH_ARB                                 0x8B84
#define GL_OBJECT_LINE_SGIS                                           0x81F7
#define GL_OBJECT_LINK_STATUS_ARB                                     0x8B82
#define GL_OBJECT_POINT_SGIS                                          0x81F5
#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB                            0x8B88
#define GL_OBJECT_SUBTYPE_ARB                                         0x8B4F
#define GL_OBJECT_TYPE                                                0x9112
#define GL_OBJECT_TYPE_ARB                                            0x8B4E
#define GL_OBJECT_VALIDATE_STATUS_ARB                                 0x8B83
#define GL_OCCLUSION_QUERY_EVENT_MASK_AMD                             0x874F
#define GL_OCCLUSION_TEST_HP                                          0x8165
#define GL_OCCLUSION_TEST_RESULT_HP                                   0x8166
#define GL_OFFSET                                                     0x92FC
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV                       0x8856
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV                0x8857
#define GL_OFFSET_HILO_TEXTURE_2D_NV                                  0x8854
#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV                           0x8855
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV                            0x8850
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV                      0x8851
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV                     0x8852
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV               0x8853
#define GL_OFFSET_TEXTURE_2D_BIAS_NV                                  0x86E3
#define GL_OFFSET_TEXTURE_2D_MATRIX_NV                                0x86E1
#define GL_OFFSET_TEXTURE_2D_NV                                       0x86E8
#define GL_OFFSET_TEXTURE_2D_SCALE_NV                                 0x86E2
#define GL_OFFSET_TEXTURE_BIAS_NV                                     0x86E3
#define GL_OFFSET_TEXTURE_MATRIX_NV                                   0x86E1
#define GL_OFFSET_TEXTURE_RECTANGLE_NV                                0x864C
#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV                          0x864D
#define GL_OFFSET_TEXTURE_SCALE_NV                                    0x86E2
#define GL_ONE                                                        1
#define GL_ONE_EXT                                                    0x87DE
#define GL_ONE_MINUS_CONSTANT_ALPHA                                   0x8004
#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT                               0x8004
#define GL_ONE_MINUS_CONSTANT_COLOR                                   0x8002
#define GL_ONE_MINUS_CONSTANT_COLOR_EXT                               0x8002
#define GL_ONE_MINUS_DST_ALPHA                                        0x0305
#define GL_ONE_MINUS_DST_COLOR                                        0x0307
#define GL_ONE_MINUS_SRC1_ALPHA                                       0x88FB
#define GL_ONE_MINUS_SRC1_COLOR                                       0x88FA
#define GL_ONE_MINUS_SRC_ALPHA                                        0x0303
#define GL_ONE_MINUS_SRC_COLOR                                        0x0301
#define GL_OPERAND0_ALPHA_ARB                                         0x8598
#define GL_OPERAND0_ALPHA_EXT                                         0x8598
#define GL_OPERAND0_RGB_ARB                                           0x8590
#define GL_OPERAND0_RGB_EXT                                           0x8590
#define GL_OPERAND1_ALPHA_ARB                                         0x8599
#define GL_OPERAND1_ALPHA_EXT                                         0x8599
#define GL_OPERAND1_RGB_ARB                                           0x8591
#define GL_OPERAND1_RGB_EXT                                           0x8591
#define GL_OPERAND2_ALPHA_ARB                                         0x859A
#define GL_OPERAND2_ALPHA_EXT                                         0x859A
#define GL_OPERAND2_RGB_ARB                                           0x8592
#define GL_OPERAND2_RGB_EXT                                           0x8592
#define GL_OPERAND3_ALPHA_NV                                          0x859B
#define GL_OPERAND3_RGB_NV                                            0x8593
#define GL_OPTIMAL_TILING_EXT                                         0x9584
#define GL_OP_ADD_EXT                                                 0x8787
#define GL_OP_CLAMP_EXT                                               0x878E
#define GL_OP_CROSS_PRODUCT_EXT                                       0x8797
#define GL_OP_DOT3_EXT                                                0x8784
#define GL_OP_DOT4_EXT                                                0x8785
#define GL_OP_EXP_BASE_2_EXT                                          0x8791
#define GL_OP_FLOOR_EXT                                               0x878F
#define GL_OP_FRAC_EXT                                                0x8789
#define GL_OP_INDEX_EXT                                               0x8782
#define GL_OP_LOG_BASE_2_EXT                                          0x8792
#define GL_OP_MADD_EXT                                                0x8788
#define GL_OP_MAX_EXT                                                 0x878A
#define GL_OP_MIN_EXT                                                 0x878B
#define GL_OP_MOV_EXT                                                 0x8799
#define GL_OP_MULTIPLY_MATRIX_EXT                                     0x8798
#define GL_OP_MUL_EXT                                                 0x8786
#define GL_OP_NEGATE_EXT                                              0x8783
#define GL_OP_POWER_EXT                                               0x8793
#define GL_OP_RECIP_EXT                                               0x8794
#define GL_OP_RECIP_SQRT_EXT                                          0x8795
#define GL_OP_ROUND_EXT                                               0x8790
#define GL_OP_SET_GE_EXT                                              0x878C
#define GL_OP_SET_LT_EXT                                              0x878D
#define GL_OP_SUB_EXT                                                 0x8796
#define GL_OR                                                         0x1507
#define GL_OR_INVERTED                                                0x150D
#define GL_OR_REVERSE                                                 0x150B
#define GL_OUTPUT_COLOR0_EXT                                          0x879B
#define GL_OUTPUT_COLOR1_EXT                                          0x879C
#define GL_OUTPUT_FOG_EXT                                             0x87BD
#define GL_OUTPUT_TEXTURE_COORD0_EXT                                  0x879D
#define GL_OUTPUT_TEXTURE_COORD10_EXT                                 0x87A7
#define GL_OUTPUT_TEXTURE_COORD11_EXT                                 0x87A8
#define GL_OUTPUT_TEXTURE_COORD12_EXT                                 0x87A9
#define GL_OUTPUT_TEXTURE_COORD13_EXT                                 0x87AA
#define GL_OUTPUT_TEXTURE_COORD14_EXT                                 0x87AB
#define GL_OUTPUT_TEXTURE_COORD15_EXT                                 0x87AC
#define GL_OUTPUT_TEXTURE_COORD16_EXT                                 0x87AD
#define GL_OUTPUT_TEXTURE_COORD17_EXT                                 0x87AE
#define GL_OUTPUT_TEXTURE_COORD18_EXT                                 0x87AF
#define GL_OUTPUT_TEXTURE_COORD19_EXT                                 0x87B0
#define GL_OUTPUT_TEXTURE_COORD1_EXT                                  0x879E
#define GL_OUTPUT_TEXTURE_COORD20_EXT                                 0x87B1
#define GL_OUTPUT_TEXTURE_COORD21_EXT                                 0x87B2
#define GL_OUTPUT_TEXTURE_COORD22_EXT                                 0x87B3
#define GL_OUTPUT_TEXTURE_COORD23_EXT                                 0x87B4
#define GL_OUTPUT_TEXTURE_COORD24_EXT                                 0x87B5
#define GL_OUTPUT_TEXTURE_COORD25_EXT                                 0x87B6
#define GL_OUTPUT_TEXTURE_COORD26_EXT                                 0x87B7
#define GL_OUTPUT_TEXTURE_COORD27_EXT                                 0x87B8
#define GL_OUTPUT_TEXTURE_COORD28_EXT                                 0x87B9
#define GL_OUTPUT_TEXTURE_COORD29_EXT                                 0x87BA
#define GL_OUTPUT_TEXTURE_COORD2_EXT                                  0x879F
#define GL_OUTPUT_TEXTURE_COORD30_EXT                                 0x87BB
#define GL_OUTPUT_TEXTURE_COORD31_EXT                                 0x87BC
#define GL_OUTPUT_TEXTURE_COORD3_EXT                                  0x87A0
#define GL_OUTPUT_TEXTURE_COORD4_EXT                                  0x87A1
#define GL_OUTPUT_TEXTURE_COORD5_EXT                                  0x87A2
#define GL_OUTPUT_TEXTURE_COORD6_EXT                                  0x87A3
#define GL_OUTPUT_TEXTURE_COORD7_EXT                                  0x87A4
#define GL_OUTPUT_TEXTURE_COORD8_EXT                                  0x87A5
#define GL_OUTPUT_TEXTURE_COORD9_EXT                                  0x87A6
#define GL_OUTPUT_VERTEX_EXT                                          0x879A
#define GL_OUT_OF_MEMORY                                              0x0505
#define GL_OVERLAY_KHR                                                0x9296
#define GL_OVERLAY_NV                                                 0x9296
#define GL_PACK_ALIGNMENT                                             0x0D05
#define GL_PACK_CMYK_HINT_EXT                                         0x800E
#define GL_PACK_COMPRESSED_BLOCK_DEPTH                                0x912D
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT                               0x912C
#define GL_PACK_COMPRESSED_BLOCK_SIZE                                 0x912E
#define GL_PACK_COMPRESSED_BLOCK_WIDTH                                0x912B
#define GL_PACK_IMAGE_DEPTH_SGIS                                      0x8131
#define GL_PACK_IMAGE_HEIGHT                                          0x806C
#define GL_PACK_IMAGE_HEIGHT_EXT                                      0x806C
#define GL_PACK_INVERT_MESA                                           0x8758
#define GL_PACK_LSB_FIRST                                             0x0D01
#define GL_PACK_RESAMPLE_OML                                          0x8984
#define GL_PACK_RESAMPLE_SGIX                                         0x842E
#define GL_PACK_ROW_BYTES_APPLE                                       0x8A15
#define GL_PACK_ROW_LENGTH                                            0x0D02
#define GL_PACK_SKIP_IMAGES                                           0x806B
#define GL_PACK_SKIP_IMAGES_EXT                                       0x806B
#define GL_PACK_SKIP_PIXELS                                           0x0D04
#define GL_PACK_SKIP_ROWS                                             0x0D03
#define GL_PACK_SKIP_VOLUMES_SGIS                                     0x8130
#define GL_PACK_SUBSAMPLE_RATE_SGIX                                   0x85A0
#define GL_PACK_SWAP_BYTES                                            0x0D00
#define GL_PALETTE4_R5_G6_B5_OES                                      0x8B92
#define GL_PALETTE4_RGB5_A1_OES                                       0x8B94
#define GL_PALETTE4_RGB8_OES                                          0x8B90
#define GL_PALETTE4_RGBA4_OES                                         0x8B93
#define GL_PALETTE4_RGBA8_OES                                         0x8B91
#define GL_PALETTE8_R5_G6_B5_OES                                      0x8B97
#define GL_PALETTE8_RGB5_A1_OES                                       0x8B99
#define GL_PALETTE8_RGB8_OES                                          0x8B95
#define GL_PALETTE8_RGBA4_OES                                         0x8B98
#define GL_PALETTE8_RGBA8_OES                                         0x8B96
#define GL_PARALLEL_ARRAYS_INTEL                                      0x83F4
#define GL_PARAMETER_BUFFER                                           0x80EE
#define GL_PARAMETER_BUFFER_ARB                                       0x80EE
#define GL_PARAMETER_BUFFER_BINDING                                   0x80EF
#define GL_PARAMETER_BUFFER_BINDING_ARB                               0x80EF
#define GL_PARTIAL_SUCCESS_NV                                         0x902E
#define GL_PASS_THROUGH_NV                                            0x86E6
#define GL_PATCHES                                                    0x000E
#define GL_PATCH_DEFAULT_INNER_LEVEL                                  0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL                                  0x8E74
#define GL_PATCH_VERTICES                                             0x8E72
#define GL_PATH_CLIENT_LENGTH_NV                                      0x907F
#define GL_PATH_COMMAND_COUNT_NV                                      0x909D
#define GL_PATH_COMPUTED_LENGTH_NV                                    0x90A0
#define GL_PATH_COORD_COUNT_NV                                        0x909E
#define GL_PATH_COVER_DEPTH_FUNC_NV                                   0x90BF
#define GL_PATH_DASH_ARRAY_COUNT_NV                                   0x909F
#define GL_PATH_DASH_CAPS_NV                                          0x907B
#define GL_PATH_DASH_OFFSET_NV                                        0x907E
#define GL_PATH_DASH_OFFSET_RESET_NV                                  0x90B4
#define GL_PATH_END_CAPS_NV                                           0x9076
#define GL_PATH_ERROR_POSITION_NV                                     0x90AB
#define GL_PATH_FILL_BOUNDING_BOX_NV                                  0x90A1
#define GL_PATH_FILL_COVER_MODE_NV                                    0x9082
#define GL_PATH_FILL_MASK_NV                                          0x9081
#define GL_PATH_FILL_MODE_NV                                          0x9080
#define GL_PATH_FORMAT_PS_NV                                          0x9071
#define GL_PATH_FORMAT_SVG_NV                                         0x9070
#define GL_PATH_GEN_COEFF_NV                                          0x90B1
#define GL_PATH_GEN_COMPONENTS_NV                                     0x90B3
#define GL_PATH_GEN_MODE_NV                                           0x90B0
#define GL_PATH_INITIAL_DASH_CAP_NV                                   0x907C
#define GL_PATH_INITIAL_END_CAP_NV                                    0x9077
#define GL_PATH_JOIN_STYLE_NV                                         0x9079
#define GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV                          0x0D36
#define GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV                         0x0D38
#define GL_PATH_MITER_LIMIT_NV                                        0x907A
#define GL_PATH_MODELVIEW_MATRIX_NV                                   0x0BA6
#define GL_PATH_MODELVIEW_NV                                          0x1700
#define GL_PATH_MODELVIEW_STACK_DEPTH_NV                              0x0BA3
#define GL_PATH_OBJECT_BOUNDING_BOX_NV                                0x908A
#define GL_PATH_PROJECTION_MATRIX_NV                                  0x0BA7
#define GL_PATH_PROJECTION_NV                                         0x1701
#define GL_PATH_PROJECTION_STACK_DEPTH_NV                             0x0BA4
#define GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV                        0x90BD
#define GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV                         0x90BE
#define GL_PATH_STENCIL_FUNC_NV                                       0x90B7
#define GL_PATH_STENCIL_REF_NV                                        0x90B8
#define GL_PATH_STENCIL_VALUE_MASK_NV                                 0x90B9
#define GL_PATH_STROKE_BOUNDING_BOX_NV                                0x90A2
#define GL_PATH_STROKE_COVER_MODE_NV                                  0x9083
#define GL_PATH_STROKE_MASK_NV                                        0x9084
#define GL_PATH_STROKE_WIDTH_NV                                       0x9075
#define GL_PATH_TERMINAL_DASH_CAP_NV                                  0x907D
#define GL_PATH_TERMINAL_END_CAP_NV                                   0x9078
#define GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV                         0x84E3
#define GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV                        0x84E4
#define GL_PERCENTAGE_AMD                                             0x8BC3
#define GL_PERFMON_RESULT_AMD                                         0x8BC6
#define GL_PERFMON_RESULT_AVAILABLE_AMD                               0x8BC4
#define GL_PERFMON_RESULT_SIZE_AMD                                    0x8BC5
#define GL_PERFORMANCE_MONITOR_AMD                                    0x9152
#define GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL                        0x94FC
#define GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL                        0x94FB
#define GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL                         0x94FA
#define GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL                        0x94F8
#define GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL                        0x94F9
#define GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL                    0x94FF
#define GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL                      0x94F1
#define GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL                       0x94F2
#define GL_PERFQUERY_COUNTER_EVENT_INTEL                              0x94F0
#define GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL                    0x94FE
#define GL_PERFQUERY_COUNTER_RAW_INTEL                                0x94F4
#define GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL                         0x94F3
#define GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL                          0x94F5
#define GL_PERFQUERY_DONOT_FLUSH_INTEL                                0x83F9
#define GL_PERFQUERY_FLUSH_INTEL                                      0x83FA
#define GL_PERFQUERY_GLOBAL_CONTEXT_INTEL                             0x00000001
#define GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL                      0x9500
#define GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL                      0x94FD
#define GL_PERFQUERY_SINGLE_CONTEXT_INTEL                             0x00000000
#define GL_PERFQUERY_WAIT_INTEL                                       0x83FB
#define GL_PERTURB_EXT                                                0x85AE
#define GL_PER_GPU_STORAGE_BIT_NV                                     0x0800
#define GL_PER_GPU_STORAGE_NV                                         0x9548
#define GL_PER_STAGE_CONSTANTS_NV                                     0x8535
#define GL_PHONG_HINT_WIN                                             0x80EB
#define GL_PHONG_WIN                                                  0x80EA
#define GL_PINLIGHT_NV                                                0x92A8
#define GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD                            0x91AE
#define GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD                            0x91AF
#define GL_PIXEL_BUFFER_BARRIER_BIT                                   0x00000080
#define GL_PIXEL_BUFFER_BARRIER_BIT_EXT                               0x00000080
#define GL_PIXEL_COUNTER_BITS_NV                                      0x8864
#define GL_PIXEL_COUNT_AVAILABLE_NV                                   0x8867
#define GL_PIXEL_COUNT_NV                                             0x8866
#define GL_PIXEL_CUBIC_WEIGHT_EXT                                     0x8333
#define GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS                           0x8355
#define GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS                             0x8354
#define GL_PIXEL_GROUP_COLOR_SGIS                                     0x8356
#define GL_PIXEL_MAG_FILTER_EXT                                       0x8331
#define GL_PIXEL_MIN_FILTER_EXT                                       0x8332
#define GL_PIXEL_PACK_BUFFER                                          0x88EB
#define GL_PIXEL_PACK_BUFFER_ARB                                      0x88EB
#define GL_PIXEL_PACK_BUFFER_BINDING                                  0x88ED
#define GL_PIXEL_PACK_BUFFER_BINDING_ARB                              0x88ED
#define GL_PIXEL_PACK_BUFFER_BINDING_EXT                              0x88ED
#define GL_PIXEL_PACK_BUFFER_EXT                                      0x88EB
#define GL_PIXEL_SUBSAMPLE_2424_SGIX                                  0x85A3
#define GL_PIXEL_SUBSAMPLE_4242_SGIX                                  0x85A4
#define GL_PIXEL_SUBSAMPLE_4444_SGIX                                  0x85A2
#define GL_PIXEL_TEXTURE_SGIS                                         0x8353
#define GL_PIXEL_TEX_GEN_MODE_SGIX                                    0x832B
#define GL_PIXEL_TEX_GEN_SGIX                                         0x8139
#define GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX                             0x813E
#define GL_PIXEL_TILE_CACHE_INCREMENT_SGIX                            0x813F
#define GL_PIXEL_TILE_CACHE_SIZE_SGIX                                 0x8145
#define GL_PIXEL_TILE_GRID_DEPTH_SGIX                                 0x8144
#define GL_PIXEL_TILE_GRID_HEIGHT_SGIX                                0x8143
#define GL_PIXEL_TILE_GRID_WIDTH_SGIX                                 0x8142
#define GL_PIXEL_TILE_HEIGHT_SGIX                                     0x8141
#define GL_PIXEL_TILE_WIDTH_SGIX                                      0x8140
#define GL_PIXEL_TRANSFORM_2D_EXT                                     0x8330
#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT                              0x8338
#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT                         0x8336
#define GL_PIXEL_UNPACK_BUFFER                                        0x88EC
#define GL_PIXEL_UNPACK_BUFFER_ARB                                    0x88EC
#define GL_PIXEL_UNPACK_BUFFER_BINDING                                0x88EF
#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB                            0x88EF
#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT                            0x88EF
#define GL_PIXEL_UNPACK_BUFFER_EXT                                    0x88EC
#define GL_PLUS_CLAMPED_ALPHA_NV                                      0x92B2
#define GL_PLUS_CLAMPED_NV                                            0x92B1
#define GL_PLUS_DARKER_NV                                             0x9292
#define GL_PLUS_NV                                                    0x9291
#define GL_PN_TRIANGLES_ATI                                           0x87F0
#define GL_PN_TRIANGLES_NORMAL_MODE_ATI                               0x87F3
#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI                        0x87F7
#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI                     0x87F8
#define GL_PN_TRIANGLES_POINT_MODE_ATI                                0x87F2
#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI                          0x87F6
#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI                         0x87F5
#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI                         0x87F4
#define GL_POINT                                                      0x1B00
#define GL_POINTS                                                     0x0000
#define GL_POINT_DISTANCE_ATTENUATION_ARB                             0x8129
#define GL_POINT_FADE_THRESHOLD_SIZE                                  0x8128
#define GL_POINT_FADE_THRESHOLD_SIZE_ARB                              0x8128
#define GL_POINT_FADE_THRESHOLD_SIZE_EXT                              0x8128
#define GL_POINT_FADE_THRESHOLD_SIZE_SGIS                             0x8128
#define GL_POINT_SIZE                                                 0x0B11
#define GL_POINT_SIZE_GRANULARITY                                     0x0B13
#define GL_POINT_SIZE_MAX_ARB                                         0x8127
#define GL_POINT_SIZE_MAX_EXT                                         0x8127
#define GL_POINT_SIZE_MAX_SGIS                                        0x8127
#define GL_POINT_SIZE_MIN_ARB                                         0x8126
#define GL_POINT_SIZE_MIN_EXT                                         0x8126
#define GL_POINT_SIZE_MIN_SGIS                                        0x8126
#define GL_POINT_SIZE_RANGE                                           0x0B12
#define GL_POINT_SPRITE_ARB                                           0x8861
#define GL_POINT_SPRITE_COORD_ORIGIN                                  0x8CA0
#define GL_POINT_SPRITE_NV                                            0x8861
#define GL_POINT_SPRITE_R_MODE_NV                                     0x8863
#define GL_POLYGON_MODE                                               0x0B40
#define GL_POLYGON_OFFSET_BIAS_EXT                                    0x8039
#define GL_POLYGON_OFFSET_CLAMP                                       0x8E1B
#define GL_POLYGON_OFFSET_CLAMP_EXT                                   0x8E1B
#define GL_POLYGON_OFFSET_COMMAND_NV                                  0x000E
#define GL_POLYGON_OFFSET_EXT                                         0x8037
#define GL_POLYGON_OFFSET_FACTOR                                      0x8038
#define GL_POLYGON_OFFSET_FACTOR_EXT                                  0x8038
#define GL_POLYGON_OFFSET_FILL                                        0x8037
#define GL_POLYGON_OFFSET_LINE                                        0x2A02
#define GL_POLYGON_OFFSET_POINT                                       0x2A01
#define GL_POLYGON_OFFSET_UNITS                                       0x2A00
#define GL_POLYGON_SMOOTH                                             0x0B41
#define GL_POLYGON_SMOOTH_HINT                                        0x0C53
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI                           0x80BB
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI                          0x80B7
#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI                            0x80BA
#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI                           0x80B6
#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI                          0x80D2
#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI                           0x80B9
#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI                          0x80B5
#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI                             0x80B8
#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI                            0x80B4
#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT                            0x8023
#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT                           0x801F
#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT                             0x8022
#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT                            0x801E
#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI                           0x80D1
#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT                            0x8021
#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT                           0x801D
#define GL_POST_CONVOLUTION_RED_BIAS_EXT                              0x8020
#define GL_POST_CONVOLUTION_RED_SCALE_EXT                             0x801C
#define GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP                        0x8162
#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX                        0x817B
#define GL_POST_TEXTURE_FILTER_BIAS_SGIX                              0x8179
#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX                       0x817C
#define GL_POST_TEXTURE_FILTER_SCALE_SGIX                             0x817A
#define GL_PREFER_DOUBLEBUFFER_HINT_PGI                               0x1A1F8
#define GL_PRESENT_DURATION_NV                                        0x8E2B
#define GL_PRESENT_TIME_NV                                            0x8E2A
#define GL_PRESERVE_ATI                                               0x8762
#define GL_PREVIOUS_ARB                                               0x8578
#define GL_PREVIOUS_EXT                                               0x8578
#define GL_PREVIOUS_TEXTURE_INPUT_NV                                  0x86E4
#define GL_PRIMARY_COLOR_ARB                                          0x8577
#define GL_PRIMARY_COLOR_EXT                                          0x8577
#define GL_PRIMARY_COLOR_NV                                           0x852C
#define GL_PRIMITIVES_GENERATED                                       0x8C87
#define GL_PRIMITIVES_GENERATED_EXT                                   0x8C87
#define GL_PRIMITIVES_GENERATED_NV                                    0x8C87
#define GL_PRIMITIVES_SUBMITTED                                       0x82EF
#define GL_PRIMITIVES_SUBMITTED_ARB                                   0x82EF
#define GL_PRIMITIVE_BOUNDING_BOX_ARB                                 0x92BE
#define GL_PRIMITIVE_ID_NV                                            0x8C7C
#define GL_PRIMITIVE_RESTART                                          0x8F9D
#define GL_PRIMITIVE_RESTART_FIXED_INDEX                              0x8D69
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED                    0x8221
#define GL_PRIMITIVE_RESTART_INDEX                                    0x8F9E
#define GL_PRIMITIVE_RESTART_INDEX_NV                                 0x8559
#define GL_PRIMITIVE_RESTART_NV                                       0x8558
#define GL_PROGRAM                                                    0x82E2
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB                           0x9341
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_NV                            0x9341
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB                0x9340
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV                 0x9340
#define GL_PROGRAM_ADDRESS_REGISTERS_ARB                              0x88B0
#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB                               0x8805
#define GL_PROGRAM_ATTRIBS_ARB                                        0x88AC
#define GL_PROGRAM_ATTRIB_COMPONENTS_NV                               0x8906
#define GL_PROGRAM_BINARY_FORMATS                                     0x87FF
#define GL_PROGRAM_BINARY_FORMAT_MESA                                 0x875F
#define GL_PROGRAM_BINARY_LENGTH                                      0x8741
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT                            0x8257
#define GL_PROGRAM_BINDING_ARB                                        0x8677
#define GL_PROGRAM_ERROR_POSITION_ARB                                 0x864B
#define GL_PROGRAM_ERROR_POSITION_NV                                  0x864B
#define GL_PROGRAM_ERROR_STRING_ARB                                   0x8874
#define GL_PROGRAM_ERROR_STRING_NV                                    0x8874
#define GL_PROGRAM_FORMAT_ARB                                         0x8876
#define GL_PROGRAM_FORMAT_ASCII_ARB                                   0x8875
#define GL_PROGRAM_INPUT                                              0x92E3
#define GL_PROGRAM_INSTRUCTIONS_ARB                                   0x88A0
#define GL_PROGRAM_LENGTH_ARB                                         0x8627
#define GL_PROGRAM_LENGTH_NV                                          0x8627
#define GL_PROGRAM_MATRIX_EXT                                         0x8E2D
#define GL_PROGRAM_MATRIX_STACK_DEPTH_EXT                             0x8E2F
#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB                       0x88B2
#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB                        0x8808
#define GL_PROGRAM_NATIVE_ATTRIBS_ARB                                 0x88AE
#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB                            0x88A2
#define GL_PROGRAM_NATIVE_PARAMETERS_ARB                              0x88AA
#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB                             0x88A6
#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB                        0x880A
#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB                        0x8809
#define GL_PROGRAM_OBJECT_ARB                                         0x8B40
#define GL_PROGRAM_OBJECT_EXT                                         0x8B40
#define GL_PROGRAM_OUTPUT                                             0x92E4
#define GL_PROGRAM_PARAMETERS_ARB                                     0x88A8
#define GL_PROGRAM_PARAMETER_NV                                       0x8644
#define GL_PROGRAM_PIPELINE                                           0x82E4
#define GL_PROGRAM_PIPELINE_BINDING                                   0x825A
#define GL_PROGRAM_PIPELINE_OBJECT_EXT                                0x8A4F
#define GL_PROGRAM_POINT_SIZE                                         0x8642
#define GL_PROGRAM_POINT_SIZE_ARB                                     0x8642
#define GL_PROGRAM_POINT_SIZE_EXT                                     0x8642
#define GL_PROGRAM_RESIDENT_NV                                        0x8647
#define GL_PROGRAM_RESULT_COMPONENTS_NV                               0x8907
#define GL_PROGRAM_SEPARABLE                                          0x8258
#define GL_PROGRAM_STRING_ARB                                         0x8628
#define GL_PROGRAM_STRING_NV                                          0x8628
#define GL_PROGRAM_TARGET_NV                                          0x8646
#define GL_PROGRAM_TEMPORARIES_ARB                                    0x88A4
#define GL_PROGRAM_TEX_INDIRECTIONS_ARB                               0x8807
#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB                               0x8806
#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB                            0x88B6
#define GL_PROTECTED_MEMORY_OBJECT_EXT                                0x959B
#define GL_PROVOKING_VERTEX                                           0x8E4F
#define GL_PROVOKING_VERTEX_EXT                                       0x8E4F
#define GL_PROXY_COLOR_TABLE_SGI                                      0x80D3
#define GL_PROXY_HISTOGRAM_EXT                                        0x8025
#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI                    0x80D5
#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI                     0x80D4
#define GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP                  0x8163
#define GL_PROXY_TEXTURE_1D                                           0x8063
#define GL_PROXY_TEXTURE_1D_ARRAY                                     0x8C19
#define GL_PROXY_TEXTURE_1D_ARRAY_EXT                                 0x8C19
#define GL_PROXY_TEXTURE_1D_EXT                                       0x8063
#define GL_PROXY_TEXTURE_1D_STACK_MESAX                               0x875B
#define GL_PROXY_TEXTURE_2D                                           0x8064
#define GL_PROXY_TEXTURE_2D_ARRAY                                     0x8C1B
#define GL_PROXY_TEXTURE_2D_ARRAY_EXT                                 0x8C1B
#define GL_PROXY_TEXTURE_2D_EXT                                       0x8064
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE                               0x9101
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY                         0x9103
#define GL_PROXY_TEXTURE_2D_STACK_MESAX                               0x875C
#define GL_PROXY_TEXTURE_3D                                           0x8070
#define GL_PROXY_TEXTURE_3D_EXT                                       0x8070
#define GL_PROXY_TEXTURE_4D_SGIS                                      0x8135
#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI                              0x80BD
#define GL_PROXY_TEXTURE_CUBE_MAP                                     0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARB                                 0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY                               0x900B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB                           0x900B
#define GL_PROXY_TEXTURE_CUBE_MAP_EXT                                 0x851B
#define GL_PROXY_TEXTURE_RECTANGLE                                    0x84F7
#define GL_PROXY_TEXTURE_RECTANGLE_ARB                                0x84F7
#define GL_PROXY_TEXTURE_RECTANGLE_NV                                 0x84F7
#define GL_PURGEABLE_APPLE                                            0x8A1D
#define GL_PURGED_CONTEXT_RESET_NV                                    0x92BB
#define GL_QUADRATIC_CURVE_TO_NV                                      0x0A
#define GL_QUADS                                                      0x0007
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION                   0x8E4C
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT               0x8E4C
#define GL_QUAD_ALPHA4_SGIS                                           0x811E
#define GL_QUAD_ALPHA8_SGIS                                           0x811F
#define GL_QUAD_INTENSITY4_SGIS                                       0x8122
#define GL_QUAD_INTENSITY8_SGIS                                       0x8123
#define GL_QUAD_LUMINANCE4_SGIS                                       0x8120
#define GL_QUAD_LUMINANCE8_SGIS                                       0x8121
#define GL_QUAD_MESH_SUN                                              0x8614
#define GL_QUAD_TEXTURE_SELECT_SGIS                                   0x8125
#define GL_QUARTER_BIT_ATI                                            0x00000010
#define GL_QUERY                                                      0x82E3
#define GL_QUERY_ALL_EVENT_BITS_AMD                                   0xFFFFFFFF
#define GL_QUERY_BUFFER                                               0x9192
#define GL_QUERY_BUFFER_AMD                                           0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT                                   0x00008000
#define GL_QUERY_BUFFER_BINDING                                       0x9193
#define GL_QUERY_BUFFER_BINDING_AMD                                   0x9193
#define GL_QUERY_BY_REGION_NO_WAIT                                    0x8E16
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED                           0x8E1A
#define GL_QUERY_BY_REGION_NO_WAIT_NV                                 0x8E16
#define GL_QUERY_BY_REGION_WAIT                                       0x8E15
#define GL_QUERY_BY_REGION_WAIT_INVERTED                              0x8E19
#define GL_QUERY_BY_REGION_WAIT_NV                                    0x8E15
#define GL_QUERY_COUNTER_BITS                                         0x8864
#define GL_QUERY_COUNTER_BITS_ARB                                     0x8864
#define GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD                      0x00000008
#define GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD                             0x00000002
#define GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD                             0x00000001
#define GL_QUERY_NO_WAIT                                              0x8E14
#define GL_QUERY_NO_WAIT_INVERTED                                     0x8E18
#define GL_QUERY_NO_WAIT_NV                                           0x8E14
#define GL_QUERY_OBJECT_AMD                                           0x9153
#define GL_QUERY_OBJECT_EXT                                           0x9153
#define GL_QUERY_RESOURCE_BUFFEROBJECT_NV                             0x9547
#define GL_QUERY_RESOURCE_MEMTYPE_VIDMEM_NV                           0x9542
#define GL_QUERY_RESOURCE_RENDERBUFFER_NV                             0x9546
#define GL_QUERY_RESOURCE_SYS_RESERVED_NV                             0x9544
#define GL_QUERY_RESOURCE_TEXTURE_NV                                  0x9545
#define GL_QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV                        0x9540
#define GL_QUERY_RESULT                                               0x8866
#define GL_QUERY_RESULT_ARB                                           0x8866
#define GL_QUERY_RESULT_AVAILABLE                                     0x8867
#define GL_QUERY_RESULT_AVAILABLE_ARB                                 0x8867
#define GL_QUERY_RESULT_NO_WAIT                                       0x9194
#define GL_QUERY_RESULT_NO_WAIT_AMD                                   0x9194
#define GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD                           0x00000004
#define GL_QUERY_TARGET                                               0x82EA
#define GL_QUERY_WAIT                                                 0x8E13
#define GL_QUERY_WAIT_INVERTED                                        0x8E17
#define GL_QUERY_WAIT_NV                                              0x8E13
#define GL_R11F_G11F_B10F                                             0x8C3A
#define GL_R11F_G11F_B10F_EXT                                         0x8C3A
#define GL_R16                                                        0x822A
#define GL_R16F                                                       0x822D
#define GL_R16F_EXT                                                   0x822D
#define GL_R16I                                                       0x8233
#define GL_R16UI                                                      0x8234
#define GL_R16_SNORM                                                  0x8F98
#define GL_R1UI_C3F_V3F_SUN                                           0x85C6
#define GL_R1UI_C4F_N3F_V3F_SUN                                       0x85C8
#define GL_R1UI_C4UB_V3F_SUN                                          0x85C5
#define GL_R1UI_N3F_V3F_SUN                                           0x85C7
#define GL_R1UI_T2F_C4F_N3F_V3F_SUN                                   0x85CB
#define GL_R1UI_T2F_N3F_V3F_SUN                                       0x85CA
#define GL_R1UI_T2F_V3F_SUN                                           0x85C9
#define GL_R1UI_V3F_SUN                                               0x85C4
#define GL_R32F                                                       0x822E
#define GL_R32F_EXT                                                   0x822E
#define GL_R32I                                                       0x8235
#define GL_R32UI                                                      0x8236
#define GL_R3_G3_B2                                                   0x2A10
#define GL_R8                                                         0x8229
#define GL_R8I                                                        0x8231
#define GL_R8UI                                                       0x8232
#define GL_R8_EXT                                                     0x8229
#define GL_R8_SNORM                                                   0x8F94
#define GL_RASTERIZER_DISCARD                                         0x8C89
#define GL_RASTERIZER_DISCARD_EXT                                     0x8C89
#define GL_RASTERIZER_DISCARD_NV                                      0x8C89
#define GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT                          0x932A
#define GL_RASTER_MULTISAMPLE_EXT                                     0x9327
#define GL_RASTER_POSITION_UNCLIPPED_IBM                              0x19262
#define GL_RASTER_SAMPLES_EXT                                         0x9328
#define GL_READ_BUFFER                                                0x0C02
#define GL_READ_FRAMEBUFFER                                           0x8CA8
#define GL_READ_FRAMEBUFFER_BINDING                                   0x8CAA
#define GL_READ_FRAMEBUFFER_BINDING_EXT                               0x8CAA
#define GL_READ_FRAMEBUFFER_EXT                                       0x8CA8
#define GL_READ_ONLY                                                  0x88B8
#define GL_READ_ONLY_ARB                                              0x88B8
#define GL_READ_PIXELS                                                0x828C
#define GL_READ_PIXELS_FORMAT                                         0x828D
#define GL_READ_PIXELS_TYPE                                           0x828E
#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV                            0x887B
#define GL_READ_PIXEL_DATA_RANGE_NV                                   0x8879
#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV                           0x887D
#define GL_READ_WRITE                                                 0x88BA
#define GL_READ_WRITE_ARB                                             0x88BA
#define GL_RECLAIM_MEMORY_HINT_PGI                                    0x1A1FE
#define GL_RECT_NV                                                    0xF6
#define GL_RED                                                        0x1903
#define GL_REDUCE_EXT                                                 0x8016
#define GL_RED_BIT_ATI                                                0x00000001
#define GL_RED_INTEGER                                                0x8D94
#define GL_RED_INTEGER_EXT                                            0x8D94
#define GL_RED_MAX_CLAMP_INGR                                         0x8564
#define GL_RED_MIN_CLAMP_INGR                                         0x8560
#define GL_RED_NV                                                     0x1903
#define GL_RED_SNORM                                                  0x8F90
#define GL_REFERENCED_BY_COMPUTE_SHADER                               0x930B
#define GL_REFERENCED_BY_FRAGMENT_SHADER                              0x930A
#define GL_REFERENCED_BY_GEOMETRY_SHADER                              0x9309
#define GL_REFERENCED_BY_MESH_SHADER_NV                               0x95A0
#define GL_REFERENCED_BY_TASK_SHADER_NV                               0x95A1
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER                          0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER                       0x9308
#define GL_REFERENCED_BY_VERTEX_SHADER                                0x9306
#define GL_REFERENCE_PLANE_EQUATION_SGIX                              0x817E
#define GL_REFERENCE_PLANE_SGIX                                       0x817D
#define GL_REFLECTION_MAP_ARB                                         0x8512
#define GL_REFLECTION_MAP_EXT                                         0x8512
#define GL_REFLECTION_MAP_NV                                          0x8512
#define GL_REGISTER_COMBINERS_NV                                      0x8522
#define GL_REG_0_ATI                                                  0x8921
#define GL_REG_10_ATI                                                 0x892B
#define GL_REG_11_ATI                                                 0x892C
#define GL_REG_12_ATI                                                 0x892D
#define GL_REG_13_ATI                                                 0x892E
#define GL_REG_14_ATI                                                 0x892F
#define GL_REG_15_ATI                                                 0x8930
#define GL_REG_16_ATI                                                 0x8931
#define GL_REG_17_ATI                                                 0x8932
#define GL_REG_18_ATI                                                 0x8933
#define GL_REG_19_ATI                                                 0x8934
#define GL_REG_1_ATI                                                  0x8922
#define GL_REG_20_ATI                                                 0x8935
#define GL_REG_21_ATI                                                 0x8936
#define GL_REG_22_ATI                                                 0x8937
#define GL_REG_23_ATI                                                 0x8938
#define GL_REG_24_ATI                                                 0x8939
#define GL_REG_25_ATI                                                 0x893A
#define GL_REG_26_ATI                                                 0x893B
#define GL_REG_27_ATI                                                 0x893C
#define GL_REG_28_ATI                                                 0x893D
#define GL_REG_29_ATI                                                 0x893E
#define GL_REG_2_ATI                                                  0x8923
#define GL_REG_30_ATI                                                 0x893F
#define GL_REG_31_ATI                                                 0x8940
#define GL_REG_3_ATI                                                  0x8924
#define GL_REG_4_ATI                                                  0x8925
#define GL_REG_5_ATI                                                  0x8926
#define GL_REG_6_ATI                                                  0x8927
#define GL_REG_7_ATI                                                  0x8928
#define GL_REG_8_ATI                                                  0x8929
#define GL_REG_9_ATI                                                  0x892A
#define GL_RELATIVE_ARC_TO_NV                                         0xFF
#define GL_RELATIVE_CONIC_CURVE_TO_NV                                 0x1B
#define GL_RELATIVE_CUBIC_CURVE_TO_NV                                 0x0D
#define GL_RELATIVE_HORIZONTAL_LINE_TO_NV                             0x07
#define GL_RELATIVE_LARGE_CCW_ARC_TO_NV                               0x17
#define GL_RELATIVE_LARGE_CW_ARC_TO_NV                                0x19
#define GL_RELATIVE_LINE_TO_NV                                        0x05
#define GL_RELATIVE_MOVE_TO_NV                                        0x03
#define GL_RELATIVE_QUADRATIC_CURVE_TO_NV                             0x0B
#define GL_RELATIVE_RECT_NV                                           0xF7
#define GL_RELATIVE_ROUNDED_RECT2_NV                                  0xEB
#define GL_RELATIVE_ROUNDED_RECT4_NV                                  0xED
#define GL_RELATIVE_ROUNDED_RECT8_NV                                  0xEF
#define GL_RELATIVE_ROUNDED_RECT_NV                                   0xE9
#define GL_RELATIVE_SMALL_CCW_ARC_TO_NV                               0x13
#define GL_RELATIVE_SMALL_CW_ARC_TO_NV                                0x15
#define GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV                          0x11
#define GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV                      0x0F
#define GL_RELATIVE_VERTICAL_LINE_TO_NV                               0x09
#define GL_RELEASED_APPLE                                             0x8A19
#define GL_RENDERBUFFER                                               0x8D41
#define GL_RENDERBUFFER_ALPHA_SIZE                                    0x8D53
#define GL_RENDERBUFFER_ALPHA_SIZE_EXT                                0x8D53
#define GL_RENDERBUFFER_BINDING                                       0x8CA7
#define GL_RENDERBUFFER_BINDING_EXT                                   0x8CA7
#define GL_RENDERBUFFER_BLUE_SIZE                                     0x8D52
#define GL_RENDERBUFFER_BLUE_SIZE_EXT                                 0x8D52
#define GL_RENDERBUFFER_COLOR_SAMPLES_NV                              0x8E10
#define GL_RENDERBUFFER_COVERAGE_SAMPLES_NV                           0x8CAB
#define GL_RENDERBUFFER_DEPTH_SIZE                                    0x8D54
#define GL_RENDERBUFFER_DEPTH_SIZE_EXT                                0x8D54
#define GL_RENDERBUFFER_EXT                                           0x8D41
#define GL_RENDERBUFFER_FREE_MEMORY_ATI                               0x87FD
#define GL_RENDERBUFFER_GREEN_SIZE                                    0x8D51
#define GL_RENDERBUFFER_GREEN_SIZE_EXT                                0x8D51
#define GL_RENDERBUFFER_HEIGHT                                        0x8D43
#define GL_RENDERBUFFER_HEIGHT_EXT                                    0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT                               0x8D44
#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT                           0x8D44
#define GL_RENDERBUFFER_RED_SIZE                                      0x8D50
#define GL_RENDERBUFFER_RED_SIZE_EXT                                  0x8D50
#define GL_RENDERBUFFER_SAMPLES                                       0x8CAB
#define GL_RENDERBUFFER_SAMPLES_EXT                                   0x8CAB
#define GL_RENDERBUFFER_STENCIL_SIZE                                  0x8D55
#define GL_RENDERBUFFER_STENCIL_SIZE_EXT                              0x8D55
#define GL_RENDERBUFFER_STORAGE_SAMPLES_AMD                           0x91B2
#define GL_RENDERBUFFER_WIDTH                                         0x8D42
#define GL_RENDERBUFFER_WIDTH_EXT                                     0x8D42
#define GL_RENDERER                                                   0x1F01
#define GL_RENDER_GPU_MASK_NV                                         0x9558
#define GL_REPEAT                                                     0x2901
#define GL_REPLACE                                                    0x1E01
#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN                         0x85C3
#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN                          0x85C2
#define GL_REPLACEMENT_CODE_ARRAY_SUN                                 0x85C0
#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN                            0x85C1
#define GL_REPLACEMENT_CODE_SUN                                       0x81D8
#define GL_REPLACE_EXT                                                0x8062
#define GL_REPLACE_MIDDLE_SUN                                         0x0002
#define GL_REPLACE_OLDEST_SUN                                         0x0003
#define GL_REPLACE_VALUE_AMD                                          0x874B
#define GL_REPLICATE_BORDER_HP                                        0x8153
#define GL_REPRESENTATIVE_FRAGMENT_TEST_NV                            0x937F
#define GL_RESAMPLE_AVERAGE_OML                                       0x8988
#define GL_RESAMPLE_DECIMATE_OML                                      0x8989
#define GL_RESAMPLE_DECIMATE_SGIX                                     0x8430
#define GL_RESAMPLE_REPLICATE_OML                                     0x8986
#define GL_RESAMPLE_REPLICATE_SGIX                                    0x8433
#define GL_RESAMPLE_ZERO_FILL_OML                                     0x8987
#define GL_RESAMPLE_ZERO_FILL_SGIX                                    0x8434
#define GL_RESCALE_NORMAL_EXT                                         0x803A
#define GL_RESET_NOTIFICATION_STRATEGY                                0x8256
#define GL_RESET_NOTIFICATION_STRATEGY_ARB                            0x8256
#define GL_RESTART_PATH_NV                                            0xF0
#define GL_RESTART_SUN                                                0x0001
#define GL_RETAINED_APPLE                                             0x8A1B
#define GL_RG                                                         0x8227
#define GL_RG16                                                       0x822C
#define GL_RG16F                                                      0x822F
#define GL_RG16F_EXT                                                  0x822F
#define GL_RG16I                                                      0x8239
#define GL_RG16UI                                                     0x823A
#define GL_RG16_SNORM                                                 0x8F99
#define GL_RG32F                                                      0x8230
#define GL_RG32F_EXT                                                  0x8230
#define GL_RG32I                                                      0x823B
#define GL_RG32UI                                                     0x823C
#define GL_RG8                                                        0x822B
#define GL_RG8I                                                       0x8237
#define GL_RG8UI                                                      0x8238
#define GL_RG8_EXT                                                    0x822B
#define GL_RG8_SNORM                                                  0x8F95
#define GL_RGB                                                        0x1907
#define GL_RGB10                                                      0x8052
#define GL_RGB10_A2                                                   0x8059
#define GL_RGB10_A2UI                                                 0x906F
#define GL_RGB10_A2_EXT                                               0x8059
#define GL_RGB10_EXT                                                  0x8052
#define GL_RGB12                                                      0x8053
#define GL_RGB12_EXT                                                  0x8053
#define GL_RGB16                                                      0x8054
#define GL_RGB16F                                                     0x881B
#define GL_RGB16F_ARB                                                 0x881B
#define GL_RGB16F_EXT                                                 0x881B
#define GL_RGB16I                                                     0x8D89
#define GL_RGB16I_EXT                                                 0x8D89
#define GL_RGB16UI                                                    0x8D77
#define GL_RGB16UI_EXT                                                0x8D77
#define GL_RGB16_EXT                                                  0x8054
#define GL_RGB16_SNORM                                                0x8F9A
#define GL_RGB2_EXT                                                   0x804E
#define GL_RGB32F                                                     0x8815
#define GL_RGB32F_ARB                                                 0x8815
#define GL_RGB32F_EXT                                                 0x8815
#define GL_RGB32I                                                     0x8D83
#define GL_RGB32I_EXT                                                 0x8D83
#define GL_RGB32UI                                                    0x8D71
#define GL_RGB32UI_EXT                                                0x8D71
#define GL_RGB4                                                       0x804F
#define GL_RGB4_EXT                                                   0x804F
#define GL_RGB4_S3TC                                                  0x83A1
#define GL_RGB5                                                       0x8050
#define GL_RGB565                                                     0x8D62
#define GL_RGB5_A1                                                    0x8057
#define GL_RGB5_A1_EXT                                                0x8057
#define GL_RGB5_EXT                                                   0x8050
#define GL_RGB8                                                       0x8051
#define GL_RGB8I                                                      0x8D8F
#define GL_RGB8I_EXT                                                  0x8D8F
#define GL_RGB8UI                                                     0x8D7D
#define GL_RGB8UI_EXT                                                 0x8D7D
#define GL_RGB8_EXT                                                   0x8051
#define GL_RGB8_SNORM                                                 0x8F96
#define GL_RGB9_E5                                                    0x8C3D
#define GL_RGB9_E5_EXT                                                0x8C3D
#define GL_RGBA                                                       0x1908
#define GL_RGBA12                                                     0x805A
#define GL_RGBA12_EXT                                                 0x805A
#define GL_RGBA16                                                     0x805B
#define GL_RGBA16F                                                    0x881A
#define GL_RGBA16F_ARB                                                0x881A
#define GL_RGBA16F_EXT                                                0x881A
#define GL_RGBA16I                                                    0x8D88
#define GL_RGBA16I_EXT                                                0x8D88
#define GL_RGBA16UI                                                   0x8D76
#define GL_RGBA16UI_EXT                                               0x8D76
#define GL_RGBA16_EXT                                                 0x805B
#define GL_RGBA16_SNORM                                               0x8F9B
#define GL_RGBA2                                                      0x8055
#define GL_RGBA2_EXT                                                  0x8055
#define GL_RGBA32F                                                    0x8814
#define GL_RGBA32F_ARB                                                0x8814
#define GL_RGBA32F_EXT                                                0x8814
#define GL_RGBA32I                                                    0x8D82
#define GL_RGBA32I_EXT                                                0x8D82
#define GL_RGBA32UI                                                   0x8D70
#define GL_RGBA32UI_EXT                                               0x8D70
#define GL_RGBA4                                                      0x8056
#define GL_RGBA4_DXT5_S3TC                                            0x83A5
#define GL_RGBA4_EXT                                                  0x8056
#define GL_RGBA4_S3TC                                                 0x83A3
#define GL_RGBA8                                                      0x8058
#define GL_RGBA8I                                                     0x8D8E
#define GL_RGBA8I_EXT                                                 0x8D8E
#define GL_RGBA8UI                                                    0x8D7C
#define GL_RGBA8UI_EXT                                                0x8D7C
#define GL_RGBA8_EXT                                                  0x8058
#define GL_RGBA8_SNORM                                                0x8F97
#define GL_RGBA_DXT5_S3TC                                             0x83A4
#define GL_RGBA_FLOAT16_APPLE                                         0x881A
#define GL_RGBA_FLOAT16_ATI                                           0x881A
#define GL_RGBA_FLOAT32_APPLE                                         0x8814
#define GL_RGBA_FLOAT32_ATI                                           0x8814
#define GL_RGBA_FLOAT_MODE_ARB                                        0x8820
#define GL_RGBA_FLOAT_MODE_ATI                                        0x8820
#define GL_RGBA_INTEGER                                               0x8D99
#define GL_RGBA_INTEGER_EXT                                           0x8D99
#define GL_RGBA_INTEGER_MODE_EXT                                      0x8D9E
#define GL_RGBA_S3TC                                                  0x83A2
#define GL_RGBA_SIGNED_COMPONENTS_EXT                                 0x8C3C
#define GL_RGBA_SNORM                                                 0x8F93
#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV                       0x86D9
#define GL_RGB_422_APPLE                                              0x8A1F
#define GL_RGB_FLOAT16_APPLE                                          0x881B
#define GL_RGB_FLOAT16_ATI                                            0x881B
#define GL_RGB_FLOAT32_APPLE                                          0x8815
#define GL_RGB_FLOAT32_ATI                                            0x8815
#define GL_RGB_INTEGER                                                0x8D98
#define GL_RGB_INTEGER_EXT                                            0x8D98
#define GL_RGB_RAW_422_APPLE                                          0x8A51
#define GL_RGB_S3TC                                                   0x83A0
#define GL_RGB_SCALE_ARB                                              0x8573
#define GL_RGB_SCALE_EXT                                              0x8573
#define GL_RGB_SNORM                                                  0x8F92
#define GL_RG_INTEGER                                                 0x8228
#define GL_RG_SNORM                                                   0x8F91
#define GL_RIGHT                                                      0x0407
#define GL_ROUNDED_RECT2_NV                                           0xEA
#define GL_ROUNDED_RECT4_NV                                           0xEC
#define GL_ROUNDED_RECT8_NV                                           0xEE
#define GL_ROUNDED_RECT_NV                                            0xE8
#define GL_ROUND_NV                                                   0x90A4
#define GL_SAMPLER                                                    0x82E6
#define GL_SAMPLER_1D                                                 0x8B5D
#define GL_SAMPLER_1D_ARB                                             0x8B5D
#define GL_SAMPLER_1D_ARRAY                                           0x8DC0
#define GL_SAMPLER_1D_ARRAY_EXT                                       0x8DC0
#define GL_SAMPLER_1D_ARRAY_SHADOW                                    0x8DC3
#define GL_SAMPLER_1D_ARRAY_SHADOW_EXT                                0x8DC3
#define GL_SAMPLER_1D_SHADOW                                          0x8B61
#define GL_SAMPLER_1D_SHADOW_ARB                                      0x8B61
#define GL_SAMPLER_2D                                                 0x8B5E
#define GL_SAMPLER_2D_ARB                                             0x8B5E
#define GL_SAMPLER_2D_ARRAY                                           0x8DC1
#define GL_SAMPLER_2D_ARRAY_EXT                                       0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW                                    0x8DC4
#define GL_SAMPLER_2D_ARRAY_SHADOW_EXT                                0x8DC4
#define GL_SAMPLER_2D_MULTISAMPLE                                     0x9108
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY                               0x910B
#define GL_SAMPLER_2D_RECT                                            0x8B63
#define GL_SAMPLER_2D_RECT_ARB                                        0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW                                     0x8B64
#define GL_SAMPLER_2D_RECT_SHADOW_ARB                                 0x8B64
#define GL_SAMPLER_2D_SHADOW                                          0x8B62
#define GL_SAMPLER_2D_SHADOW_ARB                                      0x8B62
#define GL_SAMPLER_3D                                                 0x8B5F
#define GL_SAMPLER_3D_ARB                                             0x8B5F
#define GL_SAMPLER_BINDING                                            0x8919
#define GL_SAMPLER_BUFFER                                             0x8DC2
#define GL_SAMPLER_BUFFER_AMD                                         0x9001
#define GL_SAMPLER_BUFFER_EXT                                         0x8DC2
#define GL_SAMPLER_CUBE                                               0x8B60
#define GL_SAMPLER_CUBE_ARB                                           0x8B60
#define GL_SAMPLER_CUBE_MAP_ARRAY                                     0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB                                 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW                              0x900D
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB                          0x900D
#define GL_SAMPLER_CUBE_SHADOW                                        0x8DC5
#define GL_SAMPLER_CUBE_SHADOW_EXT                                    0x8DC5
#define GL_SAMPLER_OBJECT_AMD                                         0x9155
#define GL_SAMPLER_RENDERBUFFER_NV                                    0x8E56
#define GL_SAMPLES                                                    0x80A9
#define GL_SAMPLES_3DFX                                               0x86B4
#define GL_SAMPLES_ARB                                                0x80A9
#define GL_SAMPLES_EXT                                                0x80A9
#define GL_SAMPLES_PASSED                                             0x8914
#define GL_SAMPLES_PASSED_ARB                                         0x8914
#define GL_SAMPLES_SGIS                                               0x80A9
#define GL_SAMPLE_ALPHA_TO_COVERAGE                                   0x809E
#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB                               0x809E
#define GL_SAMPLE_ALPHA_TO_MASK_EXT                                   0x809E
#define GL_SAMPLE_ALPHA_TO_MASK_SGIS                                  0x809E
#define GL_SAMPLE_ALPHA_TO_ONE                                        0x809F
#define GL_SAMPLE_ALPHA_TO_ONE_ARB                                    0x809F
#define GL_SAMPLE_ALPHA_TO_ONE_EXT                                    0x809F
#define GL_SAMPLE_ALPHA_TO_ONE_SGIS                                   0x809F
#define GL_SAMPLE_BUFFERS                                             0x80A8
#define GL_SAMPLE_BUFFERS_3DFX                                        0x86B3
#define GL_SAMPLE_BUFFERS_ARB                                         0x80A8
#define GL_SAMPLE_BUFFERS_EXT                                         0x80A8
#define GL_SAMPLE_BUFFERS_SGIS                                        0x80A8
#define GL_SAMPLE_COVERAGE                                            0x80A0
#define GL_SAMPLE_COVERAGE_ARB                                        0x80A0
#define GL_SAMPLE_COVERAGE_INVERT                                     0x80AB
#define GL_SAMPLE_COVERAGE_INVERT_ARB                                 0x80AB
#define GL_SAMPLE_COVERAGE_VALUE                                      0x80AA
#define GL_SAMPLE_COVERAGE_VALUE_ARB                                  0x80AA
#define GL_SAMPLE_LOCATION_ARB                                        0x8E50
#define GL_SAMPLE_LOCATION_NV                                         0x8E50
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB                      0x933F
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV                       0x933F
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB                       0x933E
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV                        0x933E
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB                          0x933D
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV                           0x933D
#define GL_SAMPLE_MASK                                                0x8E51
#define GL_SAMPLE_MASK_EXT                                            0x80A0
#define GL_SAMPLE_MASK_INVERT_EXT                                     0x80AB
#define GL_SAMPLE_MASK_INVERT_SGIS                                    0x80AB
#define GL_SAMPLE_MASK_NV                                             0x8E51
#define GL_SAMPLE_MASK_SGIS                                           0x80A0
#define GL_SAMPLE_MASK_VALUE                                          0x8E52
#define GL_SAMPLE_MASK_VALUE_EXT                                      0x80AA
#define GL_SAMPLE_MASK_VALUE_NV                                       0x8E52
#define GL_SAMPLE_MASK_VALUE_SGIS                                     0x80AA
#define GL_SAMPLE_PATTERN_EXT                                         0x80AC
#define GL_SAMPLE_PATTERN_SGIS                                        0x80AC
#define GL_SAMPLE_POSITION                                            0x8E50
#define GL_SAMPLE_POSITION_NV                                         0x8E50
#define GL_SAMPLE_SHADING                                             0x8C36
#define GL_SAMPLE_SHADING_ARB                                         0x8C36
#define GL_SATURATE_BIT_ATI                                           0x00000040
#define GL_SCALAR_EXT                                                 0x87BE
#define GL_SCALEBIAS_HINT_SGIX                                        0x8322
#define GL_SCALED_RESOLVE_FASTEST_EXT                                 0x90BA
#define GL_SCALED_RESOLVE_NICEST_EXT                                  0x90BB
#define GL_SCALE_BY_FOUR_NV                                           0x853F
#define GL_SCALE_BY_ONE_HALF_NV                                       0x8540
#define GL_SCALE_BY_TWO_NV                                            0x853E
#define GL_SCISSOR_BOX                                                0x0C10
#define GL_SCISSOR_BOX_EXCLUSIVE_NV                                   0x9556
#define GL_SCISSOR_COMMAND_NV                                         0x0011
#define GL_SCISSOR_TEST                                               0x0C11
#define GL_SCISSOR_TEST_EXCLUSIVE_NV                                  0x9555
#define GL_SCREEN_COORDINATES_REND                                    0x8490
#define GL_SCREEN_KHR                                                 0x9295
#define GL_SCREEN_NV                                                  0x9295
#define GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV                           0x8F27
#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB                   0x889C
#define GL_SECONDARY_COLOR_ARRAY_EXT                                  0x845E
#define GL_SECONDARY_COLOR_ARRAY_LENGTH_NV                            0x8F31
#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM                             103077
#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM                      103087
#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT                          0x845D
#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT                             0x845A
#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT                           0x845C
#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT                             0x845B
#define GL_SECONDARY_COLOR_NV                                         0x852D
#define GL_SECONDARY_INTERPOLATOR_ATI                                 0x896D
#define GL_SEMAPHORE_TYPE_BINARY_NV                                   0x95B4
#define GL_SEMAPHORE_TYPE_NV                                          0x95B3
#define GL_SEMAPHORE_TYPE_TIMELINE_NV                                 0x95B5
#define GL_SEPARABLE_2D_EXT                                           0x8012
#define GL_SEPARATE_ATTRIBS                                           0x8C8D
#define GL_SEPARATE_ATTRIBS_EXT                                       0x8C8D
#define GL_SEPARATE_ATTRIBS_NV                                        0x8C8D
#define GL_SEPARATE_SPECULAR_COLOR_EXT                                0x81FA
#define GL_SET                                                        0x150F
#define GL_SET_AMD                                                    0x874A
#define GL_SHADER                                                     0x82E1
#define GL_SHADER_BINARY_FORMATS                                      0x8DF8
#define GL_SHADER_BINARY_FORMAT_SPIR_V                                0x9551
#define GL_SHADER_BINARY_FORMAT_SPIR_V_ARB                            0x9551
#define GL_SHADER_COMPILER                                            0x8DFA
#define GL_SHADER_CONSISTENT_NV                                       0x86DD
#define GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV                        0x00000010
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT                            0x00000020
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT                        0x00000020
#define GL_SHADER_IMAGE_ATOMIC                                        0x82A6
#define GL_SHADER_IMAGE_LOAD                                          0x82A4
#define GL_SHADER_IMAGE_STORE                                         0x82A5
#define GL_SHADER_INCLUDE_ARB                                         0x8DAE
#define GL_SHADER_OBJECT_ARB                                          0x8B48
#define GL_SHADER_OBJECT_EXT                                          0x8B48
#define GL_SHADER_OPERATION_NV                                        0x86DF
#define GL_SHADER_SOURCE_LENGTH                                       0x8B88
#define GL_SHADER_STORAGE_BARRIER_BIT                                 0x00002000
#define GL_SHADER_STORAGE_BLOCK                                       0x92E6
#define GL_SHADER_STORAGE_BUFFER                                      0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING                              0x90D3
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT                     0x90DF
#define GL_SHADER_STORAGE_BUFFER_SIZE                                 0x90D5
#define GL_SHADER_STORAGE_BUFFER_START                                0x90D4
#define GL_SHADER_TYPE                                                0x8B4F
#define GL_SHADING_LANGUAGE_VERSION                                   0x8B8C
#define GL_SHADING_LANGUAGE_VERSION_ARB                               0x8B8C
#define GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV                   0x956F
#define GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV                0x9566
#define GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV                0x9567
#define GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV                0x9568
#define GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV                0x9569
#define GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV                0x956A
#define GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV                0x956B
#define GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV                     0x9565
#define GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV                    0x956C
#define GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV                    0x956D
#define GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV                    0x956E
#define GL_SHADING_RATE_IMAGE_BINDING_NV                              0x955B
#define GL_SHADING_RATE_IMAGE_NV                                      0x9563
#define GL_SHADING_RATE_IMAGE_PALETTE_COUNT_NV                        0x95B2
#define GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV                         0x955E
#define GL_SHADING_RATE_IMAGE_PER_PRIMITIVE_NV                        0x95B1
#define GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV                         0x955D
#define GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV                          0x955C
#define GL_SHADING_RATE_NO_INVOCATIONS_NV                             0x9564
#define GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV                       0x95AE
#define GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV                   0x95AF
#define GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV                  0x95B0
#define GL_SHADOW_AMBIENT_SGIX                                        0x80BF
#define GL_SHADOW_ATTENUATION_EXT                                     0x834E
#define GL_SHARED_EDGE_NV                                             0xC0
#define GL_SHARED_TEXTURE_PALETTE_EXT                                 0x81FB
#define GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS                           0x80B0
#define GL_SHORT                                                      0x1402
#define GL_SIGNALED                                                   0x9119
#define GL_SIGNED_ALPHA8_NV                                           0x8706
#define GL_SIGNED_ALPHA_NV                                            0x8705
#define GL_SIGNED_HILO16_NV                                           0x86FA
#define GL_SIGNED_HILO8_NV                                            0x885F
#define GL_SIGNED_HILO_NV                                             0x86F9
#define GL_SIGNED_IDENTITY_NV                                         0x853C
#define GL_SIGNED_INTENSITY8_NV                                       0x8708
#define GL_SIGNED_INTENSITY_NV                                        0x8707
#define GL_SIGNED_LUMINANCE8_ALPHA8_NV                                0x8704
#define GL_SIGNED_LUMINANCE8_NV                                       0x8702
#define GL_SIGNED_LUMINANCE_ALPHA_NV                                  0x8703
#define GL_SIGNED_LUMINANCE_NV                                        0x8701
#define GL_SIGNED_NEGATE_NV                                           0x853D
#define GL_SIGNED_NORMALIZED                                          0x8F9C
#define GL_SIGNED_RGB8_NV                                             0x86FF
#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV                             0x870D
#define GL_SIGNED_RGBA8_NV                                            0x86FC
#define GL_SIGNED_RGBA_NV                                             0x86FB
#define GL_SIGNED_RGB_NV                                              0x86FE
#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV                               0x870C
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST                        0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE                       0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST                      0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE                     0x82AF
#define GL_SINGLE_COLOR_EXT                                           0x81F9
#define GL_SKIP_COMPONENTS1_NV                                        -6
#define GL_SKIP_COMPONENTS2_NV                                        -5
#define GL_SKIP_COMPONENTS3_NV                                        -4
#define GL_SKIP_COMPONENTS4_NV                                        -3
#define GL_SKIP_DECODE_EXT                                            0x8A4A
#define GL_SKIP_MISSING_GLYPH_NV                                      0x90A9
#define GL_SLICE_ACCUM_SUN                                            0x85CC
#define GL_SLUMINANCE8_ALPHA8_EXT                                     0x8C45
#define GL_SLUMINANCE8_EXT                                            0x8C47
#define GL_SLUMINANCE_ALPHA_EXT                                       0x8C44
#define GL_SLUMINANCE_EXT                                             0x8C46
#define GL_SMALL_CCW_ARC_TO_NV                                        0x12
#define GL_SMALL_CW_ARC_TO_NV                                         0x14
#define GL_SMOOTH_CUBIC_CURVE_TO_NV                                   0x10
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY                              0x0B23
#define GL_SMOOTH_LINE_WIDTH_RANGE                                    0x0B22
#define GL_SMOOTH_POINT_SIZE_GRANULARITY                              0x0B13
#define GL_SMOOTH_POINT_SIZE_RANGE                                    0x0B12
#define GL_SMOOTH_QUADRATIC_CURVE_TO_NV                               0x0E
#define GL_SM_COUNT_NV                                                0x933B
#define GL_SOFTLIGHT_KHR                                              0x929C
#define GL_SOFTLIGHT_NV                                               0x929C
#define GL_SOURCE0_ALPHA_ARB                                          0x8588
#define GL_SOURCE0_ALPHA_EXT                                          0x8588
#define GL_SOURCE0_RGB_ARB                                            0x8580
#define GL_SOURCE0_RGB_EXT                                            0x8580
#define GL_SOURCE1_ALPHA                                              0x8589
#define GL_SOURCE1_ALPHA_ARB                                          0x8589
#define GL_SOURCE1_ALPHA_EXT                                          0x8589
#define GL_SOURCE1_RGB_ARB                                            0x8581
#define GL_SOURCE1_RGB_EXT                                            0x8581
#define GL_SOURCE2_ALPHA_ARB                                          0x858A
#define GL_SOURCE2_ALPHA_EXT                                          0x858A
#define GL_SOURCE2_RGB_ARB                                            0x8582
#define GL_SOURCE2_RGB_EXT                                            0x8582
#define GL_SOURCE3_ALPHA_NV                                           0x858B
#define GL_SOURCE3_RGB_NV                                             0x8583
#define GL_SPARE0_NV                                                  0x852E
#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV                             0x8532
#define GL_SPARE1_NV                                                  0x852F
#define GL_SPARSE_BUFFER_PAGE_SIZE_ARB                                0x82F8
#define GL_SPARSE_STORAGE_BIT_ARB                                     0x0400
#define GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB                 0x91A9
#define GL_SPIR_V_BINARY                                              0x9552
#define GL_SPIR_V_BINARY_ARB                                          0x9552
#define GL_SPIR_V_EXTENSIONS                                          0x9553
#define GL_SPRITE_AXIAL_SGIX                                          0x814C
#define GL_SPRITE_AXIS_SGIX                                           0x814A
#define GL_SPRITE_EYE_ALIGNED_SGIX                                    0x814E
#define GL_SPRITE_MODE_SGIX                                           0x8149
#define GL_SPRITE_OBJECT_ALIGNED_SGIX                                 0x814D
#define GL_SPRITE_SGIX                                                0x8148
#define GL_SPRITE_TRANSLATION_SGIX                                    0x814B
#define GL_SQUARE_NV                                                  0x90A3
#define GL_SR8_EXT                                                    0x8FBD
#define GL_SRC1_ALPHA                                                 0x8589
#define GL_SRC1_COLOR                                                 0x88F9
#define GL_SRC_ALPHA                                                  0x0302
#define GL_SRC_ALPHA_SATURATE                                         0x0308
#define GL_SRC_ATOP_NV                                                0x928E
#define GL_SRC_COLOR                                                  0x0300
#define GL_SRC_IN_NV                                                  0x928A
#define GL_SRC_NV                                                     0x9286
#define GL_SRC_OUT_NV                                                 0x928C
#define GL_SRC_OVER_NV                                                0x9288
#define GL_SRG8_EXT                                                   0x8FBE
#define GL_SRGB                                                       0x8C40
#define GL_SRGB8                                                      0x8C41
#define GL_SRGB8_ALPHA8                                               0x8C43
#define GL_SRGB8_ALPHA8_EXT                                           0x8C43
#define GL_SRGB8_EXT                                                  0x8C41
#define GL_SRGB_ALPHA                                                 0x8C42
#define GL_SRGB_ALPHA_EXT                                             0x8C42
#define GL_SRGB_DECODE_ARB                                            0x8299
#define GL_SRGB_EXT                                                   0x8C40
#define GL_SRGB_READ                                                  0x8297
#define GL_SRGB_WRITE                                                 0x8298
#define GL_STACK_OVERFLOW                                             0x0503
#define GL_STACK_UNDERFLOW                                            0x0504
#define GL_STANDARD_FONT_FORMAT_NV                                    0x936C
#define GL_STANDARD_FONT_NAME_NV                                      0x9072
#define GL_STATIC_ATI                                                 0x8760
#define GL_STATIC_COPY                                                0x88E6
#define GL_STATIC_COPY_ARB                                            0x88E6
#define GL_STATIC_DRAW                                                0x88E4
#define GL_STATIC_DRAW_ARB                                            0x88E4
#define GL_STATIC_READ                                                0x88E5
#define GL_STATIC_READ_ARB                                            0x88E5
#define GL_STATIC_VERTEX_ARRAY_IBM                                    103061
#define GL_STENCIL                                                    0x1802
#define GL_STENCIL_ATTACHMENT                                         0x8D20
#define GL_STENCIL_ATTACHMENT_EXT                                     0x8D20
#define GL_STENCIL_BACK_FAIL                                          0x8801
#define GL_STENCIL_BACK_FAIL_ATI                                      0x8801
#define GL_STENCIL_BACK_FUNC                                          0x8800
#define GL_STENCIL_BACK_FUNC_ATI                                      0x8800
#define GL_STENCIL_BACK_OP_VALUE_AMD                                  0x874D
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL                               0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI                           0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS                               0x8803
#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI                           0x8803
#define GL_STENCIL_BACK_REF                                           0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK                                    0x8CA4
#define GL_STENCIL_BACK_WRITEMASK                                     0x8CA5
#define GL_STENCIL_BUFFER_BIT                                         0x00000400
#define GL_STENCIL_CLEAR_TAG_VALUE_EXT                                0x88F3
#define GL_STENCIL_CLEAR_VALUE                                        0x0B91
#define GL_STENCIL_COMPONENTS                                         0x8285
#define GL_STENCIL_FAIL                                               0x0B94
#define GL_STENCIL_FUNC                                               0x0B92
#define GL_STENCIL_INDEX                                              0x1901
#define GL_STENCIL_INDEX1                                             0x8D46
#define GL_STENCIL_INDEX16                                            0x8D49
#define GL_STENCIL_INDEX16_EXT                                        0x8D49
#define GL_STENCIL_INDEX1_EXT                                         0x8D46
#define GL_STENCIL_INDEX4                                             0x8D47
#define GL_STENCIL_INDEX4_EXT                                         0x8D47
#define GL_STENCIL_INDEX8                                             0x8D48
#define GL_STENCIL_INDEX8_EXT                                         0x8D48
#define GL_STENCIL_OP_VALUE_AMD                                       0x874C
#define GL_STENCIL_PASS_DEPTH_FAIL                                    0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS                                    0x0B96
#define GL_STENCIL_REF                                                0x0B97
#define GL_STENCIL_REF_COMMAND_NV                                     0x000C
#define GL_STENCIL_RENDERABLE                                         0x8288
#define GL_STENCIL_SAMPLES_NV                                         0x932E
#define GL_STENCIL_TAG_BITS_EXT                                       0x88F2
#define GL_STENCIL_TEST                                               0x0B90
#define GL_STENCIL_TEST_TWO_SIDE_EXT                                  0x8910
#define GL_STENCIL_VALUE_MASK                                         0x0B93
#define GL_STENCIL_WRITEMASK                                          0x0B98
#define GL_STEREO                                                     0x0C33
#define GL_STORAGE_CACHED_APPLE                                       0x85BE
#define GL_STORAGE_CLIENT_APPLE                                       0x85B4
#define GL_STORAGE_PRIVATE_APPLE                                      0x85BD
#define GL_STORAGE_SHARED_APPLE                                       0x85BF
#define GL_STREAM_COPY                                                0x88E2
#define GL_STREAM_COPY_ARB                                            0x88E2
#define GL_STREAM_DRAW                                                0x88E0
#define GL_STREAM_DRAW_ARB                                            0x88E0
#define GL_STREAM_RASTERIZATION_AMD                                   0x91A0
#define GL_STREAM_READ                                                0x88E1
#define GL_STREAM_READ_ARB                                            0x88E1
#define GL_STRICT_DEPTHFUNC_HINT_PGI                                  0x1A216
#define GL_STRICT_LIGHTING_HINT_PGI                                   0x1A217
#define GL_STRICT_SCISSOR_HINT_PGI                                    0x1A218
#define GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR                        0x00000004
#define GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR                            0x00000008
#define GL_SUBGROUP_FEATURE_BASIC_BIT_KHR                             0x00000001
#define GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR                         0x00000040
#define GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV                        0x00000100
#define GL_SUBGROUP_FEATURE_QUAD_BIT_KHR                              0x00000080
#define GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR                           0x00000010
#define GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR                  0x00000020
#define GL_SUBGROUP_FEATURE_VOTE_BIT_KHR                              0x00000002
#define GL_SUBGROUP_QUAD_ALL_STAGES_KHR                               0x9535
#define GL_SUBGROUP_SIZE_KHR                                          0x9532
#define GL_SUBGROUP_SUPPORTED_FEATURES_KHR                            0x9534
#define GL_SUBGROUP_SUPPORTED_STAGES_KHR                              0x9533
#define GL_SUBPIXEL_BITS                                              0x0D50
#define GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV                          0x9347
#define GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV                          0x9348
#define GL_SUBSAMPLE_DISTANCE_AMD                                     0x883F
#define GL_SUBTRACT_ARB                                               0x84E7
#define GL_SUB_ATI                                                    0x8965
#define GL_SUCCESS_NV                                                 0x902F
#define GL_SUPERSAMPLE_SCALE_X_NV                                     0x9372
#define GL_SUPERSAMPLE_SCALE_Y_NV                                     0x9373
#define GL_SUPPORTED_MULTISAMPLE_MODES_AMD                            0x91B7
#define GL_SURFACE_MAPPED_NV                                          0x8700
#define GL_SURFACE_REGISTERED_NV                                      0x86FD
#define GL_SURFACE_STATE_NV                                           0x86EB
#define GL_SWIZZLE_STQ_ATI                                            0x8977
#define GL_SWIZZLE_STQ_DQ_ATI                                         0x8979
#define GL_SWIZZLE_STRQ_ATI                                           0x897A
#define GL_SWIZZLE_STRQ_DQ_ATI                                        0x897B
#define GL_SWIZZLE_STR_ATI                                            0x8976
#define GL_SWIZZLE_STR_DR_ATI                                         0x8978
#define GL_SYNC_CL_EVENT_ARB                                          0x8240
#define GL_SYNC_CL_EVENT_COMPLETE_ARB                                 0x8241
#define GL_SYNC_CONDITION                                             0x9113
#define GL_SYNC_FENCE                                                 0x9116
#define GL_SYNC_FLAGS                                                 0x9115
#define GL_SYNC_FLUSH_COMMANDS_BIT                                    0x00000001
#define GL_SYNC_GPU_COMMANDS_COMPLETE                                 0x9117
#define GL_SYNC_STATUS                                                0x9114
#define GL_SYNC_X11_FENCE_EXT                                         0x90E1
#define GL_SYSTEM_FONT_NAME_NV                                        0x9073
#define GL_T2F_IUI_N3F_V2F_EXT                                        0x81B3
#define GL_T2F_IUI_N3F_V3F_EXT                                        0x81B4
#define GL_T2F_IUI_V2F_EXT                                            0x81B1
#define GL_T2F_IUI_V3F_EXT                                            0x81B2
#define GL_TABLE_TOO_LARGE_EXT                                        0x8031
#define GL_TANGENT_ARRAY_EXT                                          0x8439
#define GL_TANGENT_ARRAY_POINTER_EXT                                  0x8442
#define GL_TANGENT_ARRAY_STRIDE_EXT                                   0x843F
#define GL_TANGENT_ARRAY_TYPE_EXT                                     0x843E
#define GL_TASK_SHADER_BIT_NV                                         0x00000080
#define GL_TASK_SHADER_NV                                             0x955A
#define GL_TASK_SUBROUTINE_NV                                         0x957D
#define GL_TASK_SUBROUTINE_UNIFORM_NV                                 0x957F
#define GL_TASK_WORK_GROUP_SIZE_NV                                    0x953F
#define GL_TERMINATE_SEQUENCE_COMMAND_NV                              0x0000
#define GL_TESSELLATION_FACTOR_AMD                                    0x9005
#define GL_TESSELLATION_MODE_AMD                                      0x9004
#define GL_TESS_CONTROL_OUTPUT_VERTICES                               0x8E75
#define GL_TESS_CONTROL_PROGRAM_NV                                    0x891E
#define GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV                   0x8C74
#define GL_TESS_CONTROL_SHADER                                        0x8E88
#define GL_TESS_CONTROL_SHADER_BIT                                    0x00000008
#define GL_TESS_CONTROL_SHADER_PATCHES                                0x82F1
#define GL_TESS_CONTROL_SHADER_PATCHES_ARB                            0x82F1
#define GL_TESS_CONTROL_SUBROUTINE                                    0x92E9
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM                            0x92EF
#define GL_TESS_CONTROL_TEXTURE                                       0x829C
#define GL_TESS_EVALUATION_PROGRAM_NV                                 0x891F
#define GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV                0x8C75
#define GL_TESS_EVALUATION_SHADER                                     0x8E87
#define GL_TESS_EVALUATION_SHADER_BIT                                 0x00000010
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS                         0x82F2
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB                     0x82F2
#define GL_TESS_EVALUATION_SUBROUTINE                                 0x92EA
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM                         0x92F0
#define GL_TESS_EVALUATION_TEXTURE                                    0x829D
#define GL_TESS_GEN_MODE                                              0x8E76
#define GL_TESS_GEN_POINT_MODE                                        0x8E79
#define GL_TESS_GEN_SPACING                                           0x8E77
#define GL_TESS_GEN_VERTEX_ORDER                                      0x8E78
#define GL_TEXCOORD1_BIT_PGI                                          0x10000000
#define GL_TEXCOORD2_BIT_PGI                                          0x20000000
#define GL_TEXCOORD3_BIT_PGI                                          0x40000000
#define GL_TEXCOORD4_BIT_PGI                                          0x80000000
#define GL_TEXTURE                                                    0x1702
#define GL_TEXTURE0                                                   0x84C0
#define GL_TEXTURE0_ARB                                               0x84C0
#define GL_TEXTURE1                                                   0x84C1
#define GL_TEXTURE10                                                  0x84CA
#define GL_TEXTURE10_ARB                                              0x84CA
#define GL_TEXTURE11                                                  0x84CB
#define GL_TEXTURE11_ARB                                              0x84CB
#define GL_TEXTURE12                                                  0x84CC
#define GL_TEXTURE12_ARB                                              0x84CC
#define GL_TEXTURE13                                                  0x84CD
#define GL_TEXTURE13_ARB                                              0x84CD
#define GL_TEXTURE14                                                  0x84CE
#define GL_TEXTURE14_ARB                                              0x84CE
#define GL_TEXTURE15                                                  0x84CF
#define GL_TEXTURE15_ARB                                              0x84CF
#define GL_TEXTURE16                                                  0x84D0
#define GL_TEXTURE16_ARB                                              0x84D0
#define GL_TEXTURE17                                                  0x84D1
#define GL_TEXTURE17_ARB                                              0x84D1
#define GL_TEXTURE18                                                  0x84D2
#define GL_TEXTURE18_ARB                                              0x84D2
#define GL_TEXTURE19                                                  0x84D3
#define GL_TEXTURE19_ARB                                              0x84D3
#define GL_TEXTURE1_ARB                                               0x84C1
#define GL_TEXTURE2                                                   0x84C2
#define GL_TEXTURE20                                                  0x84D4
#define GL_TEXTURE20_ARB                                              0x84D4
#define GL_TEXTURE21                                                  0x84D5
#define GL_TEXTURE21_ARB                                              0x84D5
#define GL_TEXTURE22                                                  0x84D6
#define GL_TEXTURE22_ARB                                              0x84D6
#define GL_TEXTURE23                                                  0x84D7
#define GL_TEXTURE23_ARB                                              0x84D7
#define GL_TEXTURE24                                                  0x84D8
#define GL_TEXTURE24_ARB                                              0x84D8
#define GL_TEXTURE25                                                  0x84D9
#define GL_TEXTURE25_ARB                                              0x84D9
#define GL_TEXTURE26                                                  0x84DA
#define GL_TEXTURE26_ARB                                              0x84DA
#define GL_TEXTURE27                                                  0x84DB
#define GL_TEXTURE27_ARB                                              0x84DB
#define GL_TEXTURE28                                                  0x84DC
#define GL_TEXTURE28_ARB                                              0x84DC
#define GL_TEXTURE29                                                  0x84DD
#define GL_TEXTURE29_ARB                                              0x84DD
#define GL_TEXTURE2_ARB                                               0x84C2
#define GL_TEXTURE3                                                   0x84C3
#define GL_TEXTURE30                                                  0x84DE
#define GL_TEXTURE30_ARB                                              0x84DE
#define GL_TEXTURE31                                                  0x84DF
#define GL_TEXTURE31_ARB                                              0x84DF
#define GL_TEXTURE3_ARB                                               0x84C3
#define GL_TEXTURE4                                                   0x84C4
#define GL_TEXTURE4_ARB                                               0x84C4
#define GL_TEXTURE5                                                   0x84C5
#define GL_TEXTURE5_ARB                                               0x84C5
#define GL_TEXTURE6                                                   0x84C6
#define GL_TEXTURE6_ARB                                               0x84C6
#define GL_TEXTURE7                                                   0x84C7
#define GL_TEXTURE7_ARB                                               0x84C7
#define GL_TEXTURE8                                                   0x84C8
#define GL_TEXTURE8_ARB                                               0x84C8
#define GL_TEXTURE9                                                   0x84C9
#define GL_TEXTURE9_ARB                                               0x84C9
#define GL_TEXTURE_1D                                                 0x0DE0
#define GL_TEXTURE_1D_ARRAY                                           0x8C18
#define GL_TEXTURE_1D_ARRAY_EXT                                       0x8C18
#define GL_TEXTURE_1D_BINDING_EXT                                     0x8068
#define GL_TEXTURE_1D_STACK_BINDING_MESAX                             0x875D
#define GL_TEXTURE_1D_STACK_MESAX                                     0x8759
#define GL_TEXTURE_2D                                                 0x0DE1
#define GL_TEXTURE_2D_ARRAY                                           0x8C1A
#define GL_TEXTURE_2D_ARRAY_EXT                                       0x8C1A
#define GL_TEXTURE_2D_BINDING_EXT                                     0x8069
#define GL_TEXTURE_2D_MULTISAMPLE                                     0x9100
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY                               0x9102
#define GL_TEXTURE_2D_STACK_BINDING_MESAX                             0x875E
#define GL_TEXTURE_2D_STACK_MESAX                                     0x875A
#define GL_TEXTURE_3D                                                 0x806F
#define GL_TEXTURE_3D_BINDING_EXT                                     0x806A
#define GL_TEXTURE_3D_EXT                                             0x806F
#define GL_TEXTURE_4DSIZE_SGIS                                        0x8136
#define GL_TEXTURE_4D_BINDING_SGIS                                    0x814F
#define GL_TEXTURE_4D_SGIS                                            0x8134
#define GL_TEXTURE_ALPHA_SIZE                                         0x805F
#define GL_TEXTURE_ALPHA_SIZE_EXT                                     0x805F
#define GL_TEXTURE_ALPHA_TYPE                                         0x8C13
#define GL_TEXTURE_ALPHA_TYPE_ARB                                     0x8C13
#define GL_TEXTURE_APPLICATION_MODE_EXT                               0x834F
#define GL_TEXTURE_BASE_LEVEL                                         0x813C
#define GL_TEXTURE_BASE_LEVEL_SGIS                                    0x813C
#define GL_TEXTURE_BINDING_1D                                         0x8068
#define GL_TEXTURE_BINDING_1D_ARRAY                                   0x8C1C
#define GL_TEXTURE_BINDING_1D_ARRAY_EXT                               0x8C1C
#define GL_TEXTURE_BINDING_2D                                         0x8069
#define GL_TEXTURE_BINDING_2D_ARRAY                                   0x8C1D
#define GL_TEXTURE_BINDING_2D_ARRAY_EXT                               0x8C1D
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE                             0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY                       0x9105
#define GL_TEXTURE_BINDING_3D                                         0x806A
#define GL_TEXTURE_BINDING_BUFFER                                     0x8C2C
#define GL_TEXTURE_BINDING_BUFFER_ARB                                 0x8C2C
#define GL_TEXTURE_BINDING_BUFFER_EXT                                 0x8C2C
#define GL_TEXTURE_BINDING_CUBE_MAP                                   0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARB                               0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY                             0x900A
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB                         0x900A
#define GL_TEXTURE_BINDING_CUBE_MAP_EXT                               0x8514
#define GL_TEXTURE_BINDING_RECTANGLE                                  0x84F6
#define GL_TEXTURE_BINDING_RECTANGLE_ARB                              0x84F6
#define GL_TEXTURE_BINDING_RECTANGLE_NV                               0x84F6
#define GL_TEXTURE_BINDING_RENDERBUFFER_NV                            0x8E53
#define GL_TEXTURE_BLUE_SIZE                                          0x805E
#define GL_TEXTURE_BLUE_SIZE_EXT                                      0x805E
#define GL_TEXTURE_BLUE_TYPE                                          0x8C12
#define GL_TEXTURE_BLUE_TYPE_ARB                                      0x8C12
#define GL_TEXTURE_BORDER_COLOR                                       0x1004
#define GL_TEXTURE_BORDER_VALUES_NV                                   0x871A
#define GL_TEXTURE_BUFFER                                             0x8C2A
#define GL_TEXTURE_BUFFER_ARB                                         0x8C2A
#define GL_TEXTURE_BUFFER_BINDING                                     0x8C2A
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING                          0x8C2D
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB                      0x8C2D
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT                      0x8C2D
#define GL_TEXTURE_BUFFER_EXT                                         0x8C2A
#define GL_TEXTURE_BUFFER_FORMAT_ARB                                  0x8C2E
#define GL_TEXTURE_BUFFER_FORMAT_EXT                                  0x8C2E
#define GL_TEXTURE_BUFFER_OFFSET                                      0x919D
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT                            0x919F
#define GL_TEXTURE_BUFFER_SIZE                                        0x919E
#define GL_TEXTURE_CLIPMAP_CENTER_SGIX                                0x8171
#define GL_TEXTURE_CLIPMAP_DEPTH_SGIX                                 0x8176
#define GL_TEXTURE_CLIPMAP_FRAME_SGIX                                 0x8172
#define GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX                            0x8175
#define GL_TEXTURE_CLIPMAP_OFFSET_SGIX                                0x8173
#define GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX                         0x8174
#define GL_TEXTURE_COLOR_SAMPLES_NV                                   0x9046
#define GL_TEXTURE_COLOR_TABLE_SGI                                    0x80BC
#define GL_TEXTURE_COLOR_WRITEMASK_SGIS                               0x81EF
#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB                             0x80BF
#define GL_TEXTURE_COMPARE_FUNC                                       0x884D
#define GL_TEXTURE_COMPARE_FUNC_ARB                                   0x884D
#define GL_TEXTURE_COMPARE_MODE                                       0x884C
#define GL_TEXTURE_COMPARE_MODE_ARB                                   0x884C
#define GL_TEXTURE_COMPARE_OPERATOR_SGIX                              0x819B
#define GL_TEXTURE_COMPARE_SGIX                                       0x819A
#define GL_TEXTURE_COMPRESSED                                         0x86A1
#define GL_TEXTURE_COMPRESSED_ARB                                     0x86A1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT                            0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE                              0x82B3
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH                             0x82B1
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE                              0x86A0
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB                          0x86A0
#define GL_TEXTURE_COMPRESSION_HINT                                   0x84EF
#define GL_TEXTURE_COMPRESSION_HINT_ARB                               0x84EF
#define GL_TEXTURE_CONSTANT_DATA_SUNX                                 0x81D6
#define GL_TEXTURE_COORD_ARRAY_ADDRESS_NV                             0x8F25
#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB                     0x889A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT                              0x808B
#define GL_TEXTURE_COORD_ARRAY_EXT                                    0x8078
#define GL_TEXTURE_COORD_ARRAY_LENGTH_NV                              0x8F2F
#define GL_TEXTURE_COORD_ARRAY_LIST_IBM                               103074
#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM                        103084
#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL                0x83F8
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT                            0x8092
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT                               0x8088
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT                             0x808A
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT                               0x8089
#define GL_TEXTURE_COORD_NV                                           0x8C79
#define GL_TEXTURE_COVERAGE_SAMPLES_NV                                0x9045
#define GL_TEXTURE_CUBE_MAP                                           0x8513
#define GL_TEXTURE_CUBE_MAP_ARB                                       0x8513
#define GL_TEXTURE_CUBE_MAP_ARRAY                                     0x9009
#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB                                 0x9009
#define GL_TEXTURE_CUBE_MAP_EXT                                       0x8513
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X                                0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB                            0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT                            0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y                                0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB                            0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT                            0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z                                0x851A
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB                            0x851A
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT                            0x851A
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X                                0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB                            0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT                            0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y                                0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB                            0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT                            0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z                                0x8519
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB                            0x8519
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT                            0x8519
#define GL_TEXTURE_CUBE_MAP_SEAMLESS                                  0x884F
#define GL_TEXTURE_DEFORMATION_BIT_SGIX                               0x00000001
#define GL_TEXTURE_DEFORMATION_SGIX                                   0x8195
#define GL_TEXTURE_DEPTH                                              0x8071
#define GL_TEXTURE_DEPTH_EXT                                          0x8071
#define GL_TEXTURE_DEPTH_SIZE                                         0x884A
#define GL_TEXTURE_DEPTH_SIZE_ARB                                     0x884A
#define GL_TEXTURE_DEPTH_TYPE                                         0x8C16
#define GL_TEXTURE_DEPTH_TYPE_ARB                                     0x8C16
#define GL_TEXTURE_DS_SIZE_NV                                         0x871D
#define GL_TEXTURE_DT_SIZE_NV                                         0x871E
#define GL_TEXTURE_ENV_BIAS_SGIX                                      0x80BE
#define GL_TEXTURE_FETCH_BARRIER_BIT                                  0x00000008
#define GL_TEXTURE_FETCH_BARRIER_BIT_EXT                              0x00000008
#define GL_TEXTURE_FILTER4_SIZE_SGIS                                  0x8147
#define GL_TEXTURE_FILTER_CONTROL_EXT                                 0x8500
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS                             0x9107
#define GL_TEXTURE_FLOAT_COMPONENTS_NV                                0x888C
#define GL_TEXTURE_FREE_MEMORY_ATI                                    0x87FC
#define GL_TEXTURE_GATHER                                             0x82A2
#define GL_TEXTURE_GATHER_SHADOW                                      0x82A3
#define GL_TEXTURE_GEQUAL_R_SGIX                                      0x819D
#define GL_TEXTURE_GREEN_SIZE                                         0x805D
#define GL_TEXTURE_GREEN_SIZE_EXT                                     0x805D
#define GL_TEXTURE_GREEN_TYPE                                         0x8C11
#define GL_TEXTURE_GREEN_TYPE_ARB                                     0x8C11
#define GL_TEXTURE_HEIGHT                                             0x1001
#define GL_TEXTURE_HI_SIZE_NV                                         0x871B
#define GL_TEXTURE_IMAGE_FORMAT                                       0x828F
#define GL_TEXTURE_IMAGE_TYPE                                         0x8290
#define GL_TEXTURE_IMMUTABLE_FORMAT                                   0x912F
#define GL_TEXTURE_IMMUTABLE_FORMAT_EXT                               0x912F
#define GL_TEXTURE_IMMUTABLE_LEVELS                                   0x82DF
#define GL_TEXTURE_INDEX_SIZE_EXT                                     0x80ED
#define GL_TEXTURE_INTENSITY_SIZE_EXT                                 0x8061
#define GL_TEXTURE_INTENSITY_TYPE_ARB                                 0x8C15
#define GL_TEXTURE_INTERNAL_FORMAT                                    0x1003
#define GL_TEXTURE_LEQUAL_R_SGIX                                      0x819C
#define GL_TEXTURE_LIGHTING_MODE_HP                                   0x8167
#define GL_TEXTURE_LIGHT_EXT                                          0x8350
#define GL_TEXTURE_LOD_BIAS                                           0x8501
#define GL_TEXTURE_LOD_BIAS_EXT                                       0x8501
#define GL_TEXTURE_LOD_BIAS_R_SGIX                                    0x8190
#define GL_TEXTURE_LOD_BIAS_S_SGIX                                    0x818E
#define GL_TEXTURE_LOD_BIAS_T_SGIX                                    0x818F
#define GL_TEXTURE_LO_SIZE_NV                                         0x871C
#define GL_TEXTURE_LUMINANCE_SIZE_EXT                                 0x8060
#define GL_TEXTURE_LUMINANCE_TYPE_ARB                                 0x8C14
#define GL_TEXTURE_MAG_FILTER                                         0x2800
#define GL_TEXTURE_MAG_SIZE_NV                                        0x871F
#define GL_TEXTURE_MATERIAL_FACE_EXT                                  0x8351
#define GL_TEXTURE_MATERIAL_PARAMETER_EXT                             0x8352
#define GL_TEXTURE_MAX_ANISOTROPY                                     0x84FE
#define GL_TEXTURE_MAX_ANISOTROPY_EXT                                 0x84FE
#define GL_TEXTURE_MAX_CLAMP_R_SGIX                                   0x836B
#define GL_TEXTURE_MAX_CLAMP_S_SGIX                                   0x8369
#define GL_TEXTURE_MAX_CLAMP_T_SGIX                                   0x836A
#define GL_TEXTURE_MAX_LEVEL                                          0x813D
#define GL_TEXTURE_MAX_LEVEL_SGIS                                     0x813D
#define GL_TEXTURE_MAX_LOD                                            0x813B
#define GL_TEXTURE_MAX_LOD_SGIS                                       0x813B
#define GL_TEXTURE_MEMORY_LAYOUT_INTEL                                0x83FF
#define GL_TEXTURE_MIN_FILTER                                         0x2801
#define GL_TEXTURE_MIN_LOD                                            0x813A
#define GL_TEXTURE_MIN_LOD_SGIS                                       0x813A
#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX                             0x812E
#define GL_TEXTURE_NORMAL_EXT                                         0x85AF
#define GL_TEXTURE_POST_SPECULAR_HP                                   0x8168
#define GL_TEXTURE_PRE_SPECULAR_HP                                    0x8169
#define GL_TEXTURE_PRIORITY_EXT                                       0x8066
#define GL_TEXTURE_RANGE_LENGTH_APPLE                                 0x85B7
#define GL_TEXTURE_RANGE_POINTER_APPLE                                0x85B8
#define GL_TEXTURE_RECTANGLE                                          0x84F5
#define GL_TEXTURE_RECTANGLE_ARB                                      0x84F5
#define GL_TEXTURE_RECTANGLE_NV                                       0x84F5
#define GL_TEXTURE_REDUCTION_MODE_ARB                                 0x9366
#define GL_TEXTURE_REDUCTION_MODE_EXT                                 0x9366
#define GL_TEXTURE_RED_SIZE                                           0x805C
#define GL_TEXTURE_RED_SIZE_EXT                                       0x805C
#define GL_TEXTURE_RED_TYPE                                           0x8C10
#define GL_TEXTURE_RED_TYPE_ARB                                       0x8C10
#define GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV                 0x8E54
#define GL_TEXTURE_RENDERBUFFER_NV                                    0x8E55
#define GL_TEXTURE_RESIDENT_EXT                                       0x8067
#define GL_TEXTURE_SAMPLES                                            0x9106
#define GL_TEXTURE_SHADER_NV                                          0x86DE
#define GL_TEXTURE_SHADOW                                             0x82A1
#define GL_TEXTURE_SHARED_SIZE                                        0x8C3F
#define GL_TEXTURE_SHARED_SIZE_EXT                                    0x8C3F
#define GL_TEXTURE_SPARSE_ARB                                         0x91A6
#define GL_TEXTURE_SRGB_DECODE_EXT                                    0x8A48
#define GL_TEXTURE_STENCIL_SIZE                                       0x88F1
#define GL_TEXTURE_STENCIL_SIZE_EXT                                   0x88F1
#define GL_TEXTURE_STORAGE_HINT_APPLE                                 0x85BC
#define GL_TEXTURE_STORAGE_SPARSE_BIT_AMD                             0x00000001
#define GL_TEXTURE_SWIZZLE_A                                          0x8E45
#define GL_TEXTURE_SWIZZLE_A_EXT                                      0x8E45
#define GL_TEXTURE_SWIZZLE_B                                          0x8E44
#define GL_TEXTURE_SWIZZLE_B_EXT                                      0x8E44
#define GL_TEXTURE_SWIZZLE_G                                          0x8E43
#define GL_TEXTURE_SWIZZLE_G_EXT                                      0x8E43
#define GL_TEXTURE_SWIZZLE_R                                          0x8E42
#define GL_TEXTURE_SWIZZLE_RGBA                                       0x8E46
#define GL_TEXTURE_SWIZZLE_RGBA_EXT                                   0x8E46
#define GL_TEXTURE_SWIZZLE_R_EXT                                      0x8E42
#define GL_TEXTURE_TARGET                                             0x1006
#define GL_TEXTURE_TILING_EXT                                         0x9580
#define GL_TEXTURE_TOO_LARGE_EXT                                      0x8065
#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV                             0x888F
#define GL_TEXTURE_UPDATE_BARRIER_BIT                                 0x00000100
#define GL_TEXTURE_UPDATE_BARRIER_BIT_EXT                             0x00000100
#define GL_TEXTURE_VIEW                                               0x82B5
#define GL_TEXTURE_VIEW_MIN_LAYER                                     0x82DD
#define GL_TEXTURE_VIEW_MIN_LEVEL                                     0x82DB
#define GL_TEXTURE_VIEW_NUM_LAYERS                                    0x82DE
#define GL_TEXTURE_VIEW_NUM_LEVELS                                    0x82DC
#define GL_TEXTURE_WIDTH                                              0x1000
#define GL_TEXTURE_WRAP_Q_SGIS                                        0x8137
#define GL_TEXTURE_WRAP_R                                             0x8072
#define GL_TEXTURE_WRAP_R_EXT                                         0x8072
#define GL_TEXTURE_WRAP_S                                             0x2802
#define GL_TEXTURE_WRAP_T                                             0x2803
#define GL_TEXT_FRAGMENT_SHADER_ATI                                   0x8200
#define GL_TILE_RASTER_ORDER_FIXED_MESA                               0x8BB8
#define GL_TILE_RASTER_ORDER_INCREASING_X_MESA                        0x8BB9
#define GL_TILE_RASTER_ORDER_INCREASING_Y_MESA                        0x8BBA
#define GL_TILING_TYPES_EXT                                           0x9583
#define GL_TIMELINE_SEMAPHORE_VALUE_NV                                0x9595
#define GL_TIMEOUT_EXPIRED                                            0x911B
#define GL_TIMEOUT_IGNORED                                            0xFFFFFFFFFFFFFFFF
#define GL_TIMESTAMP                                                  0x8E28
#define GL_TIME_ELAPSED                                               0x88BF
#define GL_TIME_ELAPSED_EXT                                           0x88BF
#define GL_TOP_LEVEL_ARRAY_SIZE                                       0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE                                     0x930D
#define GL_TRACK_MATRIX_NV                                            0x8648
#define GL_TRACK_MATRIX_TRANSFORM_NV                                  0x8649
#define GL_TRANSFORM_FEEDBACK                                         0x8E22
#define GL_TRANSFORM_FEEDBACK_ACTIVE                                  0x8E24
#define GL_TRANSFORM_FEEDBACK_ATTRIBS_NV                              0x8C7E
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT                             0x00000800
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT                         0x00000800
#define GL_TRANSFORM_FEEDBACK_BINDING                                 0x8E25
#define GL_TRANSFORM_FEEDBACK_BINDING_NV                              0x8E25
#define GL_TRANSFORM_FEEDBACK_BUFFER                                  0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE                           0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV                        0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING                          0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT                      0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV                       0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_EXT                              0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX                            0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE                             0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT                         0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV                          0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_NV                               0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED                           0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV                        0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE                             0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT                         0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV                          0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_START                            0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT                        0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_START_NV                         0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE                           0x934C
#define GL_TRANSFORM_FEEDBACK_NV                                      0x8E22
#define GL_TRANSFORM_FEEDBACK_OVERFLOW                                0x82EC
#define GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB                            0x82EC
#define GL_TRANSFORM_FEEDBACK_PAUSED                                  0x8E23
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN                      0x8C88
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT                  0x8C88
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV                   0x8C88
#define GL_TRANSFORM_FEEDBACK_RECORD_NV                               0x8C86
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW                         0x82ED
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB                     0x82ED
#define GL_TRANSFORM_FEEDBACK_VARYING                                 0x92F4
#define GL_TRANSFORM_FEEDBACK_VARYINGS                                0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYINGS_EXT                            0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYINGS_NV                             0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH                      0x8C76
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT                  0x8C76
#define GL_TRANSFORM_HINT_APPLE                                       0x85B1
#define GL_TRANSLATE_2D_NV                                            0x9090
#define GL_TRANSLATE_3D_NV                                            0x9091
#define GL_TRANSLATE_X_NV                                             0x908E
#define GL_TRANSLATE_Y_NV                                             0x908F
#define GL_TRANSPOSE_AFFINE_2D_NV                                     0x9096
#define GL_TRANSPOSE_AFFINE_3D_NV                                     0x9098
#define GL_TRANSPOSE_COLOR_MATRIX_ARB                                 0x84E6
#define GL_TRANSPOSE_CURRENT_MATRIX_ARB                               0x88B7
#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB                             0x84E3
#define GL_TRANSPOSE_NV                                               0x862C
#define GL_TRANSPOSE_PROGRAM_MATRIX_EXT                               0x8E2E
#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB                            0x84E4
#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB                               0x84E5
#define GL_TRIANGLES                                                  0x0004
#define GL_TRIANGLES_ADJACENCY                                        0x000C
#define GL_TRIANGLES_ADJACENCY_ARB                                    0x000C
#define GL_TRIANGLES_ADJACENCY_EXT                                    0x000C
#define GL_TRIANGLE_FAN                                               0x0006
#define GL_TRIANGLE_LIST_SUN                                          0x81D7
#define GL_TRIANGLE_MESH_SUN                                          0x8615
#define GL_TRIANGLE_STRIP                                             0x0005
#define GL_TRIANGLE_STRIP_ADJACENCY                                   0x000D
#define GL_TRIANGLE_STRIP_ADJACENCY_ARB                               0x000D
#define GL_TRIANGLE_STRIP_ADJACENCY_EXT                               0x000D
#define GL_TRIANGULAR_NV                                              0x90A5
#define GL_TRUE                                                       1
#define GL_TYPE                                                       0x92FA
#define GL_UNCORRELATED_NV                                            0x9282
#define GL_UNDEFINED_APPLE                                            0x8A1C
#define GL_UNDEFINED_VERTEX                                           0x8260
#define GL_UNIFORM                                                    0x92E1
#define GL_UNIFORM_ADDRESS_COMMAND_NV                                 0x000A
#define GL_UNIFORM_ARRAY_STRIDE                                       0x8A3C
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX                        0x92DA
#define GL_UNIFORM_BARRIER_BIT                                        0x00000004
#define GL_UNIFORM_BARRIER_BIT_EXT                                    0x00000004
#define GL_UNIFORM_BLOCK                                              0x92E2
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS                              0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES                       0x8A43
#define GL_UNIFORM_BLOCK_BINDING                                      0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE                                    0x8A40
#define GL_UNIFORM_BLOCK_INDEX                                        0x8A3A
#define GL_UNIFORM_BLOCK_NAME_LENGTH                                  0x8A41
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER                 0x90EC
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER                0x8A46
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER                0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV                 0x959C
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV                 0x959D
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER            0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER         0x84F1
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER                  0x8A44
#define GL_UNIFORM_BUFFER                                             0x8A11
#define GL_UNIFORM_BUFFER_ADDRESS_NV                                  0x936F
#define GL_UNIFORM_BUFFER_BINDING                                     0x8A28
#define GL_UNIFORM_BUFFER_BINDING_EXT                                 0x8DEF
#define GL_UNIFORM_BUFFER_EXT                                         0x8DEE
#define GL_UNIFORM_BUFFER_LENGTH_NV                                   0x9370
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT                            0x8A34
#define GL_UNIFORM_BUFFER_SIZE                                        0x8A2A
#define GL_UNIFORM_BUFFER_START                                       0x8A29
#define GL_UNIFORM_BUFFER_UNIFIED_NV                                  0x936E
#define GL_UNIFORM_IS_ROW_MAJOR                                       0x8A3E
#define GL_UNIFORM_MATRIX_STRIDE                                      0x8A3D
#define GL_UNIFORM_NAME_LENGTH                                        0x8A39
#define GL_UNIFORM_OFFSET                                             0x8A3B
#define GL_UNIFORM_SIZE                                               0x8A38
#define GL_UNIFORM_TYPE                                               0x8A37
#define GL_UNKNOWN_CONTEXT_RESET                                      0x8255
#define GL_UNKNOWN_CONTEXT_RESET_ARB                                  0x8255
#define GL_UNPACK_ALIGNMENT                                           0x0CF5
#define GL_UNPACK_CLIENT_STORAGE_APPLE                                0x85B2
#define GL_UNPACK_CMYK_HINT_EXT                                       0x800F
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH                              0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT                             0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE                               0x912A
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH                              0x9127
#define GL_UNPACK_CONSTANT_DATA_SUNX                                  0x81D5
#define GL_UNPACK_IMAGE_DEPTH_SGIS                                    0x8133
#define GL_UNPACK_IMAGE_HEIGHT                                        0x806E
#define GL_UNPACK_IMAGE_HEIGHT_EXT                                    0x806E
#define GL_UNPACK_LSB_FIRST                                           0x0CF1
#define GL_UNPACK_RESAMPLE_OML                                        0x8985
#define GL_UNPACK_RESAMPLE_SGIX                                       0x842F
#define GL_UNPACK_ROW_BYTES_APPLE                                     0x8A16
#define GL_UNPACK_ROW_LENGTH                                          0x0CF2
#define GL_UNPACK_SKIP_IMAGES                                         0x806D
#define GL_UNPACK_SKIP_IMAGES_EXT                                     0x806D
#define GL_UNPACK_SKIP_PIXELS                                         0x0CF4
#define GL_UNPACK_SKIP_ROWS                                           0x0CF3
#define GL_UNPACK_SKIP_VOLUMES_SGIS                                   0x8132
#define GL_UNPACK_SUBSAMPLE_RATE_SGIX                                 0x85A1
#define GL_UNPACK_SWAP_BYTES                                          0x0CF0
#define GL_UNSIGNALED                                                 0x9118
#define GL_UNSIGNED_BYTE                                              0x1401
#define GL_UNSIGNED_BYTE_2_3_3_REV                                    0x8362
#define GL_UNSIGNED_BYTE_3_3_2                                        0x8032
#define GL_UNSIGNED_BYTE_3_3_2_EXT                                    0x8032
#define GL_UNSIGNED_IDENTITY_NV                                       0x8536
#define GL_UNSIGNED_INT                                               0x1405
#define GL_UNSIGNED_INT16_NV                                          0x8FF0
#define GL_UNSIGNED_INT16_VEC2_NV                                     0x8FF1
#define GL_UNSIGNED_INT16_VEC3_NV                                     0x8FF2
#define GL_UNSIGNED_INT16_VEC4_NV                                     0x8FF3
#define GL_UNSIGNED_INT64_AMD                                         0x8BC2
#define GL_UNSIGNED_INT64_ARB                                         0x140F
#define GL_UNSIGNED_INT64_NV                                          0x140F
#define GL_UNSIGNED_INT64_VEC2_ARB                                    0x8FF5
#define GL_UNSIGNED_INT64_VEC2_NV                                     0x8FF5
#define GL_UNSIGNED_INT64_VEC3_ARB                                    0x8FF6
#define GL_UNSIGNED_INT64_VEC3_NV                                     0x8FF6
#define GL_UNSIGNED_INT64_VEC4_ARB                                    0x8FF7
#define GL_UNSIGNED_INT64_VEC4_NV                                     0x8FF7
#define GL_UNSIGNED_INT8_NV                                           0x8FEC
#define GL_UNSIGNED_INT8_VEC2_NV                                      0x8FED
#define GL_UNSIGNED_INT8_VEC3_NV                                      0x8FEE
#define GL_UNSIGNED_INT8_VEC4_NV                                      0x8FEF
#define GL_UNSIGNED_INT_10F_11F_11F_REV                               0x8C3B
#define GL_UNSIGNED_INT_10F_11F_11F_REV_EXT                           0x8C3B
#define GL_UNSIGNED_INT_10_10_10_2                                    0x8036
#define GL_UNSIGNED_INT_10_10_10_2_EXT                                0x8036
#define GL_UNSIGNED_INT_24_8                                          0x84FA
#define GL_UNSIGNED_INT_24_8_EXT                                      0x84FA
#define GL_UNSIGNED_INT_24_8_NV                                       0x84FA
#define GL_UNSIGNED_INT_2_10_10_10_REV                                0x8368
#define GL_UNSIGNED_INT_5_9_9_9_REV                                   0x8C3E
#define GL_UNSIGNED_INT_5_9_9_9_REV_EXT                               0x8C3E
#define GL_UNSIGNED_INT_8_8_8_8                                       0x8035
#define GL_UNSIGNED_INT_8_8_8_8_EXT                                   0x8035
#define GL_UNSIGNED_INT_8_8_8_8_REV                                   0x8367
#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV                              0x86DB
#define GL_UNSIGNED_INT_ATOMIC_COUNTER                                0x92DB
#define GL_UNSIGNED_INT_IMAGE_1D                                      0x9062
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY                                0x9068
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT                            0x9068
#define GL_UNSIGNED_INT_IMAGE_1D_EXT                                  0x9062
#define GL_UNSIGNED_INT_IMAGE_2D                                      0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY                                0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT                            0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_EXT                                  0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE                          0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY                    0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT                0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT                      0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_RECT                                 0x9065
#define GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT                             0x9065
#define GL_UNSIGNED_INT_IMAGE_3D                                      0x9064
#define GL_UNSIGNED_INT_IMAGE_3D_EXT                                  0x9064
#define GL_UNSIGNED_INT_IMAGE_BUFFER                                  0x9067
#define GL_UNSIGNED_INT_IMAGE_BUFFER_EXT                              0x9067
#define GL_UNSIGNED_INT_IMAGE_CUBE                                    0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_EXT                                0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY                          0x906A
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT                      0x906A
#define GL_UNSIGNED_INT_S8_S8_8_8_NV                                  0x86DA
#define GL_UNSIGNED_INT_SAMPLER_1D                                    0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY                              0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT                          0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_1D_EXT                                0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D                                    0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY                              0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT                          0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_EXT                                0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE                        0x910A
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY                  0x910D
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT                               0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT                           0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_3D                                    0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_3D_EXT                                0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_BUFFER                                0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD                            0x9003
#define GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT                            0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_CUBE                                  0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_EXT                              0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY                        0x900F
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB                    0x900F
#define GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV                       0x8E58
#define GL_UNSIGNED_INT_VEC2                                          0x8DC6
#define GL_UNSIGNED_INT_VEC2_EXT                                      0x8DC6
#define GL_UNSIGNED_INT_VEC3                                          0x8DC7
#define GL_UNSIGNED_INT_VEC3_EXT                                      0x8DC7
#define GL_UNSIGNED_INT_VEC4                                          0x8DC8
#define GL_UNSIGNED_INT_VEC4_EXT                                      0x8DC8
#define GL_UNSIGNED_INVERT_NV                                         0x8537
#define GL_UNSIGNED_NORMALIZED                                        0x8C17
#define GL_UNSIGNED_NORMALIZED_ARB                                    0x8C17
#define GL_UNSIGNED_SHORT                                             0x1403
#define GL_UNSIGNED_SHORT_1_5_5_5_REV                                 0x8366
#define GL_UNSIGNED_SHORT_4_4_4_4                                     0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_EXT                                 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_REV                                 0x8365
#define GL_UNSIGNED_SHORT_5_5_5_1                                     0x8034
#define GL_UNSIGNED_SHORT_5_5_5_1_EXT                                 0x8034
#define GL_UNSIGNED_SHORT_5_6_5                                       0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV                                   0x8364
#define GL_UNSIGNED_SHORT_8_8_APPLE                                   0x85BA
#define GL_UNSIGNED_SHORT_8_8_MESA                                    0x85BA
#define GL_UNSIGNED_SHORT_8_8_REV_APPLE                               0x85BB
#define GL_UNSIGNED_SHORT_8_8_REV_MESA                                0x85BB
#define GL_UPLOAD_GPU_MASK_NVX                                        0x954A
#define GL_UPPER_LEFT                                                 0x8CA2
#define GL_USE_MISSING_GLYPH_NV                                       0x90AA
#define GL_UTF16_NV                                                   0x909B
#define GL_UTF8_NV                                                    0x909A
#define GL_UUID_SIZE_EXT                                              16
#define GL_VALIDATE_STATUS                                            0x8B83
#define GL_VARIABLE_A_NV                                              0x8523
#define GL_VARIABLE_B_NV                                              0x8524
#define GL_VARIABLE_C_NV                                              0x8525
#define GL_VARIABLE_D_NV                                              0x8526
#define GL_VARIABLE_E_NV                                              0x8527
#define GL_VARIABLE_F_NV                                              0x8528
#define GL_VARIABLE_G_NV                                              0x8529
#define GL_VARIANT_ARRAY_EXT                                          0x87E8
#define GL_VARIANT_ARRAY_POINTER_EXT                                  0x87E9
#define GL_VARIANT_ARRAY_STRIDE_EXT                                   0x87E6
#define GL_VARIANT_ARRAY_TYPE_EXT                                     0x87E7
#define GL_VARIANT_DATATYPE_EXT                                       0x87E5
#define GL_VARIANT_EXT                                                0x87C1
#define GL_VARIANT_VALUE_EXT                                          0x87E4
#define GL_VBO_FREE_MEMORY_ATI                                        0x87FB
#define GL_VECTOR_EXT                                                 0x87BF
#define GL_VENDOR                                                     0x1F00
#define GL_VERSION                                                    0x1F02
#define GL_VERTEX23_BIT_PGI                                           0x00000004
#define GL_VERTEX4_BIT_PGI                                            0x00000008
#define GL_VERTEX_ARRAY                                               0x8074
#define GL_VERTEX_ARRAY_ADDRESS_NV                                    0x8F21
#define GL_VERTEX_ARRAY_BINDING                                       0x85B5
#define GL_VERTEX_ARRAY_BINDING_APPLE                                 0x85B5
#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB                            0x8896
#define GL_VERTEX_ARRAY_COUNT_EXT                                     0x807D
#define GL_VERTEX_ARRAY_EXT                                           0x8074
#define GL_VERTEX_ARRAY_LENGTH_NV                                     0x8F2B
#define GL_VERTEX_ARRAY_LIST_IBM                                      103070
#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM                               103080
#define GL_VERTEX_ARRAY_OBJECT_AMD                                    0x9154
#define GL_VERTEX_ARRAY_OBJECT_EXT                                    0x9154
#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL                       0x83F5
#define GL_VERTEX_ARRAY_POINTER_EXT                                   0x808E
#define GL_VERTEX_ARRAY_RANGE_APPLE                                   0x851D
#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE                            0x851E
#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV                               0x851E
#define GL_VERTEX_ARRAY_RANGE_NV                                      0x851D
#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE                           0x8521
#define GL_VERTEX_ARRAY_RANGE_POINTER_NV                              0x8521
#define GL_VERTEX_ARRAY_RANGE_VALID_NV                                0x851F
#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV                        0x8533
#define GL_VERTEX_ARRAY_SIZE_EXT                                      0x807A
#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE                            0x851F
#define GL_VERTEX_ARRAY_STRIDE_EXT                                    0x807C
#define GL_VERTEX_ARRAY_TYPE_EXT                                      0x807B
#define GL_VERTEX_ATTRIB_ARRAY0_NV                                    0x8650
#define GL_VERTEX_ATTRIB_ARRAY10_NV                                   0x865A
#define GL_VERTEX_ATTRIB_ARRAY11_NV                                   0x865B
#define GL_VERTEX_ATTRIB_ARRAY12_NV                                   0x865C
#define GL_VERTEX_ATTRIB_ARRAY13_NV                                   0x865D
#define GL_VERTEX_ATTRIB_ARRAY14_NV                                   0x865E
#define GL_VERTEX_ATTRIB_ARRAY15_NV                                   0x865F
#define GL_VERTEX_ATTRIB_ARRAY1_NV                                    0x8651
#define GL_VERTEX_ATTRIB_ARRAY2_NV                                    0x8652
#define GL_VERTEX_ATTRIB_ARRAY3_NV                                    0x8653
#define GL_VERTEX_ATTRIB_ARRAY4_NV                                    0x8654
#define GL_VERTEX_ATTRIB_ARRAY5_NV                                    0x8655
#define GL_VERTEX_ATTRIB_ARRAY6_NV                                    0x8656
#define GL_VERTEX_ATTRIB_ARRAY7_NV                                    0x8657
#define GL_VERTEX_ATTRIB_ARRAY8_NV                                    0x8658
#define GL_VERTEX_ATTRIB_ARRAY9_NV                                    0x8659
#define GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV                             0x8F20
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT                            0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT                        0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING                         0x889F
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB                     0x889F
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR                                0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB                            0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED                                0x8622
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB                            0x8622
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER                                0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT                            0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV                             0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV                              0x8F2A
#define GL_VERTEX_ATTRIB_ARRAY_LONG                                   0x874E
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED                             0x886A
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB                         0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER                                0x8645
#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB                            0x8645
#define GL_VERTEX_ATTRIB_ARRAY_SIZE                                   0x8623
#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB                               0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE                                 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB                             0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE                                   0x8625
#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB                               0x8625
#define GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV                             0x8F1E
#define GL_VERTEX_ATTRIB_BINDING                                      0x82D4
#define GL_VERTEX_ATTRIB_MAP1_APPLE                                   0x8A00
#define GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE                             0x8A03
#define GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE                            0x8A05
#define GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE                             0x8A04
#define GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE                              0x8A02
#define GL_VERTEX_ATTRIB_MAP2_APPLE                                   0x8A01
#define GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE                             0x8A07
#define GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE                            0x8A09
#define GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE                             0x8A08
#define GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE                              0x8A06
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET                              0x82D5
#define GL_VERTEX_BINDING_BUFFER                                      0x8F4F
#define GL_VERTEX_BINDING_DIVISOR                                     0x82D6
#define GL_VERTEX_BINDING_OFFSET                                      0x82D7
#define GL_VERTEX_BINDING_STRIDE                                      0x82D8
#define GL_VERTEX_BLEND_ARB                                           0x86A7
#define GL_VERTEX_CONSISTENT_HINT_PGI                                 0x1A22B
#define GL_VERTEX_DATA_HINT_PGI                                       0x1A22A
#define GL_VERTEX_ELEMENT_SWIZZLE_AMD                                 0x91A4
#define GL_VERTEX_ID_NV                                               0x8C7B
#define GL_VERTEX_ID_SWIZZLE_AMD                                      0x91A5
#define GL_VERTEX_PRECLIP_HINT_SGIX                                   0x83EF
#define GL_VERTEX_PRECLIP_SGIX                                        0x83EE
#define GL_VERTEX_PROGRAM_ARB                                         0x8620
#define GL_VERTEX_PROGRAM_BINDING_NV                                  0x864A
#define GL_VERTEX_PROGRAM_NV                                          0x8620
#define GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV                         0x8DA2
#define GL_VERTEX_PROGRAM_POINT_SIZE                                  0x8642
#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB                              0x8642
#define GL_VERTEX_PROGRAM_POINT_SIZE_NV                               0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB                                0x8643
#define GL_VERTEX_PROGRAM_TWO_SIDE_NV                                 0x8643
#define GL_VERTEX_SHADER                                              0x8B31
#define GL_VERTEX_SHADER_ARB                                          0x8B31
#define GL_VERTEX_SHADER_BINDING_EXT                                  0x8781
#define GL_VERTEX_SHADER_BIT                                          0x00000001
#define GL_VERTEX_SHADER_EXT                                          0x8780
#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT                             0x87CF
#define GL_VERTEX_SHADER_INVARIANTS_EXT                               0x87D1
#define GL_VERTEX_SHADER_INVOCATIONS                                  0x82F0
#define GL_VERTEX_SHADER_INVOCATIONS_ARB                              0x82F0
#define GL_VERTEX_SHADER_LOCALS_EXT                                   0x87D3
#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT                          0x87D2
#define GL_VERTEX_SHADER_OPTIMIZED_EXT                                0x87D4
#define GL_VERTEX_SHADER_VARIANTS_EXT                                 0x87D0
#define GL_VERTEX_SOURCE_ATI                                          0x8774
#define GL_VERTEX_STATE_PROGRAM_NV                                    0x8621
#define GL_VERTEX_STREAM0_ATI                                         0x876C
#define GL_VERTEX_STREAM1_ATI                                         0x876D
#define GL_VERTEX_STREAM2_ATI                                         0x876E
#define GL_VERTEX_STREAM3_ATI                                         0x876F
#define GL_VERTEX_STREAM4_ATI                                         0x8770
#define GL_VERTEX_STREAM5_ATI                                         0x8771
#define GL_VERTEX_STREAM6_ATI                                         0x8772
#define GL_VERTEX_STREAM7_ATI                                         0x8773
#define GL_VERTEX_SUBROUTINE                                          0x92E8
#define GL_VERTEX_SUBROUTINE_UNIFORM                                  0x92EE
#define GL_VERTEX_TEXTURE                                             0x829B
#define GL_VERTEX_WEIGHTING_EXT                                       0x8509
#define GL_VERTEX_WEIGHT_ARRAY_EXT                                    0x850C
#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT                            0x8510
#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT                               0x850D
#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT                             0x850F
#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT                               0x850E
#define GL_VERTICAL_LINE_TO_NV                                        0x08
#define GL_VERTICES_SUBMITTED                                         0x82EE
#define GL_VERTICES_SUBMITTED_ARB                                     0x82EE
#define GL_VIBRANCE_BIAS_NV                                           0x8719
#define GL_VIBRANCE_SCALE_NV                                          0x8713
#define GL_VIDEO_BUFFER_BINDING_NV                                    0x9021
#define GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV                            0x902D
#define GL_VIDEO_BUFFER_NV                                            0x9020
#define GL_VIDEO_BUFFER_PITCH_NV                                      0x9028
#define GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV                        0x903B
#define GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV                        0x903A
#define GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV                              0x9039
#define GL_VIDEO_CAPTURE_FRAME_WIDTH_NV                               0x9038
#define GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV                            0x903C
#define GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV                          0x9026
#define GL_VIDEO_COLOR_CONVERSION_MATRIX_NV                           0x9029
#define GL_VIDEO_COLOR_CONVERSION_MAX_NV                              0x902A
#define GL_VIDEO_COLOR_CONVERSION_MIN_NV                              0x902B
#define GL_VIDEO_COLOR_CONVERSION_OFFSET_NV                           0x902C
#define GL_VIEWPORT                                                   0x0BA2
#define GL_VIEWPORT_BOUNDS_RANGE                                      0x825D
#define GL_VIEWPORT_COMMAND_NV                                        0x0010
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX                            0x825F
#define GL_VIEWPORT_POSITION_W_SCALE_NV                               0x937C
#define GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV                       0x937D
#define GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV                       0x937E
#define GL_VIEWPORT_SUBPIXEL_BITS                                     0x825C
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV                             0x9357
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV                             0x9351
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV                             0x9353
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV                             0x9355
#define GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV                             0x9356
#define GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV                             0x9350
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV                             0x9352
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV                             0x9354
#define GL_VIEWPORT_SWIZZLE_W_NV                                      0x935B
#define GL_VIEWPORT_SWIZZLE_X_NV                                      0x9358
#define GL_VIEWPORT_SWIZZLE_Y_NV                                      0x9359
#define GL_VIEWPORT_SWIZZLE_Z_NV                                      0x935A
#define GL_VIEW_CLASS_128_BITS                                        0x82C4
#define GL_VIEW_CLASS_16_BITS                                         0x82CA
#define GL_VIEW_CLASS_24_BITS                                         0x82C9
#define GL_VIEW_CLASS_32_BITS                                         0x82C8
#define GL_VIEW_CLASS_48_BITS                                         0x82C7
#define GL_VIEW_CLASS_64_BITS                                         0x82C6
#define GL_VIEW_CLASS_8_BITS                                          0x82CB
#define GL_VIEW_CLASS_96_BITS                                         0x82C5
#define GL_VIEW_CLASS_ASTC_10x10_RGBA                                 0x9393
#define GL_VIEW_CLASS_ASTC_10x5_RGBA                                  0x9390
#define GL_VIEW_CLASS_ASTC_10x6_RGBA                                  0x9391
#define GL_VIEW_CLASS_ASTC_10x8_RGBA                                  0x9392
#define GL_VIEW_CLASS_ASTC_12x10_RGBA                                 0x9394
#define GL_VIEW_CLASS_ASTC_12x12_RGBA                                 0x9395
#define GL_VIEW_CLASS_ASTC_4x4_RGBA                                   0x9388
#define GL_VIEW_CLASS_ASTC_5x4_RGBA                                   0x9389
#define GL_VIEW_CLASS_ASTC_5x5_RGBA                                   0x938A
#define GL_VIEW_CLASS_ASTC_6x5_RGBA                                   0x938B
#define GL_VIEW_CLASS_ASTC_6x6_RGBA                                   0x938C
#define GL_VIEW_CLASS_ASTC_8x5_RGBA                                   0x938D
#define GL_VIEW_CLASS_ASTC_8x6_RGBA                                   0x938E
#define GL_VIEW_CLASS_ASTC_8x8_RGBA                                   0x938F
#define GL_VIEW_CLASS_BPTC_FLOAT                                      0x82D3
#define GL_VIEW_CLASS_BPTC_UNORM                                      0x82D2
#define GL_VIEW_CLASS_EAC_R11                                         0x9383
#define GL_VIEW_CLASS_EAC_RG11                                        0x9384
#define GL_VIEW_CLASS_ETC2_EAC_RGBA                                   0x9387
#define GL_VIEW_CLASS_ETC2_RGB                                        0x9385
#define GL_VIEW_CLASS_ETC2_RGBA                                       0x9386
#define GL_VIEW_CLASS_RGTC1_RED                                       0x82D0
#define GL_VIEW_CLASS_RGTC2_RG                                        0x82D1
#define GL_VIEW_CLASS_S3TC_DXT1_RGB                                   0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA                                  0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA                                  0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA                                  0x82CF
#define GL_VIEW_COMPATIBILITY_CLASS                                   0x82B6
#define GL_VIRTUAL_PAGE_SIZE_INDEX_ARB                                0x91A7
#define GL_VIRTUAL_PAGE_SIZE_X_AMD                                    0x9195
#define GL_VIRTUAL_PAGE_SIZE_X_ARB                                    0x9195
#define GL_VIRTUAL_PAGE_SIZE_Y_AMD                                    0x9196
#define GL_VIRTUAL_PAGE_SIZE_Y_ARB                                    0x9196
#define GL_VIRTUAL_PAGE_SIZE_Z_AMD                                    0x9197
#define GL_VIRTUAL_PAGE_SIZE_Z_ARB                                    0x9197
#define GL_VIVIDLIGHT_NV                                              0x92A6
#define GL_VOLATILE_APPLE                                             0x8A1A
#define GL_WAIT_FAILED                                                0x911D
#define GL_WARPS_PER_SM_NV                                            0x933A
#define GL_WARP_SIZE_NV                                               0x9339
#define GL_WEIGHTED_AVERAGE_ARB                                       0x9367
#define GL_WEIGHTED_AVERAGE_EXT                                       0x9367
#define GL_WEIGHT_ARRAY_ARB                                           0x86AD
#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB                            0x889E
#define GL_WEIGHT_ARRAY_POINTER_ARB                                   0x86AC
#define GL_WEIGHT_ARRAY_SIZE_ARB                                      0x86AB
#define GL_WEIGHT_ARRAY_STRIDE_ARB                                    0x86AA
#define GL_WEIGHT_ARRAY_TYPE_ARB                                      0x86A9
#define GL_WEIGHT_SUM_UNITY_ARB                                       0x86A6
#define GL_WIDE_LINE_HINT_PGI                                         0x1A222
#define GL_WINDOW_RECTANGLE_EXT                                       0x8F12
#define GL_WINDOW_RECTANGLE_MODE_EXT                                  0x8F13
#define GL_WRAP_BORDER_SUN                                            0x81D4
#define GL_WRITE_DISCARD_NV                                           0x88BE
#define GL_WRITE_ONLY                                                 0x88B9
#define GL_WRITE_ONLY_ARB                                             0x88B9
#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV                           0x887A
#define GL_WRITE_PIXEL_DATA_RANGE_NV                                  0x8878
#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV                          0x887C
#define GL_W_EXT                                                      0x87D8
#define GL_XOR                                                        0x1506
#define GL_XOR_NV                                                     0x1506
#define GL_X_EXT                                                      0x87D5
#define GL_YCBAYCR8A_4224_NV                                          0x9032
#define GL_YCBCR_422_APPLE                                            0x85B9
#define GL_YCBCR_MESA                                                 0x8757
#define GL_YCBYCR8_422_NV                                             0x9031
#define GL_YCRCBA_SGIX                                                0x8319
#define GL_YCRCB_422_SGIX                                             0x81BB
#define GL_YCRCB_444_SGIX                                             0x81BC
#define GL_YCRCB_SGIX                                                 0x8318
#define GL_Y_EXT                                                      0x87D6
#define GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV                   0x9036
#define GL_Z4Y12Z4CB12Z4CR12_444_NV                                   0x9037
#define GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV                              0x9035
#define GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV                   0x9034
#define GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV                              0x9033
#define GL_ZERO                                                       0
#define GL_ZERO_EXT                                                   0x87DD
#define GL_ZERO_TO_ONE                                                0x935F
#define GL_Z_EXT                                                      0x87D7

#include <KHR/khrplatform.h>
    typedef unsigned int GLenum;
    typedef unsigned char GLboolean;
    typedef unsigned int GLbitfield;
    typedef void GLvoid;
    typedef khronos_int8_t GLbyte;
    typedef khronos_uint8_t GLubyte;
    typedef khronos_int16_t GLshort;
    typedef khronos_uint16_t GLushort;
    typedef int GLint;
    typedef unsigned int GLuint;
    typedef khronos_int32_t GLclampx;
    typedef int GLsizei;
    typedef khronos_float_t GLfloat;
    typedef khronos_float_t GLclampf;
    typedef double GLdouble;
    typedef double GLclampd;
    typedef void* GLeglClientBufferEXT;
    typedef void* GLeglImageOES;
    typedef char GLchar;
    typedef char GLcharARB;
#ifdef __APPLE__
    typedef void* GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
    typedef khronos_uint16_t GLhalf;
    typedef khronos_uint16_t GLhalfARB;
    typedef khronos_int32_t GLfixed;
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \
    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
    typedef khronos_intptr_t GLintptr;
#else
typedef khronos_intptr_t GLintptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \
    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
    typedef khronos_intptr_t GLintptrARB;
#else
typedef khronos_intptr_t GLintptrARB;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \
    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
    typedef khronos_ssize_t GLsizeiptr;
#else
typedef khronos_ssize_t GLsizeiptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \
    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
    typedef khronos_ssize_t GLsizeiptrARB;
#else
typedef khronos_ssize_t GLsizeiptrARB;
#endif
    typedef khronos_int64_t GLint64;
    typedef khronos_int64_t GLint64EXT;
    typedef khronos_uint64_t GLuint64;
    typedef khronos_uint64_t GLuint64EXT;
    typedef struct __GLsync* GLsync;
    struct _cl_context;
    struct _cl_event;
    typedef void(GLAD_API_PTR* GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity,
                                            GLsizei length, const GLchar* message,
                                            const void* userParam);
    typedef void(GLAD_API_PTR* GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id,
                                               GLenum severity, GLsizei length,
                                               const GLchar* message, const void* userParam);
    typedef void(GLAD_API_PTR* GLDEBUGPROCKHR)(GLenum source, GLenum type, GLuint id,
                                               GLenum severity, GLsizei length,
                                               const GLchar* message, const void* userParam);
    typedef void(GLAD_API_PTR* GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity,
                                               GLsizei length, const GLchar* message,
                                               void* userParam);
    typedef unsigned short GLhalfNV;
    typedef GLintptr GLvdpauSurfaceNV;
    typedef void(GLAD_API_PTR* GLVULKANPROCNV)(void);

#define GL_VERSION_1_0 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_0;
#define GL_VERSION_1_1 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_1;
#define GL_VERSION_1_2 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_2;
#define GL_VERSION_1_3 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_3;
#define GL_VERSION_1_4 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_4;
#define GL_VERSION_1_5 1
    GLAD_API_CALL int GLAD_GL_VERSION_1_5;
#define GL_VERSION_2_0 1
    GLAD_API_CALL int GLAD_GL_VERSION_2_0;
#define GL_VERSION_2_1 1
    GLAD_API_CALL int GLAD_GL_VERSION_2_1;
#define GL_VERSION_3_0 1
    GLAD_API_CALL int GLAD_GL_VERSION_3_0;
#define GL_VERSION_3_1 1
    GLAD_API_CALL int GLAD_GL_VERSION_3_1;
#define GL_VERSION_3_2 1
    GLAD_API_CALL int GLAD_GL_VERSION_3_2;
#define GL_VERSION_3_3 1
    GLAD_API_CALL int GLAD_GL_VERSION_3_3;
#define GL_VERSION_4_0 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_0;
#define GL_VERSION_4_1 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_1;
#define GL_VERSION_4_2 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_2;
#define GL_VERSION_4_3 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_3;
#define GL_VERSION_4_4 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_4;
#define GL_VERSION_4_5 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_5;
#define GL_VERSION_4_6 1
    GLAD_API_CALL int GLAD_GL_VERSION_4_6;
#define GL_3DFX_multisample 1
    GLAD_API_CALL int GLAD_GL_3DFX_multisample;
#define GL_3DFX_tbuffer 1
    GLAD_API_CALL int GLAD_GL_3DFX_tbuffer;
#define GL_3DFX_texture_compression_FXT1 1
    GLAD_API_CALL int GLAD_GL_3DFX_texture_compression_FXT1;
#define GL_AMD_blend_minmax_factor 1
    GLAD_API_CALL int GLAD_GL_AMD_blend_minmax_factor;
#define GL_AMD_conservative_depth 1
    GLAD_API_CALL int GLAD_GL_AMD_conservative_depth;
#define GL_AMD_debug_output 1
    GLAD_API_CALL int GLAD_GL_AMD_debug_output;
#define GL_AMD_depth_clamp_separate 1
    GLAD_API_CALL int GLAD_GL_AMD_depth_clamp_separate;
#define GL_AMD_draw_buffers_blend 1
    GLAD_API_CALL int GLAD_GL_AMD_draw_buffers_blend;
#define GL_AMD_framebuffer_multisample_advanced 1
    GLAD_API_CALL int GLAD_GL_AMD_framebuffer_multisample_advanced;
#define GL_AMD_framebuffer_sample_positions 1
    GLAD_API_CALL int GLAD_GL_AMD_framebuffer_sample_positions;
#define GL_AMD_gcn_shader 1
    GLAD_API_CALL int GLAD_GL_AMD_gcn_shader;
#define GL_AMD_gpu_shader_half_float 1
    GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_half_float;
#define GL_AMD_gpu_shader_int16 1
    GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_int16;
#define GL_AMD_gpu_shader_int64 1
    GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_int64;
#define GL_AMD_interleaved_elements 1
    GLAD_API_CALL int GLAD_GL_AMD_interleaved_elements;
#define GL_AMD_multi_draw_indirect 1
    GLAD_API_CALL int GLAD_GL_AMD_multi_draw_indirect;
#define GL_AMD_name_gen_delete 1
    GLAD_API_CALL int GLAD_GL_AMD_name_gen_delete;
#define GL_AMD_occlusion_query_event 1
    GLAD_API_CALL int GLAD_GL_AMD_occlusion_query_event;
#define GL_AMD_performance_monitor 1
    GLAD_API_CALL int GLAD_GL_AMD_performance_monitor;
#define GL_AMD_pinned_memory 1
    GLAD_API_CALL int GLAD_GL_AMD_pinned_memory;
#define GL_AMD_query_buffer_object 1
    GLAD_API_CALL int GLAD_GL_AMD_query_buffer_object;
#define GL_AMD_sample_positions 1
    GLAD_API_CALL int GLAD_GL_AMD_sample_positions;
#define GL_AMD_seamless_cubemap_per_texture 1
    GLAD_API_CALL int GLAD_GL_AMD_seamless_cubemap_per_texture;
#define GL_AMD_shader_atomic_counter_ops 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_atomic_counter_ops;
#define GL_AMD_shader_ballot 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_ballot;
#define GL_AMD_shader_explicit_vertex_parameter 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_explicit_vertex_parameter;
#define GL_AMD_shader_gpu_shader_half_float_fetch 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_gpu_shader_half_float_fetch;
#define GL_AMD_shader_image_load_store_lod 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_image_load_store_lod;
#define GL_AMD_shader_stencil_export 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_stencil_export;
#define GL_AMD_shader_trinary_minmax 1
    GLAD_API_CALL int GLAD_GL_AMD_shader_trinary_minmax;
#define GL_AMD_sparse_texture 1
    GLAD_API_CALL int GLAD_GL_AMD_sparse_texture;
#define GL_AMD_stencil_operation_extended 1
    GLAD_API_CALL int GLAD_GL_AMD_stencil_operation_extended;
#define GL_AMD_texture_gather_bias_lod 1
    GLAD_API_CALL int GLAD_GL_AMD_texture_gather_bias_lod;
#define GL_AMD_texture_texture4 1
    GLAD_API_CALL int GLAD_GL_AMD_texture_texture4;
#define GL_AMD_transform_feedback3_lines_triangles 1
    GLAD_API_CALL int GLAD_GL_AMD_transform_feedback3_lines_triangles;
#define GL_AMD_transform_feedback4 1
    GLAD_API_CALL int GLAD_GL_AMD_transform_feedback4;
#define GL_AMD_vertex_shader_layer 1
    GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_layer;
#define GL_AMD_vertex_shader_tessellator 1
    GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_tessellator;
#define GL_AMD_vertex_shader_viewport_index 1
    GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_viewport_index;
#define GL_APPLE_aux_depth_stencil 1
    GLAD_API_CALL int GLAD_GL_APPLE_aux_depth_stencil;
#define GL_APPLE_client_storage 1
    GLAD_API_CALL int GLAD_GL_APPLE_client_storage;
#define GL_APPLE_element_array 1
    GLAD_API_CALL int GLAD_GL_APPLE_element_array;
#define GL_APPLE_fence 1
    GLAD_API_CALL int GLAD_GL_APPLE_fence;
#define GL_APPLE_float_pixels 1
    GLAD_API_CALL int GLAD_GL_APPLE_float_pixels;
#define GL_APPLE_flush_buffer_range 1
    GLAD_API_CALL int GLAD_GL_APPLE_flush_buffer_range;
#define GL_APPLE_object_purgeable 1
    GLAD_API_CALL int GLAD_GL_APPLE_object_purgeable;
#define GL_APPLE_rgb_422 1
    GLAD_API_CALL int GLAD_GL_APPLE_rgb_422;
#define GL_APPLE_row_bytes 1
    GLAD_API_CALL int GLAD_GL_APPLE_row_bytes;
#define GL_APPLE_specular_vector 1
    GLAD_API_CALL int GLAD_GL_APPLE_specular_vector;
#define GL_APPLE_texture_range 1
    GLAD_API_CALL int GLAD_GL_APPLE_texture_range;
#define GL_APPLE_transform_hint 1
    GLAD_API_CALL int GLAD_GL_APPLE_transform_hint;
#define GL_APPLE_vertex_array_object 1
    GLAD_API_CALL int GLAD_GL_APPLE_vertex_array_object;
#define GL_APPLE_vertex_array_range 1
    GLAD_API_CALL int GLAD_GL_APPLE_vertex_array_range;
#define GL_APPLE_vertex_program_evaluators 1
    GLAD_API_CALL int GLAD_GL_APPLE_vertex_program_evaluators;
#define GL_APPLE_ycbcr_422 1
    GLAD_API_CALL int GLAD_GL_APPLE_ycbcr_422;
#define GL_ARB_ES2_compatibility 1
    GLAD_API_CALL int GLAD_GL_ARB_ES2_compatibility;
#define GL_ARB_ES3_1_compatibility 1
    GLAD_API_CALL int GLAD_GL_ARB_ES3_1_compatibility;
#define GL_ARB_ES3_2_compatibility 1
    GLAD_API_CALL int GLAD_GL_ARB_ES3_2_compatibility;
#define GL_ARB_ES3_compatibility 1
    GLAD_API_CALL int GLAD_GL_ARB_ES3_compatibility;
#define GL_ARB_arrays_of_arrays 1
    GLAD_API_CALL int GLAD_GL_ARB_arrays_of_arrays;
#define GL_ARB_base_instance 1
    GLAD_API_CALL int GLAD_GL_ARB_base_instance;
#define GL_ARB_bindless_texture 1
    GLAD_API_CALL int GLAD_GL_ARB_bindless_texture;
#define GL_ARB_blend_func_extended 1
    GLAD_API_CALL int GLAD_GL_ARB_blend_func_extended;
#define GL_ARB_buffer_storage 1
    GLAD_API_CALL int GLAD_GL_ARB_buffer_storage;
#define GL_ARB_cl_event 1
    GLAD_API_CALL int GLAD_GL_ARB_cl_event;
#define GL_ARB_clear_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_clear_buffer_object;
#define GL_ARB_clear_texture 1
    GLAD_API_CALL int GLAD_GL_ARB_clear_texture;
#define GL_ARB_clip_control 1
    GLAD_API_CALL int GLAD_GL_ARB_clip_control;
#define GL_ARB_color_buffer_float 1
    GLAD_API_CALL int GLAD_GL_ARB_color_buffer_float;
#define GL_ARB_compatibility 1
    GLAD_API_CALL int GLAD_GL_ARB_compatibility;
#define GL_ARB_compressed_texture_pixel_storage 1
    GLAD_API_CALL int GLAD_GL_ARB_compressed_texture_pixel_storage;
#define GL_ARB_compute_shader 1
    GLAD_API_CALL int GLAD_GL_ARB_compute_shader;
#define GL_ARB_compute_variable_group_size 1
    GLAD_API_CALL int GLAD_GL_ARB_compute_variable_group_size;
#define GL_ARB_conditional_render_inverted 1
    GLAD_API_CALL int GLAD_GL_ARB_conditional_render_inverted;
#define GL_ARB_conservative_depth 1
    GLAD_API_CALL int GLAD_GL_ARB_conservative_depth;
#define GL_ARB_copy_buffer 1
    GLAD_API_CALL int GLAD_GL_ARB_copy_buffer;
#define GL_ARB_copy_image 1
    GLAD_API_CALL int GLAD_GL_ARB_copy_image;
#define GL_ARB_cull_distance 1
    GLAD_API_CALL int GLAD_GL_ARB_cull_distance;
#define GL_ARB_debug_output 1
    GLAD_API_CALL int GLAD_GL_ARB_debug_output;
#define GL_ARB_depth_buffer_float 1
    GLAD_API_CALL int GLAD_GL_ARB_depth_buffer_float;
#define GL_ARB_depth_clamp 1
    GLAD_API_CALL int GLAD_GL_ARB_depth_clamp;
#define GL_ARB_depth_texture 1
    GLAD_API_CALL int GLAD_GL_ARB_depth_texture;
#define GL_ARB_derivative_control 1
    GLAD_API_CALL int GLAD_GL_ARB_derivative_control;
#define GL_ARB_direct_state_access 1
    GLAD_API_CALL int GLAD_GL_ARB_direct_state_access;
#define GL_ARB_draw_buffers 1
    GLAD_API_CALL int GLAD_GL_ARB_draw_buffers;
#define GL_ARB_draw_buffers_blend 1
    GLAD_API_CALL int GLAD_GL_ARB_draw_buffers_blend;
#define GL_ARB_draw_elements_base_vertex 1
    GLAD_API_CALL int GLAD_GL_ARB_draw_elements_base_vertex;
#define GL_ARB_draw_indirect 1
    GLAD_API_CALL int GLAD_GL_ARB_draw_indirect;
#define GL_ARB_draw_instanced 1
    GLAD_API_CALL int GLAD_GL_ARB_draw_instanced;
#define GL_ARB_enhanced_layouts 1
    GLAD_API_CALL int GLAD_GL_ARB_enhanced_layouts;
#define GL_ARB_explicit_attrib_location 1
    GLAD_API_CALL int GLAD_GL_ARB_explicit_attrib_location;
#define GL_ARB_explicit_uniform_location 1
    GLAD_API_CALL int GLAD_GL_ARB_explicit_uniform_location;
#define GL_ARB_fragment_coord_conventions 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_coord_conventions;
#define GL_ARB_fragment_layer_viewport 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_layer_viewport;
#define GL_ARB_fragment_program 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_program;
#define GL_ARB_fragment_program_shadow 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_program_shadow;
#define GL_ARB_fragment_shader 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_shader;
#define GL_ARB_fragment_shader_interlock 1
    GLAD_API_CALL int GLAD_GL_ARB_fragment_shader_interlock;
#define GL_ARB_framebuffer_no_attachments 1
    GLAD_API_CALL int GLAD_GL_ARB_framebuffer_no_attachments;
#define GL_ARB_framebuffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_framebuffer_object;
#define GL_ARB_framebuffer_sRGB 1
    GLAD_API_CALL int GLAD_GL_ARB_framebuffer_sRGB;
#define GL_ARB_geometry_shader4 1
    GLAD_API_CALL int GLAD_GL_ARB_geometry_shader4;
#define GL_ARB_get_program_binary 1
    GLAD_API_CALL int GLAD_GL_ARB_get_program_binary;
#define GL_ARB_get_texture_sub_image 1
    GLAD_API_CALL int GLAD_GL_ARB_get_texture_sub_image;
#define GL_ARB_gl_spirv 1
    GLAD_API_CALL int GLAD_GL_ARB_gl_spirv;
#define GL_ARB_gpu_shader5 1
    GLAD_API_CALL int GLAD_GL_ARB_gpu_shader5;
#define GL_ARB_gpu_shader_fp64 1
    GLAD_API_CALL int GLAD_GL_ARB_gpu_shader_fp64;
#define GL_ARB_gpu_shader_int64 1
    GLAD_API_CALL int GLAD_GL_ARB_gpu_shader_int64;
#define GL_ARB_half_float_pixel 1
    GLAD_API_CALL int GLAD_GL_ARB_half_float_pixel;
#define GL_ARB_half_float_vertex 1
    GLAD_API_CALL int GLAD_GL_ARB_half_float_vertex;
#define GL_ARB_imaging 1
    GLAD_API_CALL int GLAD_GL_ARB_imaging;
#define GL_ARB_indirect_parameters 1
    GLAD_API_CALL int GLAD_GL_ARB_indirect_parameters;
#define GL_ARB_instanced_arrays 1
    GLAD_API_CALL int GLAD_GL_ARB_instanced_arrays;
#define GL_ARB_internalformat_query 1
    GLAD_API_CALL int GLAD_GL_ARB_internalformat_query;
#define GL_ARB_internalformat_query2 1
    GLAD_API_CALL int GLAD_GL_ARB_internalformat_query2;
#define GL_ARB_invalidate_subdata 1
    GLAD_API_CALL int GLAD_GL_ARB_invalidate_subdata;
#define GL_ARB_map_buffer_alignment 1
    GLAD_API_CALL int GLAD_GL_ARB_map_buffer_alignment;
#define GL_ARB_map_buffer_range 1
    GLAD_API_CALL int GLAD_GL_ARB_map_buffer_range;
#define GL_ARB_matrix_palette 1
    GLAD_API_CALL int GLAD_GL_ARB_matrix_palette;
#define GL_ARB_multi_bind 1
    GLAD_API_CALL int GLAD_GL_ARB_multi_bind;
#define GL_ARB_multi_draw_indirect 1
    GLAD_API_CALL int GLAD_GL_ARB_multi_draw_indirect;
#define GL_ARB_multisample 1
    GLAD_API_CALL int GLAD_GL_ARB_multisample;
#define GL_ARB_multitexture 1
    GLAD_API_CALL int GLAD_GL_ARB_multitexture;
#define GL_ARB_occlusion_query 1
    GLAD_API_CALL int GLAD_GL_ARB_occlusion_query;
#define GL_ARB_occlusion_query2 1
    GLAD_API_CALL int GLAD_GL_ARB_occlusion_query2;
#define GL_ARB_parallel_shader_compile 1
    GLAD_API_CALL int GLAD_GL_ARB_parallel_shader_compile;
#define GL_ARB_pipeline_statistics_query 1
    GLAD_API_CALL int GLAD_GL_ARB_pipeline_statistics_query;
#define GL_ARB_pixel_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_pixel_buffer_object;
#define GL_ARB_point_parameters 1
    GLAD_API_CALL int GLAD_GL_ARB_point_parameters;
#define GL_ARB_point_sprite 1
    GLAD_API_CALL int GLAD_GL_ARB_point_sprite;
#define GL_ARB_polygon_offset_clamp 1
    GLAD_API_CALL int GLAD_GL_ARB_polygon_offset_clamp;
#define GL_ARB_post_depth_coverage 1
    GLAD_API_CALL int GLAD_GL_ARB_post_depth_coverage;
#define GL_ARB_program_interface_query 1
    GLAD_API_CALL int GLAD_GL_ARB_program_interface_query;
#define GL_ARB_provoking_vertex 1
    GLAD_API_CALL int GLAD_GL_ARB_provoking_vertex;
#define GL_ARB_query_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_query_buffer_object;
#define GL_ARB_robust_buffer_access_behavior 1
    GLAD_API_CALL int GLAD_GL_ARB_robust_buffer_access_behavior;
#define GL_ARB_robustness 1
    GLAD_API_CALL int GLAD_GL_ARB_robustness;
#define GL_ARB_robustness_isolation 1
    GLAD_API_CALL int GLAD_GL_ARB_robustness_isolation;
#define GL_ARB_sample_locations 1
    GLAD_API_CALL int GLAD_GL_ARB_sample_locations;
#define GL_ARB_sample_shading 1
    GLAD_API_CALL int GLAD_GL_ARB_sample_shading;
#define GL_ARB_sampler_objects 1
    GLAD_API_CALL int GLAD_GL_ARB_sampler_objects;
#define GL_ARB_seamless_cube_map 1
    GLAD_API_CALL int GLAD_GL_ARB_seamless_cube_map;
#define GL_ARB_seamless_cubemap_per_texture 1
    GLAD_API_CALL int GLAD_GL_ARB_seamless_cubemap_per_texture;
#define GL_ARB_separate_shader_objects 1
    GLAD_API_CALL int GLAD_GL_ARB_separate_shader_objects;
#define GL_ARB_shader_atomic_counter_ops 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_atomic_counter_ops;
#define GL_ARB_shader_atomic_counters 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_atomic_counters;
#define GL_ARB_shader_ballot 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_ballot;
#define GL_ARB_shader_bit_encoding 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_bit_encoding;
#define GL_ARB_shader_clock 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_clock;
#define GL_ARB_shader_draw_parameters 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_draw_parameters;
#define GL_ARB_shader_group_vote 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_group_vote;
#define GL_ARB_shader_image_load_store 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_image_load_store;
#define GL_ARB_shader_image_size 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_image_size;
#define GL_ARB_shader_objects 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_objects;
#define GL_ARB_shader_precision 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_precision;
#define GL_ARB_shader_stencil_export 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_stencil_export;
#define GL_ARB_shader_storage_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_storage_buffer_object;
#define GL_ARB_shader_subroutine 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_subroutine;
#define GL_ARB_shader_texture_image_samples 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_texture_image_samples;
#define GL_ARB_shader_texture_lod 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_texture_lod;
#define GL_ARB_shader_viewport_layer_array 1
    GLAD_API_CALL int GLAD_GL_ARB_shader_viewport_layer_array;
#define GL_ARB_shading_language_100 1
    GLAD_API_CALL int GLAD_GL_ARB_shading_language_100;
#define GL_ARB_shading_language_420pack 1
    GLAD_API_CALL int GLAD_GL_ARB_shading_language_420pack;
#define GL_ARB_shading_language_include 1
    GLAD_API_CALL int GLAD_GL_ARB_shading_language_include;
#define GL_ARB_shading_language_packing 1
    GLAD_API_CALL int GLAD_GL_ARB_shading_language_packing;
#define GL_ARB_shadow 1
    GLAD_API_CALL int GLAD_GL_ARB_shadow;
#define GL_ARB_shadow_ambient 1
    GLAD_API_CALL int GLAD_GL_ARB_shadow_ambient;
#define GL_ARB_sparse_buffer 1
    GLAD_API_CALL int GLAD_GL_ARB_sparse_buffer;
#define GL_ARB_sparse_texture 1
    GLAD_API_CALL int GLAD_GL_ARB_sparse_texture;
#define GL_ARB_sparse_texture2 1
    GLAD_API_CALL int GLAD_GL_ARB_sparse_texture2;
#define GL_ARB_sparse_texture_clamp 1
    GLAD_API_CALL int GLAD_GL_ARB_sparse_texture_clamp;
#define GL_ARB_spirv_extensions 1
    GLAD_API_CALL int GLAD_GL_ARB_spirv_extensions;
#define GL_ARB_stencil_texturing 1
    GLAD_API_CALL int GLAD_GL_ARB_stencil_texturing;
#define GL_ARB_sync 1
    GLAD_API_CALL int GLAD_GL_ARB_sync;
#define GL_ARB_tessellation_shader 1
    GLAD_API_CALL int GLAD_GL_ARB_tessellation_shader;
#define GL_ARB_texture_barrier 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_barrier;
#define GL_ARB_texture_border_clamp 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_border_clamp;
#define GL_ARB_texture_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_object;
#define GL_ARB_texture_buffer_object_rgb32 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_object_rgb32;
#define GL_ARB_texture_buffer_range 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_range;
#define GL_ARB_texture_compression 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_compression;
#define GL_ARB_texture_compression_bptc 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_compression_bptc;
#define GL_ARB_texture_compression_rgtc 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_compression_rgtc;
#define GL_ARB_texture_cube_map 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_cube_map;
#define GL_ARB_texture_cube_map_array 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_cube_map_array;
#define GL_ARB_texture_env_add 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_env_add;
#define GL_ARB_texture_env_combine 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_env_combine;
#define GL_ARB_texture_env_crossbar 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_env_crossbar;
#define GL_ARB_texture_env_dot3 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_env_dot3;
#define GL_ARB_texture_filter_anisotropic 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_filter_anisotropic;
#define GL_ARB_texture_filter_minmax 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_filter_minmax;
#define GL_ARB_texture_float 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_float;
#define GL_ARB_texture_gather 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_gather;
#define GL_ARB_texture_mirror_clamp_to_edge 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_mirror_clamp_to_edge;
#define GL_ARB_texture_mirrored_repeat 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_mirrored_repeat;
#define GL_ARB_texture_multisample 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_multisample;
#define GL_ARB_texture_non_power_of_two 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_non_power_of_two;
#define GL_ARB_texture_query_levels 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_query_levels;
#define GL_ARB_texture_query_lod 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_query_lod;
#define GL_ARB_texture_rectangle 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_rectangle;
#define GL_ARB_texture_rg 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_rg;
#define GL_ARB_texture_rgb10_a2ui 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_rgb10_a2ui;
#define GL_ARB_texture_stencil8 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_stencil8;
#define GL_ARB_texture_storage 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_storage;
#define GL_ARB_texture_storage_multisample 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_storage_multisample;
#define GL_ARB_texture_swizzle 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_swizzle;
#define GL_ARB_texture_view 1
    GLAD_API_CALL int GLAD_GL_ARB_texture_view;
#define GL_ARB_timer_query 1
    GLAD_API_CALL int GLAD_GL_ARB_timer_query;
#define GL_ARB_transform_feedback2 1
    GLAD_API_CALL int GLAD_GL_ARB_transform_feedback2;
#define GL_ARB_transform_feedback3 1
    GLAD_API_CALL int GLAD_GL_ARB_transform_feedback3;
#define GL_ARB_transform_feedback_instanced 1
    GLAD_API_CALL int GLAD_GL_ARB_transform_feedback_instanced;
#define GL_ARB_transform_feedback_overflow_query 1
    GLAD_API_CALL int GLAD_GL_ARB_transform_feedback_overflow_query;
#define GL_ARB_transpose_matrix 1
    GLAD_API_CALL int GLAD_GL_ARB_transpose_matrix;
#define GL_ARB_uniform_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_uniform_buffer_object;
#define GL_ARB_vertex_array_bgra 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_array_bgra;
#define GL_ARB_vertex_array_object 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_array_object;
#define GL_ARB_vertex_attrib_64bit 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_attrib_64bit;
#define GL_ARB_vertex_attrib_binding 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_attrib_binding;
#define GL_ARB_vertex_blend 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_blend;
#define GL_ARB_vertex_buffer_object 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_buffer_object;
#define GL_ARB_vertex_program 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_program;
#define GL_ARB_vertex_shader 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_shader;
#define GL_ARB_vertex_type_10f_11f_11f_rev 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_type_10f_11f_11f_rev;
#define GL_ARB_vertex_type_2_10_10_10_rev 1
    GLAD_API_CALL int GLAD_GL_ARB_vertex_type_2_10_10_10_rev;
#define GL_ARB_viewport_array 1
    GLAD_API_CALL int GLAD_GL_ARB_viewport_array;
#define GL_ARB_window_pos 1
    GLAD_API_CALL int GLAD_GL_ARB_window_pos;
#define GL_ATI_draw_buffers 1
    GLAD_API_CALL int GLAD_GL_ATI_draw_buffers;
#define GL_ATI_element_array 1
    GLAD_API_CALL int GLAD_GL_ATI_element_array;
#define GL_ATI_envmap_bumpmap 1
    GLAD_API_CALL int GLAD_GL_ATI_envmap_bumpmap;
#define GL_ATI_fragment_shader 1
    GLAD_API_CALL int GLAD_GL_ATI_fragment_shader;
#define GL_ATI_map_object_buffer 1
    GLAD_API_CALL int GLAD_GL_ATI_map_object_buffer;
#define GL_ATI_meminfo 1
    GLAD_API_CALL int GLAD_GL_ATI_meminfo;
#define GL_ATI_pixel_format_float 1
    GLAD_API_CALL int GLAD_GL_ATI_pixel_format_float;
#define GL_ATI_pn_triangles 1
    GLAD_API_CALL int GLAD_GL_ATI_pn_triangles;
#define GL_ATI_separate_stencil 1
    GLAD_API_CALL int GLAD_GL_ATI_separate_stencil;
#define GL_ATI_text_fragment_shader 1
    GLAD_API_CALL int GLAD_GL_ATI_text_fragment_shader;
#define GL_ATI_texture_env_combine3 1
    GLAD_API_CALL int GLAD_GL_ATI_texture_env_combine3;
#define GL_ATI_texture_float 1
    GLAD_API_CALL int GLAD_GL_ATI_texture_float;
#define GL_ATI_texture_mirror_once 1
    GLAD_API_CALL int GLAD_GL_ATI_texture_mirror_once;
#define GL_ATI_vertex_array_object 1
    GLAD_API_CALL int GLAD_GL_ATI_vertex_array_object;
#define GL_ATI_vertex_attrib_array_object 1
    GLAD_API_CALL int GLAD_GL_ATI_vertex_attrib_array_object;
#define GL_ATI_vertex_streams 1
    GLAD_API_CALL int GLAD_GL_ATI_vertex_streams;
#define GL_EXT_422_pixels 1
    GLAD_API_CALL int GLAD_GL_EXT_422_pixels;
#define GL_EXT_EGL_image_storage 1
    GLAD_API_CALL int GLAD_GL_EXT_EGL_image_storage;
#define GL_EXT_EGL_sync 1
    GLAD_API_CALL int GLAD_GL_EXT_EGL_sync;
#define GL_EXT_abgr 1
    GLAD_API_CALL int GLAD_GL_EXT_abgr;
#define GL_EXT_bgra 1
    GLAD_API_CALL int GLAD_GL_EXT_bgra;
#define GL_EXT_bindable_uniform 1
    GLAD_API_CALL int GLAD_GL_EXT_bindable_uniform;
#define GL_EXT_blend_color 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_color;
#define GL_EXT_blend_equation_separate 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_equation_separate;
#define GL_EXT_blend_func_separate 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_func_separate;
#define GL_EXT_blend_logic_op 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_logic_op;
#define GL_EXT_blend_minmax 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_minmax;
#define GL_EXT_blend_subtract 1
    GLAD_API_CALL int GLAD_GL_EXT_blend_subtract;
#define GL_EXT_clip_volume_hint 1
    GLAD_API_CALL int GLAD_GL_EXT_clip_volume_hint;
#define GL_EXT_cmyka 1
    GLAD_API_CALL int GLAD_GL_EXT_cmyka;
#define GL_EXT_color_subtable 1
    GLAD_API_CALL int GLAD_GL_EXT_color_subtable;
#define GL_EXT_compiled_vertex_array 1
    GLAD_API_CALL int GLAD_GL_EXT_compiled_vertex_array;
#define GL_EXT_convolution 1
    GLAD_API_CALL int GLAD_GL_EXT_convolution;
#define GL_EXT_coordinate_frame 1
    GLAD_API_CALL int GLAD_GL_EXT_coordinate_frame;
#define GL_EXT_copy_texture 1
    GLAD_API_CALL int GLAD_GL_EXT_copy_texture;
#define GL_EXT_cull_vertex 1
    GLAD_API_CALL int GLAD_GL_EXT_cull_vertex;
#define GL_EXT_debug_label 1
    GLAD_API_CALL int GLAD_GL_EXT_debug_label;
#define GL_EXT_debug_marker 1
    GLAD_API_CALL int GLAD_GL_EXT_debug_marker;
#define GL_EXT_depth_bounds_test 1
    GLAD_API_CALL int GLAD_GL_EXT_depth_bounds_test;
#define GL_EXT_direct_state_access 1
    GLAD_API_CALL int GLAD_GL_EXT_direct_state_access;
#define GL_EXT_draw_buffers2 1
    GLAD_API_CALL int GLAD_GL_EXT_draw_buffers2;
#define GL_EXT_draw_instanced 1
    GLAD_API_CALL int GLAD_GL_EXT_draw_instanced;
#define GL_EXT_draw_range_elements 1
    GLAD_API_CALL int GLAD_GL_EXT_draw_range_elements;
#define GL_EXT_external_buffer 1
    GLAD_API_CALL int GLAD_GL_EXT_external_buffer;
#define GL_EXT_fog_coord 1
    GLAD_API_CALL int GLAD_GL_EXT_fog_coord;
#define GL_EXT_framebuffer_blit 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_blit;
#define GL_EXT_framebuffer_blit_layers 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_blit_layers;
#define GL_EXT_framebuffer_multisample 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_multisample;
#define GL_EXT_framebuffer_multisample_blit_scaled 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_multisample_blit_scaled;
#define GL_EXT_framebuffer_object 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_object;
#define GL_EXT_framebuffer_sRGB 1
    GLAD_API_CALL int GLAD_GL_EXT_framebuffer_sRGB;
#define GL_EXT_geometry_shader4 1
    GLAD_API_CALL int GLAD_GL_EXT_geometry_shader4;
#define GL_EXT_gpu_program_parameters 1
    GLAD_API_CALL int GLAD_GL_EXT_gpu_program_parameters;
#define GL_EXT_gpu_shader4 1
    GLAD_API_CALL int GLAD_GL_EXT_gpu_shader4;
#define GL_EXT_histogram 1
    GLAD_API_CALL int GLAD_GL_EXT_histogram;
#define GL_EXT_index_array_formats 1
    GLAD_API_CALL int GLAD_GL_EXT_index_array_formats;
#define GL_EXT_index_func 1
    GLAD_API_CALL int GLAD_GL_EXT_index_func;
#define GL_EXT_index_material 1
    GLAD_API_CALL int GLAD_GL_EXT_index_material;
#define GL_EXT_index_texture 1
    GLAD_API_CALL int GLAD_GL_EXT_index_texture;
#define GL_EXT_light_texture 1
    GLAD_API_CALL int GLAD_GL_EXT_light_texture;
#define GL_EXT_memory_object 1
    GLAD_API_CALL int GLAD_GL_EXT_memory_object;
#define GL_EXT_memory_object_fd 1
    GLAD_API_CALL int GLAD_GL_EXT_memory_object_fd;
#define GL_EXT_memory_object_win32 1
    GLAD_API_CALL int GLAD_GL_EXT_memory_object_win32;
#define GL_EXT_misc_attribute 1
    GLAD_API_CALL int GLAD_GL_EXT_misc_attribute;
#define GL_EXT_multi_draw_arrays 1
    GLAD_API_CALL int GLAD_GL_EXT_multi_draw_arrays;
#define GL_EXT_multisample 1
    GLAD_API_CALL int GLAD_GL_EXT_multisample;
#define GL_EXT_multiview_tessellation_geometry_shader 1
    GLAD_API_CALL int GLAD_GL_EXT_multiview_tessellation_geometry_shader;
#define GL_EXT_multiview_texture_multisample 1
    GLAD_API_CALL int GLAD_GL_EXT_multiview_texture_multisample;
#define GL_EXT_multiview_timer_query 1
    GLAD_API_CALL int GLAD_GL_EXT_multiview_timer_query;
#define GL_EXT_packed_depth_stencil 1
    GLAD_API_CALL int GLAD_GL_EXT_packed_depth_stencil;
#define GL_EXT_packed_float 1
    GLAD_API_CALL int GLAD_GL_EXT_packed_float;
#define GL_EXT_packed_pixels 1
    GLAD_API_CALL int GLAD_GL_EXT_packed_pixels;
#define GL_EXT_paletted_texture 1
    GLAD_API_CALL int GLAD_GL_EXT_paletted_texture;
#define GL_EXT_pixel_buffer_object 1
    GLAD_API_CALL int GLAD_GL_EXT_pixel_buffer_object;
#define GL_EXT_pixel_transform 1
    GLAD_API_CALL int GLAD_GL_EXT_pixel_transform;
#define GL_EXT_pixel_transform_color_table 1
    GLAD_API_CALL int GLAD_GL_EXT_pixel_transform_color_table;
#define GL_EXT_point_parameters 1
    GLAD_API_CALL int GLAD_GL_EXT_point_parameters;
#define GL_EXT_polygon_offset 1
    GLAD_API_CALL int GLAD_GL_EXT_polygon_offset;
#define GL_EXT_polygon_offset_clamp 1
    GLAD_API_CALL int GLAD_GL_EXT_polygon_offset_clamp;
#define GL_EXT_post_depth_coverage 1
    GLAD_API_CALL int GLAD_GL_EXT_post_depth_coverage;
#define GL_EXT_provoking_vertex 1
    GLAD_API_CALL int GLAD_GL_EXT_provoking_vertex;
#define GL_EXT_raster_multisample 1
    GLAD_API_CALL int GLAD_GL_EXT_raster_multisample;
#define GL_EXT_rescale_normal 1
    GLAD_API_CALL int GLAD_GL_EXT_rescale_normal;
#define GL_EXT_secondary_color 1
    GLAD_API_CALL int GLAD_GL_EXT_secondary_color;
#define GL_EXT_semaphore 1
    GLAD_API_CALL int GLAD_GL_EXT_semaphore;
#define GL_EXT_semaphore_fd 1
    GLAD_API_CALL int GLAD_GL_EXT_semaphore_fd;
#define GL_EXT_semaphore_win32 1
    GLAD_API_CALL int GLAD_GL_EXT_semaphore_win32;
#define GL_EXT_separate_shader_objects 1
    GLAD_API_CALL int GLAD_GL_EXT_separate_shader_objects;
#define GL_EXT_separate_specular_color 1
    GLAD_API_CALL int GLAD_GL_EXT_separate_specular_color;
#define GL_EXT_shader_framebuffer_fetch 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_framebuffer_fetch;
#define GL_EXT_shader_framebuffer_fetch_non_coherent 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent;
#define GL_EXT_shader_image_load_formatted 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_image_load_formatted;
#define GL_EXT_shader_image_load_store 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_image_load_store;
#define GL_EXT_shader_integer_mix 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_integer_mix;
#define GL_EXT_shader_samples_identical 1
    GLAD_API_CALL int GLAD_GL_EXT_shader_samples_identical;
#define GL_EXT_shadow_funcs 1
    GLAD_API_CALL int GLAD_GL_EXT_shadow_funcs;
#define GL_EXT_shared_texture_palette 1
    GLAD_API_CALL int GLAD_GL_EXT_shared_texture_palette;
#define GL_EXT_sparse_texture2 1
    GLAD_API_CALL int GLAD_GL_EXT_sparse_texture2;
#define GL_EXT_stencil_clear_tag 1
    GLAD_API_CALL int GLAD_GL_EXT_stencil_clear_tag;
#define GL_EXT_stencil_two_side 1
    GLAD_API_CALL int GLAD_GL_EXT_stencil_two_side;
#define GL_EXT_stencil_wrap 1
    GLAD_API_CALL int GLAD_GL_EXT_stencil_wrap;
#define GL_EXT_subtexture 1
    GLAD_API_CALL int GLAD_GL_EXT_subtexture;
#define GL_EXT_texture 1
    GLAD_API_CALL int GLAD_GL_EXT_texture;
#define GL_EXT_texture3D 1
    GLAD_API_CALL int GLAD_GL_EXT_texture3D;
#define GL_EXT_texture_array 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_array;
#define GL_EXT_texture_buffer_object 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_buffer_object;
#define GL_EXT_texture_compression_latc 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_compression_latc;
#define GL_EXT_texture_compression_rgtc 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_compression_rgtc;
#define GL_EXT_texture_compression_s3tc 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_compression_s3tc;
#define GL_EXT_texture_cube_map 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_cube_map;
#define GL_EXT_texture_env_add 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_env_add;
#define GL_EXT_texture_env_combine 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_env_combine;
#define GL_EXT_texture_env_dot3 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_env_dot3;
#define GL_EXT_texture_filter_anisotropic 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_filter_anisotropic;
#define GL_EXT_texture_filter_minmax 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_filter_minmax;
#define GL_EXT_texture_integer 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_integer;
#define GL_EXT_texture_lod_bias 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_lod_bias;
#define GL_EXT_texture_mirror_clamp 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_mirror_clamp;
#define GL_EXT_texture_object 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_object;
#define GL_EXT_texture_perturb_normal 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_perturb_normal;
#define GL_EXT_texture_sRGB 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB;
#define GL_EXT_texture_sRGB_R8 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB_R8;
#define GL_EXT_texture_sRGB_RG8 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB_RG8;
#define GL_EXT_texture_sRGB_decode 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB_decode;
#define GL_EXT_texture_shadow_lod 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_shadow_lod;
#define GL_EXT_texture_shared_exponent 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_shared_exponent;
#define GL_EXT_texture_snorm 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_snorm;
#define GL_EXT_texture_storage 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_storage;
#define GL_EXT_texture_swizzle 1
    GLAD_API_CALL int GLAD_GL_EXT_texture_swizzle;
#define GL_EXT_timer_query 1
    GLAD_API_CALL int GLAD_GL_EXT_timer_query;
#define GL_EXT_transform_feedback 1
    GLAD_API_CALL int GLAD_GL_EXT_transform_feedback;
#define GL_EXT_vertex_array 1
    GLAD_API_CALL int GLAD_GL_EXT_vertex_array;
#define GL_EXT_vertex_array_bgra 1
    GLAD_API_CALL int GLAD_GL_EXT_vertex_array_bgra;
#define GL_EXT_vertex_attrib_64bit 1
    GLAD_API_CALL int GLAD_GL_EXT_vertex_attrib_64bit;
#define GL_EXT_vertex_shader 1
    GLAD_API_CALL int GLAD_GL_EXT_vertex_shader;
#define GL_EXT_vertex_weighting 1
    GLAD_API_CALL int GLAD_GL_EXT_vertex_weighting;
#define GL_EXT_win32_keyed_mutex 1
    GLAD_API_CALL int GLAD_GL_EXT_win32_keyed_mutex;
#define GL_EXT_window_rectangles 1
    GLAD_API_CALL int GLAD_GL_EXT_window_rectangles;
#define GL_EXT_x11_sync_object 1
    GLAD_API_CALL int GLAD_GL_EXT_x11_sync_object;
#define GL_GREMEDY_frame_terminator 1
    GLAD_API_CALL int GLAD_GL_GREMEDY_frame_terminator;
#define GL_GREMEDY_string_marker 1
    GLAD_API_CALL int GLAD_GL_GREMEDY_string_marker;
#define GL_HP_convolution_border_modes 1
    GLAD_API_CALL int GLAD_GL_HP_convolution_border_modes;
#define GL_HP_image_transform 1
    GLAD_API_CALL int GLAD_GL_HP_image_transform;
#define GL_HP_occlusion_test 1
    GLAD_API_CALL int GLAD_GL_HP_occlusion_test;
#define GL_HP_texture_lighting 1
    GLAD_API_CALL int GLAD_GL_HP_texture_lighting;
#define GL_IBM_cull_vertex 1
    GLAD_API_CALL int GLAD_GL_IBM_cull_vertex;
#define GL_IBM_multimode_draw_arrays 1
    GLAD_API_CALL int GLAD_GL_IBM_multimode_draw_arrays;
#define GL_IBM_rasterpos_clip 1
    GLAD_API_CALL int GLAD_GL_IBM_rasterpos_clip;
#define GL_IBM_static_data 1
    GLAD_API_CALL int GLAD_GL_IBM_static_data;
#define GL_IBM_texture_mirrored_repeat 1
    GLAD_API_CALL int GLAD_GL_IBM_texture_mirrored_repeat;
#define GL_IBM_vertex_array_lists 1
    GLAD_API_CALL int GLAD_GL_IBM_vertex_array_lists;
#define GL_INGR_blend_func_separate 1
    GLAD_API_CALL int GLAD_GL_INGR_blend_func_separate;
#define GL_INGR_color_clamp 1
    GLAD_API_CALL int GLAD_GL_INGR_color_clamp;
#define GL_INGR_interlace_read 1
    GLAD_API_CALL int GLAD_GL_INGR_interlace_read;
#define GL_INTEL_blackhole_render 1
    GLAD_API_CALL int GLAD_GL_INTEL_blackhole_render;
#define GL_INTEL_conservative_rasterization 1
    GLAD_API_CALL int GLAD_GL_INTEL_conservative_rasterization;
#define GL_INTEL_fragment_shader_ordering 1
    GLAD_API_CALL int GLAD_GL_INTEL_fragment_shader_ordering;
#define GL_INTEL_framebuffer_CMAA 1
    GLAD_API_CALL int GLAD_GL_INTEL_framebuffer_CMAA;
#define GL_INTEL_map_texture 1
    GLAD_API_CALL int GLAD_GL_INTEL_map_texture;
#define GL_INTEL_parallel_arrays 1
    GLAD_API_CALL int GLAD_GL_INTEL_parallel_arrays;
#define GL_INTEL_performance_query 1
    GLAD_API_CALL int GLAD_GL_INTEL_performance_query;
#define GL_KHR_blend_equation_advanced 1
    GLAD_API_CALL int GLAD_GL_KHR_blend_equation_advanced;
#define GL_KHR_blend_equation_advanced_coherent 1
    GLAD_API_CALL int GLAD_GL_KHR_blend_equation_advanced_coherent;
#define GL_KHR_context_flush_control 1
    GLAD_API_CALL int GLAD_GL_KHR_context_flush_control;
#define GL_KHR_debug 1
    GLAD_API_CALL int GLAD_GL_KHR_debug;
#define GL_KHR_no_error 1
    GLAD_API_CALL int GLAD_GL_KHR_no_error;
#define GL_KHR_parallel_shader_compile 1
    GLAD_API_CALL int GLAD_GL_KHR_parallel_shader_compile;
#define GL_KHR_robust_buffer_access_behavior 1
    GLAD_API_CALL int GLAD_GL_KHR_robust_buffer_access_behavior;
#define GL_KHR_robustness 1
    GLAD_API_CALL int GLAD_GL_KHR_robustness;
#define GL_KHR_shader_subgroup 1
    GLAD_API_CALL int GLAD_GL_KHR_shader_subgroup;
#define GL_KHR_texture_compression_astc_hdr 1
    GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_hdr;
#define GL_KHR_texture_compression_astc_ldr 1
    GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_ldr;
#define GL_KHR_texture_compression_astc_sliced_3d 1
    GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_sliced_3d;
#define GL_MESAX_texture_stack 1
    GLAD_API_CALL int GLAD_GL_MESAX_texture_stack;
#define GL_MESA_framebuffer_flip_x 1
    GLAD_API_CALL int GLAD_GL_MESA_framebuffer_flip_x;
#define GL_MESA_framebuffer_flip_y 1
    GLAD_API_CALL int GLAD_GL_MESA_framebuffer_flip_y;
#define GL_MESA_framebuffer_swap_xy 1
    GLAD_API_CALL int GLAD_GL_MESA_framebuffer_swap_xy;
#define GL_MESA_pack_invert 1
    GLAD_API_CALL int GLAD_GL_MESA_pack_invert;
#define GL_MESA_program_binary_formats 1
    GLAD_API_CALL int GLAD_GL_MESA_program_binary_formats;
#define GL_MESA_resize_buffers 1
    GLAD_API_CALL int GLAD_GL_MESA_resize_buffers;
#define GL_MESA_shader_integer_functions 1
    GLAD_API_CALL int GLAD_GL_MESA_shader_integer_functions;
#define GL_MESA_tile_raster_order 1
    GLAD_API_CALL int GLAD_GL_MESA_tile_raster_order;
#define GL_MESA_window_pos 1
    GLAD_API_CALL int GLAD_GL_MESA_window_pos;
#define GL_MESA_ycbcr_texture 1
    GLAD_API_CALL int GLAD_GL_MESA_ycbcr_texture;
#define GL_NVX_blend_equation_advanced_multi_draw_buffers 1
    GLAD_API_CALL int GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers;
#define GL_NVX_conditional_render 1
    GLAD_API_CALL int GLAD_GL_NVX_conditional_render;
#define GL_NVX_gpu_memory_info 1
    GLAD_API_CALL int GLAD_GL_NVX_gpu_memory_info;
#define GL_NVX_gpu_multicast2 1
    GLAD_API_CALL int GLAD_GL_NVX_gpu_multicast2;
#define GL_NVX_linked_gpu_multicast 1
    GLAD_API_CALL int GLAD_GL_NVX_linked_gpu_multicast;
#define GL_NVX_progress_fence 1
    GLAD_API_CALL int GLAD_GL_NVX_progress_fence;
#define GL_NV_alpha_to_coverage_dither_control 1
    GLAD_API_CALL int GLAD_GL_NV_alpha_to_coverage_dither_control;
#define GL_NV_bindless_multi_draw_indirect 1
    GLAD_API_CALL int GLAD_GL_NV_bindless_multi_draw_indirect;
#define GL_NV_bindless_multi_draw_indirect_count 1
    GLAD_API_CALL int GLAD_GL_NV_bindless_multi_draw_indirect_count;
#define GL_NV_bindless_texture 1
    GLAD_API_CALL int GLAD_GL_NV_bindless_texture;
#define GL_NV_blend_equation_advanced 1
    GLAD_API_CALL int GLAD_GL_NV_blend_equation_advanced;
#define GL_NV_blend_equation_advanced_coherent 1
    GLAD_API_CALL int GLAD_GL_NV_blend_equation_advanced_coherent;
#define GL_NV_blend_minmax_factor 1
    GLAD_API_CALL int GLAD_GL_NV_blend_minmax_factor;
#define GL_NV_blend_square 1
    GLAD_API_CALL int GLAD_GL_NV_blend_square;
#define GL_NV_clip_space_w_scaling 1
    GLAD_API_CALL int GLAD_GL_NV_clip_space_w_scaling;
#define GL_NV_command_list 1
    GLAD_API_CALL int GLAD_GL_NV_command_list;
#define GL_NV_compute_program5 1
    GLAD_API_CALL int GLAD_GL_NV_compute_program5;
#define GL_NV_compute_shader_derivatives 1
    GLAD_API_CALL int GLAD_GL_NV_compute_shader_derivatives;
#define GL_NV_conditional_render 1
    GLAD_API_CALL int GLAD_GL_NV_conditional_render;
#define GL_NV_conservative_raster 1
    GLAD_API_CALL int GLAD_GL_NV_conservative_raster;
#define GL_NV_conservative_raster_dilate 1
    GLAD_API_CALL int GLAD_GL_NV_conservative_raster_dilate;
#define GL_NV_conservative_raster_pre_snap 1
    GLAD_API_CALL int GLAD_GL_NV_conservative_raster_pre_snap;
#define GL_NV_conservative_raster_pre_snap_triangles 1
    GLAD_API_CALL int GLAD_GL_NV_conservative_raster_pre_snap_triangles;
#define GL_NV_conservative_raster_underestimation 1
    GLAD_API_CALL int GLAD_GL_NV_conservative_raster_underestimation;
#define GL_NV_copy_depth_to_color 1
    GLAD_API_CALL int GLAD_GL_NV_copy_depth_to_color;
#define GL_NV_copy_image 1
    GLAD_API_CALL int GLAD_GL_NV_copy_image;
#define GL_NV_deep_texture3D 1
    GLAD_API_CALL int GLAD_GL_NV_deep_texture3D;
#define GL_NV_depth_buffer_float 1
    GLAD_API_CALL int GLAD_GL_NV_depth_buffer_float;
#define GL_NV_depth_clamp 1
    GLAD_API_CALL int GLAD_GL_NV_depth_clamp;
#define GL_NV_draw_texture 1
    GLAD_API_CALL int GLAD_GL_NV_draw_texture;
#define GL_NV_draw_vulkan_image 1
    GLAD_API_CALL int GLAD_GL_NV_draw_vulkan_image;
#define GL_NV_evaluators 1
    GLAD_API_CALL int GLAD_GL_NV_evaluators;
#define GL_NV_explicit_multisample 1
    GLAD_API_CALL int GLAD_GL_NV_explicit_multisample;
#define GL_NV_fence 1
    GLAD_API_CALL int GLAD_GL_NV_fence;
#define GL_NV_fill_rectangle 1
    GLAD_API_CALL int GLAD_GL_NV_fill_rectangle;
#define GL_NV_float_buffer 1
    GLAD_API_CALL int GLAD_GL_NV_float_buffer;
#define GL_NV_fog_distance 1
    GLAD_API_CALL int GLAD_GL_NV_fog_distance;
#define GL_NV_fragment_coverage_to_color 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_coverage_to_color;
#define GL_NV_fragment_program 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_program;
#define GL_NV_fragment_program2 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_program2;
#define GL_NV_fragment_program4 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_program4;
#define GL_NV_fragment_program_option 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_program_option;
#define GL_NV_fragment_shader_barycentric 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_shader_barycentric;
#define GL_NV_fragment_shader_interlock 1
    GLAD_API_CALL int GLAD_GL_NV_fragment_shader_interlock;
#define GL_NV_framebuffer_mixed_samples 1
    GLAD_API_CALL int GLAD_GL_NV_framebuffer_mixed_samples;
#define GL_NV_framebuffer_multisample_coverage 1
    GLAD_API_CALL int GLAD_GL_NV_framebuffer_multisample_coverage;
#define GL_NV_geometry_program4 1
    GLAD_API_CALL int GLAD_GL_NV_geometry_program4;
#define GL_NV_geometry_shader4 1
    GLAD_API_CALL int GLAD_GL_NV_geometry_shader4;
#define GL_NV_geometry_shader_passthrough 1
    GLAD_API_CALL int GLAD_GL_NV_geometry_shader_passthrough;
#define GL_NV_gpu_multicast 1
    GLAD_API_CALL int GLAD_GL_NV_gpu_multicast;
#define GL_NV_gpu_program4 1
    GLAD_API_CALL int GLAD_GL_NV_gpu_program4;
#define GL_NV_gpu_program5 1
    GLAD_API_CALL int GLAD_GL_NV_gpu_program5;
#define GL_NV_gpu_program5_mem_extended 1
    GLAD_API_CALL int GLAD_GL_NV_gpu_program5_mem_extended;
#define GL_NV_gpu_shader5 1
    GLAD_API_CALL int GLAD_GL_NV_gpu_shader5;
#define GL_NV_half_float 1
    GLAD_API_CALL int GLAD_GL_NV_half_float;
#define GL_NV_internalformat_sample_query 1
    GLAD_API_CALL int GLAD_GL_NV_internalformat_sample_query;
#define GL_NV_light_max_exponent 1
    GLAD_API_CALL int GLAD_GL_NV_light_max_exponent;
#define GL_NV_memory_attachment 1
    GLAD_API_CALL int GLAD_GL_NV_memory_attachment;
#define GL_NV_memory_object_sparse 1
    GLAD_API_CALL int GLAD_GL_NV_memory_object_sparse;
#define GL_NV_mesh_shader 1
    GLAD_API_CALL int GLAD_GL_NV_mesh_shader;
#define GL_NV_multisample_coverage 1
    GLAD_API_CALL int GLAD_GL_NV_multisample_coverage;
#define GL_NV_multisample_filter_hint 1
    GLAD_API_CALL int GLAD_GL_NV_multisample_filter_hint;
#define GL_NV_occlusion_query 1
    GLAD_API_CALL int GLAD_GL_NV_occlusion_query;
#define GL_NV_packed_depth_stencil 1
    GLAD_API_CALL int GLAD_GL_NV_packed_depth_stencil;
#define GL_NV_parameter_buffer_object 1
    GLAD_API_CALL int GLAD_GL_NV_parameter_buffer_object;
#define GL_NV_parameter_buffer_object2 1
    GLAD_API_CALL int GLAD_GL_NV_parameter_buffer_object2;
#define GL_NV_path_rendering 1
    GLAD_API_CALL int GLAD_GL_NV_path_rendering;
#define GL_NV_path_rendering_shared_edge 1
    GLAD_API_CALL int GLAD_GL_NV_path_rendering_shared_edge;
#define GL_NV_pixel_data_range 1
    GLAD_API_CALL int GLAD_GL_NV_pixel_data_range;
#define GL_NV_point_sprite 1
    GLAD_API_CALL int GLAD_GL_NV_point_sprite;
#define GL_NV_present_video 1
    GLAD_API_CALL int GLAD_GL_NV_present_video;
#define GL_NV_primitive_restart 1
    GLAD_API_CALL int GLAD_GL_NV_primitive_restart;
#define GL_NV_primitive_shading_rate 1
    GLAD_API_CALL int GLAD_GL_NV_primitive_shading_rate;
#define GL_NV_query_resource 1
    GLAD_API_CALL int GLAD_GL_NV_query_resource;
#define GL_NV_query_resource_tag 1
    GLAD_API_CALL int GLAD_GL_NV_query_resource_tag;
#define GL_NV_register_combiners 1
    GLAD_API_CALL int GLAD_GL_NV_register_combiners;
#define GL_NV_register_combiners2 1
    GLAD_API_CALL int GLAD_GL_NV_register_combiners2;
#define GL_NV_representative_fragment_test 1
    GLAD_API_CALL int GLAD_GL_NV_representative_fragment_test;
#define GL_NV_robustness_video_memory_purge 1
    GLAD_API_CALL int GLAD_GL_NV_robustness_video_memory_purge;
#define GL_NV_sample_locations 1
    GLAD_API_CALL int GLAD_GL_NV_sample_locations;
#define GL_NV_sample_mask_override_coverage 1
    GLAD_API_CALL int GLAD_GL_NV_sample_mask_override_coverage;
#define GL_NV_scissor_exclusive 1
    GLAD_API_CALL int GLAD_GL_NV_scissor_exclusive;
#define GL_NV_shader_atomic_counters 1
    GLAD_API_CALL int GLAD_GL_NV_shader_atomic_counters;
#define GL_NV_shader_atomic_float 1
    GLAD_API_CALL int GLAD_GL_NV_shader_atomic_float;
#define GL_NV_shader_atomic_float64 1
    GLAD_API_CALL int GLAD_GL_NV_shader_atomic_float64;
#define GL_NV_shader_atomic_fp16_vector 1
    GLAD_API_CALL int GLAD_GL_NV_shader_atomic_fp16_vector;
#define GL_NV_shader_atomic_int64 1
    GLAD_API_CALL int GLAD_GL_NV_shader_atomic_int64;
#define GL_NV_shader_buffer_load 1
    GLAD_API_CALL int GLAD_GL_NV_shader_buffer_load;
#define GL_NV_shader_buffer_store 1
    GLAD_API_CALL int GLAD_GL_NV_shader_buffer_store;
#define GL_NV_shader_storage_buffer_object 1
    GLAD_API_CALL int GLAD_GL_NV_shader_storage_buffer_object;
#define GL_NV_shader_subgroup_partitioned 1
    GLAD_API_CALL int GLAD_GL_NV_shader_subgroup_partitioned;
#define GL_NV_shader_texture_footprint 1
    GLAD_API_CALL int GLAD_GL_NV_shader_texture_footprint;
#define GL_NV_shader_thread_group 1
    GLAD_API_CALL int GLAD_GL_NV_shader_thread_group;
#define GL_NV_shader_thread_shuffle 1
    GLAD_API_CALL int GLAD_GL_NV_shader_thread_shuffle;
#define GL_NV_shading_rate_image 1
    GLAD_API_CALL int GLAD_GL_NV_shading_rate_image;
#define GL_NV_stereo_view_rendering 1
    GLAD_API_CALL int GLAD_GL_NV_stereo_view_rendering;
#define GL_NV_tessellation_program5 1
    GLAD_API_CALL int GLAD_GL_NV_tessellation_program5;
#define GL_NV_texgen_emboss 1
    GLAD_API_CALL int GLAD_GL_NV_texgen_emboss;
#define GL_NV_texgen_reflection 1
    GLAD_API_CALL int GLAD_GL_NV_texgen_reflection;
#define GL_NV_texture_barrier 1
    GLAD_API_CALL int GLAD_GL_NV_texture_barrier;
#define GL_NV_texture_compression_vtc 1
    GLAD_API_CALL int GLAD_GL_NV_texture_compression_vtc;
#define GL_NV_texture_env_combine4 1
    GLAD_API_CALL int GLAD_GL_NV_texture_env_combine4;
#define GL_NV_texture_expand_normal 1
    GLAD_API_CALL int GLAD_GL_NV_texture_expand_normal;
#define GL_NV_texture_multisample 1
    GLAD_API_CALL int GLAD_GL_NV_texture_multisample;
#define GL_NV_texture_rectangle 1
    GLAD_API_CALL int GLAD_GL_NV_texture_rectangle;
#define GL_NV_texture_rectangle_compressed 1
    GLAD_API_CALL int GLAD_GL_NV_texture_rectangle_compressed;
#define GL_NV_texture_shader 1
    GLAD_API_CALL int GLAD_GL_NV_texture_shader;
#define GL_NV_texture_shader2 1
    GLAD_API_CALL int GLAD_GL_NV_texture_shader2;
#define GL_NV_texture_shader3 1
    GLAD_API_CALL int GLAD_GL_NV_texture_shader3;
#define GL_NV_timeline_semaphore 1
    GLAD_API_CALL int GLAD_GL_NV_timeline_semaphore;
#define GL_NV_transform_feedback 1
    GLAD_API_CALL int GLAD_GL_NV_transform_feedback;
#define GL_NV_transform_feedback2 1
    GLAD_API_CALL int GLAD_GL_NV_transform_feedback2;
#define GL_NV_uniform_buffer_std430_layout 1
    GLAD_API_CALL int GLAD_GL_NV_uniform_buffer_std430_layout;
#define GL_NV_uniform_buffer_unified_memory 1
    GLAD_API_CALL int GLAD_GL_NV_uniform_buffer_unified_memory;
#define GL_NV_vdpau_interop 1
    GLAD_API_CALL int GLAD_GL_NV_vdpau_interop;
#define GL_NV_vdpau_interop2 1
    GLAD_API_CALL int GLAD_GL_NV_vdpau_interop2;
#define GL_NV_vertex_array_range 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_array_range;
#define GL_NV_vertex_array_range2 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_array_range2;
#define GL_NV_vertex_attrib_integer_64bit 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_attrib_integer_64bit;
#define GL_NV_vertex_buffer_unified_memory 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_buffer_unified_memory;
#define GL_NV_vertex_program 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program;
#define GL_NV_vertex_program1_1 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program1_1;
#define GL_NV_vertex_program2 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program2;
#define GL_NV_vertex_program2_option 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program2_option;
#define GL_NV_vertex_program3 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program3;
#define GL_NV_vertex_program4 1
    GLAD_API_CALL int GLAD_GL_NV_vertex_program4;
#define GL_NV_video_capture 1
    GLAD_API_CALL int GLAD_GL_NV_video_capture;
#define GL_NV_viewport_array2 1
    GLAD_API_CALL int GLAD_GL_NV_viewport_array2;
#define GL_NV_viewport_swizzle 1
    GLAD_API_CALL int GLAD_GL_NV_viewport_swizzle;
#define GL_OES_byte_coordinates 1
    GLAD_API_CALL int GLAD_GL_OES_byte_coordinates;
#define GL_OES_compressed_paletted_texture 1
    GLAD_API_CALL int GLAD_GL_OES_compressed_paletted_texture;
#define GL_OES_fixed_point 1
    GLAD_API_CALL int GLAD_GL_OES_fixed_point;
#define GL_OES_query_matrix 1
    GLAD_API_CALL int GLAD_GL_OES_query_matrix;
#define GL_OES_read_format 1
    GLAD_API_CALL int GLAD_GL_OES_read_format;
#define GL_OES_single_precision 1
    GLAD_API_CALL int GLAD_GL_OES_single_precision;
#define GL_OML_interlace 1
    GLAD_API_CALL int GLAD_GL_OML_interlace;
#define GL_OML_resample 1
    GLAD_API_CALL int GLAD_GL_OML_resample;
#define GL_OML_subsample 1
    GLAD_API_CALL int GLAD_GL_OML_subsample;
#define GL_OVR_multiview 1
    GLAD_API_CALL int GLAD_GL_OVR_multiview;
#define GL_OVR_multiview2 1
    GLAD_API_CALL int GLAD_GL_OVR_multiview2;
#define GL_PGI_misc_hints 1
    GLAD_API_CALL int GLAD_GL_PGI_misc_hints;
#define GL_PGI_vertex_hints 1
    GLAD_API_CALL int GLAD_GL_PGI_vertex_hints;
#define GL_REND_screen_coordinates 1
    GLAD_API_CALL int GLAD_GL_REND_screen_coordinates;
#define GL_S3_s3tc 1
    GLAD_API_CALL int GLAD_GL_S3_s3tc;
#define GL_SGIS_detail_texture 1
    GLAD_API_CALL int GLAD_GL_SGIS_detail_texture;
#define GL_SGIS_fog_function 1
    GLAD_API_CALL int GLAD_GL_SGIS_fog_function;
#define GL_SGIS_generate_mipmap 1
    GLAD_API_CALL int GLAD_GL_SGIS_generate_mipmap;
#define GL_SGIS_multisample 1
    GLAD_API_CALL int GLAD_GL_SGIS_multisample;
#define GL_SGIS_pixel_texture 1
    GLAD_API_CALL int GLAD_GL_SGIS_pixel_texture;
#define GL_SGIS_point_line_texgen 1
    GLAD_API_CALL int GLAD_GL_SGIS_point_line_texgen;
#define GL_SGIS_point_parameters 1
    GLAD_API_CALL int GLAD_GL_SGIS_point_parameters;
#define GL_SGIS_sharpen_texture 1
    GLAD_API_CALL int GLAD_GL_SGIS_sharpen_texture;
#define GL_SGIS_texture4D 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture4D;
#define GL_SGIS_texture_border_clamp 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_border_clamp;
#define GL_SGIS_texture_color_mask 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_color_mask;
#define GL_SGIS_texture_edge_clamp 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_edge_clamp;
#define GL_SGIS_texture_filter4 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_filter4;
#define GL_SGIS_texture_lod 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_lod;
#define GL_SGIS_texture_select 1
    GLAD_API_CALL int GLAD_GL_SGIS_texture_select;
#define GL_SGIX_async 1
    GLAD_API_CALL int GLAD_GL_SGIX_async;
#define GL_SGIX_async_histogram 1
    GLAD_API_CALL int GLAD_GL_SGIX_async_histogram;
#define GL_SGIX_async_pixel 1
    GLAD_API_CALL int GLAD_GL_SGIX_async_pixel;
#define GL_SGIX_blend_alpha_minmax 1
    GLAD_API_CALL int GLAD_GL_SGIX_blend_alpha_minmax;
#define GL_SGIX_calligraphic_fragment 1
    GLAD_API_CALL int GLAD_GL_SGIX_calligraphic_fragment;
#define GL_SGIX_clipmap 1
    GLAD_API_CALL int GLAD_GL_SGIX_clipmap;
#define GL_SGIX_convolution_accuracy 1
    GLAD_API_CALL int GLAD_GL_SGIX_convolution_accuracy;
#define GL_SGIX_depth_pass_instrument 1
    GLAD_API_CALL int GLAD_GL_SGIX_depth_pass_instrument;
#define GL_SGIX_depth_texture 1
    GLAD_API_CALL int GLAD_GL_SGIX_depth_texture;
#define GL_SGIX_flush_raster 1
    GLAD_API_CALL int GLAD_GL_SGIX_flush_raster;
#define GL_SGIX_fog_offset 1
    GLAD_API_CALL int GLAD_GL_SGIX_fog_offset;
#define GL_SGIX_fragment_lighting 1
    GLAD_API_CALL int GLAD_GL_SGIX_fragment_lighting;
#define GL_SGIX_framezoom 1
    GLAD_API_CALL int GLAD_GL_SGIX_framezoom;
#define GL_SGIX_igloo_interface 1
    GLAD_API_CALL int GLAD_GL_SGIX_igloo_interface;
#define GL_SGIX_instruments 1
    GLAD_API_CALL int GLAD_GL_SGIX_instruments;
#define GL_SGIX_interlace 1
    GLAD_API_CALL int GLAD_GL_SGIX_interlace;
#define GL_SGIX_ir_instrument1 1
    GLAD_API_CALL int GLAD_GL_SGIX_ir_instrument1;
#define GL_SGIX_list_priority 1
    GLAD_API_CALL int GLAD_GL_SGIX_list_priority;
#define GL_SGIX_pixel_texture 1
    GLAD_API_CALL int GLAD_GL_SGIX_pixel_texture;
#define GL_SGIX_pixel_tiles 1
    GLAD_API_CALL int GLAD_GL_SGIX_pixel_tiles;
#define GL_SGIX_polynomial_ffd 1
    GLAD_API_CALL int GLAD_GL_SGIX_polynomial_ffd;
#define GL_SGIX_reference_plane 1
    GLAD_API_CALL int GLAD_GL_SGIX_reference_plane;
#define GL_SGIX_resample 1
    GLAD_API_CALL int GLAD_GL_SGIX_resample;
#define GL_SGIX_scalebias_hint 1
    GLAD_API_CALL int GLAD_GL_SGIX_scalebias_hint;
#define GL_SGIX_shadow 1
    GLAD_API_CALL int GLAD_GL_SGIX_shadow;
#define GL_SGIX_shadow_ambient 1
    GLAD_API_CALL int GLAD_GL_SGIX_shadow_ambient;
#define GL_SGIX_sprite 1
    GLAD_API_CALL int GLAD_GL_SGIX_sprite;
#define GL_SGIX_subsample 1
    GLAD_API_CALL int GLAD_GL_SGIX_subsample;
#define GL_SGIX_tag_sample_buffer 1
    GLAD_API_CALL int GLAD_GL_SGIX_tag_sample_buffer;
#define GL_SGIX_texture_add_env 1
    GLAD_API_CALL int GLAD_GL_SGIX_texture_add_env;
#define GL_SGIX_texture_coordinate_clamp 1
    GLAD_API_CALL int GLAD_GL_SGIX_texture_coordinate_clamp;
#define GL_SGIX_texture_lod_bias 1
    GLAD_API_CALL int GLAD_GL_SGIX_texture_lod_bias;
#define GL_SGIX_texture_multi_buffer 1
    GLAD_API_CALL int GLAD_GL_SGIX_texture_multi_buffer;
#define GL_SGIX_texture_scale_bias 1
    GLAD_API_CALL int GLAD_GL_SGIX_texture_scale_bias;
#define GL_SGIX_vertex_preclip 1
    GLAD_API_CALL int GLAD_GL_SGIX_vertex_preclip;
#define GL_SGIX_ycrcb 1
    GLAD_API_CALL int GLAD_GL_SGIX_ycrcb;
#define GL_SGIX_ycrcb_subsample 1
    GLAD_API_CALL int GLAD_GL_SGIX_ycrcb_subsample;
#define GL_SGIX_ycrcba 1
    GLAD_API_CALL int GLAD_GL_SGIX_ycrcba;
#define GL_SGI_color_matrix 1
    GLAD_API_CALL int GLAD_GL_SGI_color_matrix;
#define GL_SGI_color_table 1
    GLAD_API_CALL int GLAD_GL_SGI_color_table;
#define GL_SGI_texture_color_table 1
    GLAD_API_CALL int GLAD_GL_SGI_texture_color_table;
#define GL_SUNX_constant_data 1
    GLAD_API_CALL int GLAD_GL_SUNX_constant_data;
#define GL_SUN_convolution_border_modes 1
    GLAD_API_CALL int GLAD_GL_SUN_convolution_border_modes;
#define GL_SUN_global_alpha 1
    GLAD_API_CALL int GLAD_GL_SUN_global_alpha;
#define GL_SUN_mesh_array 1
    GLAD_API_CALL int GLAD_GL_SUN_mesh_array;
#define GL_SUN_slice_accum 1
    GLAD_API_CALL int GLAD_GL_SUN_slice_accum;
#define GL_SUN_triangle_list 1
    GLAD_API_CALL int GLAD_GL_SUN_triangle_list;
#define GL_SUN_vertex 1
    GLAD_API_CALL int GLAD_GL_SUN_vertex;
#define GL_WIN_phong_shading 1
    GLAD_API_CALL int GLAD_GL_WIN_phong_shading;
#define GL_WIN_specular_fog 1
    GLAD_API_CALL int GLAD_GL_WIN_specular_fog;

    typedef void(GLAD_API_PTR* PFNGLACCUMXOESPROC)(GLenum op, GLfixed value);
    typedef GLboolean(GLAD_API_PTR* PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key,
                                                                        GLuint timeout);
    typedef void(GLAD_API_PTR* PFNGLACTIVEPROGRAMEXTPROC)(GLuint program);
    typedef void(GLAD_API_PTR* PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
    typedef void(GLAD_API_PTR* PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
    typedef void(GLAD_API_PTR* PFNGLACTIVETEXTUREPROC)(GLenum texture);
    typedef void(GLAD_API_PTR* PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
    typedef void(GLAD_API_PTR* PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLALPHAFRAGMENTOP1ATIPROC)(
        GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
    typedef void(GLAD_API_PTR* PFNGLALPHAFRAGMENTOP2ATIPROC)(
        GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod,
        GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
    typedef void(GLAD_API_PTR* PFNGLALPHAFRAGMENTOP3ATIPROC)(
        GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod,
        GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
    typedef void(GLAD_API_PTR* PFNGLALPHAFUNCXOESPROC)(GLenum func, GLfixed ref);
    typedef void(GLAD_API_PTR* PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
    typedef GLboolean(GLAD_API_PTR* PFNGLAREPROGRAMSRESIDENTNVPROC)(
        GLsizei n, const GLuint* programs, GLboolean* residences);
    typedef GLboolean(GLAD_API_PTR* PFNGLARETEXTURESRESIDENTEXTPROC)(
        GLsizei n, const GLuint* textures, GLboolean* residences);
    typedef void(GLAD_API_PTR* PFNGLARRAYELEMENTEXTPROC)(GLint i);
    typedef void(GLAD_API_PTR* PFNGLARRAYOBJECTATIPROC)(
        GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
    typedef GLuint(GLAD_API_PTR* PFNGLASYNCCOPYBUFFERSUBDATANVXPROC)(
        GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray,
        const GLuint64* fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer,
        GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size,
        GLsizei signalSemaphoreCount, const GLuint* signalSemaphoreArray,
        const GLuint64* signalValueArray);
    typedef GLuint(GLAD_API_PTR* PFNGLASYNCCOPYIMAGESUBDATANVXPROC)(
        GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray,
        const GLuint64* waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName,
        GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName,
        GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth,
        GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount,
        const GLuint* signalSemaphoreArray, const GLuint64* signalValueArray);
    typedef void(GLAD_API_PTR* PFNGLASYNCMARKERSGIXPROC)(GLuint marker);
    typedef void(GLAD_API_PTR* PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
    typedef void(GLAD_API_PTR* PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
    typedef void(GLAD_API_PTR* PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBEGINCONDITIONALRENDERNVPROC)(GLuint id, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBEGINCONDITIONALRENDERNVXPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBEGINPERFMONITORAMDPROC)(GLuint monitor);
    typedef void(GLAD_API_PTR* PFNGLBEGINPERFQUERYINTELPROC)(GLuint queryHandle);
    typedef void(GLAD_API_PTR* PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
    typedef void(GLAD_API_PTR* PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(GLenum primitiveMode);
    typedef void(GLAD_API_PTR* PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
    typedef void(GLAD_API_PTR* PFNGLBEGINVERTEXSHADEREXTPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLBEGINVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
    typedef void(GLAD_API_PTR* PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index,
                                                            const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index,
                                                               const GLcharARB* name);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERBASEEXTPROC)(GLenum target, GLuint index,
                                                           GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index,
                                                          GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFEROFFSETEXTPROC)(GLenum target, GLuint index,
                                                             GLuint buffer, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index,
                                                            GLuint buffer, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer,
                                                         GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERRANGEEXTPROC)(
        GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERRANGENVPROC)(
        GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count,
                                                         const GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLBINDBUFFERSRANGEPROC)(
        GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets,
        const GLsizeiptr* sizes);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color,
                                                              const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color,
                                                                 const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(
        GLuint program, GLuint colorNumber, GLuint index, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
    typedef void(GLAD_API_PTR* PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
    typedef void(GLAD_API_PTR* PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level,
                                                          GLboolean layered, GLint layer,
                                                          GLenum access, GLenum format);
    typedef void(GLAD_API_PTR* PFNGLBINDIMAGETEXTUREEXTPROC)(
        GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access,
        GLint format);
    typedef void(GLAD_API_PTR* PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count,
                                                           const GLuint* textures);
    typedef GLuint(GLAD_API_PTR* PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
    typedef GLuint(GLAD_API_PTR* PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
    typedef void(GLAD_API_PTR* PFNGLBINDMULTITEXTUREEXTPROC)(GLenum texunit, GLenum target,
                                                             GLuint texture);
    typedef GLuint(GLAD_API_PTR* PFNGLBINDPARAMETEREXTPROC)(GLenum value);
    typedef void(GLAD_API_PTR* PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
    typedef void(GLAD_API_PTR* PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
    typedef void(GLAD_API_PTR* PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
    typedef void(GLAD_API_PTR* PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count,
                                                      const GLuint* samplers);
    typedef void(GLAD_API_PTR* PFNGLBINDSHADINGRATEIMAGENVPROC)(GLuint texture);
    typedef GLuint(GLAD_API_PTR* PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord,
                                                                  GLenum value);
    typedef void(GLAD_API_PTR* PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
    typedef GLuint(GLAD_API_PTR* PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
    typedef void(GLAD_API_PTR* PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count,
                                                      const GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBINDTRANSFORMFEEDBACKNVPROC)(GLenum target, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBINDVERTEXARRAYPROC)(GLuint array);
    typedef void(GLAD_API_PTR* PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
    typedef void(GLAD_API_PTR* PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer,
                                                          GLintptr offset, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLBINDVERTEXBUFFERSPROC)(
        GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets,
        const GLsizei* strides);
    typedef void(GLAD_API_PTR* PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
    typedef void(GLAD_API_PTR* PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target,
        GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3BEXTPROC)(GLbyte bx, GLbyte by, GLbyte bz);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3BVEXTPROC)(const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3DEXTPROC)(GLdouble bx, GLdouble by, GLdouble bz);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3DVEXTPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3FEXTPROC)(GLfloat bx, GLfloat by, GLfloat bz);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3FVEXTPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3IEXTPROC)(GLint bx, GLint by, GLint bz);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3IVEXTPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3SEXTPROC)(GLshort bx, GLshort by, GLshort bz);
    typedef void(GLAD_API_PTR* PFNGLBINORMAL3SVEXTPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride,
                                                            const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLBITMAPXOESPROC)(GLsizei width, GLsizei height, GLfixed xorig,
                                                    GLfixed yorig, GLfixed xmove, GLfixed ymove,
                                                    const GLubyte* bitmap);
    typedef void(GLAD_API_PTR* PFNGLBLENDBARRIERKHRPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLBLENDBARRIERNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue,
                                                    GLfloat alpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDCOLOREXTPROC)(GLfloat red, GLfloat green, GLfloat blue,
                                                       GLfloat alpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue,
                                                        GLfixed alpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONINDEXEDAMDPROC)(GLuint buf, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum modeRGB,
                                                                         GLenum modeAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB,
                                                                GLenum modeAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONSEPARATEIARBPROC)(GLuint buf, GLenum modeRGB,
                                                                   GLenum modeAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBLENDEQUATIONIARBPROC)(GLuint buf, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCINDEXEDAMDPROC)(GLuint buf, GLenum src, GLenum dst);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEPROC)(
        GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEEXTPROC)(
        GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEINGRPROC)(
        GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(
        GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEIPROC)(
        GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCSEPARATEIARBPROC)(
        GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
    typedef void(GLAD_API_PTR* PFNGLBLENDFUNCIARBPROC)(GLuint buf, GLenum src, GLenum dst);
    typedef void(GLAD_API_PTR* PFNGLBLENDPARAMETERINVPROC)(GLenum pname, GLint value);
    typedef void(GLAD_API_PTR* PFNGLBLITFRAMEBUFFERPROC)(
        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1,
        GLint dstY1, GLbitfield mask, GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLBLITFRAMEBUFFEREXTPROC)(
        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1,
        GLint dstY1, GLbitfield mask, GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLBLITFRAMEBUFFERLAYEREXTPROC)(
        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0,
        GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLBLITFRAMEBUFFERLAYERSEXTPROC)(
        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1,
        GLint dstY1, GLbitfield mask, GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLBLITNAMEDFRAMEBUFFERPROC)(
        GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1,
        GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask,
        GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLBUFFERADDRESSRANGENVPROC)(
        GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
    typedef void(GLAD_API_PTR* PFNGLBUFFERATTACHMEMORYNVPROC)(GLenum target, GLuint memory,
                                                              GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size,
                                                    const void* data, GLenum usage);
    typedef void(GLAD_API_PTR* PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size,
                                                       const void* data, GLenum usage);
    typedef void(GLAD_API_PTR* PFNGLBUFFERPAGECOMMITMENTARBPROC)(GLenum target, GLintptr offset,
                                                                 GLsizeiptr size, GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLBUFFERPAGECOMMITMENTMEMNVPROC)(
        GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset,
        GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLBUFFERPARAMETERIAPPLEPROC)(GLenum target, GLenum pname,
                                                               GLint param);
    typedef void(GLAD_API_PTR* PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size,
                                                       const void* data, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLBUFFERSTORAGEEXTERNALEXTPROC)(
        GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer,
        GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLBUFFERSTORAGEMEMEXTPROC)(GLenum target, GLsizeiptr size,
                                                             GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset,
                                                       GLsizeiptr size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset,
                                                          GLsizeiptrARB size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCALLCOMMANDLISTNVPROC)(GLuint list);
    typedef GLenum(GLAD_API_PTR* PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
    typedef GLenum(GLAD_API_PTR* PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
    typedef GLenum(GLAD_API_PTR* PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer,
                                                                       GLenum target);
    typedef GLenum(GLAD_API_PTR* PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(GLuint framebuffer,
                                                                          GLenum target);
    typedef void(GLAD_API_PTR* PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
    typedef void(GLAD_API_PTR* PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
    typedef void(GLAD_API_PTR* PFNGLCLEARPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLCLEARACCUMXOESPROC)(GLfixed red, GLfixed green, GLfixed blue,
                                                        GLfixed alpha);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERDATAPROC)(
        GLenum target, GLenum internalformat, GLenum format, GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERSUBDATAPROC)(
        GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format,
        GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer,
                                                       GLfloat depth, GLint stencil);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer,
                                                       const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer,
                                                       const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer,
                                                        const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue,
                                                    GLfloat alpha);
    typedef void(GLAD_API_PTR* PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue,
                                                         GLint alpha);
    typedef void(GLAD_API_PTR* PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue,
                                                          GLuint alpha);
    typedef void(GLAD_API_PTR* PFNGLCLEARCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue,
                                                        GLfixed alpha);
    typedef void(GLAD_API_PTR* PFNGLCLEARDEPTHPROC)(GLdouble depth);
    typedef void(GLAD_API_PTR* PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
    typedef void(GLAD_API_PTR* PFNGLCLEARDEPTHFPROC)(GLfloat d);
    typedef void(GLAD_API_PTR* PFNGLCLEARDEPTHFOESPROC)(GLclampf depth);
    typedef void(GLAD_API_PTR* PFNGLCLEARDEPTHXOESPROC)(GLfixed depth);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDBUFFERDATAPROC)(
        GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDBUFFERDATAEXTPROC)(
        GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(
        GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format,
        GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC)(
        GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format,
        GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(
        GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(
        GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(
        GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(
        GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLCLEARSTENCILPROC)(GLint s);
    typedef void(GLAD_API_PTR* PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format,
                                                       GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLEARTEXSUBIMAGEPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
    typedef void(GLAD_API_PTR* PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
    typedef void(GLAD_API_PTR* PFNGLCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC)(
        GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64* fenceValueArray);
    typedef GLenum(GLAD_API_PTR* PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags,
                                                          GLuint64 timeout);
    typedef void(GLAD_API_PTR* PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
    typedef void(GLAD_API_PTR* PFNGLCLIPPLANEFOESPROC)(GLenum plane, const GLfloat* equation);
    typedef void(GLAD_API_PTR* PFNGLCLIPPLANEXOESPROC)(GLenum plane, const GLfixed* equation);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b,
                                                            GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3FVERTEX3FVSUNPROC)(const GLfloat* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3XOESPROC)(GLfixed red, GLfixed green, GLfixed blue);
    typedef void(GLAD_API_PTR* PFNGLCOLOR3XVOESPROC)(const GLfixed* components);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x,
        GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(
        const GLfloat* c, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue,
                                                   GLhalfNV alpha);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4UBVERTEX2FSUNPROC)(GLubyte r, GLubyte g, GLubyte b,
                                                             GLubyte a, GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const GLubyte* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4UBVERTEX3FSUNPROC)(
        GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const GLubyte* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4XOESPROC)(GLfixed red, GLfixed green, GLfixed blue,
                                                    GLfixed alpha);
    typedef void(GLAD_API_PTR* PFNGLCOLOR4XVOESPROC)(const GLfixed* components);
    typedef void(GLAD_API_PTR* PFNGLCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask,
                                                             GLuint dstMod, GLuint arg1,
                                                             GLuint arg1Rep, GLuint arg1Mod);
    typedef void(GLAD_API_PTR* PFNGLCOLORFRAGMENTOP2ATIPROC)(
        GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep,
        GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
    typedef void(GLAD_API_PTR* PFNGLCOLORFRAGMENTOP3ATIPROC)(
        GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep,
        GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep,
        GLuint arg3Mod);
    typedef void(GLAD_API_PTR* PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue,
                                                   GLboolean alpha);
    typedef void(GLAD_API_PTR* PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint index, GLboolean r, GLboolean g,
                                                             GLboolean b, GLboolean a);
    typedef void(GLAD_API_PTR* PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g,
                                                    GLboolean b, GLboolean a);
    typedef void(GLAD_API_PTR* PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride,
                                                         GLsizei count, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride,
                                                             const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type,
                                                            const void** pointer);
    typedef void(GLAD_API_PTR* PFNGLCOLORSUBTABLEEXTPROC)(
        GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat,
                                                       GLsizei width, GLenum format, GLenum type,
                                                       const void* table);
    typedef void(GLAD_API_PTR* PFNGLCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname,
                                                                  const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname,
                                                                  const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLCOLORTABLESGIPROC)(GLenum target, GLenum internalformat,
                                                       GLsizei width, GLenum format, GLenum type,
                                                       const void* table);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion,
                                                         GLenum variable, GLenum input,
                                                         GLenum mapping, GLenum componentUsage);
    typedef void(GLAD_API_PTR* PFNGLCOMBINEROUTPUTNVPROC)(
        GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput,
        GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct,
        GLboolean muxSum);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname,
                                                                    const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLCOMMANDLISTSEGMENTSNVPROC)(GLuint list, GLuint segments);
    typedef void(GLAD_API_PTR* PFNGLCOMPILECOMMANDLISTNVPROC)(GLuint list);
    typedef void(GLAD_API_PTR* PFNGLCOMPILESHADERPROC)(GLuint shader);
    typedef void(GLAD_API_PTR* PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
    typedef void(GLAD_API_PTR* PFNGLCOMPILESHADERINCLUDEARBPROC)(
        GLuint shader, GLsizei count, const GLchar* const* path, const GLint* length);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLsizei height, GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format,
        GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
        GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize,
        const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE1DPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border,
        GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border,
        GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE2DPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLint border, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLint border, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE3DPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLint border, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLint border, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(
        GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize,
        const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(
        GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize,
        const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLsizei height, GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width,
        GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize,
        const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format,
        GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
        GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
    typedef void(GLAD_API_PTR* PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize,
        const void* bits);
    typedef void(GLAD_API_PTR* PFNGLCONSERVATIVERASTERPARAMETERFNVPROC)(GLenum pname, GLfloat value);
    typedef void(GLAD_API_PTR* PFNGLCONSERVATIVERASTERPARAMETERINVPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONFILTER1DEXTPROC)(
        GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type,
        const void* image);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONFILTER2DEXTPROC)(
        GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
        GLenum type, const void* image);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname,
                                                                  GLfloat params);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                   const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname,
                                                                  GLint params);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                   const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERXOESPROC)(GLenum target, GLenum pname,
                                                                  GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname,
                                                                   const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget,
                                                           GLintptr readOffset,
                                                           GLintptr writeOffset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x,
                                                              GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYCOLORTABLESGIPROC)(GLenum target, GLenum internalformat,
                                                           GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(
        GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(
        GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYIMAGESUBDATAPROC)(
        GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ,
        GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ,
        GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
    typedef void(GLAD_API_PTR* PFNGLCOPYIMAGESUBDATANVPROC)(
        GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ,
        GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ,
        GLsizei width, GLsizei height, GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLsizei height, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLint x, GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(
        GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset,
        GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLCOPYPATHNVPROC)(GLuint resultPath, GLuint srcPath);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level,
                                                        GLenum internalformat, GLint x, GLint y,
                                                        GLsizei width, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level,
                                                           GLenum internalformat, GLint x, GLint y,
                                                           GLsizei width, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXIMAGE2DPROC)(
        GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width,
        GLsizei height, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXIMAGE2DEXTPROC)(
        GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width,
        GLsizei height, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE1DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(
        GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level,
                                                           GLint xoffset, GLint yoffset, GLint x,
                                                           GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width,
        GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE3DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLsizei height, GLint border);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE1DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE2DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width,
        GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE3DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLint x, GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLCOVERFILLPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode,
        GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLCOVERFILLPATHNVPROC)(GLuint path, GLenum coverMode);
    typedef void(GLAD_API_PTR* PFNGLCOVERSTROKEPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode,
        GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLCOVERSTROKEPATHNVPROC)(GLuint path, GLenum coverMode);
    typedef void(GLAD_API_PTR* PFNGLCOVERAGEMODULATIONNVPROC)(GLenum components);
    typedef void(GLAD_API_PTR* PFNGLCOVERAGEMODULATIONTABLENVPROC)(GLsizei n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLCREATECOMMANDLISTSNVPROC)(GLsizei n, GLuint* lists);
    typedef void(GLAD_API_PTR* PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint* framebuffers);
    typedef void(GLAD_API_PTR* PFNGLCREATEMEMORYOBJECTSEXTPROC)(GLsizei n, GLuint* memoryObjects);
    typedef void(GLAD_API_PTR* PFNGLCREATEPERFQUERYINTELPROC)(GLuint queryId, GLuint* queryHandle);
    typedef GLuint(GLAD_API_PTR* PFNGLCREATEPROGRAMPROC)(void);
    typedef GLhandleARB(GLAD_API_PTR* PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint* pipelines);
    typedef GLuint(GLAD_API_PTR* PFNGLCREATEPROGRESSFENCENVXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint* renderbuffers);
    typedef void(GLAD_API_PTR* PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint* samplers);
    typedef void(GLAD_API_PTR* PFNGLCREATESEMAPHORESNVPROC)(GLsizei n, GLuint* semaphores);
    typedef GLuint(GLAD_API_PTR* PFNGLCREATESHADERPROC)(GLenum type);
    typedef GLhandleARB(GLAD_API_PTR* PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
    typedef GLuint(GLAD_API_PTR* PFNGLCREATESHADERPROGRAMEXTPROC)(GLenum type, const GLchar* string);
    typedef GLuint(GLAD_API_PTR* PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count,
                                                                const GLchar* const* strings);
    typedef void(GLAD_API_PTR* PFNGLCREATESTATESNVPROC)(GLsizei n, GLuint* states);
    typedef GLsync(GLAD_API_PTR* PFNGLCREATESYNCFROMCLEVENTARBPROC)(
        struct _cl_context* context, struct _cl_event* event, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint* arrays);
    typedef void(GLAD_API_PTR* PFNGLCULLFACEPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback,
                                                              const void* userParam);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGECALLBACKAMDPROC)(GLDEBUGPROCAMD callback,
                                                                 void* userParam);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGECALLBACKARBPROC)(GLDEBUGPROCARB callback,
                                                                 const void* userParam);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type,
                                                             GLenum severity, GLsizei count,
                                                             const GLuint* ids, GLboolean enabled);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGECONTROLARBPROC)(
        GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids,
        GLboolean enabled);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGEENABLEAMDPROC)(
        GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGEINSERTPROC)(
        GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGEINSERTAMDPROC)(
        GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
    typedef void(GLAD_API_PTR* PFNGLDEBUGMESSAGEINSERTARBPROC)(
        GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
    typedef void(GLAD_API_PTR* PFNGLDEFORMSGIXPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLDEFORMATIONMAP3DSGIXPROC)(
        GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1,
        GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride,
        GLint worder, const GLdouble* points);
    typedef void(GLAD_API_PTR* PFNGLDEFORMATIONMAP3FSGIXPROC)(
        GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2,
        GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder,
        const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLDELETEASYNCMARKERSSGIXPROC)(GLuint marker, GLsizei range);
    typedef void(GLAD_API_PTR* PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLDELETECOMMANDLISTSNVPROC)(GLsizei n, const GLuint* lists);
    typedef void(GLAD_API_PTR* PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint* fences);
    typedef void(GLAD_API_PTR* PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint* fences);
    typedef void(GLAD_API_PTR* PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint* framebuffers);
    typedef void(GLAD_API_PTR* PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n,
                                                               const GLuint* framebuffers);
    typedef void(GLAD_API_PTR* PFNGLDELETEMEMORYOBJECTSEXTPROC)(GLsizei n,
                                                                const GLuint* memoryObjects);
    typedef void(GLAD_API_PTR* PFNGLDELETENAMEDSTRINGARBPROC)(GLint namelen, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLDELETENAMESAMDPROC)(GLenum identifier, GLuint num,
                                                        const GLuint* names);
    typedef void(GLAD_API_PTR* PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
    typedef void(GLAD_API_PTR* PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLDELETEPATHSNVPROC)(GLuint path, GLsizei range);
    typedef void(GLAD_API_PTR* PFNGLDELETEPERFMONITORSAMDPROC)(GLsizei n, GLuint* monitors);
    typedef void(GLAD_API_PTR* PFNGLDELETEPERFQUERYINTELPROC)(GLuint queryHandle);
    typedef void(GLAD_API_PTR* PFNGLDELETEPROGRAMPROC)(GLuint program);
    typedef void(GLAD_API_PTR* PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint* pipelines);
    typedef void(GLAD_API_PTR* PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint* programs);
    typedef void(GLAD_API_PTR* PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint* programs);
    typedef void(GLAD_API_PTR* PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLDELETEQUERYRESOURCETAGNVPROC)(GLsizei n, const GLint* tagIds);
    typedef void(GLAD_API_PTR* PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint* renderbuffers);
    typedef void(GLAD_API_PTR* PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n,
                                                                const GLuint* renderbuffers);
    typedef void(GLAD_API_PTR* PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint* samplers);
    typedef void(GLAD_API_PTR* PFNGLDELETESEMAPHORESEXTPROC)(GLsizei n, const GLuint* semaphores);
    typedef void(GLAD_API_PTR* PFNGLDELETESHADERPROC)(GLuint shader);
    typedef void(GLAD_API_PTR* PFNGLDELETESTATESNVPROC)(GLsizei n, const GLuint* states);
    typedef void(GLAD_API_PTR* PFNGLDELETESYNCPROC)(GLsync sync);
    typedef void(GLAD_API_PTR* PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(GLsizei n, const GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint* arrays);
    typedef void(GLAD_API_PTR* PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint* arrays);
    typedef void(GLAD_API_PTR* PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
    typedef void(GLAD_API_PTR* PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
    typedef void(GLAD_API_PTR* PFNGLDEPTHFUNCPROC)(GLenum func);
    typedef void(GLAD_API_PTR* PFNGLDEPTHMASKPROC)(GLboolean flag);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEARRAYDVNVPROC)(GLuint first, GLsizei count,
                                                             const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count,
                                                          const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEINDEXEDDNVPROC)(GLuint index, GLdouble n, GLdouble f);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEFOESPROC)(GLclampf n, GLclampf f);
    typedef void(GLAD_API_PTR* PFNGLDEPTHRANGEXOESPROC)(GLfixed n, GLfixed f);
    typedef void(GLAD_API_PTR* PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj,
                                                         GLhandleARB attachedObj);
    typedef void(GLAD_API_PTR* PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
    typedef void(GLAD_API_PTR* PFNGLDETAILTEXFUNCSGISPROC)(GLenum target, GLsizei n,
                                                           const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLDISABLEPROC)(GLenum cap);
    typedef void(GLAD_API_PTR* PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISABLEIPROC)(GLenum target, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y,
                                                         GLuint num_groups_z);
    typedef void(GLAD_API_PTR* PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC)(
        GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x,
        GLuint group_size_y, GLuint group_size_z);
    typedef void(GLAD_API_PTR* PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void* indirect);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first,
                                                             GLsizei count, GLsizei instancecount);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSINSTANCEDARBPROC)(GLenum mode, GLint first,
                                                                GLsizei count, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(
        GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
    typedef void(GLAD_API_PTR* PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start,
                                                                GLsizei count, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLDRAWBUFFERPROC)(GLenum buf);
    typedef void(GLAD_API_PTR* PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum* bufs);
    typedef void(GLAD_API_PTR* PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum* bufs);
    typedef void(GLAD_API_PTR* PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum* bufs);
    typedef void(GLAD_API_PTR* PFNGLDRAWCOMMANDSADDRESSNVPROC)(
        GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
    typedef void(GLAD_API_PTR* PFNGLDRAWCOMMANDSNVPROC)(GLenum primitiveMode, GLuint buffer,
                                                        const GLintptr* indirects,
                                                        const GLsizei* sizes, GLuint count);
    typedef void(GLAD_API_PTR* PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC)(
        const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos,
        GLuint count);
    typedef void(GLAD_API_PTR* PFNGLDRAWCOMMANDSSTATESNVPROC)(
        GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states,
        const GLuint* fbos, GLuint count);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first,
                                                               GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type,
                                                      const void* indices);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSBASEVERTEXPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type,
                                                              const void* indirect);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDARBPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount,
        GLuint baseinstance);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount,
        GLint basevertex);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount,
        GLint basevertex, GLuint baseinstance);
    typedef void(GLAD_API_PTR* PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(
        GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLDRAWMESHARRAYSSUNPROC)(GLenum mode, GLint first, GLsizei count,
                                                           GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLDRAWMESHTASKSINDIRECTNVPROC)(GLintptr indirect);
    typedef void(GLAD_API_PTR* PFNGLDRAWMESHTASKSNVPROC)(GLuint first, GLuint count);
    typedef void(GLAD_API_PTR* PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(
        GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start,
                                                                  GLuint end, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLDRAWRANGEELEMENTSPROC)(
        GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
    typedef void(GLAD_API_PTR* PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(
        GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices,
        GLint basevertex);
    typedef void(GLAD_API_PTR* PFNGLDRAWRANGEELEMENTSEXTPROC)(
        GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
    typedef void(GLAD_API_PTR* PFNGLDRAWTEXTURENVPROC)(
        GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z,
        GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
    typedef void(GLAD_API_PTR* PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id,
                                                                        GLsizei instancecount);
    typedef void(GLAD_API_PTR* PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(GLenum mode, GLuint id);
    typedef void(GLAD_API_PTR* PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id,
                                                                     GLuint stream);
    typedef void(GLAD_API_PTR* PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(
        GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
    typedef void(GLAD_API_PTR* PFNGLDRAWVKIMAGENVPROC)(
        GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z,
        GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
    typedef void(GLAD_API_PTR* PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC)(
        GLenum target, GLeglImageOES image, const GLint* attrib_list);
    typedef void(GLAD_API_PTR* PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC)(
        GLuint texture, GLeglImageOES image, const GLint* attrib_list);
    typedef void(GLAD_API_PTR* PFNGLEDGEFLAGFORMATNVPROC)(GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count,
                                                            const GLboolean* pointer);
    typedef void(GLAD_API_PTR* PFNGLEDGEFLAGPOINTERLISTIBMPROC)(
        GLint stride, const GLboolean** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLELEMENTPOINTERATIPROC)(GLenum type, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLENABLEPROC)(GLenum cap);
    typedef void(GLAD_API_PTR* PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENABLEIPROC)(GLenum target, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENDCONDITIONALRENDERPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDCONDITIONALRENDERNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDCONDITIONALRENDERNVXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDFRAGMENTSHADERATIPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDOCCLUSIONQUERYNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDPERFMONITORAMDPROC)(GLuint monitor);
    typedef void(GLAD_API_PTR* PFNGLENDPERFQUERYINTELPROC)(GLuint queryHandle);
    typedef void(GLAD_API_PTR* PFNGLENDQUERYPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLENDQUERYARBPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
    typedef void(GLAD_API_PTR* PFNGLENDTRANSFORMFEEDBACKPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDTRANSFORMFEEDBACKEXTPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDVERTEXSHADEREXTPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLENDVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
    typedef void(GLAD_API_PTR* PFNGLEVALCOORD1XOESPROC)(GLfixed u);
    typedef void(GLAD_API_PTR* PFNGLEVALCOORD1XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLEVALCOORD2XOESPROC)(GLfixed u, GLfixed v);
    typedef void(GLAD_API_PTR* PFNGLEVALCOORD2XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLEVALUATEDEPTHVALUESARBPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id,
                                                          const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
    typedef void(GLAD_API_PTR* PFNGLFEEDBACKBUFFERXOESPROC)(GLsizei n, GLenum type,
                                                            const GLfixed* buffer);
    typedef GLsync(GLAD_API_PTR* PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLFINALCOMBINERINPUTNVPROC)(
        GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
    typedef void(GLAD_API_PTR* PFNGLFINISHPROC)(void);
    typedef GLint(GLAD_API_PTR* PFNGLFINISHASYNCSGIXPROC)(GLuint* markerp);
    typedef void(GLAD_API_PTR* PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
    typedef void(GLAD_API_PTR* PFNGLFINISHFENCENVPROC)(GLuint fence);
    typedef void(GLAD_API_PTR* PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
    typedef void(GLAD_API_PTR* PFNGLFINISHTEXTURESUNXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFLUSHPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset,
                                                                GLsizeiptr length);
    typedef void(GLAD_API_PTR* PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(GLenum target, GLintptr offset,
                                                                     GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset,
                                                                     GLsizeiptr length);
    typedef void(GLAD_API_PTR* PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr length);
    typedef void(GLAD_API_PTR* PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLFLUSHRASTERSGIXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFLUSHSTATICDATAIBMPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void* pointer);
    typedef void(GLAD_API_PTR* PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDFORMATNVPROC)(GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride,
                                                            const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDPOINTERLISTIBMPROC)(
        GLenum type, GLint stride, const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDDVEXTPROC)(const GLdouble* coord);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDFVEXTPROC)(const GLfloat* coord);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDHNVPROC)(GLhalfNV fog);
    typedef void(GLAD_API_PTR* PFNGLFOGCOORDHVNVPROC)(const GLhalfNV* fog);
    typedef void(GLAD_API_PTR* PFNGLFOGFUNCSGISPROC)(GLsizei n, const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLFOGXOESPROC)(GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLFOGXVOESPROC)(GLenum pname, const GLfixed* param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(GLenum face, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTCOVERAGECOLORNVPROC)(GLuint color);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(GLenum pname,
                                                                  const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTMODELISGIXPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTFSGIXPROC)(GLenum light, GLenum pname,
                                                            GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname,
                                                             const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTISGIXPROC)(GLenum light, GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname,
                                                             const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTMATERIALFSGIXPROC)(GLenum face, GLenum pname,
                                                               GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname,
                                                                const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTMATERIALISGIXPROC)(GLenum face, GLenum pname,
                                                               GLint param);
    typedef void(GLAD_API_PTR* PFNGLFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname,
                                                                const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLFRAMETERMINATORGREMEDYPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFRAMEZOOMSGIXPROC)(GLint factor);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(GLuint framebuffer, GLsizei n,
                                                                   const GLenum* bufs);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname,
                                                               GLint param);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERPARAMETERIMESAPROC)(GLenum target, GLenum pname,
                                                                   GLint param);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERRENDERBUFFERPROC)(
        GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(
        GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(
        GLenum target, GLuint start, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(
        GLenum target, GLuint start, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(
        GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment,
                                                            GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE1DPROC)(
        GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(
        GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE2DPROC)(
        GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(
        GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment,
                                                              GLenum textarget, GLuint texture,
                                                              GLint level, GLint zoffset);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment,
                                                                 GLenum textarget, GLuint texture,
                                                                 GLint level, GLint zoffset);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREARBPROC)(GLenum target, GLenum attachment,
                                                               GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment,
                                                               GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURELAYERPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
    typedef void(GLAD_API_PTR* PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC)(
        GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex,
        GLsizei numViews);
    typedef void(GLAD_API_PTR* PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLFRONTFACEPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLFRUSTUMFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t,
                                                     GLfloat n, GLfloat f);
    typedef void(GLAD_API_PTR* PFNGLFRUSTUMXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t,
                                                     GLfixed n, GLfixed f);
    typedef GLuint(GLAD_API_PTR* PFNGLGENASYNCMARKERSSGIXPROC)(GLsizei range);
    typedef void(GLAD_API_PTR* PFNGLGENBUFFERSPROC)(GLsizei n, GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint* buffers);
    typedef void(GLAD_API_PTR* PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint* fences);
    typedef void(GLAD_API_PTR* PFNGLGENFENCESNVPROC)(GLsizei n, GLuint* fences);
    typedef GLuint(GLAD_API_PTR* PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
    typedef void(GLAD_API_PTR* PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint* framebuffers);
    typedef void(GLAD_API_PTR* PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint* framebuffers);
    typedef void(GLAD_API_PTR* PFNGLGENNAMESAMDPROC)(GLenum identifier, GLuint num, GLuint* names);
    typedef void(GLAD_API_PTR* PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint* ids);
    typedef GLuint(GLAD_API_PTR* PFNGLGENPATHSNVPROC)(GLsizei range);
    typedef void(GLAD_API_PTR* PFNGLGENPERFMONITORSAMDPROC)(GLsizei n, GLuint* monitors);
    typedef void(GLAD_API_PTR* PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint* pipelines);
    typedef void(GLAD_API_PTR* PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint* programs);
    typedef void(GLAD_API_PTR* PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint* programs);
    typedef void(GLAD_API_PTR* PFNGLGENQUERIESPROC)(GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLGENQUERYRESOURCETAGNVPROC)(GLsizei n, GLint* tagIds);
    typedef void(GLAD_API_PTR* PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint* renderbuffers);
    typedef void(GLAD_API_PTR* PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint* renderbuffers);
    typedef void(GLAD_API_PTR* PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint* samplers);
    typedef void(GLAD_API_PTR* PFNGLGENSEMAPHORESEXTPROC)(GLsizei n, GLuint* semaphores);
    typedef GLuint(GLAD_API_PTR* PFNGLGENSYMBOLSEXTPROC)(GLenum datatype, GLenum storagetype,
                                                         GLenum range, GLuint components);
    typedef void(GLAD_API_PTR* PFNGLGENTEXTURESPROC)(GLsizei n, GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint* textures);
    typedef void(GLAD_API_PTR* PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLGENTRANSFORMFEEDBACKSNVPROC)(GLsizei n, GLuint* ids);
    typedef void(GLAD_API_PTR* PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint* arrays);
    typedef void(GLAD_API_PTR* PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, GLuint* arrays);
    typedef GLuint(GLAD_API_PTR* PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
    typedef void(GLAD_API_PTR* PFNGLGENERATEMIPMAPPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(GLenum texunit, GLenum target);
    typedef void(GLAD_API_PTR* PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLGENERATETEXTUREMIPMAPEXTPROC)(GLuint texture, GLenum target);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(
        GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index,
                                                         GLsizei bufSize, GLsizei* length,
                                                         GLint* size, GLenum* type, GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEATTRIBARBPROC)(
        GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size,
        GLenum* type, GLcharARB* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype,
                                                                 GLuint index, GLsizei bufSize,
                                                                 GLsizei* length, GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(
        GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei* length,
        GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(
        GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index,
                                                          GLsizei bufSize, GLsizei* length,
                                                          GLint* size, GLenum* type, GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMARBPROC)(
        GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size,
        GLenum* type, GLcharARB* name);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(
        GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length,
        GLchar* uniformBlockName);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(
        GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMNAMEPROC)(
        GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount,
                                                             const GLuint* uniformIndices,
                                                             GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETACTIVEVARYINGNVPROC)(
        GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type,
        GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname,
                                                             GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname,
                                                             GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETATTACHEDOBJECTSARBPROC)(
        GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB* obj);
    typedef void(GLAD_API_PTR* PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount,
                                                            GLsizei* count, GLuint* shaders);
    typedef GLint(GLAD_API_PTR* PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj,
                                                               const GLcharARB* name);
    typedef void(GLAD_API_PTR* PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum target, GLuint index,
                                                               GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname,
                                                                GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname,
                                                              GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname,
                                                                 GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPARAMETERUI64VNVPROC)(GLenum target, GLenum pname,
                                                                   GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname,
                                                           void** params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname,
                                                              void** params);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset,
                                                          GLsizeiptr size, void* data);
    typedef void(GLAD_API_PTR* PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset,
                                                             GLsizeiptrARB size, void* data);
    typedef void(GLAD_API_PTR* PFNGLGETCLIPPLANEFOESPROC)(GLenum plane, GLfloat* equation);
    typedef void(GLAD_API_PTR* PFNGLGETCLIPPLANEXOESPROC)(GLenum plane, GLfixed* equation);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type,
                                                          void* data);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                     GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname,
                                                                     GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                     GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname,
                                                                     GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOLORTABLESGIPROC)(GLenum target, GLenum format, GLenum type,
                                                          void* table);
    typedef void(GLAD_API_PTR* PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(
        GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(
        GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(
        GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(
        GLenum stage, GLenum portion, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname,
                                                                       GLfloat* params);
    typedef GLuint(GLAD_API_PTR* PFNGLGETCOMMANDHEADERNVPROC)(GLenum tokenID, GLuint size);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(
        GLenum texunit, GLenum target, GLint lod, void* img);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level,
                                                               void* img);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint level,
                                                                  void* img);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level,
                                                                   GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target,
                                                                      GLint lod, void* img);
    typedef void(GLAD_API_PTR* PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format,
                                                                 GLenum type, void* image);
    typedef void(GLAD_API_PTR* PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                      GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                      GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname,
                                                                      GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETCOVERAGEMODULATIONTABLENVPROC)(GLsizei bufSize, GLfloat* v);
    typedef GLuint(GLAD_API_PTR* PFNGLGETDEBUGMESSAGELOGPROC)(
        GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids,
        GLenum* severities, GLsizei* lengths, GLchar* messageLog);
    typedef GLuint(GLAD_API_PTR* PFNGLGETDEBUGMESSAGELOGAMDPROC)(
        GLuint count, GLsizei bufSize, GLenum* categories, GLenum* severities, GLuint* ids,
        GLsizei* lengths, GLchar* message);
    typedef GLuint(GLAD_API_PTR* PFNGLGETDEBUGMESSAGELOGARBPROC)(
        GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids,
        GLenum* severities, GLsizei* lengths, GLchar* messageLog);
    typedef void(GLAD_API_PTR* PFNGLGETDETAILTEXFUNCSGISPROC)(GLenum target, GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLGETDOUBLEINDEXEDVEXTPROC)(GLenum target, GLuint index,
                                                              GLdouble* data);
    typedef void(GLAD_API_PTR* PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble* data);
    typedef void(GLAD_API_PTR* PFNGLGETDOUBLEI_VEXTPROC)(GLenum pname, GLuint index,
                                                         GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble* data);
    typedef GLenum(GLAD_API_PTR* PFNGLGETERRORPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(
        GLenum variable, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(
        GLenum variable, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFIRSTPERFQUERYIDINTELPROC)(GLuint* queryId);
    typedef void(GLAD_API_PTR* PFNGLGETFIXEDVOESPROC)(GLenum pname, GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETFLOATINDEXEDVEXTPROC)(GLenum target, GLuint index,
                                                             GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETFLOATI_VEXTPROC)(GLenum pname, GLuint index, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETFLOATVPROC)(GLenum pname, GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETFOGFUNCSGISPROC)(GLfloat* points);
    typedef GLint(GLAD_API_PTR* PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname,
                                                                GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname,
                                                                GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname,
                                                                   GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname,
                                                                   GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(
        GLenum target, GLenum attachment, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(
        GLenum target, GLenum attachment, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC)(
        GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size,
        GLfloat* values);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname,
                                                                   GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer,
                                                                      GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC)(GLenum target, GLenum pname,
                                                                       GLint* params);
    typedef GLenum(GLAD_API_PTR* PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
    typedef GLenum(GLAD_API_PTR* PFNGLGETGRAPHICSRESETSTATUSARBPROC)(void);
    typedef GLhandleARB(GLAD_API_PTR* PFNGLGETHANDLEARBPROC)(GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset,
                                                         GLenum format, GLenum type, void* values);
    typedef void(GLAD_API_PTR* PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                    GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                    GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETHISTOGRAMPARAMETERXVOESPROC)(GLenum target, GLenum pname,
                                                                    GLfixed* params);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETIMAGEHANDLEARBPROC)(
        GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETIMAGEHANDLENVPROC)(
        GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
    typedef void(GLAD_API_PTR* PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname,
                                                                        GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname,
                                                                        GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength,
                                                       GLsizei* length, GLcharARB* infoLog);
    typedef GLint(GLAD_API_PTR* PFNGLGETINSTRUMENTSSGIXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64* data);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64* data);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum target, GLuint index,
                                                               GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGERUI64I_VNVPROC)(GLenum value, GLuint index,
                                                             GLuint64EXT* result);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGERUI64VNVPROC)(GLenum value, GLuint64EXT* result);
    typedef void(GLAD_API_PTR* PFNGLGETINTEGERVPROC)(GLenum pname, GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETINTERNALFORMATSAMPLEIVNVPROC)(
        GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count,
        GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETINTERNALFORMATI64VPROC)(
        GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETINTERNALFORMATIVPROC)(
        GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value,
                                                                 GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value,
                                                               GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value,
                                                                 GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname,
                                                                GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname,
                                                                GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value,
                                                                     GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value,
                                                                   GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value,
                                                                     GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index,
                                                                   GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index,
                                                                   GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMAPCONTROLPOINTSNVPROC)(
        GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride,
        GLboolean packed, void* points);
    typedef void(GLAD_API_PTR* PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname,
                                                             GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname,
                                                             GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMAPXVOESPROC)(GLenum target, GLenum query, GLfixed* v);
    typedef void(GLAD_API_PTR* PFNGLGETMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC)(
        GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject,
                                                                       GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format,
                                                      GLenum type, void* values);
    typedef void(GLAD_API_PTR* PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                 GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                 GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target,
                                                             GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target,
                                                             GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord,
                                                             GLenum pname, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord,
                                                             GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord,
                                                             GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXIMAGEEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target,
                                                                    GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target,
                                                                     GLenum pname, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target,
                                                                   GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target,
                                                                   GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat* val);
    typedef void(GLAD_API_PTR* PFNGLGETMULTISAMPLEFVNVPROC)(GLenum pname, GLuint index,
                                                            GLfloat* val);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname,
                                                                     GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname,
                                                                   GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(GLuint buffer, GLenum pname,
                                                                      GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(GLuint buffer, GLenum pname,
                                                                        GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname,
                                                                void** params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(GLuint buffer, GLenum pname,
                                                                   void** params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset,
                                                               GLsizeiptr size, void* data);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset,
                                                                  GLsizeiptr size, void* data);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(
        GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC)(
        GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size,
        GLfloat* values);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer,
                                                                        GLenum pname, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC)(
        GLuint framebuffer, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target,
                                                                  GLenum pname, void* string);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDPROGRAMIVEXTPROC)(GLuint program, GLenum target,
                                                              GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(
        GLuint renderbuffer, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(
        GLuint renderbuffer, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDSTRINGARBPROC)(
        GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string);
    typedef void(GLAD_API_PTR* PFNGLGETNAMEDSTRINGIVARBPROC)(GLint namelen, const GLchar* name,
                                                             GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNEXTPERFQUERYIDINTELPROC)(GLuint queryId,
                                                                 GLuint* nextQueryId);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname,
                                                              GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname,
                                                              GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTLABELPROC)(
        GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTLABELEXTPROC)(
        GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname,
                                                                 GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(GLenum objectType, GLuint name,
                                                                   GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname,
                                                                 GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETOBJECTPTRLABELPROC)(const void* ptr, GLsizei bufSize,
                                                           GLsizei* length, GLchar* label);
    typedef void(GLAD_API_PTR* PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname,
                                                               GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname,
                                                                GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPATHCOMMANDSNVPROC)(GLuint path, GLubyte* commands);
    typedef void(GLAD_API_PTR* PFNGLGETPATHCOORDSNVPROC)(GLuint path, GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLGETPATHDASHARRAYNVPROC)(GLuint path, GLfloat* dashArray);
    typedef GLfloat(GLAD_API_PTR* PFNGLGETPATHLENGTHNVPROC)(GLuint path, GLsizei startSegment,
                                                            GLsizei numSegments);
    typedef void(GLAD_API_PTR* PFNGLGETPATHMETRICRANGENVPROC)(
        GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride,
        GLfloat* metrics);
    typedef void(GLAD_API_PTR* PFNGLGETPATHMETRICSNVPROC)(
        GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths,
        GLuint pathBase, GLsizei stride, GLfloat* metrics);
    typedef void(GLAD_API_PTR* PFNGLGETPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname,
                                                              GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLGETPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname,
                                                              GLint* value);
    typedef void(GLAD_API_PTR* PFNGLGETPATHSPACINGNVPROC)(
        GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths,
        GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType,
        GLfloat* returnedSpacing);
    typedef void(GLAD_API_PTR* PFNGLGETPERFCOUNTERINFOINTELPROC)(
        GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName,
        GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset,
        GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum,
        GLuint64* rawCounterMaxValue);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(
        GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(GLuint group, GLuint counter,
                                                                      GLenum pname, void* data);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(
        GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORCOUNTERSAMDPROC)(
        GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize,
        GLuint* counters);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(
        GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString);
    typedef void(GLAD_API_PTR* PFNGLGETPERFMONITORGROUPSAMDPROC)(
        GLint* numGroups, GLsizei groupsSize, GLuint* groups);
    typedef void(GLAD_API_PTR* PFNGLGETPERFQUERYDATAINTELPROC)(
        GLuint queryHandle, GLuint flags, GLsizei dataSize, void* data, GLuint* bytesWritten);
    typedef void(GLAD_API_PTR* PFNGLGETPERFQUERYIDBYNAMEINTELPROC)(GLchar* queryName,
                                                                   GLuint* queryId);
    typedef void(GLAD_API_PTR* PFNGLGETPERFQUERYINFOINTELPROC)(
        GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize,
        GLuint* noCounters, GLuint* noInstances, GLuint* capsMask);
    typedef void(GLAD_API_PTR* PFNGLGETPIXELMAPXVPROC)(GLenum map, GLint size, GLfixed* values);
    typedef void(GLAD_API_PTR* PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname,
                                                                       GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)(
        GLenum target, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)(
        GLenum target, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPOINTERINDEXEDVEXTPROC)(GLenum target, GLuint index,
                                                               void** data);
    typedef void(GLAD_API_PTR* PFNGLGETPOINTERI_VEXTPROC)(GLenum pname, GLuint index, void** params);
    typedef void(GLAD_API_PTR* PFNGLGETPOINTERVPROC)(GLenum pname, void** params);
    typedef void(GLAD_API_PTR* PFNGLGETPOINTERVEXTPROC)(GLenum pname, void** params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMBINARYPROC)(
        GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(GLenum target, GLuint index,
                                                                     GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(GLenum target, GLuint index,
                                                                      GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index,
                                                                     GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index,
                                                                     GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize,
                                                           GLsizei* length, GLchar* infoLog);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMINTERFACEIVPROC)(
        GLuint program, GLenum programInterface, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(GLenum target, GLuint index,
                                                                       GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(GLenum target, GLuint index,
                                                                        GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index,
                                                                       GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index,
                                                                       GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index,
                                                                 GLenum pname, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index,
                                                                 GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(
        GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname,
                                                              GLint* params);
    typedef GLuint(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCEINDEXPROC)(
        GLuint program, GLenum programInterface, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCELOCATIONPROC)(
        GLuint program, GLenum programInterface, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(
        GLuint program, GLenum programInterface, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCENAMEPROC)(
        GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length,
        GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCEFVNVPROC)(
        GLuint program, GLenum programInterface, GLuint index, GLsizei propCount,
        const GLenum* props, GLsizei count, GLsizei* length, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMRESOURCEIVPROC)(
        GLuint program, GLenum programInterface, GLuint index, GLsizei propCount,
        const GLenum* props, GLsizei count, GLsizei* length, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype,
                                                           GLenum pname, GLint* values);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname,
                                                             void* string);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname,
                                                            GLubyte* program);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC)(
        GLenum target, GLuint index, GLuint* param);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer,
                                                                  GLenum pname, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer,
                                                                GLenum pname, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer,
                                                                   GLenum pname, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer,
                                                                 GLenum pname, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index,
                                                           GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname,
                                                            GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname,
                                                               GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname,
                                                             GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname,
                                                                GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname,
                                                              GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname,
                                                                    GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                       GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname,
                                                                GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname,
                                                                 GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname,
                                                               GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname,
                                                               GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname,
                                                                   GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC)(
        GLuint semaphore, GLenum pname, GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETSEPARABLEFILTEREXTPROC)(
        GLenum target, GLenum format, GLenum type, void* row, void* column, void* span);
    typedef void(GLAD_API_PTR* PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize,
                                                          GLsizei* length, GLchar* infoLog);
    typedef void(GLAD_API_PTR* PFNGLGETSHADERPRECISIONFORMATPROC)(
        GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
    typedef void(GLAD_API_PTR* PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize,
                                                         GLsizei* length, GLchar* source);
    typedef void(GLAD_API_PTR* PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength,
                                                            GLsizei* length, GLcharARB* source);
    typedef void(GLAD_API_PTR* PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETSHADINGRATEIMAGEPALETTENVPROC)(GLuint viewport, GLuint entry,
                                                                      GLenum* rate);
    typedef void(GLAD_API_PTR* PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC)(
        GLenum rate, GLuint samples, GLuint index, GLint* location);
    typedef void(GLAD_API_PTR* PFNGLGETSHARPENTEXFUNCSGISPROC)(GLenum target, GLfloat* points);
    typedef GLushort(GLAD_API_PTR* PFNGLGETSTAGEINDEXNVPROC)(GLenum shadertype);
    typedef const GLubyte*(GLAD_API_PTR* PFNGLGETSTRINGPROC)(GLenum name);
    typedef const GLubyte*(GLAD_API_PTR* PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
    typedef GLuint(GLAD_API_PTR* PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype,
                                                              const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(
        GLuint program, GLenum shadertype, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count,
                                                   GLsizei* length, GLint* values);
    typedef void(GLAD_API_PTR* PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat* param);
    typedef void(GLAD_API_PTR* PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETTEXENVXVOESPROC)(GLenum target, GLenum pname,
                                                        GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter,
                                                              GLfloat* weights);
    typedef void(GLAD_API_PTR* PFNGLGETTEXGENXVOESPROC)(GLenum coord, GLenum pname, GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format,
                                                     GLenum type, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level,
                                                                GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level,
                                                                GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXLEVELPARAMETERXVOESPROC)(GLenum target, GLint level,
                                                                   GLenum pname, GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname,
                                                            GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname,
                                                               GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname,
                                                             GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname,
                                                                GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(GLenum target, GLenum pname,
                                                                      void** params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname,
                                                           GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname,
                                                           GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname,
                                                              GLfixed* params);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETTEXTUREHANDLEARBPROC)(GLuint texture);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETTEXTUREHANDLENVPROC)(GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREIMAGEPROC)(
        GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREIMAGEEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level,
                                                                    GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level,
                                                                    GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname,
                                                                GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target,
                                                                   GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname,
                                                                 GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target,
                                                                    GLenum pname, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname,
                                                               GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target,
                                                                  GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname,
                                                               GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target,
                                                                  GLenum pname, GLint* params);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETTEXTURESAMPLERHANDLEARBPROC)(GLuint texture,
                                                                        GLuint sampler);
    typedef GLuint64(GLAD_API_PTR* PFNGLGETTEXTURESAMPLERHANDLENVPROC)(GLuint texture,
                                                                       GLuint sampler);
    typedef void(GLAD_API_PTR* PFNGLGETTEXTURESUBIMAGEPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address,
                                                            GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(
        GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type,
        GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(
        GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type,
        GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index,
                                                                       GLint* location);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname,
                                                                   GLuint index, GLint64* param);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname,
                                                                 GLuint index, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname,
                                                                GLint* param);
    typedef GLuint(GLAD_API_PTR* PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program,
                                                                const GLchar* uniformBlockName);
    typedef GLint(GLAD_API_PTR* PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount,
                                                           const GLchar* const* uniformNames,
                                                           GLuint* uniformIndices);
    typedef GLint(GLAD_API_PTR* PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar* name);
    typedef GLint(GLAD_API_PTR* PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj,
                                                                const GLcharARB* name);
    typedef GLintptr(GLAD_API_PTR* PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location,
                                                                 GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location,
                                                      GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location,
                                                      GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location,
                                                         GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMI64VARBPROC)(GLuint program, GLint location,
                                                           GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMI64VNVPROC)(GLuint program, GLint location,
                                                          GLint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location,
                                                         GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMUI64VARBPROC)(GLuint program, GLint location,
                                                            GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMUI64VNVPROC)(GLuint program, GLint location,
                                                           GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location,
                                                       GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location,
                                                          GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETUNSIGNEDBYTEI_VEXTPROC)(GLenum target, GLuint index,
                                                               GLubyte* data);
    typedef void(GLAD_API_PTR* PFNGLGETUNSIGNEDBYTEVEXTPROC)(GLenum pname, GLubyte* data);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname,
                                                                    GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname,
                                                                    GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value,
                                                               GLboolean* data);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat* data);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint* data);
    typedef void(GLAD_API_PTR* PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, void** data);
    typedef GLint(GLAD_API_PTR* PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index,
                                                                   GLenum pname, GLint64* param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index,
                                                                 GLenum pname, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC)(GLuint vaobj, GLuint index,
                                                                     GLenum pname, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYINTEGERVEXTPROC)(GLuint vaobj, GLenum pname,
                                                                   GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC)(GLuint vaobj, GLuint index,
                                                                     GLenum pname, void** param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYPOINTERVEXTPROC)(GLuint vaobj, GLenum pname,
                                                                   void** param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint* param);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname,
                                                                         GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname,
                                                                         GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname,
                                                            GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname,
                                                               GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname,
                                                             GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname,
                                                                GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname,
                                                            GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBLDVEXTPROC)(GLuint index, GLenum pname,
                                                               GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBLI64VNVPROC)(GLuint index, GLenum pname,
                                                                GLint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBLUI64VARBPROC)(GLuint index, GLenum pname,
                                                                  GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBLUI64VNVPROC)(GLuint index, GLenum pname,
                                                                 GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname,
                                                                 void** pointer);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname,
                                                                    void** pointer);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname,
                                                                   void** pointer);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname,
                                                           GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname,
                                                              GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname,
                                                             GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname,
                                                           GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname,
                                                              GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname,
                                                             GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname,
                                                           GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname,
                                                              GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname,
                                                             GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOCAPTURESTREAMDVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOCAPTURESTREAMFVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOCAPTURESTREAMIVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOCAPTUREIVNVPROC)(GLuint video_capture_slot,
                                                             GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOI64VNVPROC)(GLuint video_slot, GLenum pname,
                                                        GLint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOIVNVPROC)(GLuint video_slot, GLenum pname,
                                                      GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOUI64VNVPROC)(GLuint video_slot, GLenum pname,
                                                         GLuint64EXT* params);
    typedef void(GLAD_API_PTR* PFNGLGETVIDEOUIVNVPROC)(GLuint video_slot, GLenum pname,
                                                       GLuint* params);
    typedef GLVULKANPROCNV(GLAD_API_PTR* PFNGLGETVKPROCADDRNVPROC)(const GLchar* name);
    typedef void(GLAD_API_PTR* PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod,
                                                                GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint lod,
                                                                   GLsizei bufSize, void* img);
    typedef void(GLAD_API_PTR* PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format,
                                                      GLenum type, GLsizei bufSize, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLGETNTEXIMAGEARBPROC)(GLenum target, GLint level, GLenum format,
                                                         GLenum type, GLsizei bufSize, void* img);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location,
                                                       GLsizei bufSize, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMDVARBPROC)(GLuint program, GLint location,
                                                          GLsizei bufSize, GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location,
                                                       GLsizei bufSize, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMFVARBPROC)(GLuint program, GLint location,
                                                          GLsizei bufSize, GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMI64VARBPROC)(GLuint program, GLint location,
                                                            GLsizei bufSize, GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location,
                                                       GLsizei bufSize, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMIVARBPROC)(GLuint program, GLint location,
                                                          GLsizei bufSize, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMUI64VARBPROC)(GLuint program, GLint location,
                                                             GLsizei bufSize, GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location,
                                                        GLsizei bufSize, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGETNUNIFORMUIVARBPROC)(GLuint program, GLint location,
                                                           GLsizei bufSize, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORBSUNPROC)(GLbyte factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORDSUNPROC)(GLdouble factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORFSUNPROC)(GLfloat factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORISUNPROC)(GLint factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORSSUNPROC)(GLshort factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORUBSUNPROC)(GLubyte factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORUISUNPROC)(GLuint factor);
    typedef void(GLAD_API_PTR* PFNGLGLOBALALPHAFACTORUSSUNPROC)(GLushort factor);
    typedef void(GLAD_API_PTR* PFNGLHINTPROC)(GLenum target, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLHINTPGIPROC)(GLenum target, GLint mode);
    typedef void(GLAD_API_PTR* PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width,
                                                      GLenum internalformat, GLboolean sink);
    typedef void(GLAD_API_PTR* PFNGLIGLOOINTERFACESGIXPROC)(GLenum pname, const void* params);
    typedef void(GLAD_API_PTR* PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(GLenum target, GLenum pname,
                                                                    GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname,
                                                                     const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(GLenum target, GLenum pname,
                                                                    GLint param);
    typedef void(GLAD_API_PTR* PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname,
                                                                     const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLIMPORTMEMORYFDEXTPROC)(GLuint memory, GLuint64 size,
                                                           GLenum handleType, GLint fd);
    typedef void(GLAD_API_PTR* PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC)(
        GLuint memory, GLuint64 size, GLenum handleType, void* handle);
    typedef void(GLAD_API_PTR* PFNGLIMPORTMEMORYWIN32NAMEEXTPROC)(
        GLuint memory, GLuint64 size, GLenum handleType, const void* name);
    typedef void(GLAD_API_PTR* PFNGLIMPORTSEMAPHOREFDEXTPROC)(GLuint semaphore, GLenum handleType,
                                                              GLint fd);
    typedef void(GLAD_API_PTR* PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC)(
        GLuint semaphore, GLenum handleType, void* handle);
    typedef void(GLAD_API_PTR* PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC)(
        GLuint semaphore, GLenum handleType, const void* name);
    typedef GLsync(GLAD_API_PTR* PFNGLIMPORTSYNCEXTPROC)(GLenum external_sync_type,
                                                         GLintptr external_sync, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLINDEXFORMATNVPROC)(GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLINDEXFUNCEXTPROC)(GLenum func, GLclampf ref);
    typedef void(GLAD_API_PTR* PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count,
                                                         const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLINDEXPOINTERLISTIBMPROC)(GLenum type, GLint stride,
                                                             const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLINDEXXOESPROC)(GLfixed component);
    typedef void(GLAD_API_PTR* PFNGLINDEXXVOESPROC)(const GLfixed* component);
    typedef void(GLAD_API_PTR* PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
    typedef void(GLAD_API_PTR* PFNGLINSERTEVENTMARKEREXTPROC)(GLsizei length, const GLchar* marker);
    typedef void(GLAD_API_PTR* PFNGLINSTRUMENTSBUFFERSGIXPROC)(GLsizei size, GLint* buffer);
    typedef void(GLAD_API_PTR* PFNGLINTERPOLATEPATHSNVPROC)(GLuint resultPath, GLuint pathA,
                                                            GLuint pathB, GLfloat weight);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset,
                                                                 GLsizeiptr length);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATEFRAMEBUFFERPROC)(
        GLenum target, GLsizei numAttachments, const GLenum* attachments);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(
        GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(
        GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATESUBFRAMEBUFFERPROC)(
        GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLINVALIDATETEXSUBIMAGEPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth);
    typedef GLboolean(GLAD_API_PTR* PFNGLISASYNCMARKERSGIXPROC)(GLuint marker);
    typedef GLboolean(GLAD_API_PTR* PFNGLISBUFFERPROC)(GLuint buffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISBUFFERARBPROC)(GLuint buffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISBUFFERRESIDENTNVPROC)(GLenum target);
    typedef GLboolean(GLAD_API_PTR* PFNGLISCOMMANDLISTNVPROC)(GLuint list);
    typedef GLboolean(GLAD_API_PTR* PFNGLISENABLEDPROC)(GLenum cap);
    typedef GLboolean(GLAD_API_PTR* PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
    typedef GLboolean(GLAD_API_PTR* PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
    typedef GLboolean(GLAD_API_PTR* PFNGLISFENCEAPPLEPROC)(GLuint fence);
    typedef GLboolean(GLAD_API_PTR* PFNGLISFENCENVPROC)(GLuint fence);
    typedef GLboolean(GLAD_API_PTR* PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle);
    typedef GLboolean(GLAD_API_PTR* PFNGLISIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle);
    typedef GLboolean(GLAD_API_PTR* PFNGLISMEMORYOBJECTEXTPROC)(GLuint memoryObject);
    typedef GLboolean(GLAD_API_PTR* PFNGLISNAMEAMDPROC)(GLenum identifier, GLuint name);
    typedef GLboolean(GLAD_API_PTR* PFNGLISNAMEDBUFFERRESIDENTNVPROC)(GLuint buffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISNAMEDSTRINGARBPROC)(GLint namelen, const GLchar* name);
    typedef GLboolean(GLAD_API_PTR* PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPATHNVPROC)(GLuint path);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPOINTINFILLPATHNVPROC)(GLuint path, GLuint mask,
                                                                  GLfloat x, GLfloat y);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPOINTINSTROKEPATHNVPROC)(GLuint path, GLfloat x,
                                                                    GLfloat y);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPROGRAMPROC)(GLuint program);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPROGRAMARBPROC)(GLuint program);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPROGRAMNVPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
    typedef GLboolean(GLAD_API_PTR* PFNGLISQUERYPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISQUERYARBPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLISSAMPLERPROC)(GLuint sampler);
    typedef GLboolean(GLAD_API_PTR* PFNGLISSEMAPHOREEXTPROC)(GLuint semaphore);
    typedef GLboolean(GLAD_API_PTR* PFNGLISSHADERPROC)(GLuint shader);
    typedef GLboolean(GLAD_API_PTR* PFNGLISSTATENVPROC)(GLuint state);
    typedef GLboolean(GLAD_API_PTR* PFNGLISSYNCPROC)(GLsync sync);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTEXTUREPROC)(GLuint texture);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTEXTUREEXTPROC)(GLuint texture);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISTRANSFORMFEEDBACKNVPROC)(GLuint id);
    typedef GLboolean(GLAD_API_PTR* PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
    typedef GLboolean(GLAD_API_PTR* PFNGLISVERTEXARRAYPROC)(GLuint array);
    typedef GLboolean(GLAD_API_PTR* PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
    typedef GLboolean(GLAD_API_PTR* PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(GLuint index, GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLLGPUCOPYIMAGESUBDATANVXPROC)(
        GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget,
        GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget,
        GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height,
        GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLLGPUINTERLOCKNVXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC)(
        GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLLABELOBJECTEXTPROC)(GLenum type, GLuint object, GLsizei length,
                                                        const GLchar* label);
    typedef void(GLAD_API_PTR* PFNGLLIGHTENVISGIXPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLLIGHTMODELXOESPROC)(GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLLIGHTMODELXVOESPROC)(GLenum pname, const GLfixed* param);
    typedef void(GLAD_API_PTR* PFNGLLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLLIGHTXVOESPROC)(GLenum light, GLenum pname,
                                                    const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLLINEWIDTHPROC)(GLfloat width);
    typedef void(GLAD_API_PTR* PFNGLLINEWIDTHXOESPROC)(GLfixed width);
    typedef void(GLAD_API_PTR* PFNGLLINKPROGRAMPROC)(GLuint program);
    typedef void(GLAD_API_PTR* PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
    typedef void(GLAD_API_PTR* PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC)(
        GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes,
        const GLuint* states, const GLuint* fbos, GLuint count);
    typedef void(GLAD_API_PTR* PFNGLLISTPARAMETERFSGIXPROC)(GLuint list, GLenum pname,
                                                            GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname,
                                                             const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLLISTPARAMETERISGIXPROC)(GLuint list, GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname,
                                                             const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLLOADMATRIXXOESPROC)(const GLfixed* m);
    typedef void(GLAD_API_PTR* PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len,
                                                       const GLubyte* program);
    typedef void(GLAD_API_PTR* PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLLOADTRANSPOSEMATRIXXOESPROC)(const GLfixed* m);
    typedef void(GLAD_API_PTR* PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
    typedef void(GLAD_API_PTR* PFNGLLOGICOPPROC)(GLenum opcode);
    typedef void(GLAD_API_PTR* PFNGLMAKEBUFFERNONRESIDENTNVPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLMAKEBUFFERRESIDENTNVPROC)(GLenum target, GLenum access);
    typedef void(GLAD_API_PTR* PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAKEIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle, GLenum access);
    typedef void(GLAD_API_PTR* PFNGLMAKEIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle, GLenum access);
    typedef void(GLAD_API_PTR* PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(GLuint buffer, GLenum access);
    typedef void(GLAD_API_PTR* PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAKETEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAKETEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
    typedef void(GLAD_API_PTR* PFNGLMAP1XOESPROC)(GLenum target, GLfixed u1, GLfixed u2,
                                                  GLint stride, GLint order, GLfixed points);
    typedef void(GLAD_API_PTR* PFNGLMAP2XOESPROC)(
        GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2,
        GLint vstride, GLint vorder, GLfixed points);
    typedef void*(GLAD_API_PTR* PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
    typedef void*(GLAD_API_PTR* PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
    typedef void*(GLAD_API_PTR* PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset,
                                                         GLsizeiptr length, GLbitfield access);
    typedef void(GLAD_API_PTR* PFNGLMAPCONTROLPOINTSNVPROC)(
        GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder,
        GLint vorder, GLboolean packed, const void* points);
    typedef void(GLAD_API_PTR* PFNGLMAPGRID1XOESPROC)(GLint n, GLfixed u1, GLfixed u2);
    typedef void(GLAD_API_PTR* PFNGLMAPGRID2XOESPROC)(GLint n, GLfixed u1, GLfixed u2, GLfixed v1,
                                                      GLfixed v2);
    typedef void*(GLAD_API_PTR* PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
    typedef void*(GLAD_API_PTR* PFNGLMAPNAMEDBUFFEREXTPROC)(GLuint buffer, GLenum access);
    typedef void*(GLAD_API_PTR* PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset,
                                                              GLsizeiptr length, GLbitfield access);
    typedef void*(GLAD_API_PTR* PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
    typedef void*(GLAD_API_PTR* PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname,
                                                          const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname,
                                                          const GLint* params);
    typedef void*(GLAD_API_PTR* PFNGLMAPTEXTURE2DINTELPROC)(
        GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum* layout);
    typedef void(GLAD_API_PTR* PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(
        GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order,
        const GLdouble* points);
    typedef void(GLAD_API_PTR* PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(
        GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order,
        const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(
        GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
        GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
    typedef void(GLAD_API_PTR* PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(
        GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1,
        GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLMATERIALXVOESPROC)(GLenum face, GLenum pname,
                                                       const GLfixed* param);
    typedef void(GLAD_API_PTR* PFNGLMATRIXFRUSTUMEXTPROC)(
        GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear,
        GLdouble zFar);
    typedef void(GLAD_API_PTR* PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type,
                                                               GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLMATRIXINDEXUBVARBPROC)(GLint size, const GLubyte* indices);
    typedef void(GLAD_API_PTR* PFNGLMATRIXINDEXUIVARBPROC)(GLint size, const GLuint* indices);
    typedef void(GLAD_API_PTR* PFNGLMATRIXINDEXUSVARBPROC)(GLint size, const GLushort* indices);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOAD3X2FNVPROC)(GLenum matrixMode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOAD3X3FNVPROC)(GLenum matrixMode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADIDENTITYEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC)(GLenum matrixMode,
                                                                   const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADDEXTPROC)(GLenum mode, const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXLOADFEXTPROC)(GLenum mode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULT3X2FNVPROC)(GLenum matrixMode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULT3X3FNVPROC)(GLenum matrixMode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC)(GLenum matrixMode,
                                                                   const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULTDEXTPROC)(GLenum mode, const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXMULTFEXTPROC)(GLenum mode, const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMATRIXORTHOEXTPROC)(GLenum mode, GLdouble left, GLdouble right,
                                                        GLdouble bottom, GLdouble top,
                                                        GLdouble zNear, GLdouble zFar);
    typedef void(GLAD_API_PTR* PFNGLMATRIXPOPEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLMATRIXPUSHEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLMATRIXROTATEDEXTPROC)(GLenum mode, GLdouble angle, GLdouble x,
                                                          GLdouble y, GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLMATRIXROTATEFEXTPROC)(GLenum mode, GLfloat angle, GLfloat x,
                                                          GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLMATRIXSCALEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y,
                                                         GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLMATRIXSCALEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y,
                                                         GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLMATRIXTRANSLATEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y,
                                                             GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLMATRIXTRANSLATEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y,
                                                             GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLMAXSHADERCOMPILERTHREADSARBPROC)(GLuint count);
    typedef void(GLAD_API_PTR* PFNGLMAXSHADERCOMPILERTHREADSKHRPROC)(GLuint count);
    typedef void(GLAD_API_PTR* PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
    typedef void(GLAD_API_PTR* PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
    typedef void(GLAD_API_PTR* PFNGLMEMORYBARRIEREXTPROC)(GLbitfield barriers);
    typedef void(GLAD_API_PTR* PFNGLMEMORYOBJECTPARAMETERIVEXTPROC)(
        GLuint memoryObject, GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
    typedef void(GLAD_API_PTR* PFNGLMINSAMPLESHADINGARBPROC)(GLfloat value);
    typedef void(GLAD_API_PTR* PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat,
                                                   GLboolean sink);
    typedef void(GLAD_API_PTR* PFNGLMULTMATRIXXOESPROC)(const GLfixed* m);
    typedef void(GLAD_API_PTR* PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const GLdouble* m);
    typedef void(GLAD_API_PTR* PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const GLfloat* m);
    typedef void(GLAD_API_PTR* PFNGLMULTTRANSPOSEMATRIXXOESPROC)(const GLfixed* m);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint* first,
                                                         const GLsizei* count, GLsizei drawcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSEXTPROC)(
        GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void* indirect,
                                                                 GLsizei drawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC)(
        GLenum mode, const void* indirect, GLsizei primcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC)(
        GLenum mode, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride,
        GLint vertexBufferCount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC)(
        GLenum mode, const void* indirect, GLsizei drawCount, GLsizei stride,
        GLint vertexBufferCount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(
        GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC)(
        GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(
        GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei* count,
                                                           GLenum type, const void* const* indices,
                                                           GLsizei drawcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(
        GLenum mode, const GLsizei* count, GLenum type, const void* const* indices,
        GLsizei drawcount, const GLint* basevertex);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSEXTPROC)(
        GLenum mode, const GLsizei* count, GLenum type, const void* const* indices,
        GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(
        GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC)(
        GLenum mode, GLenum type, const void* indirect, GLsizei primcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC)(
        GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount,
        GLsizei stride, GLint vertexBufferCount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC)(
        GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei stride,
        GLint vertexBufferCount);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(
        GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount,
        GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC)(
        GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount,
        GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC)(
        GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC)(
        GLintptr indirect, GLsizei drawcount, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(
        GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei* count,
        GLsizei primcount);
    typedef void(GLAD_API_PTR* PFNGLMULTIMODEDRAWARRAYSIBMPROC)(
        const GLenum* mode, const GLint* first, const GLsizei* count, GLsizei primcount,
        GLint modestride);
    typedef void(GLAD_API_PTR* PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(
        const GLenum* mode, const GLsizei* count, GLenum type, const void* const* indices,
        GLsizei primcount, GLint modestride);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXBUFFEREXTPROC)(GLenum texunit, GLenum target,
                                                           GLenum internalformat, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1BOESPROC)(GLenum texture, GLbyte s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1BVOESPROC)(GLenum texture, const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalfNV s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1XOESPROC)(GLenum texture, GLfixed s);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD1XVOESPROC)(GLenum texture, const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2BOESPROC)(GLenum texture, GLbyte s, GLbyte t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2BVOESPROC)(GLenum texture, const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2XOESPROC)(GLenum texture, GLfixed s, GLfixed t);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD2XVOESPROC)(GLenum texture, const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3BOESPROC)(GLenum texture, GLbyte s, GLbyte t,
                                                            GLbyte r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3BVOESPROC)(GLenum texture, const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t,
                                                            GLdouble r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t,
                                                            GLfloat r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t,
                                                           GLhalfNV r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t,
                                                            GLint r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t,
                                                            GLshort r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3XOESPROC)(GLenum texture, GLfixed s, GLfixed t,
                                                            GLfixed r);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD3XVOESPROC)(GLenum texture, const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4BOESPROC)(GLenum texture, GLbyte s, GLbyte t,
                                                            GLbyte r, GLbyte q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4BVOESPROC)(GLenum texture, const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t,
                                                            GLdouble r, GLdouble q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t,
                                                            GLfloat r, GLfloat q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t,
                                                           GLhalfNV r, GLhalfNV q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t,
                                                            GLint r, GLint q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t,
                                                            GLshort r, GLshort q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4XOESPROC)(GLenum texture, GLfixed s, GLfixed t,
                                                            GLfixed r, GLfixed q);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORD4XVOESPROC)(GLenum texture, const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXCOORDPOINTEREXTPROC)(
        GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXENVFEXTPROC)(GLenum texunit, GLenum target,
                                                         GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target,
                                                          GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXENVIEXTPROC)(GLenum texunit, GLenum target,
                                                         GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target,
                                                          GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENDEXTPROC)(GLenum texunit, GLenum coord, GLenum pname,
                                                         GLdouble param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord,
                                                          GLenum pname, const GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENFEXTPROC)(GLenum texunit, GLenum coord, GLenum pname,
                                                         GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord,
                                                          GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENIEXTPROC)(GLenum texunit, GLenum coord, GLenum pname,
                                                         GLint param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord,
                                                          GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXIMAGE3DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target,
                                                                 GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERIUIVEXTPROC)(
        GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERFEXTPROC)(GLenum texunit, GLenum target,
                                                               GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERFVEXTPROC)(
        GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERIEXTPROC)(GLenum texunit, GLenum target,
                                                               GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target,
                                                                GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXRENDERBUFFEREXTPROC)(GLenum texunit, GLenum target,
                                                                 GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXSUBIMAGE1DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format,
        GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXSUBIMAGE2DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
        GLsizei height, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTITEXSUBIMAGE3DEXTPROC)(
        GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTBARRIERNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTBLITFRAMEBUFFERNVPROC)(
        GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTBUFFERSUBDATANVPROC)(
        GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC)(
        GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer,
        GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTCOPYIMAGESUBDATANVPROC)(
        GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel,
        GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel,
        GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(
        GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC)(
        GLuint gpu, GLuint id, GLenum pname, GLint64* params);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTGETQUERYOBJECTIVNVPROC)(GLuint gpu, GLuint id,
                                                                     GLenum pname, GLint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC)(
        GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC)(GLuint gpu, GLuint id,
                                                                      GLenum pname, GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTSCISSORARRAYVNVXPROC)(GLuint gpu, GLuint first,
                                                                   GLsizei count, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTVIEWPORTARRAYVNVXPROC)(
        GLuint gpu, GLuint first, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC)(
        GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);
    typedef void(GLAD_API_PTR* PFNGLMULTICASTWAITSYNCNVPROC)(GLuint signalGpu,
                                                             GLbitfield waitGpuMask);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERATTACHMEMORYNVPROC)(GLuint buffer, GLuint memory,
                                                                   GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size,
                                                         const void* data, GLenum usage);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLsizeiptr size,
                                                            const void* data, GLenum usage);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset,
        GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size,
                                                            const void* data, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSTORAGEEXTPROC)(GLuint buffer, GLsizeiptr size,
                                                               const void* data, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC)(
        GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer,
        GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC)(GLuint buffer, GLsizeiptr size,
                                                                  GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset,
                                                            GLsizeiptr size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset,
                                                               GLsizeiptr size, const void* data);
    typedef void(GLAD_API_PTR* PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(
        GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset,
        GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n,
                                                                     const GLenum* bufs);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer,
                                                                    GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC)(GLuint framebuffer,
                                                                       GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(
        GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(
        GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(
        GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(
        GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(
        GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(
        GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level,
        GLint zoffset);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(
        GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(
        GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
    typedef void(GLAD_API_PTR* PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(
        GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(
        GLuint program, GLenum target, GLuint index, const GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(
        GLuint program, GLenum target, GLuint index, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(
        GLuint program, GLenum target, GLuint index, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(
        GLuint program, GLenum target, GLuint index, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(
        GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLNAMEDPROGRAMSTRINGEXTPROC)(
        GLuint program, GLenum target, GLenum format, GLsizei len, const void* string);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(
        GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(
        GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(
        GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(
        GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(
        GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(
        GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLNAMEDSTRINGARBPROC)(
        GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string);
    typedef GLuint(GLAD_API_PTR* PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const void* pointer,
                                                              GLenum usage);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3FVERTEX3FSUNPROC)(GLfloat nx, GLfloat ny, GLfloat nz,
                                                             GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3FVERTEX3FVSUNPROC)(const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3HNVPROC)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3XOESPROC)(GLfixed nx, GLfixed ny, GLfixed nz);
    typedef void(GLAD_API_PTR* PFNGLNORMAL3XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLNORMALFORMATNVPROC)(GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride,
                                                          GLsizei count, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLNORMALPOINTERLISTIBMPROC)(
        GLenum type, GLint stride, const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const void** pointer);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte nx, GLbyte ny,
                                                           GLbyte nz);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble nx, GLdouble ny,
                                                           GLdouble nz);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble* coords);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat nx, GLfloat ny,
                                                           GLfloat nz);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint nx, GLint ny,
                                                           GLint nz);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint* coords);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort nx, GLshort ny,
                                                           GLshort nz);
    typedef void(GLAD_API_PTR* PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort* coords);
    typedef void(GLAD_API_PTR* PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length,
                                                     const GLchar* label);
    typedef void(GLAD_API_PTR* PFNGLOBJECTPTRLABELPROC)(const void* ptr, GLsizei length,
                                                        const GLchar* label);
    typedef GLenum(GLAD_API_PTR* PFNGLOBJECTPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name,
                                                                GLenum option);
    typedef GLenum(GLAD_API_PTR* PFNGLOBJECTUNPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name,
                                                                  GLenum option);
    typedef void(GLAD_API_PTR* PFNGLORTHOFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t,
                                                   GLfloat n, GLfloat f);
    typedef void(GLAD_API_PTR* PFNGLORTHOXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t,
                                                   GLfixed n, GLfixed f);
    typedef void(GLAD_API_PTR* PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
    typedef void(GLAD_API_PTR* PFNGLPASSTHROUGHXOESPROC)(GLfixed token);
    typedef void(GLAD_API_PTR* PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat* values);
    typedef void(GLAD_API_PTR* PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
    typedef void(GLAD_API_PTR* PFNGLPATHCOMMANDSNVPROC)(GLuint path, GLsizei numCommands,
                                                        const GLubyte* commands, GLsizei numCoords,
                                                        GLenum coordType, const void* coords);
    typedef void(GLAD_API_PTR* PFNGLPATHCOORDSNVPROC)(GLuint path, GLsizei numCoords,
                                                      GLenum coordType, const void* coords);
    typedef void(GLAD_API_PTR* PFNGLPATHCOVERDEPTHFUNCNVPROC)(GLenum func);
    typedef void(GLAD_API_PTR* PFNGLPATHDASHARRAYNVPROC)(GLuint path, GLsizei dashCount,
                                                         const GLfloat* dashArray);
    typedef GLenum(GLAD_API_PTR* PFNGLPATHGLYPHINDEXARRAYNVPROC)(
        GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle,
        GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
    typedef GLenum(GLAD_API_PTR* PFNGLPATHGLYPHINDEXRANGENVPROC)(
        GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint pathParameterTemplate,
        GLfloat emScale, GLuint* baseAndCount);
    typedef void(GLAD_API_PTR* PFNGLPATHGLYPHRANGENVPROC)(
        GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle,
        GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs,
        GLuint pathParameterTemplate, GLfloat emScale);
    typedef void(GLAD_API_PTR* PFNGLPATHGLYPHSNVPROC)(
        GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle,
        GLsizei numGlyphs, GLenum type, const void* charcodes, GLenum handleMissingGlyphs,
        GLuint pathParameterTemplate, GLfloat emScale);
    typedef GLenum(GLAD_API_PTR* PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC)(
        GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void* fontData,
        GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate,
        GLfloat emScale);
    typedef void(GLAD_API_PTR* PFNGLPATHPARAMETERFNVPROC)(GLuint path, GLenum pname, GLfloat value);
    typedef void(GLAD_API_PTR* PFNGLPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname,
                                                           const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPATHPARAMETERINVPROC)(GLuint path, GLenum pname, GLint value);
    typedef void(GLAD_API_PTR* PFNGLPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname,
                                                           const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPATHSTENCILDEPTHOFFSETNVPROC)(GLfloat factor, GLfloat units);
    typedef void(GLAD_API_PTR* PFNGLPATHSTENCILFUNCNVPROC)(GLenum func, GLint ref, GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLPATHSTRINGNVPROC)(GLuint path, GLenum format, GLsizei length,
                                                      const void* pathString);
    typedef void(GLAD_API_PTR* PFNGLPATHSUBCOMMANDSNVPROC)(
        GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands,
        const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void* coords);
    typedef void(GLAD_API_PTR* PFNGLPATHSUBCOORDSNVPROC)(
        GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
    typedef void(GLAD_API_PTR* PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLPAUSETRANSFORMFEEDBACKNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length,
                                                          const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLPIXELMAPXPROC)(GLenum map, GLint size, const GLfixed* values);
    typedef void(GLAD_API_PTR* PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLPIXELSTOREXPROC)(GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTEXGENPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname,
                                                                    const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPIXELTEXGENPARAMETERISGISPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname,
                                                                    const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPIXELTEXGENSGIXPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLPIXELTRANSFERXOESPROC)(GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname,
                                                                     GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname,
                                                                      const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname,
                                                                     GLint param);
    typedef void(GLAD_API_PTR* PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname,
                                                                      const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPIXELZOOMXOESPROC)(GLfixed xfactor, GLfixed yfactor);
    typedef GLboolean(GLAD_API_PTR* PFNGLPOINTALONGPATHNVPROC)(
        GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x,
        GLfloat* y, GLfloat* tangentX, GLfloat* tangentY);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERFVSGISPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTPARAMETERXVOESPROC)(GLenum pname, const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLPOINTSIZEPROC)(GLfloat size);
    typedef void(GLAD_API_PTR* PFNGLPOINTSIZEXOESPROC)(GLfixed size);
    typedef GLint(GLAD_API_PTR* PFNGLPOLLASYNCSGIXPROC)(GLuint* markerp);
    typedef GLint(GLAD_API_PTR* PFNGLPOLLINSTRUMENTSSGIXPROC)(GLint* marker_p);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units,
                                                            GLfloat clamp);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONOFFSETCLAMPEXTPROC)(GLfloat factor, GLfloat units,
                                                               GLfloat clamp);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
    typedef void(GLAD_API_PTR* PFNGLPOLYGONOFFSETXOESPROC)(GLfixed factor, GLfixed units);
    typedef void(GLAD_API_PTR* PFNGLPOPDEBUGGROUPPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLPOPGROUPMARKEREXTPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLPRESENTFRAMEDUALFILLNVPROC)(
        GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId,
        GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1,
        GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
    typedef void(GLAD_API_PTR* PFNGLPRESENTFRAMEKEYEDNVPROC)(
        GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId,
        GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0,
        GLenum target1, GLuint fill1, GLuint key1);
    typedef void(GLAD_API_PTR* PFNGLPRIMITIVEBOUNDINGBOXARBPROC)(
        GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY,
        GLfloat maxZ, GLfloat maxW);
    typedef void(GLAD_API_PTR* PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
    typedef void(GLAD_API_PTR* PFNGLPRIMITIVERESTARTNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint* textures,
                                                               const GLclampf* priorities);
    typedef void(GLAD_API_PTR* PFNGLPRIORITIZETEXTURESXOESPROC)(GLsizei n, const GLuint* textures,
                                                                const GLfixed* priorities);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat,
                                                       const void* binary, GLsizei length);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(
        GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(
        GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(
        GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETER4DARBPROC)(
        GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index,
                                                                   const GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETER4FARBPROC)(
        GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index,
                                                                   const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERI4INVPROC)(
        GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index,
                                                                   const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERI4UINVPROC)(
        GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index,
                                                                    const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(
        GLenum target, GLuint index, GLsizei count, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(
        GLenum target, GLuint index, GLsizei count, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(
        GLenum target, GLuint index, GLsizei count, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(
        GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index,
                                                                     const GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(
        GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index,
                                                                     const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(
        GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index,
                                                                     const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(
        GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index,
                                                                      const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(
        GLenum target, GLuint index, GLsizei count, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(
        GLenum target, GLuint index, GLsizei count, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(
        GLenum target, GLuint index, GLsizei count, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(
        GLuint id, GLsizei len, const GLubyte* name, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETER4DNVPROC)(
        GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index,
                                                               const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETER4FNVPROC)(
        GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index,
                                                               const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname,
                                                           GLint value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETERIARBPROC)(GLuint program, GLenum pname,
                                                              GLint value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname,
                                                              GLint value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index,
                                                                GLsizei count, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index,
                                                                GLsizei count, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC)(
        GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len,
                                                          const void* string);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC)(
        GLenum target, GLsizei count, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location,
                                                          GLdouble v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1DEXTPROC)(GLuint program, GLint location,
                                                             GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1DVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location,
                                                          GLfloat v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1FEXTPROC)(GLuint program, GLint location,
                                                             GLfloat v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1FVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1I64ARBPROC)(GLuint program, GLint location,
                                                               GLint64 x);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1I64NVPROC)(GLuint program, GLint location,
                                                              GLint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1I64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1I64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1IEXTPROC)(GLuint program, GLint location,
                                                             GLint v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1IVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location,
                                                           GLuint v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UI64ARBPROC)(GLuint program, GLint location,
                                                                GLuint64 x);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UI64NVPROC)(GLuint program, GLint location,
                                                               GLuint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UI64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UIEXTPROC)(GLuint program, GLint location,
                                                              GLuint v0);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location,
                                                            GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM1UIVEXTPROC)(GLuint program, GLint location,
                                                               GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location,
                                                          GLdouble v0, GLdouble v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2DEXTPROC)(GLuint program, GLint location,
                                                             GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2DVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location,
                                                          GLfloat v0, GLfloat v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2FEXTPROC)(GLuint program, GLint location,
                                                             GLfloat v0, GLfloat v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2FVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0,
                                                          GLint v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2I64ARBPROC)(GLuint program, GLint location,
                                                               GLint64 x, GLint64 y);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2I64NVPROC)(GLuint program, GLint location,
                                                              GLint64EXT x, GLint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2I64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2I64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2IEXTPROC)(GLuint program, GLint location,
                                                             GLint v0, GLint v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2IVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location,
                                                           GLuint v0, GLuint v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UI64ARBPROC)(GLuint program, GLint location,
                                                                GLuint64 x, GLuint64 y);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UI64NVPROC)(GLuint program, GLint location,
                                                               GLuint64EXT x, GLuint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UI64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UIEXTPROC)(GLuint program, GLint location,
                                                              GLuint v0, GLuint v1);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location,
                                                            GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM2UIVEXTPROC)(GLuint program, GLint location,
                                                               GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location,
                                                          GLdouble v0, GLdouble v1, GLdouble v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3DEXTPROC)(GLuint program, GLint location,
                                                             GLdouble x, GLdouble y, GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3DVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location,
                                                          GLfloat v0, GLfloat v1, GLfloat v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3FEXTPROC)(GLuint program, GLint location,
                                                             GLfloat v0, GLfloat v1, GLfloat v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3FVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0,
                                                          GLint v1, GLint v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3I64ARBPROC)(GLuint program, GLint location,
                                                               GLint64 x, GLint64 y, GLint64 z);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3I64NVPROC)(
        GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3I64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3I64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3IEXTPROC)(GLuint program, GLint location,
                                                             GLint v0, GLint v1, GLint v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3IVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location,
                                                           GLuint v0, GLuint v1, GLuint v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UI64ARBPROC)(GLuint program, GLint location,
                                                                GLuint64 x, GLuint64 y, GLuint64 z);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UI64NVPROC)(
        GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UI64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UIEXTPROC)(GLuint program, GLint location,
                                                              GLuint v0, GLuint v1, GLuint v2);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location,
                                                            GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM3UIVEXTPROC)(GLuint program, GLint location,
                                                               GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4DPROC)(
        GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4DEXTPROC)(
        GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4DVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4FPROC)(
        GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4FEXTPROC)(
        GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4FVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0,
                                                          GLint v1, GLint v2, GLint v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4I64ARBPROC)(
        GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4I64NVPROC)(
        GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4I64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4I64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4IEXTPROC)(
        GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location,
                                                           GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4IVEXTPROC)(GLuint program, GLint location,
                                                              GLsizei count, const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UIPROC)(
        GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UI64ARBPROC)(
        GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UI64NVPROC)(
        GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UI64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UIEXTPROC)(
        GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location,
                                                            GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORM4UIVEXTPROC)(GLuint program, GLint location,
                                                               GLsizei count, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC)(GLuint program, GLint location,
                                                                     GLuint64 value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC)(GLuint program, GLint location,
                                                                    GLuint64 value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* values);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64* values);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(
        GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMUI64NVPROC)(GLuint program, GLint location,
                                                              GLuint64EXT value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMUNIFORMUI64VNVPROC)(
        GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
    typedef void(GLAD_API_PTR* PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLPROVOKINGVERTEXEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length,
                                                        const GLchar* message);
    typedef void(GLAD_API_PTR* PFNGLPUSHGROUPMARKEREXTPROC)(GLsizei length, const GLchar* marker);
    typedef void(GLAD_API_PTR* PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
    typedef GLbitfield(GLAD_API_PTR* PFNGLQUERYMATRIXXOESPROC)(GLfixed* mantissa, GLint* exponent);
    typedef void(GLAD_API_PTR* PFNGLQUERYOBJECTPARAMETERUIAMDPROC)(GLenum target, GLuint id,
                                                                   GLenum pname, GLuint param);
    typedef GLint(GLAD_API_PTR* PFNGLQUERYRESOURCENVPROC)(GLenum queryType, GLint tagId,
                                                          GLuint count, GLint* buffer);
    typedef void(GLAD_API_PTR* PFNGLQUERYRESOURCETAGNVPROC)(GLint tagId, const GLchar* tagString);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS2XOESPROC)(GLfixed x, GLfixed y);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS2XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS3XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS3XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS4XOESPROC)(GLfixed x, GLfixed y, GLfixed z, GLfixed w);
    typedef void(GLAD_API_PTR* PFNGLRASTERPOS4XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLRASTERSAMPLESEXTPROC)(GLuint samples,
                                                          GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLREADBUFFERPROC)(GLenum src);
    typedef void(GLAD_API_PTR* PFNGLREADINSTRUMENTSSGIXPROC)(GLint marker);
    typedef void(GLAD_API_PTR* PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height,
                                                    GLenum format, GLenum type, void* pixels);
    typedef void(GLAD_API_PTR* PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width,
                                                     GLsizei height, GLenum format, GLenum type,
                                                     GLsizei bufSize, void* data);
    typedef void(GLAD_API_PTR* PFNGLREADNPIXELSARBPROC)(GLint x, GLint y, GLsizei width,
                                                        GLsizei height, GLenum format, GLenum type,
                                                        GLsizei bufSize, void* data);
    typedef void(GLAD_API_PTR* PFNGLRECTXOESPROC)(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);
    typedef void(GLAD_API_PTR* PFNGLRECTXVOESPROC)(const GLfixed* v1, const GLfixed* v2);
    typedef void(GLAD_API_PTR* PFNGLREFERENCEPLANESGIXPROC)(const GLdouble* equation);
    typedef GLboolean(GLAD_API_PTR* PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key);
    typedef void(GLAD_API_PTR* PFNGLRELEASESHADERCOMPILERPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLRENDERGPUMASKNVPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat,
                                                             GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEEXTPROC)(
        GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(
        GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(
        GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat,
        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEPOINTERSUNPROC)(GLenum type, GLsizei stride,
                                                                   const void** pointer);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUBSUNPROC)(GLubyte code);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUBVSUNPROC)(const GLubyte* code);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz,
        GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* c, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(
        GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLubyte* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUISUNPROC)(GLuint code);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx,
        GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y,
        GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* tc, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(
        GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(
        const GLuint* rc, const GLfloat* tc, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(GLuint rc, GLfloat x,
                                                                      GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const GLuint* rc,
                                                                       const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUIVSUNPROC)(const GLuint* code);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUSSUNPROC)(GLushort code);
    typedef void(GLAD_API_PTR* PFNGLREPLACEMENTCODEUSVSUNPROC)(const GLushort* code);
    typedef void(GLAD_API_PTR* PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n,
                                                                   const GLuint* programs);
    typedef void(GLAD_API_PTR* PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLRESETMEMORYOBJECTPARAMETERNVPROC)(GLuint memory, GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLRESETMINMAXEXTPROC)(GLenum target);
    typedef void(GLAD_API_PTR* PFNGLRESIZEBUFFERSMESAPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLRESOLVEDEPTHVALUESNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLRESUMETRANSFORMFEEDBACKNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLROTATEXOESPROC)(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
    typedef void(GLAD_API_PTR* PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
    typedef void(GLAD_API_PTR* PFNGLSAMPLECOVERAGEARBPROC)(GLfloat value, GLboolean invert);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEMASKINDEXEDNVPROC)(GLuint index, GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEMASKSGISPROC)(GLclampf value, GLboolean invert);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
    typedef void(GLAD_API_PTR* PFNGLSAMPLEPATTERNSGISPROC)(GLenum pattern);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname,
                                                             const GLint* param);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname,
                                                              const GLuint* param);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname,
                                                           GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname,
                                                            const GLfloat* param);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname,
                                                           GLint param);
    typedef void(GLAD_API_PTR* PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname,
                                                            const GLint* param);
    typedef void(GLAD_API_PTR* PFNGLSCALEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
    typedef void(GLAD_API_PTR* PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLSCISSOREXCLUSIVEARRAYVNVPROC)(GLuint first, GLsizei count,
                                                                  const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLSCISSOREXCLUSIVENVPROC)(GLint x, GLint y, GLsizei width,
                                                            GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom,
                                                        GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green,
                                                             GLdouble blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green,
                                                             GLfloat blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green,
                                                            GLhalfNV blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green,
                                                             GLshort blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green,
                                                              GLubyte blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green,
                                                              GLushort blue);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLORFORMATNVPROC)(GLint size, GLenum type,
                                                                GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLORPOINTEREXTPROC)(
        GLint size, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(
        GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(
        GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
    typedef void(GLAD_API_PTR* PFNGLSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname,
                                                                const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname,
                                                                    const GLuint64* params);
    typedef void(GLAD_API_PTR* PFNGLSEPARABLEFILTER2DEXTPROC)(
        GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
        GLenum type, const void* row, const void* column);
    typedef void(GLAD_API_PTR* PFNGLSETFENCEAPPLEPROC)(GLuint fence);
    typedef void(GLAD_API_PTR* PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
    typedef void(GLAD_API_PTR* PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst,
                                                                      const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, const void* addr);
    typedef void(GLAD_API_PTR* PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type,
                                                             const void* addr);
    typedef void(GLAD_API_PTR* PFNGLSETMULTISAMPLEFVAMDPROC)(GLenum pname, GLuint index,
                                                             const GLfloat* val);
    typedef void(GLAD_API_PTR* PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint* shaders,
                                                      GLenum binaryFormat, const void* binary,
                                                      GLsizei length);
    typedef void(GLAD_API_PTR* PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
    typedef void(GLAD_API_PTR* PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1,
                                                      GLuint arg2);
    typedef void(GLAD_API_PTR* PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1,
                                                      GLuint arg2, GLuint arg3);
    typedef void(GLAD_API_PTR* PFNGLSHADERSOURCEPROC)(
        GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);
    typedef void(GLAD_API_PTR* PFNGLSHADERSOURCEARBPROC)(
        GLhandleARB shaderObj, GLsizei count, const GLcharARB** string, const GLint* length);
    typedef void(GLAD_API_PTR* PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(
        GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
    typedef void(GLAD_API_PTR* PFNGLSHADINGRATEIMAGEBARRIERNVPROC)(GLboolean synchronize);
    typedef void(GLAD_API_PTR* PFNGLSHADINGRATEIMAGEPALETTENVPROC)(
        GLuint viewport, GLuint first, GLsizei count, const GLenum* rates);
    typedef void(GLAD_API_PTR* PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC)(GLenum rate, GLuint samples,
                                                                        const GLint* locations);
    typedef void(GLAD_API_PTR* PFNGLSHADINGRATESAMPLEORDERNVPROC)(GLenum order);
    typedef void(GLAD_API_PTR* PFNGLSHARPENTEXFUNCSGISPROC)(GLenum target, GLsizei n,
                                                            const GLfloat* points);
    typedef void(GLAD_API_PTR* PFNGLSIGNALSEMAPHOREEXTPROC)(
        GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers,
        GLuint numTextureBarriers, const GLuint* textures, const GLenum* dstLayouts);
    typedef void(GLAD_API_PTR* PFNGLSIGNALSEMAPHOREUI64NVXPROC)(
        GLuint signalGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray,
        const GLuint64* fenceValueArray);
    typedef void(GLAD_API_PTR* PFNGLSIGNALVKFENCENVPROC)(GLuint64 vkFence);
    typedef void(GLAD_API_PTR* PFNGLSIGNALVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
    typedef void(GLAD_API_PTR* PFNGLSPECIALIZESHADERPROC)(
        GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants,
        const GLuint* pConstantIndex, const GLuint* pConstantValue);
    typedef void(GLAD_API_PTR* PFNGLSPECIALIZESHADERARBPROC)(
        GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants,
        const GLuint* pConstantIndex, const GLuint* pConstantValue);
    typedef void(GLAD_API_PTR* PFNGLSPRITEPARAMETERFSGIXPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLSPRITEPARAMETERFVSGIXPROC)(GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLSPRITEPARAMETERISGIXPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLSPRITEPARAMETERIVSGIXPROC)(GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLSTARTINSTRUMENTSSGIXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLSTATECAPTURENVPROC)(GLuint state, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLSTENCILCLEARTAGEXTPROC)(GLsizei stencilTagBits,
                                                            GLuint stencilClearTag);
    typedef void(GLAD_API_PTR* PFNGLSTENCILFILLPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode,
        GLuint mask, GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLSTENCILFILLPATHNVPROC)(GLuint path, GLenum fillMode,
                                                           GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref,
                                                             GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc,
                                                                GLint ref, GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILMASKPROC)(GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
    typedef void(GLAD_API_PTR* PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail,
                                                           GLenum dppass);
    typedef void(GLAD_API_PTR* PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail,
                                                              GLenum dpfail, GLenum dppass);
    typedef void(GLAD_API_PTR* PFNGLSTENCILOPVALUEAMDPROC)(GLenum face, GLuint value);
    typedef void(GLAD_API_PTR* PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference,
        GLuint mask, GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLSTENCILSTROKEPATHNVPROC)(GLuint path, GLint reference,
                                                             GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode,
        GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLSTENCILTHENCOVERFILLPATHNVPROC)(GLuint path, GLenum fillMode,
                                                                    GLuint mask, GLenum coverMode);
    typedef void(GLAD_API_PTR* PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC)(
        GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference,
        GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC)(
        GLuint path, GLint reference, GLuint mask, GLenum coverMode);
    typedef void(GLAD_API_PTR* PFNGLSTOPINSTRUMENTSSGIXPROC)(GLint marker);
    typedef void(GLAD_API_PTR* PFNGLSTRINGMARKERGREMEDYPROC)(GLsizei len, const void* string);
    typedef void(GLAD_API_PTR* PFNGLSUBPIXELPRECISIONBIASNVPROC)(GLuint xbits, GLuint ybits);
    typedef void(GLAD_API_PTR* PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY,
                                                    GLenum outZ, GLenum outW);
    typedef void(GLAD_API_PTR* PFNGLSYNCTEXTUREINTELPROC)(GLuint texture);
    typedef void(GLAD_API_PTR* PFNGLTAGSAMPLEBUFFERSGIXPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3BEXTPROC)(GLbyte tx, GLbyte ty, GLbyte tz);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3BVEXTPROC)(const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3DEXTPROC)(GLdouble tx, GLdouble ty, GLdouble tz);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3DVEXTPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3FEXTPROC)(GLfloat tx, GLfloat ty, GLfloat tz);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3FVEXTPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3IEXTPROC)(GLint tx, GLint ty, GLint tz);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3IVEXTPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3SEXTPROC)(GLshort tx, GLshort ty, GLshort tz);
    typedef void(GLAD_API_PTR* PFNGLTANGENT3SVEXTPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride,
                                                           const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLTBUFFERMASK3DFXPROC)(GLuint mask);
    typedef void(GLAD_API_PTR* PFNGLTESSELLATIONFACTORAMDPROC)(GLfloat factor);
    typedef void(GLAD_API_PTR* PFNGLTESSELLATIONMODEAMDPROC)(GLenum mode);
    typedef GLboolean(GLAD_API_PTR* PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
    typedef GLboolean(GLAD_API_PTR* PFNGLTESTFENCENVPROC)(GLuint fence);
    typedef GLboolean(GLAD_API_PTR* PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
    typedef void(GLAD_API_PTR* PFNGLTEXATTACHMEMORYNVPROC)(GLenum target, GLuint memory,
                                                           GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat,
                                                   GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTEXBUFFERARBPROC)(GLenum target, GLenum internalformat,
                                                      GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat,
                                                      GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTEXBUFFERRANGEPROC)(
        GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, const GLfloat* param);
    typedef void(GLAD_API_PTR* PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, const GLint* param);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1BOESPROC)(GLbyte s);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1HNVPROC)(GLhalfNV s);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1XOESPROC)(GLfixed s);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD1XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2BOESPROC)(GLbyte s, GLbyte t);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(
        GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(
        const GLfloat* tc, const GLfloat* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(
        GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny,
        GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(
        const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(
        GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y,
        GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(
        const GLfloat* tc, const GLubyte* c, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(
        GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(
        const GLfloat* tc, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat x,
                                                               GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const GLfloat* tc, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2HNVPROC)(GLhalfNV s, GLhalfNV t);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2XOESPROC)(GLfixed s, GLfixed t);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD2XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3BOESPROC)(GLbyte s, GLbyte t, GLbyte r);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3XOESPROC)(GLfixed s, GLfixed t, GLfixed r);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD3XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4BOESPROC)(GLbyte s, GLbyte t, GLbyte r, GLbyte q);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(
        GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a,
        GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(
        const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4FVERTEX4FSUNPROC)(
        GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const GLfloat* tc, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r,
                                                      GLhalfNV q);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4XOESPROC)(GLfixed s, GLfixed t, GLfixed r, GLfixed q);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORD4XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORDFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride,
                                                            GLsizei count, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORDPOINTERLISTIBMPROC)(
        GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type,
                                                               const void** pointer);
    typedef void(GLAD_API_PTR* PFNGLTEXENVXOESPROC)(GLenum target, GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLTEXENVXVOESPROC)(GLenum target, GLenum pname,
                                                     const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLsizei n,
                                                           const GLfloat* weights);
    typedef void(GLAD_API_PTR* PFNGLTEXGENXOESPROC)(GLenum coord, GLenum pname, GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLTEXGENXVOESPROC)(GLenum coord, GLenum pname,
                                                     const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE1DPROC)(
        GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border,
        GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE2DPROC)(
        GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
        GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE2DMULTISAMPLEPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(
        GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat,
        GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE3DPROC)(
        GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE3DEXTPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE3DMULTISAMPLEPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(
        GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat,
        GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXIMAGE4DSGISPROC)(
        GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXPAGECOMMITMENTARBPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLTEXPAGECOMMITMENTMEMNVPROC)(
        GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset,
        GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname,
                                                         const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname,
                                                            const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname,
                                                          const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname,
                                                             const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname,
                                                        const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname,
                                                        const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERXOESPROC)(GLenum target, GLenum pname,
                                                          GLfixed param);
    typedef void(GLAD_API_PTR* PFNGLTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname,
                                                           const GLfixed* params);
    typedef void(GLAD_API_PTR* PFNGLTEXRENDERBUFFERNVPROC)(GLenum target, GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels,
                                                      GLenum internalformat, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE1DEXTPROC)(GLenum target, GLsizei levels,
                                                         GLenum internalformat, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE2DPROC)(
        GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE2DEXTPROC)(
        GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels,
                                                      GLenum internalformat, GLsizei width,
                                                      GLsizei height, GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE3DEXTPROC)(GLenum target, GLsizei levels,
                                                         GLenum internalformat, GLsizei width,
                                                         GLsizei height, GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(
        GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGEMEM1DEXTPROC)(GLenum target, GLsizei levels,
                                                            GLenum internalFormat, GLsizei width,
                                                            GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGEMEM2DEXTPROC)(
        GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height,
        GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC)(
        GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height,
        GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGEMEM3DEXTPROC)(
        GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height,
        GLsizei depth, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC)(
        GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height,
        GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXSTORAGESPARSEAMDPROC)(
        GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth,
        GLsizei layers, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset,
                                                       GLsizei width, GLenum format, GLenum type,
                                                       const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset,
                                                          GLsizei width, GLenum format, GLenum type,
                                                          const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE2DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE2DEXTPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE3DPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE3DEXTPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXSUBIMAGE4DSGISPROC)(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset,
        GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREATTACHMEMORYNVPROC)(GLuint texture, GLuint memory,
                                                               GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBARRIERPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBARRIERNVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat,
                                                       GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBUFFEREXTPROC)(GLuint texture, GLenum target,
                                                          GLenum internalformat, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBUFFERRANGEPROC)(
        GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREBUFFERRANGEEXTPROC)(GLuint texture, GLenum target,
                                                               GLenum internalformat, GLuint buffer,
                                                               GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLTEXTURECOLORMASKSGISPROC)(GLboolean red, GLboolean green,
                                                              GLboolean blue, GLboolean alpha);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(
        GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples,
        GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(
        GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width,
        GLsizei height, GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width,
        GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(
        GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples,
        GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth,
        GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(
        GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width,
        GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPAGECOMMITMENTEXTPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC)(
        GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset,
        GLboolean commit);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname,
                                                             const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target,
                                                                GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname,
                                                              const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIUIVEXTPROC)(
        GLuint texture, GLenum target, GLenum pname, const GLuint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname,
                                                           GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERFEXTPROC)(GLuint texture, GLenum target,
                                                              GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname,
                                                            const GLfloat* param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target,
                                                               GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname,
                                                           GLint param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIEXTPROC)(GLuint texture, GLenum target,
                                                              GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname,
                                                            const GLint* param);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target,
                                                               GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLTEXTURERANGEAPPLEPROC)(GLenum target, GLsizei length,
                                                           const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLTEXTURERENDERBUFFEREXTPROC)(GLuint texture, GLenum target,
                                                                GLuint renderbuffer);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels,
                                                          GLenum internalformat, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE2DPROC)(
        GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE2DEXTPROC)(GLuint texture, GLenum target,
                                                             GLsizei levels, GLenum internalformat,
                                                             GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(
        GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC)(
        GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width,
        GLsizei height, GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels,
                                                          GLenum internalformat, GLsizei width,
                                                          GLsizei height, GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width,
        GLsizei height, GLsizei depth);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(
        GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height,
        GLsizei depth, GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC)(
        GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width,
        GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGEMEM1DEXTPROC)(
        GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory,
        GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGEMEM2DEXTPROC)(
        GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height,
        GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC)(
        GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height,
        GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGEMEM3DEXTPROC)(
        GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height,
        GLsizei depth, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC)(
        GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height,
        GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESTORAGESPARSEAMDPROC)(
        GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height,
        GLsizei depth, GLsizei layers, GLbitfield flags);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE1DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE1DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format,
        GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE2DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE2DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
        GLsizei height, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE3DPROC)(
        GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width,
        GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTURESUBIMAGE3DEXTPROC)(
        GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
        GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,
        const void* pixels);
    typedef void(GLAD_API_PTR* PFNGLTEXTUREVIEWPROC)(
        GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel,
        GLuint numlevels, GLuint minlayer, GLuint numlayers);
    typedef void(GLAD_API_PTR* PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix,
                                                       GLenum transform);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(
        GLsizei count, const GLint* attribs, GLenum bufferMode);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index,
                                                                     GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(
        GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC)(
        GLsizei count, const GLint* attribs, GLsizei nbuffers, const GLint* bufstreams,
        GLenum bufferMode);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(
        GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(
        GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(
        GLuint program, GLsizei count, const GLint* locations, GLenum bufferMode);
    typedef void(GLAD_API_PTR* PFNGLTRANSFORMPATHNVPROC)(
        GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
    typedef void(GLAD_API_PTR* PFNGLTRANSLATEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count,
                                                    const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count,
                                                    const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count,
                                                       const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1I64ARBPROC)(GLint location, GLint64 x);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1I64NVPROC)(GLint location, GLint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1I64VARBPROC)(GLint location, GLsizei count,
                                                         const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1I64VNVPROC)(GLint location, GLsizei count,
                                                        const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count,
                                                    const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count,
                                                       const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UI64ARBPROC)(GLint location, GLuint64 x);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UI64NVPROC)(GLint location, GLuint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UI64VARBPROC)(GLint location, GLsizei count,
                                                          const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UI64VNVPROC)(GLint location, GLsizei count,
                                                         const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count,
                                                     const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count,
                                                        const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count,
                                                    const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count,
                                                    const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count,
                                                       const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2I64ARBPROC)(GLint location, GLint64 x, GLint64 y);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2I64VARBPROC)(GLint location, GLsizei count,
                                                         const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2I64VNVPROC)(GLint location, GLsizei count,
                                                        const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count,
                                                    const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count,
                                                       const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UI64NVPROC)(GLint location, GLuint64EXT x,
                                                        GLuint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UI64VARBPROC)(GLint location, GLsizei count,
                                                          const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UI64VNVPROC)(GLint location, GLsizei count,
                                                         const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count,
                                                     const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count,
                                                        const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y,
                                                   GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count,
                                                    const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1,
                                                   GLfloat v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1,
                                                      GLfloat v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count,
                                                    const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count,
                                                       const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3I64ARBPROC)(GLint location, GLint64 x, GLint64 y,
                                                        GLint64 z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y,
                                                       GLint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3I64VARBPROC)(GLint location, GLsizei count,
                                                         const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3I64VNVPROC)(GLint location, GLsizei count,
                                                        const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count,
                                                    const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count,
                                                       const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y,
                                                         GLuint64 z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UI64NVPROC)(GLint location, GLuint64EXT x,
                                                        GLuint64EXT y, GLuint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UI64VARBPROC)(GLint location, GLsizei count,
                                                          const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UI64VNVPROC)(GLint location, GLsizei count,
                                                         const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1,
                                                       GLuint v2);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count,
                                                     const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count,
                                                        const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y,
                                                   GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count,
                                                    const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1,
                                                   GLfloat v2, GLfloat v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1,
                                                      GLfloat v2, GLfloat v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count,
                                                    const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count,
                                                       const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2,
                                                   GLint v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4I64ARBPROC)(GLint location, GLint64 x, GLint64 y,
                                                        GLint64 z, GLint64 w);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y,
                                                       GLint64EXT z, GLint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4I64VARBPROC)(GLint location, GLsizei count,
                                                         const GLint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4I64VNVPROC)(GLint location, GLsizei count,
                                                        const GLint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2,
                                                      GLint v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count,
                                                    const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count,
                                                       const GLint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2,
                                                    GLuint v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y,
                                                         GLuint64 z, GLuint64 w);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UI64NVPROC)(
        GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UI64VARBPROC)(GLint location, GLsizei count,
                                                          const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UI64VNVPROC)(GLint location, GLsizei count,
                                                         const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1,
                                                       GLuint v2, GLuint v3);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count,
                                                     const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count,
                                                        const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMBLOCKBINDINGPROC)(
        GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location,
                                                          GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMHANDLEUI64ARBPROC)(GLint location, GLuint64 value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMHANDLEUI64NVPROC)(GLint location, GLuint64 value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMHANDLEUI64VARBPROC)(GLint location, GLsizei count,
                                                               const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMHANDLEUI64VNVPROC)(GLint location, GLsizei count,
                                                              const GLuint64* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2FVARBPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2X3DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2X3FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2X4DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX2X4FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3FVARBPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3X2DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3X2FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3X4DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX3X4FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4FVARBPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4X2DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4X2FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4X3DVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMMATRIX4X3FVPROC)(
        GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count,
                                                               const GLuint* indices);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMUI64NVPROC)(GLint location, GLuint64EXT value);
    typedef void(GLAD_API_PTR* PFNGLUNIFORMUI64VNVPROC)(GLint location, GLsizei count,
                                                        const GLuint64EXT* value);
    typedef void(GLAD_API_PTR* PFNGLUNLOCKARRAYSEXTPROC)(void);
    typedef GLboolean(GLAD_API_PTR* PFNGLUNMAPBUFFERPROC)(GLenum target);
    typedef GLboolean(GLAD_API_PTR* PFNGLUNMAPBUFFERARBPROC)(GLenum target);
    typedef GLboolean(GLAD_API_PTR* PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
    typedef GLboolean(GLAD_API_PTR* PFNGLUNMAPNAMEDBUFFEREXTPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLUNMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level);
    typedef void(GLAD_API_PTR* PFNGLUPDATEOBJECTBUFFERATIPROC)(
        GLuint buffer, GLuint offset, GLsizei size, const void* pointer, GLenum preserve);
    typedef void(GLAD_API_PTR* PFNGLUPLOADGPUMASKNVXPROC)(GLbitfield mask);
    typedef void(GLAD_API_PTR* PFNGLUSEPROGRAMPROC)(GLuint program);
    typedef void(GLAD_API_PTR* PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
    typedef void(GLAD_API_PTR* PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages,
                                                          GLuint program);
    typedef void(GLAD_API_PTR* PFNGLUSESHADERPROGRAMEXTPROC)(GLenum type, GLuint program);
    typedef void(GLAD_API_PTR* PFNGLVDPAUFININVPROC)(void);
    typedef void(GLAD_API_PTR* PFNGLVDPAUGETSURFACEIVNVPROC)(
        GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei* length, GLint* values);
    typedef void(GLAD_API_PTR* PFNGLVDPAUINITNVPROC)(const void* vdpDevice,
                                                     const void* getProcAddress);
    typedef GLboolean(GLAD_API_PTR* PFNGLVDPAUISSURFACENVPROC)(GLvdpauSurfaceNV surface);
    typedef void(GLAD_API_PTR* PFNGLVDPAUMAPSURFACESNVPROC)(GLsizei numSurfaces,
                                                            const GLvdpauSurfaceNV* surfaces);
    typedef GLvdpauSurfaceNV(GLAD_API_PTR* PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)(
        const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames);
    typedef GLvdpauSurfaceNV(GLAD_API_PTR* PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)(
        const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames);
    typedef GLvdpauSurfaceNV(GLAD_API_PTR* PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC)(
        const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames,
        GLboolean isFrameStructure);
    typedef void(GLAD_API_PTR* PFNGLVDPAUSURFACEACCESSNVPROC)(GLvdpauSurfaceNV surface,
                                                              GLenum access);
    typedef void(GLAD_API_PTR* PFNGLVDPAUUNMAPSURFACESNVPROC)(GLsizei numSurface,
                                                              const GLvdpauSurfaceNV* surfaces);
    typedef void(GLAD_API_PTR* PFNGLVDPAUUNREGISTERSURFACENVPROC)(GLvdpauSurfaceNV surface);
    typedef void(GLAD_API_PTR* PFNGLVALIDATEPROGRAMPROC)(GLuint program);
    typedef void(GLAD_API_PTR* PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
    typedef void(GLAD_API_PTR* PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
    typedef void(GLAD_API_PTR* PFNGLVARIANTARRAYOBJECTATIPROC)(
        GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
    typedef void(GLAD_API_PTR* PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride,
                                                           const void* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTBVEXTPROC)(GLuint id, const GLbyte* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTDVEXTPROC)(GLuint id, const GLdouble* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTFVEXTPROC)(GLuint id, const GLfloat* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTIVEXTPROC)(GLuint id, const GLint* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTSVEXTPROC)(GLuint id, const GLshort* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTUBVEXTPROC)(GLuint id, const GLubyte* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTUIVEXTPROC)(GLuint id, const GLuint* addr);
    typedef void(GLAD_API_PTR* PFNGLVARIANTUSVEXTPROC)(GLuint id, const GLushort* addr);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2BOESPROC)(GLbyte x, GLbyte y);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2HNVPROC)(GLhalfNV x, GLhalfNV y);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2XOESPROC)(GLfixed x);
    typedef void(GLAD_API_PTR* PFNGLVERTEX2XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3BOESPROC)(GLbyte x, GLbyte y, GLbyte z);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3XOESPROC)(GLfixed x, GLfixed y);
    typedef void(GLAD_API_PTR* PFNGLVERTEX3XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4BOESPROC)(GLbyte x, GLbyte y, GLbyte z, GLbyte w);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4BVOESPROC)(const GLbyte* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4HVNVPROC)(const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
    typedef void(GLAD_API_PTR* PFNGLVERTEX4XVOESPROC)(const GLfixed* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex,
                                                                  GLuint bindingindex);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYATTRIBFORMATPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized,
        GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYATTRIBIFORMATPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYATTRIBLFORMATPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC)(
        GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYBINDINGDIVISORPROC)(
        GLuint vaobj, GLuint bindingindex, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYCOLOROFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYINDEXOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride,
        GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYNORMALOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC)(
        GLuint vaobj, GLuint attribindex, GLuint bindingindex);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC)(
        GLuint vaobj, GLuint index, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized,
        GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride,
        GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC)(
        GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride,
        GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized,
        GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC)(
        GLuint vaobj, GLuint bindingindex, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXBUFFERPROC)(
        GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(
        GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets,
        const GLsizei* strides);
    typedef void(GLAD_API_PTR* PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC)(
        GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalfNV x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y,
                                                        GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y,
                                                           GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y,
                                                          GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y,
                                                        GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y,
                                                           GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y,
                                                          GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y,
                                                          GLhalfNV z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y,
                                                        GLshort z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y,
                                                           GLshort z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y,
                                                          GLshort z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y,
                                                          GLubyte z, GLubyte w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y,
                                                             GLubyte z, GLubyte w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y,
                                                        GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y,
                                                           GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y,
                                                          GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y,
                                                        GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y,
                                                           GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y,
                                                          GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y,
                                                          GLhalfNV z, GLhalfNV w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y,
                                                        GLshort z, GLshort w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y,
                                                           GLshort z, GLshort w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y,
                                                          GLshort z, GLshort w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y,
                                                           GLubyte z, GLubyte w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(
        GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer,
        GLuint offset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex,
                                                             GLuint bindingindex);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBDIVISORARBPROC)(GLuint index, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBFORMATPROC)(
        GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBFORMATNVPROC)(GLuint index, GLint size, GLenum type,
                                                              GLboolean normalized, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y,
                                                          GLuint z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y,
                                                             GLuint z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z,
                                                         GLint w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z,
                                                            GLint w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y,
                                                          GLuint z, GLuint w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y,
                                                             GLuint z, GLuint w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size,
                                                             GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBIFORMATNVPROC)(GLuint index, GLint size,
                                                               GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type,
                                                              GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBIPOINTEREXTPROC)(
        GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1DEXTPROC)(GLuint index, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1DVEXTPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1I64NVPROC)(GLuint index, GLint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1I64VNVPROC)(GLuint index, const GLint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1UI64ARBPROC)(GLuint index, GLuint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1UI64NVPROC)(GLuint index, GLuint64EXT x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1UI64VARBPROC)(GLuint index, const GLuint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL1UI64VNVPROC)(GLuint index, const GLuint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2DEXTPROC)(GLuint index, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2DVEXTPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2I64NVPROC)(GLuint index, GLint64EXT x,
                                                             GLint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2I64VNVPROC)(GLuint index, const GLint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2UI64NVPROC)(GLuint index, GLuint64EXT x,
                                                              GLuint64EXT y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL2UI64VNVPROC)(GLuint index, const GLuint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y,
                                                         GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3DEXTPROC)(GLuint index, GLdouble x, GLdouble y,
                                                            GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3DVEXTPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3I64NVPROC)(GLuint index, GLint64EXT x,
                                                             GLint64EXT y, GLint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3I64VNVPROC)(GLuint index, const GLint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3UI64NVPROC)(GLuint index, GLuint64EXT x,
                                                              GLuint64EXT y, GLuint64EXT z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL3UI64VNVPROC)(GLuint index, const GLuint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y,
                                                         GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4DEXTPROC)(GLuint index, GLdouble x, GLdouble y,
                                                            GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4DVEXTPROC)(GLuint index, const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4I64NVPROC)(
        GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4I64VNVPROC)(GLuint index, const GLint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4UI64NVPROC)(
        GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBL4UI64VNVPROC)(GLuint index, const GLuint64EXT* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size,
                                                             GLenum type, GLuint relativeoffset);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBLFORMATNVPROC)(GLuint index, GLint size,
                                                               GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type,
                                                              GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBLPOINTEREXTPROC)(
        GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type,
                                                          GLboolean normalized, GLuint value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP1UIVPROC)(
        GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type,
                                                          GLboolean normalized, GLuint value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP2UIVPROC)(
        GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type,
                                                          GLboolean normalized, GLuint value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP3UIVPROC)(
        GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type,
                                                          GLboolean normalized, GLuint value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBP4UIVPROC)(
        GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBPARAMETERIAMDPROC)(GLuint index, GLenum pname,
                                                                   GLint param);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type,
                                                             GLboolean normalized, GLsizei stride,
                                                             const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBPOINTERARBPROC)(
        GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,
        const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBPOINTERNVPROC)(
        GLuint index, GLint fsize, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei count,
                                                            const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei count,
                                                            const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n,
                                                            const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei count,
                                                            const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei count,
                                                            const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei count,
                                                            const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n,
                                                            const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei count,
                                                            const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei count,
                                                            const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei count,
                                                            const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n,
                                                            const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei count,
                                                            const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei count,
                                                            const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei count,
                                                            const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n,
                                                            const GLhalfNV* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei count,
                                                            const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei count,
                                                             const GLubyte* v);
    typedef void(GLAD_API_PTR* PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
    typedef void(GLAD_API_PTR* PFNGLVERTEXBLENDARBPROC)(GLint count);
    typedef void(GLAD_API_PTR* PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
    typedef void(GLAD_API_PTR* PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
    typedef void(GLAD_API_PTR* PFNGLVERTEXFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride,
                                                          GLsizei count, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXPOINTERLISTIBMPROC)(
        GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
    typedef void(GLAD_API_PTR* PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type,
                                                             const void** pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1DATIPROC)(GLenum stream, GLdouble x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1DVATIPROC)(GLenum stream, const GLdouble* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1FATIPROC)(GLenum stream, GLfloat x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1FVATIPROC)(GLenum stream, const GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1IATIPROC)(GLenum stream, GLint x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1IVATIPROC)(GLenum stream, const GLint* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1SATIPROC)(GLenum stream, GLshort x);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM1SVATIPROC)(GLenum stream, const GLshort* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y,
                                                           GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y,
                                                           GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y,
                                                           GLshort z);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y,
                                                           GLdouble z, GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y,
                                                           GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z,
                                                           GLint w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y,
                                                           GLshort z, GLshort w);
    typedef void(GLAD_API_PTR* PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort* coords);
    typedef void(GLAD_API_PTR* PFNGLVERTEXWEIGHTPOINTEREXTPROC)(
        GLint size, GLenum type, GLsizei stride, const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
    typedef void(GLAD_API_PTR* PFNGLVERTEXWEIGHTFVEXTPROC)(const GLfloat* weight);
    typedef void(GLAD_API_PTR* PFNGLVERTEXWEIGHTHNVPROC)(GLhalfNV weight);
    typedef void(GLAD_API_PTR* PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalfNV* weight);
    typedef GLenum(GLAD_API_PTR* PFNGLVIDEOCAPTURENVPROC)(
        GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT* capture_time);
    typedef void(GLAD_API_PTR* PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
    typedef void(GLAD_API_PTR* PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
    typedef void(GLAD_API_PTR* PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC)(
        GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count,
                                                        const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y,
                                                          GLfloat w, GLfloat h);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTPOSITIONWSCALENVPROC)(GLuint index, GLfloat xcoeff,
                                                                  GLfloat ycoeff);
    typedef void(GLAD_API_PTR* PFNGLVIEWPORTSWIZZLENVPROC)(
        GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
    typedef void(GLAD_API_PTR* PFNGLWAITSEMAPHOREEXTPROC)(
        GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers,
        GLuint numTextureBarriers, const GLuint* textures, const GLenum* srcLayouts);
    typedef void(GLAD_API_PTR* PFNGLWAITSEMAPHOREUI64NVXPROC)(
        GLuint waitGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray,
        const GLuint64* fenceValueArray);
    typedef void(GLAD_API_PTR* PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
    typedef void(GLAD_API_PTR* PFNGLWAITVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTPATHSNVPROC)(GLuint resultPath, GLsizei numPaths,
                                                       const GLuint* paths, const GLfloat* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride,
                                                          const void* pointer);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTBVARBPROC)(GLint size, const GLbyte* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTDVARBPROC)(GLint size, const GLdouble* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTFVARBPROC)(GLint size, const GLfloat* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTIVARBPROC)(GLint size, const GLint* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTSVARBPROC)(GLint size, const GLshort* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTUBVARBPROC)(GLint size, const GLubyte* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTUIVARBPROC)(GLint size, const GLuint* weights);
    typedef void(GLAD_API_PTR* PFNGLWEIGHTUSVARBPROC)(GLint size, const GLushort* weights);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2DVARBPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2FVARBPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2IVARBPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2IVMESAPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2SVARBPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS2SVMESAPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3DVARBPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3FVARBPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3IVARBPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3IVMESAPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3SVARBPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS3SVMESAPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z,
                                                         GLdouble w);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4IVMESAPROC)(const GLint* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
    typedef void(GLAD_API_PTR* PFNGLWINDOWPOS4SVMESAPROC)(const GLshort* v);
    typedef void(GLAD_API_PTR* PFNGLWINDOWRECTANGLESEXTPROC)(GLenum mode, GLsizei count,
                                                             const GLint* box);
    typedef void(GLAD_API_PTR* PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX,
                                                      GLenum outY, GLenum outZ, GLenum outW);

    GLAD_API_CALL PFNGLACCUMXOESPROC glad_glAccumxOES;
    GLAD_API_CALL PFNGLACCUMXOESPROC glad_debug_glAccumxOES;
#define glAccumxOES glad_debug_glAccumxOES
    GLAD_API_CALL PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_glAcquireKeyedMutexWin32EXT;
    GLAD_API_CALL PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_debug_glAcquireKeyedMutexWin32EXT;
#define glAcquireKeyedMutexWin32EXT glad_debug_glAcquireKeyedMutexWin32EXT
    GLAD_API_CALL PFNGLACTIVEPROGRAMEXTPROC glad_glActiveProgramEXT;
    GLAD_API_CALL PFNGLACTIVEPROGRAMEXTPROC glad_debug_glActiveProgramEXT;
#define glActiveProgramEXT glad_debug_glActiveProgramEXT
    GLAD_API_CALL PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;
    GLAD_API_CALL PFNGLACTIVESHADERPROGRAMPROC glad_debug_glActiveShaderProgram;

/// <summary>
///   set the active program object for a program pipeline object
///   <para>
///     glActiveShaderProgram sets the linked program named by program to be the active program for
///     the program pipeline object pipeline. The active program in the active program pipeline
///     object is the target of calls to glUniform when no program has been made current through a
///     call to glUseProgram.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies the program pipeline object to set the active program object
/// for.</param> <param name='program'>Specifies the program object to set as the active program
/// pipeline object</param>
#define glActiveShaderProgram glad_debug_glActiveShaderProgram
    GLAD_API_CALL PFNGLACTIVESTENCILFACEEXTPROC glad_glActiveStencilFaceEXT;
    GLAD_API_CALL PFNGLACTIVESTENCILFACEEXTPROC glad_debug_glActiveStencilFaceEXT;
#define glActiveStencilFaceEXT glad_debug_glActiveStencilFaceEXT
    GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
    GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_debug_glActiveTexture;

/// <summary>
///   select active texture unit
///   <para>
///     glActiveTexture selects which texture unit subsequent texture state calls will affect. The
///     number of texture units an implementation supports is implementation dependent, but must be
///     at least 80.
///   </para>
/// </summary>
/// <param name='texture'>Specifies which texture unit to make active. The number of texture units
/// is implementation dependent, but must be at least 80.</param>
#define glActiveTexture glad_debug_glActiveTexture
    GLAD_API_CALL PFNGLACTIVETEXTUREARBPROC glad_glActiveTextureARB;
    GLAD_API_CALL PFNGLACTIVETEXTUREARBPROC glad_debug_glActiveTextureARB;
#define glActiveTextureARB glad_debug_glActiveTextureARB
    GLAD_API_CALL PFNGLACTIVEVARYINGNVPROC glad_glActiveVaryingNV;
    GLAD_API_CALL PFNGLACTIVEVARYINGNVPROC glad_debug_glActiveVaryingNV;
#define glActiveVaryingNV glad_debug_glActiveVaryingNV
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP1ATIPROC glad_glAlphaFragmentOp1ATI;
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP1ATIPROC glad_debug_glAlphaFragmentOp1ATI;
#define glAlphaFragmentOp1ATI glad_debug_glAlphaFragmentOp1ATI
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP2ATIPROC glad_glAlphaFragmentOp2ATI;
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP2ATIPROC glad_debug_glAlphaFragmentOp2ATI;
#define glAlphaFragmentOp2ATI glad_debug_glAlphaFragmentOp2ATI
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP3ATIPROC glad_glAlphaFragmentOp3ATI;
    GLAD_API_CALL PFNGLALPHAFRAGMENTOP3ATIPROC glad_debug_glAlphaFragmentOp3ATI;
#define glAlphaFragmentOp3ATI glad_debug_glAlphaFragmentOp3ATI
    GLAD_API_CALL PFNGLALPHAFUNCXOESPROC glad_glAlphaFuncxOES;
    GLAD_API_CALL PFNGLALPHAFUNCXOESPROC glad_debug_glAlphaFuncxOES;
#define glAlphaFuncxOES glad_debug_glAlphaFuncxOES
    GLAD_API_CALL PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC glad_glAlphaToCoverageDitherControlNV;
    GLAD_API_CALL PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC
        glad_debug_glAlphaToCoverageDitherControlNV;
#define glAlphaToCoverageDitherControlNV glad_debug_glAlphaToCoverageDitherControlNV
    GLAD_API_CALL PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC
        glad_glApplyFramebufferAttachmentCMAAINTEL;
    GLAD_API_CALL PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC
        glad_debug_glApplyFramebufferAttachmentCMAAINTEL;
#define glApplyFramebufferAttachmentCMAAINTEL glad_debug_glApplyFramebufferAttachmentCMAAINTEL
    GLAD_API_CALL PFNGLAPPLYTEXTUREEXTPROC glad_glApplyTextureEXT;
    GLAD_API_CALL PFNGLAPPLYTEXTUREEXTPROC glad_debug_glApplyTextureEXT;
#define glApplyTextureEXT glad_debug_glApplyTextureEXT
    GLAD_API_CALL PFNGLAREPROGRAMSRESIDENTNVPROC glad_glAreProgramsResidentNV;
    GLAD_API_CALL PFNGLAREPROGRAMSRESIDENTNVPROC glad_debug_glAreProgramsResidentNV;
#define glAreProgramsResidentNV glad_debug_glAreProgramsResidentNV
    GLAD_API_CALL PFNGLARETEXTURESRESIDENTEXTPROC glad_glAreTexturesResidentEXT;
    GLAD_API_CALL PFNGLARETEXTURESRESIDENTEXTPROC glad_debug_glAreTexturesResidentEXT;
#define glAreTexturesResidentEXT glad_debug_glAreTexturesResidentEXT
    GLAD_API_CALL PFNGLARRAYELEMENTEXTPROC glad_glArrayElementEXT;
    GLAD_API_CALL PFNGLARRAYELEMENTEXTPROC glad_debug_glArrayElementEXT;
#define glArrayElementEXT glad_debug_glArrayElementEXT
    GLAD_API_CALL PFNGLARRAYOBJECTATIPROC glad_glArrayObjectATI;
    GLAD_API_CALL PFNGLARRAYOBJECTATIPROC glad_debug_glArrayObjectATI;
#define glArrayObjectATI glad_debug_glArrayObjectATI
    GLAD_API_CALL PFNGLASYNCCOPYBUFFERSUBDATANVXPROC glad_glAsyncCopyBufferSubDataNVX;
    GLAD_API_CALL PFNGLASYNCCOPYBUFFERSUBDATANVXPROC glad_debug_glAsyncCopyBufferSubDataNVX;
#define glAsyncCopyBufferSubDataNVX glad_debug_glAsyncCopyBufferSubDataNVX
    GLAD_API_CALL PFNGLASYNCCOPYIMAGESUBDATANVXPROC glad_glAsyncCopyImageSubDataNVX;
    GLAD_API_CALL PFNGLASYNCCOPYIMAGESUBDATANVXPROC glad_debug_glAsyncCopyImageSubDataNVX;
#define glAsyncCopyImageSubDataNVX glad_debug_glAsyncCopyImageSubDataNVX
    GLAD_API_CALL PFNGLASYNCMARKERSGIXPROC glad_glAsyncMarkerSGIX;
    GLAD_API_CALL PFNGLASYNCMARKERSGIXPROC glad_debug_glAsyncMarkerSGIX;
#define glAsyncMarkerSGIX glad_debug_glAsyncMarkerSGIX
    GLAD_API_CALL PFNGLATTACHOBJECTARBPROC glad_glAttachObjectARB;
    GLAD_API_CALL PFNGLATTACHOBJECTARBPROC glad_debug_glAttachObjectARB;
#define glAttachObjectARB glad_debug_glAttachObjectARB
    GLAD_API_CALL PFNGLATTACHSHADERPROC glad_glAttachShader;
    GLAD_API_CALL PFNGLATTACHSHADERPROC glad_debug_glAttachShader;

/// <summary>
///   Attaches a shader object to a program object
///   <para>
///     In order to create a complete shader program, there must be a way to specify the list of
///     things that will be linked together. Program objects provide this mechanism. Shaders that
///     are to be linked together in a program object must first be attached to that program object.
///     glAttachShader attaches the shader object specified by shader to the program object
///     specified by program. This indicates that shader will be included in link operations that
///     will be performed on program. All operations that can be performed on a shader object are
///     valid whether or not the shader object is attached to a program object. It is permissible to
///     attach a shader object to a program object before source code has been loaded into the
///     shader object or before the shader object has been compiled. It is permissible to attach
///     multiple shader objects of the same type because each may contain a portion of the complete
///     shader. It is also permissible to attach a shader object to more than one program object. If
///     a shader object is deleted while it is attached to a program object, it will be flagged for
///     deletion, and deletion will not occur until glDetachShader is called to detach it from all
///     program objects to which it is attached.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to which a shader object will be
/// attached.</param> <param name='shader'>Specifies the shader object that is to be
/// attached.</param>
#define glAttachShader glad_debug_glAttachShader
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_debug_glBeginConditionalRender;

/// <summary>
///   start conditional rendering
///   <para>
///     Conditional rendering is started using glBeginConditionalRender and ended using
///     glEndConditionalRender. During conditional rendering, all vertex array commands, as well as
///     glClear and glClearBuffer have no effect if the ( GL_SAMPLES_PASSED ) result of the query
///     object id is zero, or if the ( GL_ANY_SAMPLES_PASSED ) result is GL_FALSE. The results of
///     commands setting the current vertex state, such as glVertexAttrib are undefined. If the (
///     GL_SAMPLES_PASSED ) result is non-zero or if the ( GL_ANY_SAMPLES_PASSED ) result is GL_TRUE
///     , such commands are not discarded. The id parameter to glBeginConditionalRender must be the
///     name of a query object previously returned from a call to glGenQueries. mode specifies how
///     the results of the query object are to be interpreted. If mode is GL_QUERY_WAIT , the GL
///     waits for the results of the query to be available and then uses the results to determine if
///     subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT , the GL may choose
///     to unconditionally execute the subsequent rendering commands without waiting for the query
///     to complete. If mode is GL_QUERY_BY_REGION_WAIT , the GL will also wait for occlusion query
///     results and discard rendering commands if the result of the occlusion query is zero. If the
///     query result is non-zero, subsequent rendering commands are executed, but the GL may discard
///     the results of the commands for any region of the framebuffer that did not contribute to the
///     sample count in the specified occlusion query. Any such discarding is done in an
///     implementation-dependent manner, but the rendering command results may not be discarded for
///     any samples that contributed to the occlusion query sample count. If mode is
///     GL_QUERY_BY_REGION_NO_WAIT , the GL operates as in GL_QUERY_BY_REGION_WAIT , but may choose
///     to unconditionally execute the subsequent rendering commands without waiting for the query
///     to complete.
///   </para>
/// </summary>
/// <param name='id'>Specifies the name of an occlusion query object whose results are used to
/// determine if the rendering commands are discarded.</param> <param name='mode'>Specifies
/// how</param>
#define glBeginConditionalRender glad_debug_glBeginConditionalRender
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVPROC glad_glBeginConditionalRenderNV;
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVPROC glad_debug_glBeginConditionalRenderNV;
#define glBeginConditionalRenderNV glad_debug_glBeginConditionalRenderNV
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVXPROC glad_glBeginConditionalRenderNVX;
    GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVXPROC glad_debug_glBeginConditionalRenderNVX;
#define glBeginConditionalRenderNVX glad_debug_glBeginConditionalRenderNVX
    GLAD_API_CALL PFNGLBEGINFRAGMENTSHADERATIPROC glad_glBeginFragmentShaderATI;
    GLAD_API_CALL PFNGLBEGINFRAGMENTSHADERATIPROC glad_debug_glBeginFragmentShaderATI;
#define glBeginFragmentShaderATI glad_debug_glBeginFragmentShaderATI
    GLAD_API_CALL PFNGLBEGINOCCLUSIONQUERYNVPROC glad_glBeginOcclusionQueryNV;
    GLAD_API_CALL PFNGLBEGINOCCLUSIONQUERYNVPROC glad_debug_glBeginOcclusionQueryNV;
#define glBeginOcclusionQueryNV glad_debug_glBeginOcclusionQueryNV
    GLAD_API_CALL PFNGLBEGINPERFMONITORAMDPROC glad_glBeginPerfMonitorAMD;
    GLAD_API_CALL PFNGLBEGINPERFMONITORAMDPROC glad_debug_glBeginPerfMonitorAMD;
#define glBeginPerfMonitorAMD glad_debug_glBeginPerfMonitorAMD
    GLAD_API_CALL PFNGLBEGINPERFQUERYINTELPROC glad_glBeginPerfQueryINTEL;
    GLAD_API_CALL PFNGLBEGINPERFQUERYINTELPROC glad_debug_glBeginPerfQueryINTEL;
#define glBeginPerfQueryINTEL glad_debug_glBeginPerfQueryINTEL
    GLAD_API_CALL PFNGLBEGINQUERYPROC glad_glBeginQuery;
    GLAD_API_CALL PFNGLBEGINQUERYPROC glad_debug_glBeginQuery;

/// <summary>
///   delimit the boundaries of a query object
///   <para>
///     glBeginQuery and glEndQuery delimit the boundaries of a query object. query must be a name
///     previously returned from a call to glGenQueries. If a query object with name id does not yet
///     exist it is created with the type determined by target. target must be one of
///     GL_SAMPLES_PASSED , GL_ANY_SAMPLES_PASSED , GL_PRIMITIVES_GENERATED ,
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN , or GL_TIME_ELAPSED. The behavior of the query
///     object depends on its type and is as follows. If target is GL_SAMPLES_PASSED , id must be an
///     unused name, or the name of an existing occlusion query object. When glBeginQuery is
///     executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will
///     increment the counter for every sample that passes the depth test. If the value of
///     GL_SAMPLE_BUFFERS is 0, then the samples-passed count is incremented by 1 for each fragment.
///     If the value of GL_SAMPLE_BUFFERS is 1, then the samples-passed count is incremented by the
///     number of samples whose coverage bit is set. However, implementations, at their discression
///     may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in
///     the fragment is covered. When glEndQuery is executed, the samples-passed counter is assigned
///     to the query object's result value. This value can be queried by calling glGetQueryObject
///     with pname GL_QUERY_RESULT. If target is GL_ANY_SAMPLES_PASSED or
///     GL_ANY_SAMPLES_PASSED_CONSERVATIVE , id must be an unused name, or the name of an existing
///     boolean occlusion query object. When glBeginQuery is executed, the query object's
///     samples-passed flag is reset to GL_FALSE. Subsequent rendering causes the flag to be set to
///     GL_TRUE if any sample passes the depth test in the case of GL_ANY_SAMPLES_PASSED , or if the
///     implementation determines that any sample might pass the depth test in the case of
///     GL_ANY_SAMPLES_PASSED_CONSERVATIVE. The implementation may be able to provide a more
///     efficient test in the case of GL_ANY_SAMPLES_PASSED_CONSERVATIVE if some false positives are
///     acceptable to the application. When glEndQuery is executed, the samples-passed flag is
///     assigned to the query object's result value. This value can be queried by calling
///     glGetQueryObject with pname GL_QUERY_RESULT. If target is GL_PRIMITIVES_GENERATED , id must
///     be an unused name, or the name of an existing primitive query object previously bound to the
///     GL_PRIMITIVES_GENERATED query binding. When glBeginQuery is executed, the query object's
///     primitives-generated counter is reset to 0. Subsequent rendering will increment the counter
///     once for every vertex that is emitted from the geometry shader, or from the vertex shader if
///     no geometry shader is present. When glEndQuery is executed, the primitives-generated counter
///     is assigned to the query object's result value. This value can be queried by calling
///     glGetQueryObject with pname GL_QUERY_RESULT. If target is
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN , id must be an unused name, or the name of an
///     existing primitive query object previously bound to the
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN query binding. When glBeginQuery is executed, the
///     query object's primitives-written counter is reset to 0. Subsequent rendering will increment
///     the counter once for every vertex that is written into the bound transform feedback
///     buffer(s). If transform feedback mode is not activated between the call to glBeginQuery and
///     glEndQuery , the counter will not be incremented. When glEndQuery is executed, the
///     primitives-written counter is assigned to the query object's result value. This value can be
///     queried by calling glGetQueryObject with pname GL_QUERY_RESULT. If target is GL_TIME_ELAPSED
///     , id must be an unused name, or the name of an existing timer query object previously bound
///     to the GL_TIME_ELAPSED query binding. When glBeginQuery is executed, the query object's time
///     counter is reset to 0. When glEndQuery is executed, the elapsed server time that has passed
///     since the call to glBeginQuery is written into the query object's time counter. This value
///     can be queried by calling glGetQueryObject with pname GL_QUERY_RESULT. Querying the
///     GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the
///     query object has completed and the result is available. GL_QUERY_RESULT_AVAILABLE can be
///     queried to determine if the result is immediately available or if the rendering is not yet
///     complete.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target type of query object established between</param>
/// <param name='id'>Specifies the name of a query object.</param>
#define glBeginQuery glad_debug_glBeginQuery
    GLAD_API_CALL PFNGLBEGINQUERYARBPROC glad_glBeginQueryARB;
    GLAD_API_CALL PFNGLBEGINQUERYARBPROC glad_debug_glBeginQueryARB;
#define glBeginQueryARB glad_debug_glBeginQueryARB
    GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
    GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_debug_glBeginQueryIndexed;

/// <summary>
///   delimit the boundaries of a query object on an indexed target
///   <para>
///     glBeginQueryIndexed and glEndQueryIndexed delimit the boundaries of a query object. query
///     must be a name previously returned from a call to glGenQueries. If a query object with name
///     id does not yet exist it is created with the type determined by target. target must be one
///     of GL_SAMPLES_PASSED , GL_ANY_SAMPLES_PASSED , GL_PRIMITIVES_GENERATED ,
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN , or GL_TIME_ELAPSED. The behavior of the query
///     object depends on its type and is as follows. index specifies the index of the query target
///     and must be between a target -specific maximum. If target is GL_SAMPLES_PASSED , id must be
///     an unused name, or the name of an existing occlusion query object. When glBeginQueryIndexed
///     is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering
///     will increment the counter for every sample that passes the depth test. If the value of
///     GL_SAMPLE_BUFFERS is 0, then the samples-passed count is incremented by 1 for each fragment.
///     If the value of GL_SAMPLE_BUFFERS is 1, then the samples-passed count is incremented by the
///     number of samples whose coverage bit is set. However, implementations, at their discression
///     may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in
///     the fragment is covered. When glEndQueryIndexed is executed, the samples-passed counter is
///     assigned to the query object's result value. This value can be queried by calling
///     glGetQueryObject with pname GL_QUERY_RESULT. When target is GL_SAMPLES_PASSED , index must
///     be zero. If target is GL_ANY_SAMPLES_PASSED , id must be an unused name, or the name of an
///     existing boolean occlusion query object. When glBeginQueryIndexed is executed, the query
///     object's samples-passed flag is reset to GL_FALSE. Subsequent rendering causes the flag to
///     be set to GL_TRUE if any sample passes the depth test. When glEndQueryIndexed is executed,
///     the samples-passed flag is assigned to the query object's result value. This value can be
///     queried by calling glGetQueryObject with pname GL_QUERY_RESULT. When target is
///     GL_ANY_SAMPLES_PASSED , index must be zero. If target is GL_PRIMITIVES_GENERATED , id must
///     be an unused name, or the name of an existing primitive query object previously bound to the
///     GL_PRIMITIVES_GENERATED query binding. When glBeginQueryIndexed is executed, the query
///     object's primitives-generated counter is reset to 0. Subsequent rendering will increment the
///     counter once for every vertex that is emitted from the geometry shader to the stream given
///     by index , or from the vertex shader if index is zero and no geometry shader is present.
///     When glEndQueryIndexed is executed, the primitives-generated counter for stream index is
///     assigned to the query object's result value. This value can be queried by calling
///     glGetQueryObject with pname GL_QUERY_RESULT. When target is GL_PRIMITIVES_GENERATED , index
///     must be less than the value of GL_MAX_VERTEX_STREAMS. If target is
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN , id must be an unused name, or the name of an
///     existing primitive query object previously bound to the
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN query binding. When glBeginQueryIndexed is
///     executed, the query object's primitives-written counter for the stream specified by index is
///     reset to 0. Subsequent rendering will increment the counter once for every vertex that is
///     written into the bound transform feedback buffer(s) for stream index. If transform feedback
///     mode is not activated between the call to glBeginQueryIndexed and glEndQueryIndexed , the
///     counter will not be incremented. When glEndQueryIndexed is executed, the primitives-written
///     counter for stream index is assigned to the query object's result value. This value can be
///     queried by calling glGetQueryObject with pname GL_QUERY_RESULT. When target is
///     GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN , index must be less than the value of
///     GL_MAX_VERTEX_STREAMS. If target is GL_TIME_ELAPSED , id must be an unused name, or the name
///     of an existing timer query object previously bound to the GL_TIME_ELAPSED query binding.
///     When glBeginQueryIndexed is executed, the query object's time counter is reset to 0. When
///     glEndQueryIndexed is executed, the elapsed server time that has passed since the call to
///     glBeginQueryIndexed is written into the query object's time counter. This value can be
///     queried by calling glGetQueryObject with pname GL_QUERY_RESULT. When target is
///     GL_TIME_ELAPSED , index must be zero. Querying the GL_QUERY_RESULT implicitly flushes the GL
///     pipeline until the rendering delimited by the query object has completed and the result is
///     available. GL_QUERY_RESULT_AVAILABLE can be queried to determine if the result is
///     immediately available or if the rendering is not yet complete.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target type of query object established between</param>
/// <param name='index'>Specifies the index of the query target upon which to begin the
/// query.</param> <param name='id'>Specifies the name of a query object.</param>
#define glBeginQueryIndexed glad_debug_glBeginQueryIndexed
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_debug_glBeginTransformFeedback;

/// <summary>
///   start transform feedback operation
///   <para>
///     Transform feedback mode captures the values of varying variables written by the vertex
///     shader (or, if active, the geometry shader). Transform feedback is said to be active after a
///     call to glBeginTransformFeedback until a subsequent call to glEndTransformFeedback.
///     Transform feedback commands must be paired. If no geometry shader is present, while
///     transform feedback is active the mode parameter to glDrawArrays must match those specified
///     in the following table: If a geometry shader is present, the output primitive type from the
///     geometry shader must match those provided in the following table:
///   </para>
/// </summary>
/// <param name='primitiveMode'>Specify the output type of the primitives that will be recorded into
/// the buffer objects that are bound for transform feedback.</param>
#define glBeginTransformFeedback glad_debug_glBeginTransformFeedback
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_glBeginTransformFeedbackEXT;
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_debug_glBeginTransformFeedbackEXT;
#define glBeginTransformFeedbackEXT glad_debug_glBeginTransformFeedbackEXT
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_glBeginTransformFeedbackNV;
    GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_debug_glBeginTransformFeedbackNV;
#define glBeginTransformFeedbackNV glad_debug_glBeginTransformFeedbackNV
    GLAD_API_CALL PFNGLBEGINVERTEXSHADEREXTPROC glad_glBeginVertexShaderEXT;
    GLAD_API_CALL PFNGLBEGINVERTEXSHADEREXTPROC glad_debug_glBeginVertexShaderEXT;
#define glBeginVertexShaderEXT glad_debug_glBeginVertexShaderEXT
    GLAD_API_CALL PFNGLBEGINVIDEOCAPTURENVPROC glad_glBeginVideoCaptureNV;
    GLAD_API_CALL PFNGLBEGINVIDEOCAPTURENVPROC glad_debug_glBeginVideoCaptureNV;
#define glBeginVideoCaptureNV glad_debug_glBeginVideoCaptureNV
    GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
    GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_debug_glBindAttribLocation;

/// <summary>
///   Associates a generic vertex attribute index with a named attribute variable
///   <para>
///     glBindAttribLocation is used to associate a user-defined attribute variable in the program
///     object specified by program with a generic vertex attribute index. The name of the
///     user-defined attribute variable is passed as a null terminated string in name. The generic
///     vertex attribute index to be bound to this variable is specified by index. When program is
///     made part of current state, values provided via the generic vertex attribute index will
///     modify the value of the user-defined attribute variable specified by name. If name refers to
///     a matrix attribute variable, index refers to the first column of the matrix. Other matrix
///     columns are then automatically bound to locations index+1 for a matrix of type mat2 ;
///     index+1 and index+2 for a matrix of type mat3 ; and index+1 , index+2 , and index+3 for a
///     matrix of type mat4. This command makes it possible for vertex shaders to use descriptive
///     names for attribute variables rather than generic variables that are numbered from zero to
///     the value of GL_MAX_VERTEX_ATTRIBS minus one. The values sent to each generic attribute
///     index are part of current state. If a different program object is made current by calling
///     glUseProgram , the generic vertex attributes are tracked in such a way that the same values
///     will be observed by attributes in the new program object that are also bound to index.
///     Attribute variable name-to-generic attribute index bindings for a program object can be
///     explicitly assigned at any time by calling glBindAttribLocation. Attribute bindings do not
///     go into effect until glLinkProgram is called. After a program object has been linked
///     successfully, the index values for generic attributes remain fixed (and their values can be
///     queried) until the next link command occurs. Any attribute binding that occurs after the
///     program object has been linked will not take effect until the next time the program object
///     is linked.
///   </para>
/// </summary>
/// <param name='program'>Specifies the handle of the program object in which the association is to
/// be made.</param> <param name='index'>Specifies the index of the generic vertex attribute to be
/// bound.</param> <param name='name'>Specifies a null terminated string containing the name of the
/// vertex shader attribute variable to which</param>
#define glBindAttribLocation glad_debug_glBindAttribLocation
    GLAD_API_CALL PFNGLBINDATTRIBLOCATIONARBPROC glad_glBindAttribLocationARB;
    GLAD_API_CALL PFNGLBINDATTRIBLOCATIONARBPROC glad_debug_glBindAttribLocationARB;
#define glBindAttribLocationARB glad_debug_glBindAttribLocationARB
    GLAD_API_CALL PFNGLBINDBUFFERPROC glad_glBindBuffer;
    GLAD_API_CALL PFNGLBINDBUFFERPROC glad_debug_glBindBuffer;

/// <summary>
///   bind a named buffer object
///   <para>
///     glBindBuffer binds a buffer object to the specified buffer binding point. Calling
///     glBindBuffer with target set to one of the accepted symbolic constants and buffer set to the
///     name of a buffer object binds that buffer object name to the target. If no buffer object
///     with name buffer exists, one is created with that name. When a buffer object is bound to a
///     target, the previous binding for that target is automatically broken. Buffer object names
///     are unsigned integers. The value zero is reserved, but there is no default buffer object for
///     each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object
///     previously bound, and restores client memory usage for that buffer object target (if
///     supported for that target). Buffer object names and the corresponding buffer object contents
///     are local to the shared object space of the current GL rendering context; two rendering
///     contexts share buffer object names only if they explicitly enable sharing between contexts
///     through the appropriate GL windows interfaces functions. glGenBuffers must be used to
///     generate a set of unused buffer object names. The state of a buffer object immediately after
///     it is first bound is an unmapped zero-sized memory buffer with GL_READ_WRITE access and
///     GL_STATIC_DRAW usage. While a non-zero buffer object name is bound, GL operations on the
///     target to which it is bound affect the bound buffer object, and queries of the target to
///     which it is bound return state from the bound buffer object. While buffer object name zero
///     is bound, as in the initial state, attempts to modify or query state on the target to which
///     it is bound generates an GL_INVALID_OPERATION error. When a non-zero buffer object is bound
///     to the GL_ARRAY_BUFFER target, the vertex array pointer parameter is interpreted as an
///     offset within the buffer object measured in basic machine units. When a non-zero buffer
///     object is bound to the GL_DRAW_INDIRECT_BUFFER target, parameters for draws issued through
///     glDrawArraysIndirect and glDrawElementsIndirect are sourced from the specified offset in
///     that buffer object's data store. When a non-zero buffer object is bound to the
///     GL_DISPATCH_INDIRECT_BUFFER target, the parameters for compute dispatches issued through
///     glDispatchComputeIndirect are sourced from the specified offset in that buffer object's data
///     store. While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the
///     indices parameter of glDrawElements , glDrawElementsInstanced , glDrawElementsBaseVertex ,
///     glDrawRangeElements , glDrawRangeElementsBaseVertex , glMultiDrawElements , or
///     glMultiDrawElementsBaseVertex is interpreted as an offset within the buffer object measured
///     in basic machine units. While a non-zero buffer object is bound to the GL_PIXEL_PACK_BUFFER
///     target, the following commands are affected: glGetCompressedTexImage , glGetTexImage , and
///     glReadPixels. The pointer parameter is interpreted as an offset within the buffer object
///     measured in basic machine units. While a non-zero buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target, the following commands are affected: glCompressedTexImage1D ,
///     glCompressedTexImage2D , glCompressedTexImage3D , glCompressedTexSubImage1D ,
///     glCompressedTexSubImage2D , glCompressedTexSubImage3D , glTexImage1D , glTexImage2D ,
///     glTexImage3D , glTexSubImage1D , glTexSubImage2D , and glTexSubImage3D. The pointer
///     parameter is interpreted as an offset within the buffer object measured in basic machine
///     units. The buffer targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided to allow
///     glCopyBufferSubData to be used without disturbing the state of other bindings. However,
///     glCopyBufferSubData may be used with any pair of buffer binding points. The
///     GL_TRANSFORM_FEEDBACK_BUFFER buffer binding point may be passed to glBindBuffer , but will
///     not directly affect transform feedback state. Instead, the indexed
///     GL_TRANSFORM_FEEDBACK_BUFFER bindings must be used through a call to glBindBufferBase or
///     glBindBufferRange. This will affect the generic GL_TRANSFORM_FEEDBACK_BUFFER binding.
///     Likewise, the GL_UNIFORM_BUFFER , GL_ATOMIC_COUNTER_BUFFER and GL_SHADER_STORAGE_BUFFER
///     buffer binding points may be used, but do not directly affect uniform buffer, atomic counter
///     buffer or shader storage buffer state, respectively. glBindBufferBase or glBindBufferRange
///     must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader
///     storage buffer binding point. The GL_QUERY_BUFFER binding point is used to specify a buffer
///     object that is to receive the results of query objects through calls to the glGetQueryObject
///     family of commands. A buffer object binding created with glBindBuffer remains active until a
///     different buffer object name is bound to the same target, or until the bound buffer object
///     is deleted with glDeleteBuffers. Once created, a named buffer object may be re-bound to any
///     target as often as needed. However, the GL implementation may make choices about how to
///     optimize the storage of a buffer object based on its initial binding target.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound, which must be one
/// of the buffer binding targets in the following table:</param> <param name='buffer'>Specifies the
/// name of a buffer object.</param>
#define glBindBuffer glad_debug_glBindBuffer
    GLAD_API_CALL PFNGLBINDBUFFERARBPROC glad_glBindBufferARB;
    GLAD_API_CALL PFNGLBINDBUFFERARBPROC glad_debug_glBindBufferARB;
#define glBindBufferARB glad_debug_glBindBufferARB
    GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
    GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_debug_glBindBufferBase;

/// <summary>
///   bind a buffer object to an indexed buffer target
///   <para>
///     glBindBufferBase binds the buffer object buffer to the binding point at index index of the
///     array of targets specified by target. Each target represents an indexed array of buffer
///     binding points, as well as a single general binding point that can be used by other buffer
///     manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding buffer to
///     the indexed buffer binding target, glBindBufferBase also binds buffer to the generic buffer
///     binding point specified by target.
///   </para>
/// </summary>
/// <param name='target'>Specify the target of the bind operation.</param>
/// <param name='index'>Specify the index of the binding point within the array specified by</param>
/// <param name='buffer'>The name of a buffer object to bind to the specified binding point.</param>
#define glBindBufferBase glad_debug_glBindBufferBase
    GLAD_API_CALL PFNGLBINDBUFFERBASEEXTPROC glad_glBindBufferBaseEXT;
    GLAD_API_CALL PFNGLBINDBUFFERBASEEXTPROC glad_debug_glBindBufferBaseEXT;
#define glBindBufferBaseEXT glad_debug_glBindBufferBaseEXT
    GLAD_API_CALL PFNGLBINDBUFFERBASENVPROC glad_glBindBufferBaseNV;
    GLAD_API_CALL PFNGLBINDBUFFERBASENVPROC glad_debug_glBindBufferBaseNV;
#define glBindBufferBaseNV glad_debug_glBindBufferBaseNV
    GLAD_API_CALL PFNGLBINDBUFFEROFFSETEXTPROC glad_glBindBufferOffsetEXT;
    GLAD_API_CALL PFNGLBINDBUFFEROFFSETEXTPROC glad_debug_glBindBufferOffsetEXT;
#define glBindBufferOffsetEXT glad_debug_glBindBufferOffsetEXT
    GLAD_API_CALL PFNGLBINDBUFFEROFFSETNVPROC glad_glBindBufferOffsetNV;
    GLAD_API_CALL PFNGLBINDBUFFEROFFSETNVPROC glad_debug_glBindBufferOffsetNV;
#define glBindBufferOffsetNV glad_debug_glBindBufferOffsetNV
    GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
    GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_debug_glBindBufferRange;

/// <summary>
///   bind a range within a buffer object to an indexed buffer target
///   <para>
///     glBindBufferRange binds a range the buffer object buffer represented by offset and size to
///     the binding point at index index of the array of targets specified by target. Each target
///     represents an indexed array of buffer binding points, as well as a single general binding
///     point that can be used by other buffer manipulation functions such as glBindBuffer or
///     glMapBuffer. In addition to binding a range of buffer to the indexed buffer binding target,
///     glBindBufferRange also binds the range to the generic buffer binding point specified by
///     target. offset specifies the offset in basic machine units into the buffer object buffer and
///     size specifies the amount of data that can be read from the buffer object while used as an
///     indexed target.
///   </para>
/// </summary>
/// <param name='target'>Specify the target of the bind operation.</param>
/// <param name='index'>Specify the index of the binding point within the array specified by</param>
/// <param name='buffer'>The name of a buffer object to bind to the specified binding point.</param>
/// <param name='offset'>The starting offset in basic machine units into the buffer object</param>
/// <param name='size'>The amount of data in machine units that can be read from the buffer object
/// while used as an indexed target.</param>
#define glBindBufferRange glad_debug_glBindBufferRange
    GLAD_API_CALL PFNGLBINDBUFFERRANGEEXTPROC glad_glBindBufferRangeEXT;
    GLAD_API_CALL PFNGLBINDBUFFERRANGEEXTPROC glad_debug_glBindBufferRangeEXT;
#define glBindBufferRangeEXT glad_debug_glBindBufferRangeEXT
    GLAD_API_CALL PFNGLBINDBUFFERRANGENVPROC glad_glBindBufferRangeNV;
    GLAD_API_CALL PFNGLBINDBUFFERRANGENVPROC glad_debug_glBindBufferRangeNV;
#define glBindBufferRangeNV glad_debug_glBindBufferRangeNV
    GLAD_API_CALL PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;
    GLAD_API_CALL PFNGLBINDBUFFERSBASEPROC glad_debug_glBindBuffersBase;

/// <summary>
///   bind one or more buffer objects to a sequence of indexed buffer targets
///   <para>
///     glBindBuffersBase binds a set of count buffer objects whose names are given in the array
///     buffers to the count consecutive binding points starting from index index of the array of
///     targets specified by target. If buffers is NULL then glBindBuffersBase unbinds any buffers
///     that are currently bound to the referenced binding points. Assuming no errors are generated,
///     it is equivalent to the following pseudo-code, which calls glBindBufferBase :
///   </para>
/// </summary>
/// <param name='target'>Specify the target of the bind operation.</param>
/// <param name='index'>Specify the index of the first binding point within the array specified
/// by</param> <param name='count'>Specify the number of contiguous binding points to which to bind
/// buffers.</param> <param name='buffers'>A pointer to an array of names of buffer objects to bind
/// to the targets on the specified binding point, or</param>
#define glBindBuffersBase glad_debug_glBindBuffersBase
    GLAD_API_CALL PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;
    GLAD_API_CALL PFNGLBINDBUFFERSRANGEPROC glad_debug_glBindBuffersRange;

/// <summary>
///   bind ranges of one or more buffer objects to a sequence of indexed buffer targets
///   <para>
///     glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in
///     the array buffers to the count consecutive binding points starting from index index of the
///     array of targets specified by target. offsets specifies the address of an array containing
///     count starting offsets within the buffers, and sizes specifies the adderess of an array of
///     count sizes of the ranges. If buffers is NULL then offsets and sizes are ignored and
///     glBindBuffersRange unbinds any buffers that are currently bound to the referenced binding
///     points. Assuming no errors are generated, it is equivalent to the following pseudo-code,
///     which calls glBindBufferRange :
///   </para>
/// </summary>
/// <param name='target'>Specify the target of the bind operation.</param>
/// <param name='index'>Specify the index of the first binding point within the array specified
/// by</param> <param name='count'>Specify the number of contiguous binding points to which to bind
/// buffers.</param> <param name='buffers'>A pointer to an array of names of buffer objects to bind
/// to the targets on the specified binding point, or</param>
#define glBindBuffersRange glad_debug_glBindBuffersRange
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_debug_glBindFragDataLocation;

/// <summary>
///   bind a user-defined varying out variable to a fragment shader color number
///   <para>
///     glBindFragDataLocation explicitly specifies the binding of the user-defined varying out
///     variable name to fragment shader color number colorNumber for program program. If name was
///     bound previously, its assigned binding is replaced with colorNumber. name must be a
///     null-terminated string. colorNumber must be less than GL_MAX_DRAW_BUFFERS. The bindings
///     specified by glBindFragDataLocation have no effect until program is next linked. Bindings
///     may be specified at any time after program has been created. Specifically, they may be
///     specified before shader objects are attached to the program. Therefore, any name may be
///     specified in name , including a name that is never used as a varying out variable in any
///     fragment shader object. Names beginning with gl_ are reserved by the GL. In addition to the
///     errors generated by glBindFragDataLocation , the program program will fail to link if: The
///     number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS. More than one
///     varying out variable is bound to the same color number.
///   </para>
/// </summary>
/// <param name='program'>The name of the program containing varying out variable whose binding to
/// modify</param> <param name='colorNumber'>The color number to bind the user-defined varying out
/// variable to</param> <param name='name'>The name of the user-defined varying out variable whose
/// binding to modify</param>
#define glBindFragDataLocation glad_debug_glBindFragDataLocation
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONEXTPROC glad_glBindFragDataLocationEXT;
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONEXTPROC glad_debug_glBindFragDataLocationEXT;
#define glBindFragDataLocationEXT glad_debug_glBindFragDataLocationEXT
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
    GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_debug_glBindFragDataLocationIndexed;

/// <summary>
///   bind a user-defined varying out variable to a fragment shader color number and index
///   <para>
///     glBindFragDataLocationIndexed specifies that the varying out variable name in program should
///     be bound to fragment color colorNumber when the program is next linked. index may be zero or
///     one to specify that the color be used as either the first or second color input to the blend
///     equation, respectively. The bindings specified by glBindFragDataLocationIndexed have no
///     effect until program is next linked. Bindings may be specified at any time after program has
///     been created. Specifically, they may be specified before shader objects are attached to the
///     program. Therefore, any name may be specified in name , including a name that is never used
///     as a varying out variable in any fragment shader object. Names beginning with gl_ are
///     reserved by the GL. If name was bound previously, its assigned binding is replaced with
///     colorNumber and index. name must be a null-terminated string. index must be less than or
///     equal to one, and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if index is
///     zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or
///     equal to one. In addition to the errors generated by glBindFragDataLocationIndexed , the
///     program program will fail to link if: The number of active outputs is greater than the value
///     GL_MAX_DRAW_BUFFERS. More than one varying out variable is bound to the same color number.
///   </para>
/// </summary>
/// <param name='program'>The name of the program containing varying out variable whose binding to
/// modify</param> <param name='colorNumber'>The color number to bind the user-defined varying out
/// variable to</param> <param name='index'>The index of the color input to bind the user-defined
/// varying out variable to</param> <param name='name'>The name of the user-defined varying out
/// variable whose binding to modify</param>
#define glBindFragDataLocationIndexed glad_debug_glBindFragDataLocationIndexed
    GLAD_API_CALL PFNGLBINDFRAGMENTSHADERATIPROC glad_glBindFragmentShaderATI;
    GLAD_API_CALL PFNGLBINDFRAGMENTSHADERATIPROC glad_debug_glBindFragmentShaderATI;
#define glBindFragmentShaderATI glad_debug_glBindFragmentShaderATI
    GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
    GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_debug_glBindFramebuffer;

/// <summary>
///   bind a framebuffer to a framebuffer target
///   <para>
///     glBindFramebuffer binds the framebuffer object with name framebuffer to the framebuffer
///     target specified by target. target must be either GL_DRAW_FRAMEBUFFER , GL_READ_FRAMEBUFFER
///     or GL_FRAMEBUFFER. If a framebuffer object is bound to GL_DRAW_FRAMEBUFFER or
///     GL_READ_FRAMEBUFFER , it becomes the target for rendering or readback operations,
///     respectively, until it is deleted or another framebuffer is bound to the corresponding bind
///     point. Calling glBindFramebuffer with target set to GL_FRAMEBUFFER binds framebuffer to both
///     the read and draw framebuffer targets. framebuffer is the name of a framebuffer object
///     previously returned from a call to glGenFramebuffers , or zero to break the existing binding
///     of a framebuffer object to target.
///   </para>
/// </summary>
/// <param name='target'>Specifies the framebuffer target of the binding operation.</param>
/// <param name='framebuffer'>Specifies the name of the framebuffer object to bind.</param>
#define glBindFramebuffer glad_debug_glBindFramebuffer
    GLAD_API_CALL PFNGLBINDFRAMEBUFFEREXTPROC glad_glBindFramebufferEXT;
    GLAD_API_CALL PFNGLBINDFRAMEBUFFEREXTPROC glad_debug_glBindFramebufferEXT;
#define glBindFramebufferEXT glad_debug_glBindFramebufferEXT
    GLAD_API_CALL PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;
    GLAD_API_CALL PFNGLBINDIMAGETEXTUREPROC glad_debug_glBindImageTexture;

/// <summary>
///   bind a level of a texture to an image unit
///   <para>
///     glBindImageTexture binds a single level of a texture to an image unit for the purpose of
///     reading and writing it from shaders. unit specifies the zero-based index of the image unit
///     to which to bind the texture level. texture specifies the name of an existing texture object
///     to bind to the image unit. If texture is zero, then any existing binding to the image unit
///     is broken. level specifies the level of the texture to bind to the image unit. If texture is
///     the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array
///     texture, or a two-dimensional multisample array texture, then it is possible to bind either
///     the entire array, or only a single layer of the array to the image unit. In such cases, if
///     layered is GL_TRUE , the entire array is attached to the image unit and layer is ignored.
///     However, if layered is GL_FALSE then layer specifies the layer of the array to attach to the
///     image unit. access specifies the access types to be performed by shaders and may be set to
///     GL_READ_ONLY , GL_WRITE_ONLY , or GL_READ_WRITE to indicate read-only, write-only or
///     read-write access, respectively. Violation of the access type specified in access (for
///     example, if a shader writes to an image bound with access set to GL_READ_ONLY ) will lead to
///     undefined results, possibly including program termination. format specifies the format that
///     is to be used when performing formatted stores into the image from shaders. format must be
///     compatible with the texture's internal format and must be one of the formats listed in the
///     following table. When a texture is bound to an image unit, the format parameter for the
///     image unit need not exactly match the texture internal format as long as the formats are
///     considered compatible as defined in the OpenGL Specification. The matching criterion used
///     for a given texture may be determined by calling glGetTexParameter with value set to
///     GL_IMAGE_FORMAT_COMPATIBILITY_TYPE , with return values of
///     GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE and GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS ,
///     specifying matches by size and class, respectively.
///   </para>
/// </summary>
/// <param name='unit'>Specifies the index of the image unit to which to bind the texture</param>
/// <param name='texture'>Specifies the name of the texture to bind to the image unit.</param>
/// <param name='level'>Specifies the level of the texture that is to be bound.</param>
/// <param name='layered'>Specifies whether a layered texture binding is to be established.</param>
/// <param name='layer'>If</param>
/// <param name='access'>Specifies a token indicating the type of access that will be performed on
/// the image.</param> <param name='format'>Specifies the format that the elements of the image will
/// be treated as for the purposes of formatted stores.</param>
#define glBindImageTexture glad_debug_glBindImageTexture
    GLAD_API_CALL PFNGLBINDIMAGETEXTUREEXTPROC glad_glBindImageTextureEXT;
    GLAD_API_CALL PFNGLBINDIMAGETEXTUREEXTPROC glad_debug_glBindImageTextureEXT;
#define glBindImageTextureEXT glad_debug_glBindImageTextureEXT
    GLAD_API_CALL PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;
    GLAD_API_CALL PFNGLBINDIMAGETEXTURESPROC glad_debug_glBindImageTextures;

/// <summary>
///   bind one or more named texture images to a sequence of consecutive image units
///   <para>
///     glBindImageTextures binds images from an array of existing texture objects to a specified
///     number of consecutive image units. count specifies the number of texture objects whose names
///     are stored in the array textures. That number of texture names are read from the array and
///     bound to the count consecutive texture units starting from first. If the name zero appears
///     in the textures array, any existing binding to the image unit is reset. Any non-zero entry
///     in textures must be the name of an existing texture object. When a non-zero entry in
///     textures is present, the image at level zero is bound, the binding is considered layered,
///     with the first layer set to zero, and the image is bound for read-write access. The image
///     unit format parameter is taken from the internal format of the image at level zero of the
///     texture object. For cube map textures, the internal format of the positive X image of level
///     zero is used. If textures is NULL then it is as if an appropriately sized array containing
///     only zeros had been specified. glBindImageTextures is equivalent to the following pseudo
///     code: Each entry in textures will be checked individually and if found to be invalid, the
///     state for that image unit will not be changed and an error will be generated. However, the
///     state for other texture image units referenced by the command will still be updated.
///   </para>
/// </summary>
/// <param name='first'>Specifies the first image unit to which a texture is to be bound.</param>
/// <param name='count'>Specifies the number of textures to bind.</param>
/// <param name='textures'>Specifies the address of an array of names of existing texture
/// objects.</param>
#define glBindImageTextures glad_debug_glBindImageTextures
    GLAD_API_CALL PFNGLBINDLIGHTPARAMETEREXTPROC glad_glBindLightParameterEXT;
    GLAD_API_CALL PFNGLBINDLIGHTPARAMETEREXTPROC glad_debug_glBindLightParameterEXT;
#define glBindLightParameterEXT glad_debug_glBindLightParameterEXT
    GLAD_API_CALL PFNGLBINDMATERIALPARAMETEREXTPROC glad_glBindMaterialParameterEXT;
    GLAD_API_CALL PFNGLBINDMATERIALPARAMETEREXTPROC glad_debug_glBindMaterialParameterEXT;
#define glBindMaterialParameterEXT glad_debug_glBindMaterialParameterEXT
    GLAD_API_CALL PFNGLBINDMULTITEXTUREEXTPROC glad_glBindMultiTextureEXT;
    GLAD_API_CALL PFNGLBINDMULTITEXTUREEXTPROC glad_debug_glBindMultiTextureEXT;
#define glBindMultiTextureEXT glad_debug_glBindMultiTextureEXT
    GLAD_API_CALL PFNGLBINDPARAMETEREXTPROC glad_glBindParameterEXT;
    GLAD_API_CALL PFNGLBINDPARAMETEREXTPROC glad_debug_glBindParameterEXT;
#define glBindParameterEXT glad_debug_glBindParameterEXT
    GLAD_API_CALL PFNGLBINDPROGRAMARBPROC glad_glBindProgramARB;
    GLAD_API_CALL PFNGLBINDPROGRAMARBPROC glad_debug_glBindProgramARB;
#define glBindProgramARB glad_debug_glBindProgramARB
    GLAD_API_CALL PFNGLBINDPROGRAMNVPROC glad_glBindProgramNV;
    GLAD_API_CALL PFNGLBINDPROGRAMNVPROC glad_debug_glBindProgramNV;
#define glBindProgramNV glad_debug_glBindProgramNV
    GLAD_API_CALL PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;
    GLAD_API_CALL PFNGLBINDPROGRAMPIPELINEPROC glad_debug_glBindProgramPipeline;

/// <summary>
///   bind a program pipeline to the current context
///   <para>
///     glBindProgramPipeline binds a program pipeline object to the current context. pipeline must
///     be a name previously returned from a call to glGenProgramPipelines. If no program pipeline
///     exists with name pipeline then a new pipeline object is created with that name and
///     initialized to the default state vector. When a program pipeline object is bound using
///     glBindProgramPipeline , any previous binding is broken and is replaced with a binding to the
///     specified pipeline object. If pipeline is zero, the previous binding is broken and is not
///     replaced, leaving no pipeline object bound. If no current program object has been
///     established by glUseProgram , the program objects used for each stage and for uniform
///     updates are taken from the bound program pipeline object, if any. If there is a current
///     program object established by glUseProgram , the bound program pipeline object has no effect
///     on rendering or uniform updates. When a bound program pipeline object is used for rendering,
///     individual shader executables are taken from its program objects.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies the name of the pipeline object to bind to the context.</param>
#define glBindProgramPipeline glad_debug_glBindProgramPipeline
    GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
    GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_debug_glBindRenderbuffer;

/// <summary>
///   bind a renderbuffer to a renderbuffer target
///   <para>
///     glBindRenderbuffer binds the renderbuffer object with name renderbuffer to the renderbuffer
///     target specified by target. target must be GL_RENDERBUFFER. renderbuffer is the name of a
///     renderbuffer object previously returned from a call to glGenRenderbuffers , or zero to break
///     the existing binding of a renderbuffer object to target.
///   </para>
/// </summary>
/// <param name='target'>Specifies the renderbuffer target of the binding operation.</param>
/// <param name='renderbuffer'>Specifies the name of the renderbuffer object to bind.</param>
#define glBindRenderbuffer glad_debug_glBindRenderbuffer
    GLAD_API_CALL PFNGLBINDRENDERBUFFEREXTPROC glad_glBindRenderbufferEXT;
    GLAD_API_CALL PFNGLBINDRENDERBUFFEREXTPROC glad_debug_glBindRenderbufferEXT;
#define glBindRenderbufferEXT glad_debug_glBindRenderbufferEXT
    GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_glBindSampler;
    GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_debug_glBindSampler;

/// <summary>
///   bind a named sampler to a texturing target
///   <para>
///     glBindSampler binds sampler to the texture unit at index unit. sampler must be zero or the
///     name of a sampler object previously returned from a call to glGenSamplers. unit must be less
///     than the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS. When a sampler object is bound to a
///     texture unit, its state supersedes that of the texture object bound to that texture unit. If
///     the sampler name zero is bound to a texture unit, the currently bound texture's sampler
///     state becomes active. A single sampler object may be bound to multiple texture units
///     simultaneously.
///   </para>
/// </summary>
/// <param name='unit'>Specifies the index of the texture unit to which the sampler is
/// bound.</param> <param name='sampler'>Specifies the name of a sampler.</param>
#define glBindSampler glad_debug_glBindSampler
    GLAD_API_CALL PFNGLBINDSAMPLERSPROC glad_glBindSamplers;
    GLAD_API_CALL PFNGLBINDSAMPLERSPROC glad_debug_glBindSamplers;

/// <summary>
///   bind one or more named sampler objects to a sequence of consecutive sampler units
///   <para>
///     glBindSamplers binds samplers from an array of existing sampler objects to a specified
///     number of consecutive sampler units. count specifies the number of sampler objects whose
///     names are stored in the array samplers. That number of sampler names is read from the array
///     and bound to the count consecutive sampler units starting from first. If the name zero
///     appears in the samplers array, any existing binding to the sampler unit is reset. Any
///     non-zero entry in samplers must be the name of an existing sampler object. When a non-zero
///     entry in samplers is present, that sampler object is bound to the corresponding sampler
///     unit. If samplers is NULL then it is as if an appropriately sized array containing only
///     zeros had been specified. glBindSamplers is equivalent to the following pseudo code: Each
///     entry in samplers will be checked individually and if found to be invalid, the state for
///     that sampler unit will not be changed and an error will be generated. However, the state for
///     other sampler units referenced by the command will still be updated.
///   </para>
/// </summary>
/// <param name='first'>Specifies the first sampler unit to which a sampler object is to be
/// bound.</param> <param name='count'>Specifies the number of samplers to bind.</param> <param
/// name='samplers'>Specifies the address of an array of names of existing sampler objects.</param>
#define glBindSamplers glad_debug_glBindSamplers
    GLAD_API_CALL PFNGLBINDSHADINGRATEIMAGENVPROC glad_glBindShadingRateImageNV;
    GLAD_API_CALL PFNGLBINDSHADINGRATEIMAGENVPROC glad_debug_glBindShadingRateImageNV;
#define glBindShadingRateImageNV glad_debug_glBindShadingRateImageNV
    GLAD_API_CALL PFNGLBINDTEXGENPARAMETEREXTPROC glad_glBindTexGenParameterEXT;
    GLAD_API_CALL PFNGLBINDTEXGENPARAMETEREXTPROC glad_debug_glBindTexGenParameterEXT;
#define glBindTexGenParameterEXT glad_debug_glBindTexGenParameterEXT
    GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_glBindTexture;
    GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_debug_glBindTexture;

/// <summary>
///   bind a named texture to a texturing target
///   <para>
///     glBindTexture lets you create or use a named texture. Calling glBindTexture with target set
///     to GL_TEXTURE_1D , GL_TEXTURE_2D , GL_TEXTURE_3D , GL_TEXTURE_1D_ARRAY , GL_TEXTURE_2D_ARRAY
///     , GL_TEXTURE_RECTANGLE , GL_TEXTURE_CUBE_MAP , GL_TEXTURE_CUBE_MAP_ARRAY , GL_TEXTURE_BUFFER
///     , GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and texture set to the name
///     of the new texture binds the texture name to the target. When a texture is bound to a
///     target, the previous binding for that target is automatically broken. Texture names are
///     unsigned integers. The value zero is reserved to represent the default texture for each
///     texture target. Texture names and the corresponding texture contents are local to the shared
///     object space of the current GL rendering context; two rendering contexts share texture names
///     only if they explicitly enable sharing between contexts through the appropriate GL windows
///     interfaces functions. You must use glGenTextures to generate a set of new texture names.
///     When a texture is first bound, it assumes the specified target: A texture first bound to
///     GL_TEXTURE_1D becomes one-dimensional texture, a texture first bound to GL_TEXTURE_2D
///     becomes two-dimensional texture, a texture first bound to GL_TEXTURE_3D becomes
///     three-dimensional texture, a texture first bound to GL_TEXTURE_1D_ARRAY becomes
///     one-dimensional array texture, a texture first bound to GL_TEXTURE_2D_ARRAY becomes
///     two-dimensional array texture, a texture first bound to GL_TEXTURE_RECTANGLE becomes
///     rectangle texture, a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped
///     texture, a texture first bound to GL_TEXTURE_CUBE_MAP_ARRAY becomes a cube-mapped array
///     texture, a texture first bound to GL_TEXTURE_BUFFER becomes a buffer texture, a texture
///     first bound to GL_TEXTURE_2D_MULTISAMPLE becomes a two-dimensional multisampled texture, and
///     a texture first bound to GL_TEXTURE_2D_MULTISAMPLE_ARRAY becomes a two-dimensional
///     multisampled array texture. The state of a one-dimensional texture immediately after it is
///     first bound is equivalent to the state of the default GL_TEXTURE_1D at GL initialization,
///     and similarly for the other texture types. While a texture is bound, GL operations on the
///     target to which it is bound affect the bound texture, and queries of the target to which it
///     is bound return state from the bound texture. In effect, the texture targets become aliases
///     for the textures currently bound to them, and the texture name zero refers to the default
///     textures that were bound to them at initialization. A texture binding created with
///     glBindTexture remains active until a different texture is bound to the same target, or until
///     the bound texture is deleted with glDeleteTextures. Once created, a named texture may be
///     re-bound to its same original target as often as needed. It is usually much faster to use
///     glBindTexture to bind an existing named texture to one of the texture targets than it is to
///     reload the texture image using glTexImage1D , glTexImage2D , glTexImage3D or another similar
///     function.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound. Must be one of</param>
/// <param name='texture'>Specifies the name of a texture.</param>
#define glBindTexture glad_debug_glBindTexture
    GLAD_API_CALL PFNGLBINDTEXTUREEXTPROC glad_glBindTextureEXT;
    GLAD_API_CALL PFNGLBINDTEXTUREEXTPROC glad_debug_glBindTextureEXT;
#define glBindTextureEXT glad_debug_glBindTextureEXT
    GLAD_API_CALL PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;
    GLAD_API_CALL PFNGLBINDTEXTUREUNITPROC glad_debug_glBindTextureUnit;

/// <summary>
///   bind an existing texture object to the specified texture unit
///   <para>
///     glBindTextureUnit binds an existing texture object to the texture unit numbered unit.
///     texture must be zero or the name of an existing texture object. When texture is the name of
///     an existing texture object, that object is bound to the target, in the corresponding texture
///     unit, that was specified when the object was created. When texture is zero, each of the
///     targets enumerated at the beginning of this section is reset to its default texture for the
///     corresponding texture image unit.
///   </para>
/// </summary>
/// <param name='unit'>Specifies the texture unit, to which the texture object should be bound
/// to.</param> <param name='texture'>Specifies the name of a texture.</param>
#define glBindTextureUnit glad_debug_glBindTextureUnit
    GLAD_API_CALL PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_glBindTextureUnitParameterEXT;
    GLAD_API_CALL PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_debug_glBindTextureUnitParameterEXT;
#define glBindTextureUnitParameterEXT glad_debug_glBindTextureUnitParameterEXT
    GLAD_API_CALL PFNGLBINDTEXTURESPROC glad_glBindTextures;
    GLAD_API_CALL PFNGLBINDTEXTURESPROC glad_debug_glBindTextures;

/// <summary>
///   bind one or more named textures to a sequence of consecutive texture units
///   <para>
///     glBindTextures binds an array of existing texture objects to a specified number of
///     consecutive texture units. count specifies the number of texture objects whose names are
///     stored in the array textures. That number of texture names are read from the array and bound
///     to the count consecutive texture units starting from first. The target, or type of texture
///     is deduced from the texture object and each texture is bound to the corresponding target of
///     the texture unit. If the name zero appears in the textures array, any existing binding to
///     any target of the texture unit is reset and the default texture for that target is bound in
///     its place. Any non-zero entry in textures must be the name of an existing texture object. If
///     textures is NULL then it is as if an appropriately sized array containing only zeros had
///     been specified. With the exception that the active texture selector maintains its current
///     value, glBindTextures is equivalent to the following pseudo code: Each entry in textures
///     will be checked individually and if found to be invalid, the state for that texture unit
///     will not be changed and an error will be generated. However, the state for other texture
///     units referenced by the command will still be updated.
///   </para>
/// </summary>
/// <param name='first'>Specifies the first texture unit to which a texture is to be bound.</param>
/// <param name='count'>Specifies the number of textures to bind.</param>
/// <param name='textures'>Specifies the address of an array of names of existing texture
/// objects.</param>
#define glBindTextures glad_debug_glBindTextures
    GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
    GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_debug_glBindTransformFeedback;

/// <summary>
///   bind a transform feedback object
///   <para>
///     glBindTransformFeedback binds the transform feedback object with name id to the current GL
///     state. id must be a name previously returned from a call to glGenTransformFeedbacks. If id
///     has not previously been bound, a new transform feedback object with name id and initialized
///     with with the default transform state vector is created. In the initial state, a default
///     transform feedback object is bound and treated as a transform feedback object with a name of
///     zero. If the name zero is subsequently bound, the default transform feedback object is again
///     bound to the GL state. While a transform feedback buffer object is bound, GL operations on
///     the target to which it is bound affect the bound transform feedback object, and queries of
///     the target to which a transform feedback object is bound return state from the bound object.
///     When buffer objects are bound for transform feedback, they are attached to the currently
///     bound transform feedback object. Buffer objects are used for trans- form feedback only if
///     they are attached to the currently bound transform feedback object.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which to bind the transform feedback object</param>
/// <param name='id'>Specifies the name of a transform feedback object reserved by</param>
#define glBindTransformFeedback glad_debug_glBindTransformFeedback
    GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_glBindTransformFeedbackNV;
    GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_debug_glBindTransformFeedbackNV;
#define glBindTransformFeedbackNV glad_debug_glBindTransformFeedbackNV
    GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
    GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_debug_glBindVertexArray;

/// <summary>
///   bind a vertex array object
///   <para>
///     glBindVertexArray binds the vertex array object with name array. array is the name of a
///     vertex array object previously returned from a call to glGenVertexArrays , or zero to break
///     the existing vertex array object binding. If no vertex array object with name array exists,
///     one is created when array is first bound. If the bind is successful no change is made to the
///     state of the vertex array object, and any previous vertex array object binding is broken.
///   </para>
/// </summary>
/// <param name='array'>Specifies the name of the vertex array to bind.</param>
#define glBindVertexArray glad_debug_glBindVertexArray
    GLAD_API_CALL PFNGLBINDVERTEXARRAYAPPLEPROC glad_glBindVertexArrayAPPLE;
    GLAD_API_CALL PFNGLBINDVERTEXARRAYAPPLEPROC glad_debug_glBindVertexArrayAPPLE;
#define glBindVertexArrayAPPLE glad_debug_glBindVertexArrayAPPLE
    GLAD_API_CALL PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;
    GLAD_API_CALL PFNGLBINDVERTEXBUFFERPROC glad_debug_glBindVertexBuffer;

/// <summary>
///   bind a buffer to a vertex buffer bind point
///   <para>
///     glBindVertexBuffer and glVertexArrayVertexBuffer bind the buffer named buffer to the vertex
///     buffer binding point whose index is given by bindingindex. glBindVertexBuffer modifies the
///     binding of the currently bound vertex array object, whereas glVertexArrayVertexBuffer allows
///     the caller to specify ID of the vertex array object with an argument named vaobj , for which
///     the binding should be modified. offset and stride specify the offset of the first element
///     within the buffer and the distance between elements within the buffer, respectively, and are
///     both measured in basic machine units. bindingindex must be less than the value of
///     GL_MAX_VERTEX_ATTRIB_BINDINGS. offset and stride must be greater than or equal to zero. If
///     buffer is zero, then any buffer currently bound to the specified binding point is unbound.
///     If buffer is not the name of an existing buffer object, the GL first creates a new state
///     vector, initialized with a zero-sized memory buffer and comprising all the state and with
///     the same initial values as in case of glBindBuffer. buffer is then attached to the specified
///     bindingindex of the vertex array object.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object to be used by</param>
/// <param name='bindingindex'>The index of the vertex buffer binding point to which to bind the
/// buffer.</param> <param name='buffer'>The name of a buffer to bind to the vertex buffer binding
/// point.</param> <param name='offset'>The offset of the first element of the buffer.</param>
/// <param name='stride'>The distance between elements within the buffer.</param>
#define glBindVertexBuffer glad_debug_glBindVertexBuffer
    GLAD_API_CALL PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;
    GLAD_API_CALL PFNGLBINDVERTEXBUFFERSPROC glad_debug_glBindVertexBuffers;

/// <summary>
///   attach multiple buffer objects to a vertex array object
///   <para>
///     glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing
///     buffer objects to a specified number of consecutive vertex buffer binding points units in a
///     vertex array object. For glBindVertexBuffers , the vertex array object is the currently
///     bound vertex array object. For glVertexArrayVertexBuffers , vaobj is the name of the vertex
///     array object. count existing buffer objects are bound to vertex buffer binding points
///     numbered $first$ through $first + count - 1$. If buffers is not NULL, it specifies an array
///     of count values, each of which must be zero or the name of an existing buffer object.
///     offsets and strides specify arrays of count values indicating the offset of the first
///     element and stride between elements in each buffer, respectively. If buffers is NULL, each
///     affected vertex buffer binding point from $first$ through $first + count - 1$ will be reset
///     to have no bound buffer object. In this case, the offsets and strides associated with the
///     binding points are set to default values, ignoring offsets and strides. glBindVertexBuffers
///     is equivalent (assuming no errors are generated) to: except that buffers will not be created
///     if they do not exist. glVertexArrayVertexBuffers is equivalent to the pseudocode above, but
///     replacing glBindVertexBuffers (args) with glVertexArrayVertexBuffers (vaobj, args). The
///     values specified in buffers , offsets , and strides will be checked separately for each
///     vertex buffer binding point. When a value for a specific vertex buffer binding point is
///     invalid, the state for that binding point will be unchanged and an error will be generated.
///     However, state for other vertex buffer binding points will still be changed if their
///     corresponding values are valid.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object for</param>
/// <param name='first'>Specifies the first vertex buffer binding point to which a buffer object is
/// to be bound.</param> <param name='count'>Specifies the number of buffers to bind.</param> <param
/// name='buffers'>Specifies the address of an array of names of existing buffer objects.</param>
/// <param name='offsets'>Specifies the address of an array of offsets to associate with the binding
/// points.</param> <param name='strides'>Specifies the address of an array of strides to associate
/// with the binding points.</param>
#define glBindVertexBuffers glad_debug_glBindVertexBuffers
    GLAD_API_CALL PFNGLBINDVERTEXSHADEREXTPROC glad_glBindVertexShaderEXT;
    GLAD_API_CALL PFNGLBINDVERTEXSHADEREXTPROC glad_debug_glBindVertexShaderEXT;
#define glBindVertexShaderEXT glad_debug_glBindVertexShaderEXT
    GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC glad_glBindVideoCaptureStreamBufferNV;
    GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC
        glad_debug_glBindVideoCaptureStreamBufferNV;
#define glBindVideoCaptureStreamBufferNV glad_debug_glBindVideoCaptureStreamBufferNV
    GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC glad_glBindVideoCaptureStreamTextureNV;
    GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC
        glad_debug_glBindVideoCaptureStreamTextureNV;
#define glBindVideoCaptureStreamTextureNV glad_debug_glBindVideoCaptureStreamTextureNV
    GLAD_API_CALL PFNGLBINORMAL3BEXTPROC glad_glBinormal3bEXT;
    GLAD_API_CALL PFNGLBINORMAL3BEXTPROC glad_debug_glBinormal3bEXT;
#define glBinormal3bEXT glad_debug_glBinormal3bEXT
    GLAD_API_CALL PFNGLBINORMAL3BVEXTPROC glad_glBinormal3bvEXT;
    GLAD_API_CALL PFNGLBINORMAL3BVEXTPROC glad_debug_glBinormal3bvEXT;
#define glBinormal3bvEXT glad_debug_glBinormal3bvEXT
    GLAD_API_CALL PFNGLBINORMAL3DEXTPROC glad_glBinormal3dEXT;
    GLAD_API_CALL PFNGLBINORMAL3DEXTPROC glad_debug_glBinormal3dEXT;
#define glBinormal3dEXT glad_debug_glBinormal3dEXT
    GLAD_API_CALL PFNGLBINORMAL3DVEXTPROC glad_glBinormal3dvEXT;
    GLAD_API_CALL PFNGLBINORMAL3DVEXTPROC glad_debug_glBinormal3dvEXT;
#define glBinormal3dvEXT glad_debug_glBinormal3dvEXT
    GLAD_API_CALL PFNGLBINORMAL3FEXTPROC glad_glBinormal3fEXT;
    GLAD_API_CALL PFNGLBINORMAL3FEXTPROC glad_debug_glBinormal3fEXT;
#define glBinormal3fEXT glad_debug_glBinormal3fEXT
    GLAD_API_CALL PFNGLBINORMAL3FVEXTPROC glad_glBinormal3fvEXT;
    GLAD_API_CALL PFNGLBINORMAL3FVEXTPROC glad_debug_glBinormal3fvEXT;
#define glBinormal3fvEXT glad_debug_glBinormal3fvEXT
    GLAD_API_CALL PFNGLBINORMAL3IEXTPROC glad_glBinormal3iEXT;
    GLAD_API_CALL PFNGLBINORMAL3IEXTPROC glad_debug_glBinormal3iEXT;
#define glBinormal3iEXT glad_debug_glBinormal3iEXT
    GLAD_API_CALL PFNGLBINORMAL3IVEXTPROC glad_glBinormal3ivEXT;
    GLAD_API_CALL PFNGLBINORMAL3IVEXTPROC glad_debug_glBinormal3ivEXT;
#define glBinormal3ivEXT glad_debug_glBinormal3ivEXT
    GLAD_API_CALL PFNGLBINORMAL3SEXTPROC glad_glBinormal3sEXT;
    GLAD_API_CALL PFNGLBINORMAL3SEXTPROC glad_debug_glBinormal3sEXT;
#define glBinormal3sEXT glad_debug_glBinormal3sEXT
    GLAD_API_CALL PFNGLBINORMAL3SVEXTPROC glad_glBinormal3svEXT;
    GLAD_API_CALL PFNGLBINORMAL3SVEXTPROC glad_debug_glBinormal3svEXT;
#define glBinormal3svEXT glad_debug_glBinormal3svEXT
    GLAD_API_CALL PFNGLBINORMALPOINTEREXTPROC glad_glBinormalPointerEXT;
    GLAD_API_CALL PFNGLBINORMALPOINTEREXTPROC glad_debug_glBinormalPointerEXT;
#define glBinormalPointerEXT glad_debug_glBinormalPointerEXT
    GLAD_API_CALL PFNGLBITMAPXOESPROC glad_glBitmapxOES;
    GLAD_API_CALL PFNGLBITMAPXOESPROC glad_debug_glBitmapxOES;
#define glBitmapxOES glad_debug_glBitmapxOES
    GLAD_API_CALL PFNGLBLENDBARRIERKHRPROC glad_glBlendBarrierKHR;
    GLAD_API_CALL PFNGLBLENDBARRIERKHRPROC glad_debug_glBlendBarrierKHR;
#define glBlendBarrierKHR glad_debug_glBlendBarrierKHR
    GLAD_API_CALL PFNGLBLENDBARRIERNVPROC glad_glBlendBarrierNV;
    GLAD_API_CALL PFNGLBLENDBARRIERNVPROC glad_debug_glBlendBarrierNV;
#define glBlendBarrierNV glad_debug_glBlendBarrierNV
    GLAD_API_CALL PFNGLBLENDCOLORPROC glad_glBlendColor;
    GLAD_API_CALL PFNGLBLENDCOLORPROC glad_debug_glBlendColor;

/// <summary>
///   set the blend color
///   <para>
///     The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The
///     color components are clamped to the range 0 1 before being stored. See glBlendFunc for a
///     complete description of the blending operations. Initially the GL_BLEND_COLOR is set to (0,
///     0, 0, 0).
///   </para>
/// </summary>
/// <param name='red'>specify the components of</param>
#define glBlendColor glad_debug_glBlendColor
    GLAD_API_CALL PFNGLBLENDCOLOREXTPROC glad_glBlendColorEXT;
    GLAD_API_CALL PFNGLBLENDCOLOREXTPROC glad_debug_glBlendColorEXT;
#define glBlendColorEXT glad_debug_glBlendColorEXT
    GLAD_API_CALL PFNGLBLENDCOLORXOESPROC glad_glBlendColorxOES;
    GLAD_API_CALL PFNGLBLENDCOLORXOESPROC glad_debug_glBlendColorxOES;
#define glBlendColorxOES glad_debug_glBlendColorxOES
    GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
    GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_debug_glBlendEquation;

/// <summary>
///   specify the equation used for both the RGB blend equation and the Alpha blend equation
///   <para>
///     The blend equations determine how a new pixel (the ''source'' color) is combined with a
///     pixel already in the framebuffer (the ''destination'' color). This function sets both the
///     RGB blend equation and the alpha blend equation to a single equation. glBlendEquationi
///     specifies the blend equation for a single draw buffer whereas glBlendEquation sets the blend
///     equation for all draw buffers. These equations use the source and destination blend factors
///     specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or
///     glBlendFuncSeparate for a description of the various blend factors. In the equations that
///     follow, source and destination color components are referred to as R s G s B s A s and R d G
///     d B d A d , respectively. The result color is referred to as R r G r B r A r. The source and
///     destination blend factors are denoted s R s G s B s A and d R d G d B d A , respectively.
///     For these equations all color components are understood to have values in the range 0 1. The
///     results of these equations are clamped to the range 0 1. The GL_MIN and GL_MAX equations are
///     useful for applications that analyze image data (image thresholding against a constant
///     color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency,
///     among other things. Initially, both the RGB blend equation and the alpha blend equation are
///     set to GL_FUNC_ADD.
///   </para>
/// </summary>
/// <param name='buf'>for</param>
/// <param name='mode'>specifies how source and destination colors are combined. It must be</param>
#define glBlendEquation glad_debug_glBlendEquation
    GLAD_API_CALL PFNGLBLENDEQUATIONEXTPROC glad_glBlendEquationEXT;
    GLAD_API_CALL PFNGLBLENDEQUATIONEXTPROC glad_debug_glBlendEquationEXT;
#define glBlendEquationEXT glad_debug_glBlendEquationEXT
    GLAD_API_CALL PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_glBlendEquationIndexedAMD;
    GLAD_API_CALL PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_debug_glBlendEquationIndexedAMD;
#define glBlendEquationIndexedAMD glad_debug_glBlendEquationIndexedAMD
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_debug_glBlendEquationSeparate;

/// <summary>
///   set the RGB blend equation and the alpha blend equation separately
///   <para>
///     The blend equations determines how a new pixel (the ''source'' color) is combined with a
///     pixel already in the framebuffer (the ''destination'' color). These functions specify one
///     blend equation for the RGB-color components and one blend equation for the alpha component.
///     glBlendEquationSeparatei specifies the blend equations for a single draw buffer whereas
///     glBlendEquationSeparate sets the blend equations for all draw buffers. The blend equations
///     use the source and destination blend factors specified by either glBlendFunc or
///     glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various
///     blend factors. In the equations that follow, source and destination color components are
///     referred to as R s G s B s A s and R d G d B d A d , respectively. The result color is
///     referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G
///     s B s A and d R d G d B d A , respectively. For these equations all color components are
///     understood to have values in the range 0 1. The results of these equations are clamped to
///     the range 0 1. The GL_MIN and GL_MAX equations are useful for applications that analyze
///     image data (image thresholding against a constant color, for example). The GL_FUNC_ADD
///     equation is useful for antialiasing and transparency, among other things. Initially, both
///     the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
///   </para>
/// </summary>
/// <param name='buf'>for</param>
/// <param name='modeRGB'>specifies the RGB blend equation, how the red, green, and blue components
/// of the source and destination colors are combined. It must be</param> <param
/// name='modeAlpha'>specifies the alpha blend equation, how the alpha component of the source and
/// destination colors are combined. It must be</param>
#define glBlendEquationSeparate glad_debug_glBlendEquationSeparate
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_glBlendEquationSeparateEXT;
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_debug_glBlendEquationSeparateEXT;
#define glBlendEquationSeparateEXT glad_debug_glBlendEquationSeparateEXT
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC glad_glBlendEquationSeparateIndexedAMD;
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC
        glad_debug_glBlendEquationSeparateIndexedAMD;
#define glBlendEquationSeparateIndexedAMD glad_debug_glBlendEquationSeparateIndexedAMD
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_debug_glBlendEquationSeparatei;
#define glBlendEquationSeparatei glad_debug_glBlendEquationSeparatei
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_glBlendEquationSeparateiARB;
    GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_debug_glBlendEquationSeparateiARB;
#define glBlendEquationSeparateiARB glad_debug_glBlendEquationSeparateiARB
    GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
    GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_debug_glBlendEquationi;
#define glBlendEquationi glad_debug_glBlendEquationi
    GLAD_API_CALL PFNGLBLENDEQUATIONIARBPROC glad_glBlendEquationiARB;
    GLAD_API_CALL PFNGLBLENDEQUATIONIARBPROC glad_debug_glBlendEquationiARB;
#define glBlendEquationiARB glad_debug_glBlendEquationiARB
    GLAD_API_CALL PFNGLBLENDFUNCPROC glad_glBlendFunc;
    GLAD_API_CALL PFNGLBLENDFUNCPROC glad_debug_glBlendFunc;

/// <summary>
///   specify pixel arithmetic
///   <para>
///     Pixels can be drawn using a function that blends the incoming (source) RGBA values with the
///     RGBA values that are already in the frame buffer (the destination values). Blending is
///     initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable
///     blending. glBlendFunc defines the operation of blending for all draw buffers when it is
///     enabled. glBlendFunci defines the operation of blending for a single draw buffer specified
///     by buf when enabled for that draw buffer. sfactor specifies which method is used to scale
///     the source color components. dfactor specifies which method is used to scale the destination
///     color components. Both parameters must be one of the following symbolic constants: GL_ZERO ,
///     GL_ONE , GL_SRC_COLOR , GL_ONE_MINUS_SRC_COLOR , GL_DST_COLOR , GL_ONE_MINUS_DST_COLOR ,
///     GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA , GL_DST_ALPHA , GL_ONE_MINUS_DST_ALPHA ,
///     GL_CONSTANT_COLOR , GL_ONE_MINUS_CONSTANT_COLOR , GL_CONSTANT_ALPHA ,
///     GL_ONE_MINUS_CONSTANT_ALPHA , GL_SRC_ALPHA_SATURATE , GL_SRC1_COLOR ,
///     GL_ONE_MINUS_SRC1_COLOR , GL_SRC1_ALPHA , and GL_ONE_MINUS_SRC1_ALPHA. The possible methods
///     are described in the following table. Each method defines four scale factors, one each for
///     red, green, blue, and alpha. In the table and in subsequent equations, first source, second
///     source and destination color components are referred to as R s0 G s0 B s0 A s0 , R s1 G s1 B
///     s1 A s1 and R d G d B d A d , respectively. The color specified by glBlendColor is referred
///     to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B
///     k A , where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha
///     bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d
///     G d B d A. The scale factors described in the table, denoted f R f G f B f A , represent
///     either source or destination factors. All scale factors have range 0 1. In the table, i =
///     min ⁡ A s k A - A d k A To determine the blended RGBA values of a pixel, the system uses
///     the following equations: R d = min ⁡ k R R s ⁢ s R + R d ⁢ d R G d = min ⁡ k G G s
///     ⁢ s G + G d ⁢ d G B d = min ⁡ k B B s ⁢ s B + B d ⁢ d B A d = min ⁡ k A A s ⁢
///     s A + A d ⁢ d A Despite the apparent precision of the above equations, blending arithmetic
///     is not exactly specified, because blending operates with imprecise integer color values.
///     However, a blend factor that should be equal to 1 is guaranteed not to modify its
///     multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when
///     sfactor is GL_SRC_ALPHA , dfactor is GL_ONE_MINUS_SRC_ALPHA , and A s is equal to k A , the
///     equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
///   </para>
/// </summary>
/// <param name='buf'>For</param>
/// <param name='sfactor'>Specifies how the red, green, blue, and alpha source blending factors are
/// computed. The initial value is</param> <param name='dfactor'>Specifies how the red, green, blue,
/// and alpha destination blending factors are computed. The following symbolic constants are
/// accepted:</param>
#define glBlendFunc glad_debug_glBlendFunc
    GLAD_API_CALL PFNGLBLENDFUNCINDEXEDAMDPROC glad_glBlendFuncIndexedAMD;
    GLAD_API_CALL PFNGLBLENDFUNCINDEXEDAMDPROC glad_debug_glBlendFuncIndexedAMD;
#define glBlendFuncIndexedAMD glad_debug_glBlendFuncIndexedAMD
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_debug_glBlendFuncSeparate;

/// <summary>
///   specify pixel arithmetic for RGB and alpha components separately
///   <para>
///     Pixels can be drawn using a function that blends the incoming (source) RGBA values with the
///     RGBA values that are already in the frame buffer (the destination values). Blending is
///     initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable
///     blending. glBlendFuncSeparate defines the operation of blending for all draw buffers when it
///     is enabled. glBlendFuncSeparatei defines the operation of blending for a single draw buffer
///     specified by buf when enabled for that draw buffer. srcRGB specifies which method is used to
///     scale the source RGB-color components. dstRGB specifies which method is used to scale the
///     destination RGB-color components. Likewise, srcAlpha specifies which method is used to scale
///     the source alpha color component, and dstAlpha specifies which method is used to scale the
///     destination alpha component. The possible methods are described in the following table. Each
///     method defines four scale factors, one each for red, green, blue, and alpha. In the table
///     and in subsequent equations, first source, second source and destination color components
///     are referred to as R s0 G s0 B s0 A s0 , R s1 G s1 B s1 A s1 , and R d G d B d A d ,
///     respectively. The color specified by glBlendColor is referred to as R c G c B c A c. They
///     are understood to have integer values between 0 and k R k G k B k A , where k c = 2 m c - 1
///     and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and
///     destination scale factors are referred to as s R s G s B s A and d R d G d B d A. All scale
///     factors have range 0 1. In the table, i = min ⁡ A s 1 - A d To determine the blended RGBA
///     values of a pixel, the system uses the following equations: R d = min ⁡ k R R s ⁢ s R +
///     R d ⁢ d R G d = min ⁡ k G G s ⁢ s G + G d ⁢ d G B d = min ⁡ k B B s ⁢ s B + B d
///     ⁢ d B A d = min ⁡ k A A s ⁢ s A + A d ⁢ d A Despite the apparent precision of the
///     above equations, blending arithmetic is not exactly specified, because blending operates
///     with imprecise integer color values. However, a blend factor that should be equal to 1 is
///     guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its
///     multiplicand to 0. For example, when srcRGB is GL_SRC_ALPHA , dstRGB is
///     GL_ONE_MINUS_SRC_ALPHA , and A s is equal to k A , the equations reduce to simple
///     replacement: R d = R s G d = G s B d = B s A d = A s
///   </para>
/// </summary>
/// <param name='buf'>For</param>
/// <param name='srcRGB'>Specifies how the red, green, and blue blending factors are computed. The
/// initial value is</param> <param name='dstRGB'>Specifies how the red, green, and blue destination
/// blending factors are computed. The initial value is</param> <param name='srcAlpha'>Specified how
/// the alpha source blending factor is computed. The initial value is</param> <param
/// name='dstAlpha'>Specified how the alpha destination blending factor is computed. The initial
/// value is</param>
#define glBlendFuncSeparate glad_debug_glBlendFuncSeparate
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEEXTPROC glad_glBlendFuncSeparateEXT;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEEXTPROC glad_debug_glBlendFuncSeparateEXT;
#define glBlendFuncSeparateEXT glad_debug_glBlendFuncSeparateEXT
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEINGRPROC glad_glBlendFuncSeparateINGR;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEINGRPROC glad_debug_glBlendFuncSeparateINGR;
#define glBlendFuncSeparateINGR glad_debug_glBlendFuncSeparateINGR
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_glBlendFuncSeparateIndexedAMD;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_debug_glBlendFuncSeparateIndexedAMD;
#define glBlendFuncSeparateIndexedAMD glad_debug_glBlendFuncSeparateIndexedAMD
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_debug_glBlendFuncSeparatei;
#define glBlendFuncSeparatei glad_debug_glBlendFuncSeparatei
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIARBPROC glad_glBlendFuncSeparateiARB;
    GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIARBPROC glad_debug_glBlendFuncSeparateiARB;
#define glBlendFuncSeparateiARB glad_debug_glBlendFuncSeparateiARB
    GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_glBlendFunci;
    GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_debug_glBlendFunci;
#define glBlendFunci glad_debug_glBlendFunci
    GLAD_API_CALL PFNGLBLENDFUNCIARBPROC glad_glBlendFunciARB;
    GLAD_API_CALL PFNGLBLENDFUNCIARBPROC glad_debug_glBlendFunciARB;
#define glBlendFunciARB glad_debug_glBlendFunciARB
    GLAD_API_CALL PFNGLBLENDPARAMETERINVPROC glad_glBlendParameteriNV;
    GLAD_API_CALL PFNGLBLENDPARAMETERINVPROC glad_debug_glBlendParameteriNV;
#define glBlendParameteriNV glad_debug_glBlendParameteriNV
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_debug_glBlitFramebuffer;

/// <summary>
///   copy a block of pixels from one framebuffer object to another
///   <para>
///     glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one
///     region of a read framebuffer to another region of a draw framebuffer. For glBlitFramebuffer
///     , the read and draw framebuffers are those bound to the GL_READ_FRAMEBUFFER and
///     GL_DRAW_FRAMEBUFFER targets respectively. For glBlitNamedFramebuffer , readFramebuffer and
///     drawFramebuffer are the names of the read read and draw framebuffer objects respectively. If
///     readFramebuffer or drawFramebuffer is zero, then the default read or draw framebuffer
///     respectively is used. mask is the bitwise OR of a number of values indicating which buffers
///     are to be copied. The values are GL_COLOR_BUFFER_BIT , GL_DEPTH_BUFFER_BIT , and
///     GL_STENCIL_BUFFER_BIT. The pixels corresponding to these buffers are copied from the source
///     rectangle bounded by the locations ( srcX0 , srcY0 ) and ( srcX1 , srcY1 ) to the
///     destination rectangle bounded by the locations ( dstX0 , dstY0 ) and ( dstX1 , dstY1 ). The
///     lower bounds of the rectangle are inclusive, while the upper bounds are exclusive. The
///     actual region taken from the read framebuffer is limited to the intersection of the source
///     buffers being transferred, which may include the color buffer selected by the read buffer,
///     the depth buffer, and/or the stencil buffer depending on mask. The actual region written to
///     the draw framebuffer is limited to the intersection of the destination buffers being
///     written, which may include multiple draw buffers, the depth buffer, and/or the stencil
///     buffer depending on mask. Whether or not the source or destination regions are altered due
///     to these limits, the scaling and offset applied to pixels being transferred is performed as
///     though no such limits were present. If the sizes of the source and destination rectangles
///     are not equal, filter specifies the interpolation method that will be applied to resize the
///     source image , and must be GL_NEAREST or GL_LINEAR. GL_LINEAR is only a valid interpolation
///     method for the color buffer. If filter is not GL_NEAREST and mask includes
///     GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT , no data is transferred and a
///     GL_INVALID_OPERATION error is generated. If filter is GL_LINEAR and the source rectangle
///     would require sampling outside the bounds of the source framebuffer, values are read as if
///     the GL_CLAMP_TO_EDGE texture wrapping mode were applied. When the color buffer is
///     transferred, values are taken from the read buffer of the specified read framebuffer and
///     written to each of the draw buffers of the specified draw framebuffer. If the source and
///     destination rectangles overlap or are the same, and the read and draw buffers are the same,
///     the result of the operation is undefined.
///   </para>
/// </summary>
/// <param name='readFramebuffer'>Specifies the name of the source framebuffer object for</param>
/// <param name='drawFramebuffer'>Specifies the name of the destination framebuffer object
/// for</param> <param name='srcX0'>Specify the bounds of the source rectangle within the read
/// buffer of the read framebuffer.</param> <param name='srcY0'>Specify the bounds of the
/// destination rectangle within the write buffer of the write framebuffer.</param> <param
/// name='srcX1'>The bitwise OR of the flags indicating which buffers are to be copied. The allowed
/// flags are</param> <param name='srcY1'>Specifies the interpolation to be applied if the image is
/// stretched. Must be</param>
#define glBlitFramebuffer glad_debug_glBlitFramebuffer
    GLAD_API_CALL PFNGLBLITFRAMEBUFFEREXTPROC glad_glBlitFramebufferEXT;
    GLAD_API_CALL PFNGLBLITFRAMEBUFFEREXTPROC glad_debug_glBlitFramebufferEXT;
#define glBlitFramebufferEXT glad_debug_glBlitFramebufferEXT
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERLAYEREXTPROC glad_glBlitFramebufferLayerEXT;
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERLAYEREXTPROC glad_debug_glBlitFramebufferLayerEXT;
#define glBlitFramebufferLayerEXT glad_debug_glBlitFramebufferLayerEXT
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERLAYERSEXTPROC glad_glBlitFramebufferLayersEXT;
    GLAD_API_CALL PFNGLBLITFRAMEBUFFERLAYERSEXTPROC glad_debug_glBlitFramebufferLayersEXT;
#define glBlitFramebufferLayersEXT glad_debug_glBlitFramebufferLayersEXT
    GLAD_API_CALL PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;
    GLAD_API_CALL PFNGLBLITNAMEDFRAMEBUFFERPROC glad_debug_glBlitNamedFramebuffer;
#define glBlitNamedFramebuffer glad_debug_glBlitNamedFramebuffer
    GLAD_API_CALL PFNGLBUFFERADDRESSRANGENVPROC glad_glBufferAddressRangeNV;
    GLAD_API_CALL PFNGLBUFFERADDRESSRANGENVPROC glad_debug_glBufferAddressRangeNV;
#define glBufferAddressRangeNV glad_debug_glBufferAddressRangeNV
    GLAD_API_CALL PFNGLBUFFERATTACHMEMORYNVPROC glad_glBufferAttachMemoryNV;
    GLAD_API_CALL PFNGLBUFFERATTACHMEMORYNVPROC glad_debug_glBufferAttachMemoryNV;
#define glBufferAttachMemoryNV glad_debug_glBufferAttachMemoryNV
    GLAD_API_CALL PFNGLBUFFERDATAPROC glad_glBufferData;
    GLAD_API_CALL PFNGLBUFFERDATAPROC glad_debug_glBufferData;

/// <summary>
///   creates and initializes a buffer object's data store
///   <para>
///     glBufferData and glNamedBufferData create a new data store for a buffer object. In case of
///     glBufferData , the buffer object currently bound to target is used. For glNamedBufferData ,
///     a buffer object associated with ID specified by the caller in buffer will be used instead.
///     While creating the new storage, any pre-existing data store is deleted. The new data store
///     is created with the specified size in bytes and usage. If data is not NULL , the data store
///     is initialized with data from this pointer. In its initial state, the new data store is not
///     mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE. usage is a
///     hint to the GL implementation as to how a buffer object's data store will be accessed. This
///     enables the GL implementation to make more intelligent decisions that may significantly
///     impact buffer object performance. It does not, however, constrain the actual usage of the
///     data store. usage can be broken down into two parts: first, the frequency of access
///     (modification and usage), and second, the nature of that access. The frequency of access may
///     be one of these: The data store contents will be modified once and used at most a few times.
///     The data store contents will be modified once and used many times. The data store contents
///     will be modified repeatedly and used many times. The nature of access may be one of these:
///     The data store contents are modified by the application, and used as the source for GL
///     drawing and image specification commands. The data store contents are modified by reading
///     data from the GL, and used to return that data when queried by the application. The data
///     store contents are modified by reading data from the GL, and used as the source for GL
///     drawing and image specification commands.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='size'>Specifies the size in bytes of the buffer object's new data store.</param>
/// <param name='data'>Specifies a pointer to data that will be copied into the data store for
/// initialization, or</param> <param name='usage'>Specifies the expected usage pattern of the data
/// store. The symbolic constant must be</param>
#define glBufferData glad_debug_glBufferData
    GLAD_API_CALL PFNGLBUFFERDATAARBPROC glad_glBufferDataARB;
    GLAD_API_CALL PFNGLBUFFERDATAARBPROC glad_debug_glBufferDataARB;
#define glBufferDataARB glad_debug_glBufferDataARB
    GLAD_API_CALL PFNGLBUFFERPAGECOMMITMENTARBPROC glad_glBufferPageCommitmentARB;
    GLAD_API_CALL PFNGLBUFFERPAGECOMMITMENTARBPROC glad_debug_glBufferPageCommitmentARB;
#define glBufferPageCommitmentARB glad_debug_glBufferPageCommitmentARB
    GLAD_API_CALL PFNGLBUFFERPAGECOMMITMENTMEMNVPROC glad_glBufferPageCommitmentMemNV;
    GLAD_API_CALL PFNGLBUFFERPAGECOMMITMENTMEMNVPROC glad_debug_glBufferPageCommitmentMemNV;
#define glBufferPageCommitmentMemNV glad_debug_glBufferPageCommitmentMemNV
    GLAD_API_CALL PFNGLBUFFERPARAMETERIAPPLEPROC glad_glBufferParameteriAPPLE;
    GLAD_API_CALL PFNGLBUFFERPARAMETERIAPPLEPROC glad_debug_glBufferParameteriAPPLE;
#define glBufferParameteriAPPLE glad_debug_glBufferParameteriAPPLE
    GLAD_API_CALL PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;
    GLAD_API_CALL PFNGLBUFFERSTORAGEPROC glad_debug_glBufferStorage;

/// <summary>
///   creates and initializes a buffer object's immutable data store
///   <para>
///     glBufferStorage and glNamedBufferStorage create a new immutable data store. For
///     glBufferStorage , the buffer object currently bound to target will be initialized. For
///     glNamedBufferStorage , buffer is the name of the buffer object that will be configured. The
///     size of the data store is specified by size. If an initial data is available, its address
///     may be supplied in data. Otherwise, to create an uninitialized data store, data should be
///     NULL. The flags parameters specifies the intended usage of the buffer's data store. It must
///     be a bitwise combination of a subset of the following flags: The contents of the data store
///     may be updated after creation through calls to glBufferSubData. If this bit is not set, the
///     buffer content may not be directly updated by the client. The data argument may be used to
///     specify the initial content of the buffer's data store regardless of the presence of the
///     GL_DYNAMIC_STORAGE_BIT. Regardless of the presence of this bit, buffers may always be
///     updated with server-side calls such as glCopyBufferSubData and glClearBufferSubData. The
///     data store may be mapped by the client for read access and a pointer in the client's address
///     space obtained that may be read from. The data store may be mapped by the client for write
///     access and a pointer in the client's address space obtained that may be written through. The
///     client may request that the server read from or write to the buffer while it is mapped. The
///     client's pointer to the data store remains valid so long as the data store is mapped, even
///     during execution of drawing or dispatch commands. Shared access to buffers that are
///     simultaneously mapped for client access and are used by the server will be coherent, so long
///     as that mapping is performed using glMapBufferRange. That is, data written to the store by
///     either the client or server will be immediately visible to the other with no further action
///     taken by the application. In particular, If GL_MAP_COHERENT_BIT is not set and the client
///     performs a write followed by a call to the glMemoryBarrier command with the
///     GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set, then in subsequent commands the server will see the
///     writes. If GL_MAP_COHERENT_BIT is set and the client performs a write, then in subsequent
///     commands the server will see the writes. If GL_MAP_COHERENT_BIT is not set and the server
///     performs a write, the application must call glMemoryBarrier with the
///     GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set and then call glFenceSync with
///     GL_SYNC_GPU_COMMANDS_COMPLETE (or glFinish ). Then the CPU will see the writes after the
///     sync is complete. If GL_MAP_COHERENT_BIT is set and the server does a write, the app must
///     call FenceSync with GL_SYNC_GPU_COMMANDS_COMPLETE (or glFinish ). Then the CPU will see the
///     writes after the sync is complete. When all other criteria for the buffer storage allocation
///     are met, this bit may be used by an implementation to determine whether to use storage that
///     is local to the server or to the client to serve as the backing store for the buffer. The
///     allowed combinations of flags are subject to certain restrictions. They are as follows: If
///     flags contains GL_MAP_PERSISTENT_BIT , it must also contain at least one of GL_MAP_READ_BIT
///     or GL_MAP_WRITE_BIT. If flags contains GL_MAP_COHERENT_BIT , it must also contain
///     GL_MAP_PERSISTENT_BIT.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='size'>Specifies the size in bytes of the buffer object's new data store.</param>
/// <param name='data'>Specifies a pointer to data that will be copied into the data store for
/// initialization, or</param> <param name='flags'>Specifies the intended usage of the buffer's data
/// store. Must be a bitwise combination of the following flags.</param>
#define glBufferStorage glad_debug_glBufferStorage
    GLAD_API_CALL PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_glBufferStorageExternalEXT;
    GLAD_API_CALL PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_debug_glBufferStorageExternalEXT;
#define glBufferStorageExternalEXT glad_debug_glBufferStorageExternalEXT
    GLAD_API_CALL PFNGLBUFFERSTORAGEMEMEXTPROC glad_glBufferStorageMemEXT;
    GLAD_API_CALL PFNGLBUFFERSTORAGEMEMEXTPROC glad_debug_glBufferStorageMemEXT;
#define glBufferStorageMemEXT glad_debug_glBufferStorageMemEXT
    GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
    GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_debug_glBufferSubData;

/// <summary>
///   updates a subset of a buffer object's data store
///   <para>
///     glBufferSubData and glNamedBufferSubData redefine some or all of the data store for the
///     specified buffer object. Data starting at byte offset offset and extending for size bytes is
///     copied to the data store from the memory pointed to by data. offset and size must define a
///     range lying entirely within the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='offset'>Specifies the offset into the buffer object's data store where data
/// replacement will begin, measured in bytes.</param> <param name='size'>Specifies the size in
/// bytes of the data store region being replaced.</param> <param name='data'>Specifies a pointer to
/// the new data that will be copied into the data store.</param>
#define glBufferSubData glad_debug_glBufferSubData
    GLAD_API_CALL PFNGLBUFFERSUBDATAARBPROC glad_glBufferSubDataARB;
    GLAD_API_CALL PFNGLBUFFERSUBDATAARBPROC glad_debug_glBufferSubDataARB;
#define glBufferSubDataARB glad_debug_glBufferSubDataARB
    GLAD_API_CALL PFNGLCALLCOMMANDLISTNVPROC glad_glCallCommandListNV;
    GLAD_API_CALL PFNGLCALLCOMMANDLISTNVPROC glad_debug_glCallCommandListNV;
#define glCallCommandListNV glad_debug_glCallCommandListNV
    GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
    GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_debug_glCheckFramebufferStatus;

/// <summary>
///   check the completeness status of a framebuffer
///   <para>
///     glCheckFramebufferStatus and glCheckNamedFramebufferStatus return the completeness status of
///     a framebuffer object when treated as a read or draw framebuffer, depending on the value of
///     target. For glCheckFramebufferStatus , the framebuffer checked is that bound to target ,
///     which must be GL_DRAW_FRAMEBUFFER , GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. GL_FRAMEBUFFER is
///     equivalent to GL_DRAW_FRAMEBUFFER. For glCheckNamedFramebufferStatus , framebuffer is zero
///     or the name of the framebuffer object to check. If framebuffer is zero, then the status of
///     the default read or draw framebuffer, as determined by target , is returned. The return
///     value is GL_FRAMEBUFFER_COMPLETE if the specified framebuffer is complete. Otherwise, the
///     return value is determined as follows: GL_FRAMEBUFFER_UNDEFINED is returned if the specified
///     framebuffer is the default read or draw framebuffer, but the default framebuffer does not
///     exist. GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT is returned if any of the framebuffer attachment
///     points are framebuffer incomplete. GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT is returned
///     if the framebuffer does not have at least one image attached to it.
///     GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER is returned if the value of
///     GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for any color attachment point(s) named by
///     GL_DRAW_BUFFERi. GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER is returned if GL_READ_BUFFER is not
///     GL_NONE and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for the color
///     attachment point named by GL_READ_BUFFER. GL_FRAMEBUFFER_UNSUPPORTED is returned if the
///     combination of internal formats of the attached images violates an implementation-dependent
///     set of restrictions. GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is returned if the value of
///     GL_RENDERBUFFER_SAMPLES is not the same for all attached renderbuffers; if the value of
///     GL_TEXTURE_SAMPLES is the not same for all attached textures; or, if the attached images are
///     a mix of renderbuffers and textures, the value of GL_RENDERBUFFER_SAMPLES does not match the
///     value of GL_TEXTURE_SAMPLES. GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is also returned if the
///     value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is not the same for all attached textures; or, if
///     the attached images are a mix of renderbuffers and textures, the value of
///     GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is not GL_TRUE for all attached textures.
///     GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS is returned if any framebuffer attachment is
///     layered, and any populated attachment is not layered, or if all populated color attachments
///     are not from textures of the same target. Additionally, if an error occurs, zero is
///     returned.
///   </para>
/// </summary>
/// <param name='target'>Specify the target to which the framebuffer is bound for</param>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
#define glCheckFramebufferStatus glad_debug_glCheckFramebufferStatus
    GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_glCheckFramebufferStatusEXT;
    GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_debug_glCheckFramebufferStatusEXT;
#define glCheckFramebufferStatusEXT glad_debug_glCheckFramebufferStatusEXT
    GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;
    GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_debug_glCheckNamedFramebufferStatus;
#define glCheckNamedFramebufferStatus glad_debug_glCheckNamedFramebufferStatus
    GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glad_glCheckNamedFramebufferStatusEXT;
    GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC
        glad_debug_glCheckNamedFramebufferStatusEXT;
#define glCheckNamedFramebufferStatusEXT glad_debug_glCheckNamedFramebufferStatusEXT
    GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_glClampColor;
    GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_debug_glClampColor;

/// <summary>
///   specify whether data read via
///   <para>
///     glClampColor controls color clamping that is performed during glReadPixels. target must be
///     GL_CLAMP_READ_COLOR. If clamp is GL_TRUE , read color clamping is enabled; if clamp is
///     GL_FALSE , read color clamping is disabled. If clamp is GL_FIXED_ONLY , read color clamping
///     is enabled only if the selected read buffer has fixed point components and disabled
///     otherwise.
///   </para>
/// </summary>
/// <param name='target'>Target for color clamping.</param>
/// <param name='clamp'>Specifies whether to apply color clamping.</param>
#define glClampColor glad_debug_glClampColor
    GLAD_API_CALL PFNGLCLAMPCOLORARBPROC glad_glClampColorARB;
    GLAD_API_CALL PFNGLCLAMPCOLORARBPROC glad_debug_glClampColorARB;
#define glClampColorARB glad_debug_glClampColorARB
    GLAD_API_CALL PFNGLCLEARPROC glad_glClear;
    GLAD_API_CALL PFNGLCLEARPROC glad_debug_glClear;

/// <summary>
///   clear buffers to preset values
///   <para>
///     glClear sets the bitplane area of the window to values previously selected by glClearColor ,
///     glClearDepth , and glClearStencil. Multiple color buffers can be cleared simultaneously by
///     selecting more than one buffer at a time using glDrawBuffer. The pixel ownership test, the
///     scissor test, dithering, and the buffer writemasks affect the operation of glClear. The
///     scissor box bounds the cleared region. Alpha function, blend function, logical operation,
///     stenciling, texture mapping, and depth-buffering are ignored by glClear. glClear takes a
///     single argument that is the bitwise OR of several values indicating which buffer is to be
///     cleared. The values are as follows: Indicates the buffers currently enabled for color
///     writing. Indicates the depth buffer. Indicates the stencil buffer. The value to which each
///     buffer is cleared depends on the setting of the clear value for that buffer.
///   </para>
/// </summary>
/// <param name='mask'>Bitwise OR of masks that indicate the buffers to be cleared. The three masks
/// are</param>
#define glClear glad_debug_glClear
    GLAD_API_CALL PFNGLCLEARACCUMXOESPROC glad_glClearAccumxOES;
    GLAD_API_CALL PFNGLCLEARACCUMXOESPROC glad_debug_glClearAccumxOES;
#define glClearAccumxOES glad_debug_glClearAccumxOES
    GLAD_API_CALL PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;
    GLAD_API_CALL PFNGLCLEARBUFFERDATAPROC glad_debug_glClearBufferData;

/// <summary>
///   fill a buffer object's data store with a fixed value
///   <para>
///     glClearBufferData and glClearNamedBufferData fill the entirety of a buffer object's data
///     store with data from client memory. Data, initially supplied in a format specified by format
///     in data type type is read from the memory address given by data and converted into the
///     internal representation given by internalformat , which must be one of the following sized
///     internal formats: This converted data is then replicated throughout the buffer object's data
///     store. If data is NULL, then the buffer's data store is filled with zeros.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='internalformat'>The internal format with which the data will be stored in the
/// buffer object.</param> <param name='format'>The format of the data in memory addressed
/// by</param> <param name='type'>The type of the data in memory addressed by</param> <param
/// name='data'>The address of a memory location storing the data to be replicated into the buffer's
/// data store.</param>
#define glClearBufferData glad_debug_glClearBufferData
    GLAD_API_CALL PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;
    GLAD_API_CALL PFNGLCLEARBUFFERSUBDATAPROC glad_debug_glClearBufferSubData;

/// <summary>
///   fill all or part of buffer object's data store with a fixed value
///   <para>
///     glClearBufferSubData and glClearNamedBufferSubData fill a specified region of a buffer
///     object's data store with data from client memory. offset and size specify the extent of the
///     region within the data store of the buffer object to fill with data. Data, initially
///     supplied in a format specified by format in data type type is read from the memory address
///     given by data and converted into the internal representation given by internalformat , which
///     must be one of the following sized internal formats: This converted data is then replicated
///     throughout the specified region of the buffer object's data store. If data is NULL, then the
///     subrange of the buffer's data store is filled with zeros.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='internalformat'>The internal format with which the data will be stored in the
/// buffer object.</param> <param name='offset'>The offset in basic machine units into the buffer
/// object's data store at which to start filling.</param> <param name='size'>The size in basic
/// machine units of the range of the data store to fill.</param> <param name='format'>The format of
/// the data in memory addressed by</param> <param name='type'>The type of the data in memory
/// addressed by</param> <param name='data'>The address of a memory location storing the data to be
/// replicated into the buffer's data store.</param>
#define glClearBufferSubData glad_debug_glClearBufferSubData
    GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
    GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_debug_glClearBufferfi;
#define glClearBufferfi glad_debug_glClearBufferfi
    GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
    GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_debug_glClearBufferfv;
#define glClearBufferfv glad_debug_glClearBufferfv
    GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
    GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_debug_glClearBufferiv;
#define glClearBufferiv glad_debug_glClearBufferiv
    GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
    GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_debug_glClearBufferuiv;
#define glClearBufferuiv glad_debug_glClearBufferuiv
    GLAD_API_CALL PFNGLCLEARCOLORPROC glad_glClearColor;
    GLAD_API_CALL PFNGLCLEARCOLORPROC glad_debug_glClearColor;

/// <summary>
///   specify clear values for the color buffers
///   <para>
///     glClearColor specifies the red, green, blue, and alpha values used by glClear to clear the
///     color buffers. Values specified by glClearColor are clamped to the range 0 1.
///   </para>
/// </summary>
/// <param name='red'>Specify the red, green, blue, and alpha values used when the color buffers are
/// cleared. The initial values are all 0.</param>
#define glClearColor glad_debug_glClearColor
    GLAD_API_CALL PFNGLCLEARCOLORIIEXTPROC glad_glClearColorIiEXT;
    GLAD_API_CALL PFNGLCLEARCOLORIIEXTPROC glad_debug_glClearColorIiEXT;
#define glClearColorIiEXT glad_debug_glClearColorIiEXT
    GLAD_API_CALL PFNGLCLEARCOLORIUIEXTPROC glad_glClearColorIuiEXT;
    GLAD_API_CALL PFNGLCLEARCOLORIUIEXTPROC glad_debug_glClearColorIuiEXT;
#define glClearColorIuiEXT glad_debug_glClearColorIuiEXT
    GLAD_API_CALL PFNGLCLEARCOLORXOESPROC glad_glClearColorxOES;
    GLAD_API_CALL PFNGLCLEARCOLORXOESPROC glad_debug_glClearColorxOES;
#define glClearColorxOES glad_debug_glClearColorxOES
    GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_glClearDepth;
    GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_debug_glClearDepth;

/// <summary>
///   specify the clear value for the depth buffer
///   <para>
///     glClearDepth specifies the depth value used by glClear to clear the depth buffer. Values
///     specified by glClearDepth are clamped to the range 0 1.
///   </para>
/// </summary>
/// <param name='depth'>Specifies the depth value used when the depth buffer is cleared. The initial
/// value is 1.</param>
#define glClearDepth glad_debug_glClearDepth
    GLAD_API_CALL PFNGLCLEARDEPTHDNVPROC glad_glClearDepthdNV;
    GLAD_API_CALL PFNGLCLEARDEPTHDNVPROC glad_debug_glClearDepthdNV;
#define glClearDepthdNV glad_debug_glClearDepthdNV
    GLAD_API_CALL PFNGLCLEARDEPTHFPROC glad_glClearDepthf;
    GLAD_API_CALL PFNGLCLEARDEPTHFPROC glad_debug_glClearDepthf;
#define glClearDepthf glad_debug_glClearDepthf
    GLAD_API_CALL PFNGLCLEARDEPTHFOESPROC glad_glClearDepthfOES;
    GLAD_API_CALL PFNGLCLEARDEPTHFOESPROC glad_debug_glClearDepthfOES;
#define glClearDepthfOES glad_debug_glClearDepthfOES
    GLAD_API_CALL PFNGLCLEARDEPTHXOESPROC glad_glClearDepthxOES;
    GLAD_API_CALL PFNGLCLEARDEPTHXOESPROC glad_debug_glClearDepthxOES;
#define glClearDepthxOES glad_debug_glClearDepthxOES
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAPROC glad_debug_glClearNamedBufferData;
#define glClearNamedBufferData glad_debug_glClearNamedBufferData
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_glClearNamedBufferDataEXT;
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_debug_glClearNamedBufferDataEXT;
#define glClearNamedBufferDataEXT glad_debug_glClearNamedBufferDataEXT
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_debug_glClearNamedBufferSubData;
#define glClearNamedBufferSubData glad_debug_glClearNamedBufferSubData
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_glClearNamedBufferSubDataEXT;
    GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_debug_glClearNamedBufferSubDataEXT;
#define glClearNamedBufferSubDataEXT glad_debug_glClearNamedBufferSubDataEXT
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_debug_glClearNamedFramebufferfi;
#define glClearNamedFramebufferfi glad_debug_glClearNamedFramebufferfi
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_debug_glClearNamedFramebufferfv;
#define glClearNamedFramebufferfv glad_debug_glClearNamedFramebufferfv
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_debug_glClearNamedFramebufferiv;
#define glClearNamedFramebufferiv glad_debug_glClearNamedFramebufferiv
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;
    GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_debug_glClearNamedFramebufferuiv;
#define glClearNamedFramebufferuiv glad_debug_glClearNamedFramebufferuiv
    GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_glClearStencil;
    GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_debug_glClearStencil;

/// <summary>
///   specify the clear value for the stencil buffer
///   <para>
///     glClearStencil specifies the index used by glClear to clear the stencil buffer. s is masked
///     with 2 m - 1 , where m is the number of bits in the stencil buffer.
///   </para>
/// </summary>
/// <param name='s'>Specifies the index used when the stencil buffer is cleared. The initial value
/// is 0.</param>
#define glClearStencil glad_debug_glClearStencil
    GLAD_API_CALL PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;
    GLAD_API_CALL PFNGLCLEARTEXIMAGEPROC glad_debug_glClearTexImage;

/// <summary>
///   fills all a texture image with a constant value
///   <para>
///     glClearTexImage fills all an image contained in a texture with an application supplied
///     value. texture must be the name of an existing texture. Further, texture may not be the name
///     of a buffer texture, nor may its internal format be compressed. format and type specify the
///     format and type of the source data and are interpreted as they are for glTexImage3D.
///     Textures with a base internal format of GL_DEPTH_COMPONENT , GL_STENCIL_INDEX , or
///     GL_DEPTH_STENCIL require depth component, stencil, or depth-stencil component data
///     respectively. Textures with other base internal formats require RGBA formats. Textures with
///     integer internal formats require integer data. data is a pointer to an array of between one
///     and four components of texel data that will be used as the source for the constant fill
///     value. The elements of data are converted by the GL into the internal format of the texture
///     image (that was specified when the level was defined by any of the glTexImage* ,
///     glTexStorage* or glCopyTexImage* commands), and then used to fill the specified range of the
///     destination texture level. If data is NULL , then the pointer is ignored and the sub-range
///     of the texture image is filled with zeros. If texture is a multisample texture, all the
///     samples in a texel are cleared to the value specified by data.
///   </para>
/// </summary>
/// <param name='texture'>The name of an existing texture object containing the image to be
/// cleared.</param> <param name='level'>The level of</param> <param name='format'>The format of the
/// data whose address in memory is given by</param> <param name='type'>The type of the data whose
/// address in memory is given by</param> <param name='data'>The address in memory of the data to be
/// used to clear the specified region.</param>
#define glClearTexImage glad_debug_glClearTexImage
    GLAD_API_CALL PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;
    GLAD_API_CALL PFNGLCLEARTEXSUBIMAGEPROC glad_debug_glClearTexSubImage;

/// <summary>
///   fills all or part of a texture image with a constant value
///   <para>
///     glClearTexSubImage fills all or part of an image contained in a texture with an application
///     supplied value. texture must be the name of an existing texture. Further, texture may not be
///     the name of a buffer texture, nor may its internal format be compressed. Arguments xoffset ,
///     yoffset , and zoffset specify the lower left texel coordinates of a width-wide by
///     height-high by depth-deep rectangular subregion of the texel array. For one-dimensional
///     array textures, yoffset is interpreted as the first layer to be cleared and height is the
///     number of layers to clear. For two-dimensional array textures, zoffset is interpreted as the
///     first layer to be cleared and depth is the number of layers to clear. Cube map textures are
///     treated as an array of six slices in the z-dimension, where the value of zoffset is
///     interpreted as specifying the cube map face for the corresponding layer and depth is the
///     number of faces to clear. For cube map array textures, zoffset is the first layer-face to
///     clear, and depth is the number of layer-faces to clear. Each layer-face is translated into
///     an array layer and a cube map face as described in the OpenGL Specification. Negative values
///     of xoffset , yoffset , and zoffset correspond to the coordinates of border texels. Taking ws
///     , hs , ds , wb , hb , and db to be the specified width , height , depth , and the border
///     width, border height, and border depth of the texel array and taking x , y , z , w , h , and
///     d to be the xoffset , yoffset , zoffset , width , height , and depth argument values, any of
///     the following relationships generates a GL_INVALID_OPERATION error: For texture types that
///     do not have certain dimensions, this command treats those dimensions as having a size of 1.
///     For example, to clear a portion of a two-dimensional texture, use zoffset equal to zero and
///     depth equal to one. format and type specify the format and type of the source data and are
///     interpreted as they are for glTexImage3D. Textures with a base internal format of
///     GL_DEPTH_COMPONENT , GL_STENCIL_INDEX , or GL_DEPTH_STENCIL require depth component,
///     stencil, or depth-stencil component data respectively. Textures with other base internal
///     formats require RGBA formats. Textures with integer internal formats require integer data.
///     data is a pointer to an array of between one and four components of texel data that will be
///     used as the source for the constant fill value. The elements of data are converted by the GL
///     into the internal format of the texture image (that was specified when the level was defined
///     by any of the glTexImage* , glTexStorage* or glCopyTexImage* commands), and then used to
///     fill the specified range of the destination texture level. If data is NULL , then the
///     pointer is ignored and the sub-range of the texture image is filled with zeros. If texture
///     is a multisample texture, all the samples in a texel are cleared to the value specified by
///     data.
///   </para>
/// </summary>
/// <param name='texture'>The name of an existing texture object containing the image to be
/// cleared.</param> <param name='level'>The level of</param> <param name='xoffset'>The coordinate
/// of the left edge of the region to be cleared.</param> <param name='yoffset'>The coordinate of
/// the lower edge of the region to be cleared.</param> <param name='zoffset'>The coordinate of the
/// front of the region to be cleared.</param> <param name='width'>The width of the region to be
/// cleared.</param> <param name='height'>The height of the region to be cleared.</param> <param
/// name='depth'>The depth of the region to be cleared.</param> <param name='format'>The format of
/// the data whose address in memory is given by</param> <param name='type'>The type of the data
/// whose address in memory is given by</param> <param name='data'>The address in memory of the data
/// to be used to clear the specified region.</param>
#define glClearTexSubImage glad_debug_glClearTexSubImage
    GLAD_API_CALL PFNGLCLIENTACTIVETEXTUREARBPROC glad_glClientActiveTextureARB;
    GLAD_API_CALL PFNGLCLIENTACTIVETEXTUREARBPROC glad_debug_glClientActiveTextureARB;
#define glClientActiveTextureARB glad_debug_glClientActiveTextureARB
    GLAD_API_CALL PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_glClientActiveVertexStreamATI;
    GLAD_API_CALL PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_debug_glClientActiveVertexStreamATI;
#define glClientActiveVertexStreamATI glad_debug_glClientActiveVertexStreamATI
    GLAD_API_CALL PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_glClientAttribDefaultEXT;
    GLAD_API_CALL PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_debug_glClientAttribDefaultEXT;
#define glClientAttribDefaultEXT glad_debug_glClientAttribDefaultEXT
    GLAD_API_CALL PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC glad_glClientWaitSemaphoreui64NVX;
    GLAD_API_CALL PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC glad_debug_glClientWaitSemaphoreui64NVX;
#define glClientWaitSemaphoreui64NVX glad_debug_glClientWaitSemaphoreui64NVX
    GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
    GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_debug_glClientWaitSync;

/// <summary>
///   block and wait for a sync object to become signaled
///   <para>
///     glClientWaitSync causes the client to block and wait for the sync object specified by sync
///     to become signaled. If sync is signaled when glClientWaitSync is called, glClientWaitSync
///     returns immediately, otherwise it will block and wait for up to timeout nanoseconds for sync
///     to become signaled. The return value is one of four status values: GL_ALREADY_SIGNALED
///     indicates that sync was signaled at the time that glClientWaitSync was called.
///     GL_TIMEOUT_EXPIRED indicates that at least timeout nanoseconds passed and sync did not
///     become signaled. GL_CONDITION_SATISFIED indicates that sync was signaled before the timeout
///     expired. GL_WAIT_FAILED indicates that an error occurred. Additionally, an OpenGL error will
///     be generated.
///   </para>
/// </summary>
/// <param name='sync'>The sync object whose status to wait on.</param>
/// <param name='flags'>A bitfield controlling the command flushing behavior.</param>
/// <param name='timeout'>The timeout, specified in nanoseconds, for which the implementation should
/// wait for</param>
#define glClientWaitSync glad_debug_glClientWaitSync
    GLAD_API_CALL PFNGLCLIPCONTROLPROC glad_glClipControl;
    GLAD_API_CALL PFNGLCLIPCONTROLPROC glad_debug_glClipControl;

/// <summary>
///   control clip coordinate to window coordinate behavior
///   <para>
///     glClipControl controls the clipping volume behavior and the clip coordinate to window
///     coordinate transformation behavior. The view volume is defined by $$z_{min} \leq z_c \leq
///     w_c$$ where $z_{min} = -w_c$ when depth is GL_NEGATIVE_ONE_TO_ONE , and $z_{min} = 0$ when
///     depth is GL_ZERO_TO_ONE. The normalized device coordinate $y_d$ is given by $$y_d = { { f
///     \times y_c } \over w_c }$$ where $f = 1$ when origin is GL_LOWER_LEFT , and $f = -1$ when
///     origin is GL_UPPER_LEFT. The window coordinate $z_w$ is given by $$z_w = s \times z_d + b$$
///     where $s = { { f - n } \over 2 }$ and $b = { {n + f} \over 2 }$ when depth is
///     GL_NEGATIVE_ONE_TO_ONE , and $s = f - n$ and $b = n$ when depth is GL_ZERO_TO_ONE. $n$ and
///     $f$ are the near and far depth range values set with glDepthRange. Finally, the polygon area
///     computation defined by gl_FrontFacing to determine if a polygon is front- or back-facing has
///     its sign negated when origin is GL_UPPER_LEFT.
///   </para>
/// </summary>
/// <param name='origin'>Specifies the clip control origin. Must be one of</param>
/// <param name='depth'>Specifies the clip control depth mode. Must be one of</param>
#define glClipControl glad_debug_glClipControl
    GLAD_API_CALL PFNGLCLIPPLANEFOESPROC glad_glClipPlanefOES;
    GLAD_API_CALL PFNGLCLIPPLANEFOESPROC glad_debug_glClipPlanefOES;
#define glClipPlanefOES glad_debug_glClipPlanefOES
    GLAD_API_CALL PFNGLCLIPPLANEXOESPROC glad_glClipPlanexOES;
    GLAD_API_CALL PFNGLCLIPPLANEXOESPROC glad_debug_glClipPlanexOES;
#define glClipPlanexOES glad_debug_glClipPlanexOES
    GLAD_API_CALL PFNGLCOLOR3FVERTEX3FSUNPROC glad_glColor3fVertex3fSUN;
    GLAD_API_CALL PFNGLCOLOR3FVERTEX3FSUNPROC glad_debug_glColor3fVertex3fSUN;
#define glColor3fVertex3fSUN glad_debug_glColor3fVertex3fSUN
    GLAD_API_CALL PFNGLCOLOR3FVERTEX3FVSUNPROC glad_glColor3fVertex3fvSUN;
    GLAD_API_CALL PFNGLCOLOR3FVERTEX3FVSUNPROC glad_debug_glColor3fVertex3fvSUN;
#define glColor3fVertex3fvSUN glad_debug_glColor3fVertex3fvSUN
    GLAD_API_CALL PFNGLCOLOR3HNVPROC glad_glColor3hNV;
    GLAD_API_CALL PFNGLCOLOR3HNVPROC glad_debug_glColor3hNV;
#define glColor3hNV glad_debug_glColor3hNV
    GLAD_API_CALL PFNGLCOLOR3HVNVPROC glad_glColor3hvNV;
    GLAD_API_CALL PFNGLCOLOR3HVNVPROC glad_debug_glColor3hvNV;
#define glColor3hvNV glad_debug_glColor3hvNV
    GLAD_API_CALL PFNGLCOLOR3XOESPROC glad_glColor3xOES;
    GLAD_API_CALL PFNGLCOLOR3XOESPROC glad_debug_glColor3xOES;
#define glColor3xOES glad_debug_glColor3xOES
    GLAD_API_CALL PFNGLCOLOR3XVOESPROC glad_glColor3xvOES;
    GLAD_API_CALL PFNGLCOLOR3XVOESPROC glad_debug_glColor3xvOES;
#define glColor3xvOES glad_debug_glColor3xvOES
    GLAD_API_CALL PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glColor4fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_debug_glColor4fNormal3fVertex3fSUN;
#define glColor4fNormal3fVertex3fSUN glad_debug_glColor4fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glColor4fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_debug_glColor4fNormal3fVertex3fvSUN;
#define glColor4fNormal3fVertex3fvSUN glad_debug_glColor4fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLCOLOR4HNVPROC glad_glColor4hNV;
    GLAD_API_CALL PFNGLCOLOR4HNVPROC glad_debug_glColor4hNV;
#define glColor4hNV glad_debug_glColor4hNV
    GLAD_API_CALL PFNGLCOLOR4HVNVPROC glad_glColor4hvNV;
    GLAD_API_CALL PFNGLCOLOR4HVNVPROC glad_debug_glColor4hvNV;
#define glColor4hvNV glad_debug_glColor4hvNV
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX2FSUNPROC glad_glColor4ubVertex2fSUN;
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX2FSUNPROC glad_debug_glColor4ubVertex2fSUN;
#define glColor4ubVertex2fSUN glad_debug_glColor4ubVertex2fSUN
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX2FVSUNPROC glad_glColor4ubVertex2fvSUN;
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX2FVSUNPROC glad_debug_glColor4ubVertex2fvSUN;
#define glColor4ubVertex2fvSUN glad_debug_glColor4ubVertex2fvSUN
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX3FSUNPROC glad_glColor4ubVertex3fSUN;
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX3FSUNPROC glad_debug_glColor4ubVertex3fSUN;
#define glColor4ubVertex3fSUN glad_debug_glColor4ubVertex3fSUN
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX3FVSUNPROC glad_glColor4ubVertex3fvSUN;
    GLAD_API_CALL PFNGLCOLOR4UBVERTEX3FVSUNPROC glad_debug_glColor4ubVertex3fvSUN;
#define glColor4ubVertex3fvSUN glad_debug_glColor4ubVertex3fvSUN
    GLAD_API_CALL PFNGLCOLOR4XOESPROC glad_glColor4xOES;
    GLAD_API_CALL PFNGLCOLOR4XOESPROC glad_debug_glColor4xOES;
#define glColor4xOES glad_debug_glColor4xOES
    GLAD_API_CALL PFNGLCOLOR4XVOESPROC glad_glColor4xvOES;
    GLAD_API_CALL PFNGLCOLOR4XVOESPROC glad_debug_glColor4xvOES;
#define glColor4xvOES glad_debug_glColor4xvOES
    GLAD_API_CALL PFNGLCOLORFORMATNVPROC glad_glColorFormatNV;
    GLAD_API_CALL PFNGLCOLORFORMATNVPROC glad_debug_glColorFormatNV;
#define glColorFormatNV glad_debug_glColorFormatNV
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP1ATIPROC glad_glColorFragmentOp1ATI;
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP1ATIPROC glad_debug_glColorFragmentOp1ATI;
#define glColorFragmentOp1ATI glad_debug_glColorFragmentOp1ATI
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP2ATIPROC glad_glColorFragmentOp2ATI;
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP2ATIPROC glad_debug_glColorFragmentOp2ATI;
#define glColorFragmentOp2ATI glad_debug_glColorFragmentOp2ATI
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP3ATIPROC glad_glColorFragmentOp3ATI;
    GLAD_API_CALL PFNGLCOLORFRAGMENTOP3ATIPROC glad_debug_glColorFragmentOp3ATI;
#define glColorFragmentOp3ATI glad_debug_glColorFragmentOp3ATI
    GLAD_API_CALL PFNGLCOLORMASKPROC glad_glColorMask;
    GLAD_API_CALL PFNGLCOLORMASKPROC glad_debug_glColorMask;

/// <summary>
///   enable and disable writing of frame buffer color components
///   <para>
///     glColorMask and glColorMaski specify whether the individual color components in the frame
///     buffer can or cannot be written. glColorMaski sets the mask for a specific draw buffer,
///     whereas glColorMask sets the mask for all draw buffers. If red is GL_FALSE , for example, no
///     change is made to the red component of any pixel in any of the color buffers, regardless of
///     the drawing operation attempted. Changes to individual bits of components cannot be
///     controlled. Rather, changes are either enabled or disabled for entire color components.
///   </para>
/// </summary>
/// <param name='buf'>For</param>
/// <param name='red'>Specify whether red, green, blue, and alpha are to be written into the frame
/// buffer. The initial values are all</param>
#define glColorMask glad_debug_glColorMask
    GLAD_API_CALL PFNGLCOLORMASKINDEXEDEXTPROC glad_glColorMaskIndexedEXT;
    GLAD_API_CALL PFNGLCOLORMASKINDEXEDEXTPROC glad_debug_glColorMaskIndexedEXT;
#define glColorMaskIndexedEXT glad_debug_glColorMaskIndexedEXT
    GLAD_API_CALL PFNGLCOLORMASKIPROC glad_glColorMaski;
    GLAD_API_CALL PFNGLCOLORMASKIPROC glad_debug_glColorMaski;
#define glColorMaski glad_debug_glColorMaski
    GLAD_API_CALL PFNGLCOLORPOINTEREXTPROC glad_glColorPointerEXT;
    GLAD_API_CALL PFNGLCOLORPOINTEREXTPROC glad_debug_glColorPointerEXT;
#define glColorPointerEXT glad_debug_glColorPointerEXT
    GLAD_API_CALL PFNGLCOLORPOINTERLISTIBMPROC glad_glColorPointerListIBM;
    GLAD_API_CALL PFNGLCOLORPOINTERLISTIBMPROC glad_debug_glColorPointerListIBM;
#define glColorPointerListIBM glad_debug_glColorPointerListIBM
    GLAD_API_CALL PFNGLCOLORPOINTERVINTELPROC glad_glColorPointervINTEL;
    GLAD_API_CALL PFNGLCOLORPOINTERVINTELPROC glad_debug_glColorPointervINTEL;
#define glColorPointervINTEL glad_debug_glColorPointervINTEL
    GLAD_API_CALL PFNGLCOLORSUBTABLEEXTPROC glad_glColorSubTableEXT;
    GLAD_API_CALL PFNGLCOLORSUBTABLEEXTPROC glad_debug_glColorSubTableEXT;
#define glColorSubTableEXT glad_debug_glColorSubTableEXT
    GLAD_API_CALL PFNGLCOLORTABLEEXTPROC glad_glColorTableEXT;
    GLAD_API_CALL PFNGLCOLORTABLEEXTPROC glad_debug_glColorTableEXT;
#define glColorTableEXT glad_debug_glColorTableEXT
    GLAD_API_CALL PFNGLCOLORTABLEPARAMETERFVSGIPROC glad_glColorTableParameterfvSGI;
    GLAD_API_CALL PFNGLCOLORTABLEPARAMETERFVSGIPROC glad_debug_glColorTableParameterfvSGI;
#define glColorTableParameterfvSGI glad_debug_glColorTableParameterfvSGI
    GLAD_API_CALL PFNGLCOLORTABLEPARAMETERIVSGIPROC glad_glColorTableParameterivSGI;
    GLAD_API_CALL PFNGLCOLORTABLEPARAMETERIVSGIPROC glad_debug_glColorTableParameterivSGI;
#define glColorTableParameterivSGI glad_debug_glColorTableParameterivSGI
    GLAD_API_CALL PFNGLCOLORTABLESGIPROC glad_glColorTableSGI;
    GLAD_API_CALL PFNGLCOLORTABLESGIPROC glad_debug_glColorTableSGI;
#define glColorTableSGI glad_debug_glColorTableSGI
    GLAD_API_CALL PFNGLCOMBINERINPUTNVPROC glad_glCombinerInputNV;
    GLAD_API_CALL PFNGLCOMBINERINPUTNVPROC glad_debug_glCombinerInputNV;
#define glCombinerInputNV glad_debug_glCombinerInputNV
    GLAD_API_CALL PFNGLCOMBINEROUTPUTNVPROC glad_glCombinerOutputNV;
    GLAD_API_CALL PFNGLCOMBINEROUTPUTNVPROC glad_debug_glCombinerOutputNV;
#define glCombinerOutputNV glad_debug_glCombinerOutputNV
    GLAD_API_CALL PFNGLCOMBINERPARAMETERFNVPROC glad_glCombinerParameterfNV;
    GLAD_API_CALL PFNGLCOMBINERPARAMETERFNVPROC glad_debug_glCombinerParameterfNV;
#define glCombinerParameterfNV glad_debug_glCombinerParameterfNV
    GLAD_API_CALL PFNGLCOMBINERPARAMETERFVNVPROC glad_glCombinerParameterfvNV;
    GLAD_API_CALL PFNGLCOMBINERPARAMETERFVNVPROC glad_debug_glCombinerParameterfvNV;
#define glCombinerParameterfvNV glad_debug_glCombinerParameterfvNV
    GLAD_API_CALL PFNGLCOMBINERPARAMETERINVPROC glad_glCombinerParameteriNV;
    GLAD_API_CALL PFNGLCOMBINERPARAMETERINVPROC glad_debug_glCombinerParameteriNV;
#define glCombinerParameteriNV glad_debug_glCombinerParameteriNV
    GLAD_API_CALL PFNGLCOMBINERPARAMETERIVNVPROC glad_glCombinerParameterivNV;
    GLAD_API_CALL PFNGLCOMBINERPARAMETERIVNVPROC glad_debug_glCombinerParameterivNV;
#define glCombinerParameterivNV glad_debug_glCombinerParameterivNV
    GLAD_API_CALL PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_glCombinerStageParameterfvNV;
    GLAD_API_CALL PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_debug_glCombinerStageParameterfvNV;
#define glCombinerStageParameterfvNV glad_debug_glCombinerStageParameterfvNV
    GLAD_API_CALL PFNGLCOMMANDLISTSEGMENTSNVPROC glad_glCommandListSegmentsNV;
    GLAD_API_CALL PFNGLCOMMANDLISTSEGMENTSNVPROC glad_debug_glCommandListSegmentsNV;
#define glCommandListSegmentsNV glad_debug_glCommandListSegmentsNV
    GLAD_API_CALL PFNGLCOMPILECOMMANDLISTNVPROC glad_glCompileCommandListNV;
    GLAD_API_CALL PFNGLCOMPILECOMMANDLISTNVPROC glad_debug_glCompileCommandListNV;
#define glCompileCommandListNV glad_debug_glCompileCommandListNV
    GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_glCompileShader;
    GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_debug_glCompileShader;

/// <summary>
///   Compiles a shader object
///   <para>
///     glCompileShader compiles the source code strings that have been stored in the shader object
///     specified by shader. The compilation status will be stored as part of the shader object's
///     state. This value will be set to GL_TRUE if the shader was compiled without errors and is
///     ready for use, and GL_FALSE otherwise. It can be queried by calling glGetShader with
///     arguments shader and GL_COMPILE_STATUS. Compilation of a shader can fail for a number of
///     reasons as specified by the OpenGL Shading Language Specification. Whether or not the
///     compilation was successful, information about the compilation can be obtained from the
///     shader object's information log by calling glGetShaderInfoLog.
///   </para>
/// </summary>
/// <param name='shader'>Specifies the shader object to be compiled.</param>
#define glCompileShader glad_debug_glCompileShader
    GLAD_API_CALL PFNGLCOMPILESHADERARBPROC glad_glCompileShaderARB;
    GLAD_API_CALL PFNGLCOMPILESHADERARBPROC glad_debug_glCompileShaderARB;
#define glCompileShaderARB glad_debug_glCompileShaderARB
    GLAD_API_CALL PFNGLCOMPILESHADERINCLUDEARBPROC glad_glCompileShaderIncludeARB;
    GLAD_API_CALL PFNGLCOMPILESHADERINCLUDEARBPROC glad_debug_glCompileShaderIncludeARB;
#define glCompileShaderIncludeARB glad_debug_glCompileShaderIncludeARB
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_glCompressedMultiTexImage1DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_debug_glCompressedMultiTexImage1DEXT;
#define glCompressedMultiTexImage1DEXT glad_debug_glCompressedMultiTexImage1DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_glCompressedMultiTexImage2DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_debug_glCompressedMultiTexImage2DEXT;
#define glCompressedMultiTexImage2DEXT glad_debug_glCompressedMultiTexImage2DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_glCompressedMultiTexImage3DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_debug_glCompressedMultiTexImage3DEXT;
#define glCompressedMultiTexImage3DEXT glad_debug_glCompressedMultiTexImage3DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glad_glCompressedMultiTexSubImage1DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC
        glad_debug_glCompressedMultiTexSubImage1DEXT;
#define glCompressedMultiTexSubImage1DEXT glad_debug_glCompressedMultiTexSubImage1DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glad_glCompressedMultiTexSubImage2DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC
        glad_debug_glCompressedMultiTexSubImage2DEXT;
#define glCompressedMultiTexSubImage2DEXT glad_debug_glCompressedMultiTexSubImage2DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glad_glCompressedMultiTexSubImage3DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC
        glad_debug_glCompressedMultiTexSubImage3DEXT;
#define glCompressedMultiTexSubImage3DEXT glad_debug_glCompressedMultiTexSubImage3DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_debug_glCompressedTexImage1D;

/// <summary>
///   specify a one-dimensional texture image in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexImage1D
///     loads a previously defined, and retrieved, compressed one-dimensional texture image if
///     target is GL_TEXTURE_1D (see glTexImage1D ). If target is GL_PROXY_TEXTURE_1D , no data is
///     read from data , but all of the texture image state is recalculated, checked for
///     consistency, and checked against the implementation's capabilities. If the implementation
///     cannot handle a texture of the requested texture size, it sets all of the image state to 0,
///     but does not generate an error (see glGetError ). To query for an entire mipmap array, use
///     an image array level greater than or equal to 1. internalformat must be an
///     extension-specified compressed-texture format. When a texture is loaded with glTexImage1D
///     using a generic compressed texture format (e.g., GL_COMPRESSED_RGB ) the GL selects from one
///     of its extensions supporting compressed textures. In order to load the compressed texture
///     image using glCompressedTexImage1D , query the compressed texture image's size and format
///     using glGetTexLevelParameter. If a non-zero named buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified, data
///     is treated as a byte offset into the buffer object's data store. If the compressed data are
///     arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a
///     sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the
///     same way as they do for glTexImage1D. In the following description, denote by b s , b w , b
///     h , and b d the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE ,
///     GL_UNPACK_COMPRESSED_BLOCK_WIDTH , GL_UNPACK_COMPRESSED_BLOCK_HEIGHT , and
///     GL_UNPACK_COMPRESSED_BLOCK_DEPTH , respectively. b s is the compressed block size in bytes;
///     b w , b h , and b d are the compressed block width, height, and depth in pixels. By default
///     the pixel storage modes GL_UNPACK_ROW_LENGTH , GL_UNPACK_SKIP_ROWS , GL_UNPACK_SKIP_PIXELS ,
///     GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To
///     enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH , b s and b w must both be non-zero.
///     To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT , b h must be non-zero. To
///     also enable GL_UNPACK_SKIP_IMAGES , b d must be non-zero. All parameters must be consistent
///     with the compressed format to produce the desired results. When selecting a sub-rectangle
///     from a compressed image, the value of GL_UNPACK_SKIP_PIXELS must be a multiple of b w
///     imageSize must be equal to: b s × width b w
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalformat'>Specifies the format of the compressed image data
/// stored at address</param> <param name='width'>Specifies the width of the texture image. All
/// implementations support texture images that are at least 64 texels wide. The height of the 1D
/// texture image is 1.</param> <param name='border'>This value must be 0.</param> <param
/// name='imageSize'>Specifies the number of unsigned bytes of image data starting at the address
/// specified by</param> <param name='data'>Specifies a pointer to the compressed image data in
/// memory.</param>
#define glCompressedTexImage1D glad_debug_glCompressedTexImage1D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_glCompressedTexImage1DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_debug_glCompressedTexImage1DARB;
#define glCompressedTexImage1DARB glad_debug_glCompressedTexImage1DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_debug_glCompressedTexImage2D;

/// <summary>
///   specify a two-dimensional texture image in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexImage2D
///     loads a previously defined, and retrieved, compressed two-dimensional texture image if
///     target is GL_TEXTURE_2D , or one of the cube map faces such as
///     GL_TEXTURE_CUBE_MAP_POSITIVE_X. (see glTexImage2D ). If target is GL_TEXTURE_1D_ARRAY , data
///     is treated as an array of compressed 1D textures. If target is GL_PROXY_TEXTURE_2D ,
///     GL_PROXY_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP , no data is read from data , but all
///     of the texture image state is recalculated, checked for consistency, and checked against the
///     implementation's capabilities. If the implementation cannot handle a texture of the
///     requested texture size, it sets all of the image state to 0, but does not generate an error
///     (see glGetError ). To query for an entire mipmap array, use an image array level greater
///     than or equal to 1. internalformat must be a known compressed image format (such as GL_RGTC
///     ) or an extension-specified compressed-texture format. When a texture is loaded with
///     glTexImage2D using a generic compressed texture format (e.g., GL_COMPRESSED_RGB ), the GL
///     selects from one of its extensions supporting compressed textures. In order to load the
///     compressed texture image using glCompressedTexImage2D , query the compressed texture image's
///     size and format using glGetTexLevelParameter. If a non-zero named buffer object is bound to
///     the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified,
///     data is treated as a byte offset into the buffer object's data store. If the compressed data
///     are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select
///     a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the
///     same way as they do for glTexImage2D. In the following description, denote by b s , b w , b
///     h , and b d , the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE ,
///     GL_UNPACK_COMPRESSED_BLOCK_WIDTH , GL_UNPACK_COMPRESSED_BLOCK_HEIGHT , and
///     GL_UNPACK_COMPRESSED_BLOCK_DEPTH , respectively. b s is the compressed block size in bytes;
///     b w , b h , and b d are the compressed block width, height, and depth in pixels. By default
///     the pixel storage modes GL_UNPACK_ROW_LENGTH , GL_UNPACK_SKIP_ROWS , GL_UNPACK_SKIP_PIXELS ,
///     GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To
///     enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH , b s and b w must both be non-zero.
///     To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT , b h must be non-zero. To
///     also enable GL_UNPACK_SKIP_IMAGES , b d must be non-zero. All parameters must be consistent
///     with the compressed format to produce the desired results. When selecting a sub-rectangle
///     from a compressed image: The value of GL_UNPACK_SKIP_PIXELS must be a multiple of b w ; the
///     value of GL_UNPACK_SKIP_ROWS must be a multiple of b w. imageSize must be equal to: b s ×
///     width b w × height b h
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalformat'>Specifies the format of the compressed image data
/// stored at address</param> <param name='width'>Specifies the width of the texture image. All
/// implementations support 2D texture and cube map texture images that are at least 16384 texels
/// wide.</param> <param name='height'>Specifies the height of the texture image. All
/// implementations support 2D texture and cube map texture images that are at least 16384 texels
/// high.</param> <param name='border'>This value must be 0.</param> <param
/// name='imageSize'>Specifies the number of unsigned bytes of image data starting at the address
/// specified by</param> <param name='data'>Specifies a pointer to the compressed image data in
/// memory.</param>
#define glCompressedTexImage2D glad_debug_glCompressedTexImage2D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_glCompressedTexImage2DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_debug_glCompressedTexImage2DARB;
#define glCompressedTexImage2DARB glad_debug_glCompressedTexImage2DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_debug_glCompressedTexImage3D;

/// <summary>
///   specify a three-dimensional texture image in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexImage3D
///     loads a previously defined, and retrieved, compressed three-dimensional texture image if
///     target is GL_TEXTURE_3D (see glTexImage3D ). If target is GL_TEXTURE_2D_ARRAY , data is
///     treated as an array of compressed 2D textures. If target is GL_PROXY_TEXTURE_3D or
///     GL_PROXY_TEXTURE_2D_ARRAY , no data is read from data , but all of the texture image state
///     is recalculated, checked for consistency, and checked against the implementation's
///     capabilities. If the implementation cannot handle a texture of the requested texture size,
///     it sets all of the image state to 0, but does not generate an error (see glGetError ). To
///     query for an entire mipmap array, use an image array level greater than or equal to 1.
///     internalformat must be a known compressed image format (such as GL_RGTC ) or an
///     extension-specified compressed-texture format. When a texture is loaded with glTexImage2D
///     using a generic compressed texture format (e.g., GL_COMPRESSED_RGB ), the GL selects from
///     one of its extensions supporting compressed textures. In order to load the compressed
///     texture image using glCompressedTexImage3D , query the compressed texture image's size and
///     format using glGetTexLevelParameter. If a non-zero named buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified, data
///     is treated as a byte offset into the buffer object's data store. If the compressed data are
///     arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a
///     sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the
///     same way as they do for glTexImage1D. In the following description, denote by b s , b w , b
///     h , and b d the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE ,
///     GL_UNPACK_COMPRESSED_BLOCK_WIDTH , GL_UNPACK_COMPRESSED_BLOCK_HEIGHT , and
///     GL_UNPACK_COMPRESSED_BLOCK_DEPTH , respectively. b s is the compressed block size in bytes;
///     b w , b h , and b d are the compressed block width, height, and depth in pixels. By default
///     the pixel storage modes GL_UNPACK_ROW_LENGTH , GL_UNPACK_SKIP_ROWS , GL_UNPACK_SKIP_PIXELS ,
///     GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To
///     enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH , b s and b w must both be non-zero.
///     To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT , b h must be non-zero. To
///     also enable GL_UNPACK_SKIP_IMAGES , b d must be non-zero. All parameters must be consistent
///     with the compressed format to produce the desired results. When selecting a sub-rectangle
///     from a compressed image: the value of GL_UNPACK_SKIP_PIXELS must be a multiple of b w ; the
///     value of GL_UNPACK_SKIP_ROWS must be a multiple of b w ; the value of GL_UNPACK_SKIP_IMAGES
///     must be a multiple of b w. imageSize must be equal to: b s × width b w × height b h × depth
///     b d
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalformat'>Specifies the format of the compressed image data
/// stored at address</param> <param name='width'>Specifies the width of the texture image. All
/// implementations support 3D texture images that are at least 16 texels wide.</param> <param
/// name='height'>Specifies the height of the texture image. All implementations support 3D texture
/// images that are at least 16 texels high.</param> <param name='depth'>Specifies the depth of the
/// texture image. All implementations support 3D texture images that are at least 16 texels
/// deep.</param> <param name='border'>This value must be 0.</param> <param
/// name='imageSize'>Specifies the number of unsigned bytes of image data starting at the address
/// specified by</param> <param name='data'>Specifies a pointer to the compressed image data in
/// memory.</param>
#define glCompressedTexImage3D glad_debug_glCompressedTexImage3D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_glCompressedTexImage3DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_debug_glCompressedTexImage3DARB;
#define glCompressedTexImage3DARB glad_debug_glCompressedTexImage3DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_debug_glCompressedTexSubImage1D;

/// <summary>
///   specify a one-dimensional texture subimage in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexSubImage1D
///     and glCompressedTextureSubImage1D redefine a contiguous subregion of an existing
///     one-dimensional texture image. The texels referenced by data replace the portion of the
///     existing texture array with x indices xoffset and xoffset + width - 1 , inclusive. This
///     region may not include any texels outside the range of the texture array as it was
///     originally specified. It is not an error to specify a subtexture with width of 0, but such a
///     specification has no effect. internalformat must be a known compressed image format (such as
///     GL_RGTC ) or an extension-specified compressed-texture format. The format of the compressed
///     texture image is selected by the GL implementation that compressed it (see glTexImage1D ),
///     and should be queried at the time the texture was compressed with glGetTexLevelParameter. If
///     a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see
///     glBindBuffer ) while a texture image is specified, data is treated as a byte offset into the
///     buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target, to which the texture is bound, for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='width'>Specifies the width of the texture subimage.</param>
/// <param name='format'>Specifies the format of the compressed image data stored at address</param>
/// <param name='imageSize'>Specifies the number of unsigned bytes of image data starting at the
/// address specified by</param> <param name='data'>Specifies a pointer to the compressed image data
/// in memory.</param>
#define glCompressedTexSubImage1D glad_debug_glCompressedTexSubImage1D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_glCompressedTexSubImage1DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_debug_glCompressedTexSubImage1DARB;
#define glCompressedTexSubImage1DARB glad_debug_glCompressedTexSubImage1DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_debug_glCompressedTexSubImage2D;

/// <summary>
///   specify a two-dimensional texture subimage in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexSubImage2D
///     and glCompressedTextureSubImage2D redefine a contiguous subregion of an existing
///     two-dimensional texture image. The texels referenced by data replace the portion of the
///     existing texture array with x indices xoffset and xoffset + width - 1 , and the y indices
///     yoffset and yoffset + height - 1 , inclusive. This region may not include any texels outside
///     the range of the texture array as it was originally specified. It is not an error to specify
///     a subtexture with width of 0, but such a specification has no effect. internalformat must be
///     a known compressed image format (such as GL_RGTC ) or an extension-specified
///     compressed-texture format. The format of the compressed texture image is selected by the GL
///     implementation that compressed it (see glTexImage2D ) and should be queried at the time the
///     texture was compressed with glGetTexLevelParameter. If a non-zero named buffer object is
///     bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is
///     specified, data is treated as a byte offset into the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='width'>Specifies the width of the texture
/// subimage.</param> <param name='height'>Specifies the height of the texture subimage.</param>
/// <param name='format'>Specifies the format of the compressed image data stored at address</param>
/// <param name='imageSize'>Specifies the number of unsigned bytes of image data starting at the
/// address specified by</param> <param name='data'>Specifies a pointer to the compressed image data
/// in memory.</param>
#define glCompressedTexSubImage2D glad_debug_glCompressedTexSubImage2D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_glCompressedTexSubImage2DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_debug_glCompressedTexSubImage2DARB;
#define glCompressedTexSubImage2DARB glad_debug_glCompressedTexSubImage2DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_debug_glCompressedTexSubImage3D;

/// <summary>
///   specify a three-dimensional texture subimage in a compressed format
///   <para>
///     Texturing allows elements of an image array to be read by shaders. glCompressedTexSubImage3D
///     and glCompressedTextureSubImage3D redefine a contiguous subregion of an existing
///     three-dimensional texture image. The texels referenced by data replace the portion of the
///     existing texture array with x indices xoffset and xoffset + width - 1 , and the y indices
///     yoffset and yoffset + height - 1 , and the z indices zoffset and zoffset + depth - 1 ,
///     inclusive. This region may not include any texels outside the range of the texture array as
///     it was originally specified. It is not an error to specify a subtexture with width of 0, but
///     such a specification has no effect. internalformat must be a known compressed image format
///     (such as GL_RGTC ) or an extension-specified compressed-texture format. The format of the
///     compressed texture image is selected by the GL implementation that compressed it (see
///     glTexImage3D ) and should be queried at the time the texture was compressed with
///     glGetTexLevelParameter. If a non-zero named buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified, data
///     is treated as a byte offset into the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='width'>Specifies the width of the texture
/// subimage.</param> <param name='height'>Specifies the height of the texture subimage.</param>
/// <param name='depth'>Specifies the depth of the texture subimage.</param>
/// <param name='format'>Specifies the format of the compressed image data stored at address</param>
/// <param name='imageSize'>Specifies the number of unsigned bytes of image data starting at the
/// address specified by</param> <param name='data'>Specifies a pointer to the compressed image data
/// in memory.</param>
#define glCompressedTexSubImage3D glad_debug_glCompressedTexSubImage3D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_glCompressedTexSubImage3DARB;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_debug_glCompressedTexSubImage3DARB;
#define glCompressedTexSubImage3DARB glad_debug_glCompressedTexSubImage3DARB
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_glCompressedTextureImage1DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_debug_glCompressedTextureImage1DEXT;
#define glCompressedTextureImage1DEXT glad_debug_glCompressedTextureImage1DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_glCompressedTextureImage2DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_debug_glCompressedTextureImage2DEXT;
#define glCompressedTextureImage2DEXT glad_debug_glCompressedTextureImage2DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_glCompressedTextureImage3DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_debug_glCompressedTextureImage3DEXT;
#define glCompressedTextureImage3DEXT glad_debug_glCompressedTextureImage3DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_debug_glCompressedTextureSubImage1D;
#define glCompressedTextureSubImage1D glad_debug_glCompressedTextureSubImage1D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glad_glCompressedTextureSubImage1DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC
        glad_debug_glCompressedTextureSubImage1DEXT;
#define glCompressedTextureSubImage1DEXT glad_debug_glCompressedTextureSubImage1DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_debug_glCompressedTextureSubImage2D;
#define glCompressedTextureSubImage2D glad_debug_glCompressedTextureSubImage2D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glad_glCompressedTextureSubImage2DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC
        glad_debug_glCompressedTextureSubImage2DEXT;
#define glCompressedTextureSubImage2DEXT glad_debug_glCompressedTextureSubImage2DEXT
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_debug_glCompressedTextureSubImage3D;
#define glCompressedTextureSubImage3D glad_debug_glCompressedTextureSubImage3D
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glad_glCompressedTextureSubImage3DEXT;
    GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC
        glad_debug_glCompressedTextureSubImage3DEXT;
#define glCompressedTextureSubImage3DEXT glad_debug_glCompressedTextureSubImage3DEXT
    GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glad_glConservativeRasterParameterfNV;
    GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERFNVPROC
        glad_debug_glConservativeRasterParameterfNV;
#define glConservativeRasterParameterfNV glad_debug_glConservativeRasterParameterfNV
    GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERINVPROC glad_glConservativeRasterParameteriNV;
    GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERINVPROC
        glad_debug_glConservativeRasterParameteriNV;
#define glConservativeRasterParameteriNV glad_debug_glConservativeRasterParameteriNV
    GLAD_API_CALL PFNGLCONVOLUTIONFILTER1DEXTPROC glad_glConvolutionFilter1DEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONFILTER1DEXTPROC glad_debug_glConvolutionFilter1DEXT;
#define glConvolutionFilter1DEXT glad_debug_glConvolutionFilter1DEXT
    GLAD_API_CALL PFNGLCONVOLUTIONFILTER2DEXTPROC glad_glConvolutionFilter2DEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONFILTER2DEXTPROC glad_debug_glConvolutionFilter2DEXT;
#define glConvolutionFilter2DEXT glad_debug_glConvolutionFilter2DEXT
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_glConvolutionParameterfEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_debug_glConvolutionParameterfEXT;
#define glConvolutionParameterfEXT glad_debug_glConvolutionParameterfEXT
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_glConvolutionParameterfvEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_debug_glConvolutionParameterfvEXT;
#define glConvolutionParameterfvEXT glad_debug_glConvolutionParameterfvEXT
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_glConvolutionParameteriEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_debug_glConvolutionParameteriEXT;
#define glConvolutionParameteriEXT glad_debug_glConvolutionParameteriEXT
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_glConvolutionParameterivEXT;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_debug_glConvolutionParameterivEXT;
#define glConvolutionParameterivEXT glad_debug_glConvolutionParameterivEXT
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERXOESPROC glad_glConvolutionParameterxOES;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERXOESPROC glad_debug_glConvolutionParameterxOES;
#define glConvolutionParameterxOES glad_debug_glConvolutionParameterxOES
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERXVOESPROC glad_glConvolutionParameterxvOES;
    GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERXVOESPROC glad_debug_glConvolutionParameterxvOES;
#define glConvolutionParameterxvOES glad_debug_glConvolutionParameterxvOES
    GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
    GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_debug_glCopyBufferSubData;

/// <summary>
///   copy all or part of the data store of a buffer object to the data store of another buffer
///   object <para>
///     glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a
///     source buffer object to the data store attached to a destination buffer object. The number
///     of basic machine units indicated by size is copied from the source at offset readOffset to
///     the destination at writeOffset. readOffset , writeOffset and size are in terms of basic
///     machine units. For glCopyBufferSubData , readTarget and writeTarget specify the targets to
///     which the source and destination buffer objects are bound, and must each be one of the
///     buffer binding targets in the following table: Any of these targets may be used, but the
///     targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided specifically to allow
///     copies between buffers without disturbing other GL state. readOffset , writeOffset and size
///     must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed
///     the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of
///     the buffer bound to writeTarget. If the source and destination are the same buffer object,
///     then the source and destination ranges must not overlap.
///   </para>
/// </summary>
/// <param name='readTarget'>Specifies the target to which the source buffer object is bound
/// for</param> <param name='writeTarget'>Specifies the target to which the destination buffer
/// object is bound for</param> <param name='readBuffer'>Specifies the name of the source buffer
/// object for</param> <param name='writeBuffer'>Specifies the name of the destination buffer object
/// for</param> <param name='readOffset'>Specifies the offset, in basic machine units, within the
/// data store of the source buffer object at which data will be read.</param> <param
/// name='writeOffset'>Specifies the offset, in basic machine units, within the data store of the
/// destination buffer object at which data will be written.</param> <param name='size'>Specifies
/// the size, in basic machine units, of the data to be copied from the source buffer object to the
/// destination buffer object.</param>
#define glCopyBufferSubData glad_debug_glCopyBufferSubData
    GLAD_API_CALL PFNGLCOPYCOLORSUBTABLEEXTPROC glad_glCopyColorSubTableEXT;
    GLAD_API_CALL PFNGLCOPYCOLORSUBTABLEEXTPROC glad_debug_glCopyColorSubTableEXT;
#define glCopyColorSubTableEXT glad_debug_glCopyColorSubTableEXT
    GLAD_API_CALL PFNGLCOPYCOLORTABLESGIPROC glad_glCopyColorTableSGI;
    GLAD_API_CALL PFNGLCOPYCOLORTABLESGIPROC glad_debug_glCopyColorTableSGI;
#define glCopyColorTableSGI glad_debug_glCopyColorTableSGI
    GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_glCopyConvolutionFilter1DEXT;
    GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_debug_glCopyConvolutionFilter1DEXT;
#define glCopyConvolutionFilter1DEXT glad_debug_glCopyConvolutionFilter1DEXT
    GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_glCopyConvolutionFilter2DEXT;
    GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_debug_glCopyConvolutionFilter2DEXT;
#define glCopyConvolutionFilter2DEXT glad_debug_glCopyConvolutionFilter2DEXT
    GLAD_API_CALL PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;
    GLAD_API_CALL PFNGLCOPYIMAGESUBDATAPROC glad_debug_glCopyImageSubData;

/// <summary>
///   perform a raw data copy between two images
///   <para>
///     glCopyImageSubData may be used to copy data from one image (i.e. texture or renderbuffer) to
///     another. glCopyImageSubData does not perform general-purpose conversions such as scaling,
///     resizing, blending, color-space, or format conversions. It should be considered to operate
///     in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different
///     internal formats, provided the formats are compatible. glCopyImageSubData also allows
///     copying between certain types of compressed and uncompressed internal formats. This copy
///     does not perform on-the-fly compression or decompression. When copying from an uncompressed
///     internal format to a compressed internal format, each texel of uncompressed data becomes a
///     single block of compressed data. When copying from a compressed internal format to an
///     uncompressed internal format, a block of compressed data becomes a single texel of
///     uncompressed data. The texel size of the uncompressed format must be the same size the block
///     size of the compressed formats. Thus it is permitted to copy between a 128-bit uncompressed
///     format and a compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed
///     format and a compressed format which uses 4-bit 4x4 blocks. The source object is identified
///     by srcName and srcTarget and the destination object is identified by dstName and dstTarget.
///     The interpretation of the name depends on the value of the corresponding target parameter.
///     If target is GL_RENDERBUFFER , the name is interpreted as the name of a renderbuffer object.
///     If the target parameter is a texture target, the name is interpreted as a texture object.
///     All non-proxy texture targets are accepted, with the exception of GL_TEXTURE_BUFFER and the
///     cubemap face selectors. srcLevel and dstLevel identify the source and destination level of
///     detail. For textures, this must be a valid level of detail in the texture object. For
///     renderbuffers, this value must be zero. srcX , srcY , and srcZ specify the lower left texel
///     coordinates of a srcWidth -wide by srcHeight -high by srcDepth -deep rectangular subregion
///     of the source texel array. Similarly, dstX , dstY and dstZ specify the coordinates of a
///     subregion of the destination texel array. The source and destination subregions must be
///     contained entirely within the specified level of the corresponding image objects. The
///     dimensions are always specified in texels, even for compressed texture formats. However, it
///     should be noted that if only one of the source and destination textures is compressed then
///     the number of texels touched in the compressed image will be a factor of the block size
///     larger than in the uncompressed image. Slices of a GL_TEXTURE_1D_ARRAY , GL_TEXTURE_2D_ARRAY
///     , GL_TEXTURE_CUBE_MAP_ARRAY GL_TEXTURE_3D and faces of GL_TEXTURE_CUBE_MAP are all
///     compatible provided they share a compatible internal format, and multiple slices or faces
///     may be copied between these objects with a single call by specifying the starting slice with
///     srcZ and dstZ , and the number of slices to be copied with srcDepth. Cubemap textures always
///     have six faces which are selected by a zero-based face index. For the purposes of
///     CopyImageSubData, two internal formats are considered compatible if any of the following
///     conditions are met: the formats are the same, the formats are considered compatible
///     according to the compatibility rules used for texture views as defined in section 3.9.X. In
///     particular, if both internal formats are listed in the same entry of Table 3.X.2, they are
///     considered compatible, or one format is compressed and the other is uncompressed and
///     Table 4.X.1 lists the two formats in the same row. If the formats are not compatible, an
///     INVALID_OPERATION error is generated.
///   </para>
/// </summary>
/// <param name='srcName'>The name of a texture or renderbuffer object from which to copy.</param>
/// <param name='srcTarget'>The target representing the namespace of the source name</param>
/// <param name='srcLevel'>The mipmap level to read from the source.</param>
/// <param name='srcX'>The X coordinate of the left edge of the souce region to copy.</param>
/// <param name='srcY'>The Y coordinate of the top edge of the souce region to copy.</param>
/// <param name='srcZ'>The Z coordinate of the near edge of the souce region to copy.</param>
/// <param name='dstName'>The name of a texture or renderbuffer object to which to copy.</param>
/// <param name='dstTarget'>The target representing the namespace of the destination name</param>
/// <param name='dstX'>The X coordinate of the left edge of the destination region.</param>
/// <param name='dstY'>The Y coordinate of the top edge of the destination region.</param>
/// <param name='dstZ'>The Z coordinate of the near edge of the destination region.</param>
/// <param name='srcWidth'>The width of the region to be copied.</param>
/// <param name='srcHeight'>The height of the region to be copied.</param>
/// <param name='srcDepth'>The depth of the region to be copied.</param>
#define glCopyImageSubData glad_debug_glCopyImageSubData
    GLAD_API_CALL PFNGLCOPYIMAGESUBDATANVPROC glad_glCopyImageSubDataNV;
    GLAD_API_CALL PFNGLCOPYIMAGESUBDATANVPROC glad_debug_glCopyImageSubDataNV;
#define glCopyImageSubDataNV glad_debug_glCopyImageSubDataNV
    GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_glCopyMultiTexImage1DEXT;
    GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_debug_glCopyMultiTexImage1DEXT;
#define glCopyMultiTexImage1DEXT glad_debug_glCopyMultiTexImage1DEXT
    GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_glCopyMultiTexImage2DEXT;
    GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_debug_glCopyMultiTexImage2DEXT;
#define glCopyMultiTexImage2DEXT glad_debug_glCopyMultiTexImage2DEXT
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_glCopyMultiTexSubImage1DEXT;
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_debug_glCopyMultiTexSubImage1DEXT;
#define glCopyMultiTexSubImage1DEXT glad_debug_glCopyMultiTexSubImage1DEXT
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_glCopyMultiTexSubImage2DEXT;
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_debug_glCopyMultiTexSubImage2DEXT;
#define glCopyMultiTexSubImage2DEXT glad_debug_glCopyMultiTexSubImage2DEXT
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_glCopyMultiTexSubImage3DEXT;
    GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_debug_glCopyMultiTexSubImage3DEXT;
#define glCopyMultiTexSubImage3DEXT glad_debug_glCopyMultiTexSubImage3DEXT
    GLAD_API_CALL PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;
    GLAD_API_CALL PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_debug_glCopyNamedBufferSubData;
#define glCopyNamedBufferSubData glad_debug_glCopyNamedBufferSubData
    GLAD_API_CALL PFNGLCOPYPATHNVPROC glad_glCopyPathNV;
    GLAD_API_CALL PFNGLCOPYPATHNVPROC glad_debug_glCopyPathNV;
#define glCopyPathNV glad_debug_glCopyPathNV
    GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
    GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_debug_glCopyTexImage1D;

/// <summary>
///   copy pixels into a 1D texture image
///   <para>
///     glCopyTexImage1D defines a one-dimensional texture image with pixels from the current
///     GL_READ_BUFFER. The screen-aligned pixel row with left corner at x y and with a length of
///     width defines the texture array at the mipmap level specified by level. internalformat
///     specifies the internal format of the texture array. The pixels in the row are processed
///     exactly as if glReadPixels had been called, but the process stops just before final
///     conversion. At this point all pixel component values are clamped to the range 0 1 and then
///     converted to the texture's internal format for storage in the texel array. Pixel ordering is
///     such that lower x screen coordinates correspond to lower texture coordinates. If any of the
///     pixels within the specified row of the current GL_READ_BUFFER are outside the window
///     associated with the current rendering context, then the values obtained for those pixels are
///     undefined. glCopyTexImage1D defines a one-dimensional texture image with pixels from the
///     current GL_READ_BUFFER. When internalformat is one of the sRGB types, the GL does not
///     automatically convert the source pixels to the sRGB color space. In this case, the
///     glPixelMap function can be used to accomplish the conversion.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalformat'>Specifies the internal format of the texture. Must be
/// one of the following symbolic constants:</param> <param name='x'>Specify the window coordinates
/// of the left corner of the row of pixels to be copied.</param> <param name='y'>Specifies the
/// width of the texture image. The height of the texture image is 1.</param> <param
/// name='width'>Must be 0.</param>
#define glCopyTexImage1D glad_debug_glCopyTexImage1D
    GLAD_API_CALL PFNGLCOPYTEXIMAGE1DEXTPROC glad_glCopyTexImage1DEXT;
    GLAD_API_CALL PFNGLCOPYTEXIMAGE1DEXTPROC glad_debug_glCopyTexImage1DEXT;
#define glCopyTexImage1DEXT glad_debug_glCopyTexImage1DEXT
    GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
    GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_debug_glCopyTexImage2D;

/// <summary>
///   copy pixels into a 2D texture image
///   <para>
///     glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image with
///     pixels from the current GL_READ_BUFFER. The screen-aligned pixel rectangle with lower left
///     corner at ( x , y ) and with a width of width and a height of height defines the texture
///     array at the mipmap level specified by level. internalformat specifies the internal format
///     of the texture array. The pixels in the rectangle are processed exactly as if glReadPixels
///     had been called, but the process stops just before final conversion. At this point all pixel
///     component values are clamped to the range 0 1 and then converted to the texture's internal
///     format for storage in the texel array. Pixel ordering is such that lower x and y screen
///     coordinates correspond to lower s and t texture coordinates. If any of the pixels within the
///     specified rectangle of the current GL_READ_BUFFER are outside the window associated with the
///     current rendering context, then the values obtained for those pixels are undefined. When
///     internalformat is one of the sRGB types, the GL does not automatically convert the source
///     pixels to the sRGB color space. In this case, the glPixelMap function can be used to
///     accomplish the conversion.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalformat'>Specifies the internal format of the texture. Must be
/// one of the following symbolic constants:</param> <param name='x'>Specify the window coordinates
/// of the lower left corner of the rectangular region of pixels to be copied.</param> <param
/// name='y'>Specifies the width of the texture image.</param> <param name='width'>Specifies the
/// height of the texture image.</param> <param name='height'>Must be 0.</param>
#define glCopyTexImage2D glad_debug_glCopyTexImage2D
    GLAD_API_CALL PFNGLCOPYTEXIMAGE2DEXTPROC glad_glCopyTexImage2DEXT;
    GLAD_API_CALL PFNGLCOPYTEXIMAGE2DEXTPROC glad_debug_glCopyTexImage2DEXT;
#define glCopyTexImage2DEXT glad_debug_glCopyTexImage2DEXT
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_debug_glCopyTexSubImage1D;

/// <summary>
///   copy a one-dimensional texture subimage
///   <para>
///     glCopyTexSubImage1D and glCopyTextureSubImage1D replace a portion of a one-dimensional
///     texture image with pixels from the current GL_READ_BUFFER (rather than from main memory, as
///     is the case for glTexSubImage1D ). For glCopyTexSubImage1D , the texture object that is
///     bound to target will be used for the process. For glCopyTextureSubImage1D , texture tells
///     which texture object should be used for the purpose of the call. The screen-aligned pixel
///     row with left corner at ( x ,\ y ), and with length width replaces the portion of the
///     texture array with x indices xoffset through xoffset + width - 1 , inclusive. The
///     destination in the texture array may not include any texels outside the texture array as it
///     was originally specified. The pixels in the row are processed exactly as if glReadPixels had
///     been called, but the process stops just before final conversion. At this point, all pixel
///     component values are clamped to the range 0 1 and then converted to the texture's internal
///     format for storage in the texel array. It is not an error to specify a subtexture with zero
///     width, but such a specification has no effect. If any of the pixels within the specified row
///     of the current GL_READ_BUFFER are outside the read window associated with the current
///     rendering context, then the values obtained for those pixels are undefined. No change is
///     made to the internalformat or width parameters of the specified texture array or to texel
///     values outside the specified subregion.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies the texel offset within the texture array.</param>
/// <param name='x'>Specify the window coordinates of the left corner of the row of pixels to be
/// copied.</param> <param name='y'>Specifies the width of the texture subimage.</param>
#define glCopyTexSubImage1D glad_debug_glCopyTexSubImage1D
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_glCopyTexSubImage1DEXT;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_debug_glCopyTexSubImage1DEXT;
#define glCopyTexSubImage1DEXT glad_debug_glCopyTexSubImage1DEXT
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_debug_glCopyTexSubImage2D;

/// <summary>
///   copy a two-dimensional texture subimage
///   <para>
///     glCopyTexSubImage2D and glCopyTextureSubImage2D replace a rectangular portion of a
///     two-dimensional texture image, cube-map texture image, rectangular image, or a linear
///     portion of a number of slices of a one-dimensional array texture with pixels from the
///     current GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage2D ).
///     The screen-aligned pixel rectangle with lower left corner at x y and with width width and
///     height height replaces the portion of the texture array with x indices xoffset through
///     xoffset + width - 1 , inclusive, and y indices yoffset through yoffset + height - 1 ,
///     inclusive, at the mipmap level specified by level. The pixels in the rectangle are processed
///     exactly as if glReadPixels had been called, but the process stops just before final
///     conversion. At this point, all pixel component values are clamped to the range 0 1 and then
///     converted to the texture's internal format for storage in the texel array. The destination
///     rectangle in the texture array may not include any texels outside the texture array as it
///     was originally specified. It is not an error to specify a subtexture with zero width or
///     height, but such a specification has no effect. When target is GL_TEXTURE_1D_ARRAY then the
///     y coordinate and height are treated as the start slice and number of slices to modify. If
///     any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside
///     the read window associated with the current rendering context, then the values obtained for
///     those pixels are undefined. No change is made to the internalformat , width , or height ,
///     parameters of the specified texture array or to texel values outside the specified
///     subregion.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='x'>Specify the window coordinates of the lower left
/// corner of the rectangular region of pixels to be copied.</param> <param name='y'>Specifies the
/// width of the texture subimage.</param> <param name='width'>Specifies the height of the texture
/// subimage.</param>
#define glCopyTexSubImage2D glad_debug_glCopyTexSubImage2D
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_glCopyTexSubImage2DEXT;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_debug_glCopyTexSubImage2DEXT;
#define glCopyTexSubImage2DEXT glad_debug_glCopyTexSubImage2DEXT
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_debug_glCopyTexSubImage3D;

/// <summary>
///   copy a three-dimensional texture subimage
///   <para>
///     glCopyTexSubImage3D and glCopyTextureSubImage3D functions replace a rectangular portion of a
///     three-dimensional or two-dimensional array texture image with pixels from the current
///     GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage3D ). The
///     screen-aligned pixel rectangle with lower left corner at ( x , y ) and with width width and
///     height height replaces the portion of the texture array with x indices xoffset through
///     xoffset + width - 1 , inclusive, and y indices yoffset through yoffset + height - 1 ,
///     inclusive, at z index zoffset and at the mipmap level specified by level. The pixels in the
///     rectangle are processed exactly as if glReadPixels had been called, but the process stops
///     just before final conversion. At this point, all pixel component values are clamped to the
///     range 0 1 and then converted to the texture's internal format for storage in the texel
///     array. The destination rectangle in the texture array may not include any texels outside the
///     texture array as it was originally specified. It is not an error to specify a subtexture
///     with zero width or height, but such a specification has no effect. If any of the pixels
///     within the specified rectangle of the current GL_READ_BUFFER are outside the read window
///     associated with the current rendering context, then the values obtained for those pixels are
///     undefined. No change is made to the internalformat , width , height , depth , or border
///     parameters of the specified texture array or to texel values outside the specified
///     subregion.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='zoffset'>Specifies a texel offset in the z direction
/// within the texture array.</param> <param name='x'>Specify the window coordinates of the lower
/// left corner of the rectangular region of pixels to be copied.</param> <param name='y'>Specifies
/// the width of the texture subimage.</param> <param name='width'>Specifies the height of the
/// texture subimage.</param>
#define glCopyTexSubImage3D glad_debug_glCopyTexSubImage3D
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_glCopyTexSubImage3DEXT;
    GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_debug_glCopyTexSubImage3DEXT;
#define glCopyTexSubImage3DEXT glad_debug_glCopyTexSubImage3DEXT
    GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_glCopyTextureImage1DEXT;
    GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_debug_glCopyTextureImage1DEXT;
#define glCopyTextureImage1DEXT glad_debug_glCopyTextureImage1DEXT
    GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_glCopyTextureImage2DEXT;
    GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_debug_glCopyTextureImage2DEXT;
#define glCopyTextureImage2DEXT glad_debug_glCopyTextureImage2DEXT
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_debug_glCopyTextureSubImage1D;
#define glCopyTextureSubImage1D glad_debug_glCopyTextureSubImage1D
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_glCopyTextureSubImage1DEXT;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_debug_glCopyTextureSubImage1DEXT;
#define glCopyTextureSubImage1DEXT glad_debug_glCopyTextureSubImage1DEXT
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_debug_glCopyTextureSubImage2D;
#define glCopyTextureSubImage2D glad_debug_glCopyTextureSubImage2D
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_glCopyTextureSubImage2DEXT;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_debug_glCopyTextureSubImage2DEXT;
#define glCopyTextureSubImage2DEXT glad_debug_glCopyTextureSubImage2DEXT
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_debug_glCopyTextureSubImage3D;
#define glCopyTextureSubImage3D glad_debug_glCopyTextureSubImage3D
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_glCopyTextureSubImage3DEXT;
    GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_debug_glCopyTextureSubImage3DEXT;
#define glCopyTextureSubImage3DEXT glad_debug_glCopyTextureSubImage3DEXT
    GLAD_API_CALL PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_glCoverFillPathInstancedNV;
    GLAD_API_CALL PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_debug_glCoverFillPathInstancedNV;
#define glCoverFillPathInstancedNV glad_debug_glCoverFillPathInstancedNV
    GLAD_API_CALL PFNGLCOVERFILLPATHNVPROC glad_glCoverFillPathNV;
    GLAD_API_CALL PFNGLCOVERFILLPATHNVPROC glad_debug_glCoverFillPathNV;
#define glCoverFillPathNV glad_debug_glCoverFillPathNV
    GLAD_API_CALL PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_glCoverStrokePathInstancedNV;
    GLAD_API_CALL PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_debug_glCoverStrokePathInstancedNV;
#define glCoverStrokePathInstancedNV glad_debug_glCoverStrokePathInstancedNV
    GLAD_API_CALL PFNGLCOVERSTROKEPATHNVPROC glad_glCoverStrokePathNV;
    GLAD_API_CALL PFNGLCOVERSTROKEPATHNVPROC glad_debug_glCoverStrokePathNV;
#define glCoverStrokePathNV glad_debug_glCoverStrokePathNV
    GLAD_API_CALL PFNGLCOVERAGEMODULATIONNVPROC glad_glCoverageModulationNV;
    GLAD_API_CALL PFNGLCOVERAGEMODULATIONNVPROC glad_debug_glCoverageModulationNV;
#define glCoverageModulationNV glad_debug_glCoverageModulationNV
    GLAD_API_CALL PFNGLCOVERAGEMODULATIONTABLENVPROC glad_glCoverageModulationTableNV;
    GLAD_API_CALL PFNGLCOVERAGEMODULATIONTABLENVPROC glad_debug_glCoverageModulationTableNV;
#define glCoverageModulationTableNV glad_debug_glCoverageModulationTableNV
    GLAD_API_CALL PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;
    GLAD_API_CALL PFNGLCREATEBUFFERSPROC glad_debug_glCreateBuffers;

/// <summary>
///   create buffer objects
///   <para>
///     glCreateBuffers returns n previously unused buffer names in buffers , each representing a
///     new buffer object initialized as if it had been bound to an unspecified target.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of buffer objects to create.</param>
/// <param name='buffers'>Specifies an array in which names of the new buffer objects are
/// stored.</param>
#define glCreateBuffers glad_debug_glCreateBuffers
    GLAD_API_CALL PFNGLCREATECOMMANDLISTSNVPROC glad_glCreateCommandListsNV;
    GLAD_API_CALL PFNGLCREATECOMMANDLISTSNVPROC glad_debug_glCreateCommandListsNV;
#define glCreateCommandListsNV glad_debug_glCreateCommandListsNV
    GLAD_API_CALL PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;
    GLAD_API_CALL PFNGLCREATEFRAMEBUFFERSPROC glad_debug_glCreateFramebuffers;

/// <summary>
///   create framebuffer objects
///   <para>
///     glCreateFramebuffers returns n previously unused framebuffer names in framebuffers , each
///     representing a new framebuffer object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of framebuffer objects to create.</param>
/// <param name='framebuffers'>Specifies an array in which names of the new framebuffer objects are
/// stored.</param>
#define glCreateFramebuffers glad_debug_glCreateFramebuffers
    GLAD_API_CALL PFNGLCREATEMEMORYOBJECTSEXTPROC glad_glCreateMemoryObjectsEXT;
    GLAD_API_CALL PFNGLCREATEMEMORYOBJECTSEXTPROC glad_debug_glCreateMemoryObjectsEXT;
#define glCreateMemoryObjectsEXT glad_debug_glCreateMemoryObjectsEXT
    GLAD_API_CALL PFNGLCREATEPERFQUERYINTELPROC glad_glCreatePerfQueryINTEL;
    GLAD_API_CALL PFNGLCREATEPERFQUERYINTELPROC glad_debug_glCreatePerfQueryINTEL;
#define glCreatePerfQueryINTEL glad_debug_glCreatePerfQueryINTEL
    GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
    GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_debug_glCreateProgram;

/// <summary>
///   Creates a program object
///   <para>
///     glCreateProgram creates an empty program object and returns a non-zero value by which it can
///     be referenced. A program object is an object to which shader objects can be attached. This
///     provides a mechanism to specify the shader objects that will be linked to create a program.
///     It also provides a means for checking the compatibility of the shaders that will be used to
///     create a program (for instance, checking the compatibility between a vertex shader and a
///     fragment shader). When no longer needed as part of a program object, shader objects can be
///     detached. One or more executables are created in a program object by successfully attaching
///     shader objects to it with glAttachShader , successfully compiling the shader objects with
///     glCompileShader , and successfully linking the program object with glLinkProgram. These
///     executables are made part of current state when glUseProgram is called. Program objects can
///     be deleted by calling glDeleteProgram. The memory associated with the program object will be
///     deleted when it is no longer part of current rendering state for any context.
///   </para>
/// </summary>
#define glCreateProgram glad_debug_glCreateProgram
    GLAD_API_CALL PFNGLCREATEPROGRAMOBJECTARBPROC glad_glCreateProgramObjectARB;
    GLAD_API_CALL PFNGLCREATEPROGRAMOBJECTARBPROC glad_debug_glCreateProgramObjectARB;
#define glCreateProgramObjectARB glad_debug_glCreateProgramObjectARB
    GLAD_API_CALL PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;
    GLAD_API_CALL PFNGLCREATEPROGRAMPIPELINESPROC glad_debug_glCreateProgramPipelines;

/// <summary>
///   create program pipeline objects
///   <para>
///     glCreateProgramPipelines returns n previously unused program pipeline names in pipelines ,
///     each representing a new program pipeline object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of program pipeline objects to create.</param>
/// <param name='pipelines'>Specifies an array in which names of the new program pipeline objects
/// are stored.</param>
#define glCreateProgramPipelines glad_debug_glCreateProgramPipelines
    GLAD_API_CALL PFNGLCREATEPROGRESSFENCENVXPROC glad_glCreateProgressFenceNVX;
    GLAD_API_CALL PFNGLCREATEPROGRESSFENCENVXPROC glad_debug_glCreateProgressFenceNVX;
#define glCreateProgressFenceNVX glad_debug_glCreateProgressFenceNVX
    GLAD_API_CALL PFNGLCREATEQUERIESPROC glad_glCreateQueries;
    GLAD_API_CALL PFNGLCREATEQUERIESPROC glad_debug_glCreateQueries;

/// <summary>
///   create query objects
///   <para>
///     glCreateQueries returns n previously unused query object names in ids , each representing a
///     new query object with the specified target. target may be one of GL_SAMPLES_PASSED ,
///     GL_ANY_SAMPLES_PASSED , GL_ANY_SAMPLES_PASSED_CONSERVATIVE , GL_TIME_ELAPSED , GL_TIMESTAMP
///     , GL_PRIMITIVES_GENERATED or GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target of each created query object.</param>
/// <param name='n'>Number of query objects to create.</param>
/// <param name='ids'>Specifies an array in which names of the new query objects are stored.</param>
#define glCreateQueries glad_debug_glCreateQueries
    GLAD_API_CALL PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;
    GLAD_API_CALL PFNGLCREATERENDERBUFFERSPROC glad_debug_glCreateRenderbuffers;

/// <summary>
///   create renderbuffer objects
///   <para>
///     glCreateRenderbuffers returns n previously unused renderbuffer object names in renderbuffers
///     , each representing a new renderbuffer object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of renderbuffer objects to create.</param>
/// <param name='renderbuffers'>Specifies an array in which names of the new renderbuffer objects
/// are stored.</param>
#define glCreateRenderbuffers glad_debug_glCreateRenderbuffers
    GLAD_API_CALL PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;
    GLAD_API_CALL PFNGLCREATESAMPLERSPROC glad_debug_glCreateSamplers;

/// <summary>
///   create sampler objects
///   <para>
///     glCreateSamplers returns n previously unused sampler names in samplers , each representing a
///     new sampler object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of sampler objects to create.</param>
/// <param name='samplers'>Specifies an array in which names of the new sampler objects are
/// stored.</param>
#define glCreateSamplers glad_debug_glCreateSamplers
    GLAD_API_CALL PFNGLCREATESEMAPHORESNVPROC glad_glCreateSemaphoresNV;
    GLAD_API_CALL PFNGLCREATESEMAPHORESNVPROC glad_debug_glCreateSemaphoresNV;
#define glCreateSemaphoresNV glad_debug_glCreateSemaphoresNV
    GLAD_API_CALL PFNGLCREATESHADERPROC glad_glCreateShader;
    GLAD_API_CALL PFNGLCREATESHADERPROC glad_debug_glCreateShader;

/// <summary>
///   Creates a shader object
///   <para>
///     glCreateShader creates an empty shader object and returns a non-zero value by which it can
///     be referenced. A shader object is used to maintain the source code strings that define a
///     shader. shaderType indicates the type of shader to be created. Five types of shader are
///     supported. A shader of type GL_COMPUTE_SHADER is a shader that is intended to run on the
///     programmable compute processor. A shader of type GL_VERTEX_SHADER is a shader that is
///     intended to run on the programmable vertex processor. A shader of type
///     GL_TESS_CONTROL_SHADER is a shader that is intended to run on the programmable tessellation
///     processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER is a shader that
///     is intended to run on the programmable tessellation processor in the evaluation stage. A
///     shader of type GL_GEOMETRY_SHADER is a shader that is intended to run on the programmable
///     geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run
///     on the programmable fragment processor. When created, a shader object's GL_SHADER_TYPE
///     parameter is set to either GL_COMPUTE_SHADER , GL_VERTEX_SHADER , GL_TESS_CONTROL_SHADER ,
///     GL_TESS_EVALUATION_SHADER , GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER , depending on the
///     value of shaderType.
///   </para>
/// </summary>
/// <param name='shaderType'>Specifies the type of shader to be created. Must be one of</param>
#define glCreateShader glad_debug_glCreateShader
    GLAD_API_CALL PFNGLCREATESHADEROBJECTARBPROC glad_glCreateShaderObjectARB;
    GLAD_API_CALL PFNGLCREATESHADEROBJECTARBPROC glad_debug_glCreateShaderObjectARB;
#define glCreateShaderObjectARB glad_debug_glCreateShaderObjectARB
    GLAD_API_CALL PFNGLCREATESHADERPROGRAMEXTPROC glad_glCreateShaderProgramEXT;
    GLAD_API_CALL PFNGLCREATESHADERPROGRAMEXTPROC glad_debug_glCreateShaderProgramEXT;
#define glCreateShaderProgramEXT glad_debug_glCreateShaderProgramEXT
    GLAD_API_CALL PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;
    GLAD_API_CALL PFNGLCREATESHADERPROGRAMVPROC glad_debug_glCreateShaderProgramv;
#define glCreateShaderProgramv glad_debug_glCreateShaderProgramv
    GLAD_API_CALL PFNGLCREATESTATESNVPROC glad_glCreateStatesNV;
    GLAD_API_CALL PFNGLCREATESTATESNVPROC glad_debug_glCreateStatesNV;
#define glCreateStatesNV glad_debug_glCreateStatesNV
    GLAD_API_CALL PFNGLCREATESYNCFROMCLEVENTARBPROC glad_glCreateSyncFromCLeventARB;
    GLAD_API_CALL PFNGLCREATESYNCFROMCLEVENTARBPROC glad_debug_glCreateSyncFromCLeventARB;
#define glCreateSyncFromCLeventARB glad_debug_glCreateSyncFromCLeventARB
    GLAD_API_CALL PFNGLCREATETEXTURESPROC glad_glCreateTextures;
    GLAD_API_CALL PFNGLCREATETEXTURESPROC glad_debug_glCreateTextures;

/// <summary>
///   create texture objects
///   <para>
///     glCreateTextures returns n previously unused texture names in textures , each representing a
///     new texture object of the dimensionality and type specified by target and initialized to the
///     default values for that texture type. target must be one of GL_TEXTURE_1D , GL_TEXTURE_2D ,
///     GL_TEXTURE_3D , GL_TEXTURE_1D_ARRAY , GL_TEXTURE_2D_ARRAY , GL_TEXTURE_RECTANGLE ,
///     GL_TEXTURE_CUBE_MAP , GL_TEXTURE_CUBE_MAP_ARRAY , GL_TEXTURE_BUFFER ,
///     GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
///   </para>
/// </summary>
/// <param name='target'>Specifies the effective texture target of each created texture.</param>
/// <param name='n'>Number of texture objects to create.</param>
/// <param name='textures'>Specifies an array in which names of the new texture objects are
/// stored.</param>
#define glCreateTextures glad_debug_glCreateTextures
    GLAD_API_CALL PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;
    GLAD_API_CALL PFNGLCREATETRANSFORMFEEDBACKSPROC glad_debug_glCreateTransformFeedbacks;

/// <summary>
///   create transform feedback objects
///   <para>
///     glCreateTransformFeedbacks returns n previously unused transform feedback object names in
///     ids , each representing a new transform feedback object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of transform feedback objects to create.</param>
/// <param name='ids'>Specifies an array in which names of the new transform feedback objects are
/// stored.</param>
#define glCreateTransformFeedbacks glad_debug_glCreateTransformFeedbacks
    GLAD_API_CALL PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;
    GLAD_API_CALL PFNGLCREATEVERTEXARRAYSPROC glad_debug_glCreateVertexArrays;

/// <summary>
///   create vertex array objects
///   <para>
///     glCreateVertexArrays returns n previously unused vertex array object names in arrays , each
///     representing a new vertex array object initialized to the default state.
///   </para>
/// </summary>
/// <param name='n'>Number of vertex array objects to create.</param>
/// <param name='arrays'>Specifies an array in which names of the new vertex array objects are
/// stored.</param>
#define glCreateVertexArrays glad_debug_glCreateVertexArrays
    GLAD_API_CALL PFNGLCULLFACEPROC glad_glCullFace;
    GLAD_API_CALL PFNGLCULLFACEPROC glad_debug_glCullFace;

/// <summary>
///   specify whether front- or back-facing facets can be culled
///   <para>
///     glCullFace specifies whether front- or back-facing facets are culled (as specified by mode )
///     when facet culling is enabled. Facet culling is initially disabled. To enable and disable
///     facet culling, call the glEnable and glDisable commands with the argument GL_CULL_FACE.
///     Facets include triangles, quadrilaterals, polygons, and rectangles. glFrontFace specifies
///     which of the clockwise and counterclockwise facets are front-facing and back-facing. See
///     glFrontFace.
///   </para>
/// </summary>
/// <param name='mode'>Specifies whether front- or back-facing facets are candidates for culling.
/// Symbolic constants</param>
#define glCullFace glad_debug_glCullFace
    GLAD_API_CALL PFNGLCULLPARAMETERDVEXTPROC glad_glCullParameterdvEXT;
    GLAD_API_CALL PFNGLCULLPARAMETERDVEXTPROC glad_debug_glCullParameterdvEXT;
#define glCullParameterdvEXT glad_debug_glCullParameterdvEXT
    GLAD_API_CALL PFNGLCULLPARAMETERFVEXTPROC glad_glCullParameterfvEXT;
    GLAD_API_CALL PFNGLCULLPARAMETERFVEXTPROC glad_debug_glCullParameterfvEXT;
#define glCullParameterfvEXT glad_debug_glCullParameterfvEXT
    GLAD_API_CALL PFNGLCURRENTPALETTEMATRIXARBPROC glad_glCurrentPaletteMatrixARB;
    GLAD_API_CALL PFNGLCURRENTPALETTEMATRIXARBPROC glad_debug_glCurrentPaletteMatrixARB;
#define glCurrentPaletteMatrixARB glad_debug_glCurrentPaletteMatrixARB
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKPROC glad_debug_glDebugMessageCallback;

/// <summary>
///   specify a callback to receive debugging messages from the GL
///   <para>
///     glDebugMessageCallback sets the current debug output callback function to the function whose
///     address is given in callback. The callback function should have the following prototype (in
///     C), or be otherwise compatible with such a prototype: This function is defined to have the
///     same calling convention as the GL API functions. In most cases this is defined as APIENTRY ,
///     although it will vary depending on platform, language and compiler. Each time a debug
///     message is generated the debug callback function will be invoked with source , type , id ,
///     and severity associated with the message, and length set to the length of debug message
///     whose character string is in the array pointed to by message. userParam will be set to the
///     value passed in the userParam parameter to the most recent call to glDebugMessageCallback.
///   </para>
/// </summary>
/// <param name='callback'>The address of a callback function that will be called when a debug
/// message is generated.</param> <param name='userParam'>A user supplied pointer that will be
/// passed on each invocation of</param>
#define glDebugMessageCallback glad_debug_glDebugMessageCallback
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_glDebugMessageCallbackAMD;
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_debug_glDebugMessageCallbackAMD;
#define glDebugMessageCallbackAMD glad_debug_glDebugMessageCallbackAMD
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKARBPROC glad_glDebugMessageCallbackARB;
    GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKARBPROC glad_debug_glDebugMessageCallbackARB;
#define glDebugMessageCallbackARB glad_debug_glDebugMessageCallbackARB
    GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;
    GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLPROC glad_debug_glDebugMessageControl;

/// <summary>
///   control the reporting of debug messages in a debug context
///   <para>
///     glDebugMessageControl controls the reporting of debug messages generated by a debug context.
///     The parameters source , type and severity form a filter to select messages from the pool of
///     potential messages generated by the GL. source may be GL_DEBUG_SOURCE_API ,
///     GL_DEBUG_SOURCE_WINDOW_SYSTEM , GL_DEBUG_SOURCE_SHADER_COMPILER ,
///     GL_DEBUG_SOURCE_THIRD_PARTY , GL_DEBUG_SOURCE_APPLICATION , GL_DEBUG_SOURCE_OTHER to select
///     messages generated by usage of the GL API, the window system, the shader compiler, third
///     party tools or libraries, explicitly by the application or by some other source,
///     respectively. It may also take the value GL_DONT_CARE. If source is not GL_DONT_CARE then
///     only messages whose source matches source will be referenced. type may be one of
///     GL_DEBUG_TYPE_ERROR , GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR , GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR ,
///     GL_DEBUG_TYPE_PORTABILITY , GL_DEBUG_TYPE_PERFORMANCE , GL_DEBUG_TYPE_MARKER ,
///     GL_DEBUG_TYPE_PUSH_GROUP , GL_DEBUG_TYPE_POP_GROUP , or GL_DEBUG_TYPE_OTHER to indicate the
///     type of messages describing GL errors, attempted use of deprecated features, triggering of
///     undefined behavior, portability issues, performance notifications, markers, group push and
///     pop events, and other types of messages, respectively. It may also take the value
///     GL_DONT_CARE. If type is not GL_DONT_CARE then only messages whose type matches type will be
///     referenced. severity may be one of GL_DEBUG_SEVERITY_LOW , GL_DEBUG_SEVERITY_MEDIUM , or
///     GL_DEBUG_SEVERITY_HIGH to select messages of low, medium or high severity messages or to
///     GL_DEBUG_SEVERITY_NOTIFICATION for notifications. It may also take the value GL_DONT_CARE.
///     If severity is not GL_DONT_CARE then only messages whose severity matches severity will be
///     referenced. ids contains a list of count message identifiers to select specific messages
///     from the pool of available messages. If count is zero then the value of ids is ignored.
///     Otherwise, only messages appearing in this list are selected. In this case, source and type
///     may not be GL_DONT_CARE and severity must be GL_DONT_CARE. If enabled is GL_TRUE then
///     messages that match the filter formed by source , type , severity and ids are enabled.
///     Otherwise, those messages are disabled.
///   </para>
/// </summary>
/// <param name='source'>The source of debug messages to enable or disable.</param>
/// <param name='type'>The type of debug messages to enable or disable.</param>
/// <param name='severity'>The severity of debug messages to enable or disable.</param>
/// <param name='count'>The length of the array</param>
/// <param name='ids'>The address of an array of unsigned integers contianing the ids of the
/// messages to enable or disable.</param> <param name='enabled'>A Boolean flag determining whether
/// the selected messages should be enabled or disabled.</param>
#define glDebugMessageControl glad_debug_glDebugMessageControl
    GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLARBPROC glad_glDebugMessageControlARB;
    GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLARBPROC glad_debug_glDebugMessageControlARB;
#define glDebugMessageControlARB glad_debug_glDebugMessageControlARB
    GLAD_API_CALL PFNGLDEBUGMESSAGEENABLEAMDPROC glad_glDebugMessageEnableAMD;
    GLAD_API_CALL PFNGLDEBUGMESSAGEENABLEAMDPROC glad_debug_glDebugMessageEnableAMD;
#define glDebugMessageEnableAMD glad_debug_glDebugMessageEnableAMD
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTPROC glad_debug_glDebugMessageInsert;

/// <summary>
///   inject an application-supplied message into the debug message queue
///   <para>
///     glDebugMessageInsert inserts a user-supplied message into the debug output queue. source
///     specifies the source that will be used to classify the message and must be
///     GL_DEBUG_SOURCE_APPLICATION or GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved
///     for use by the GL implementation. type indicates the type of the message to be inserted and
///     may be one of GL_DEBUG_TYPE_ERROR , GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR ,
///     GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR , GL_DEBUG_TYPE_PORTABILITY , GL_DEBUG_TYPE_PERFORMANCE ,
///     GL_DEBUG_TYPE_MARKER , GL_DEBUG_TYPE_PUSH_GROUP , GL_DEBUG_TYPE_POP_GROUP , or
///     GL_DEBUG_TYPE_OTHER. severity indicates the severity of the message and may be
///     GL_DEBUG_SEVERITY_LOW , GL_DEBUG_SEVERITY_MEDIUM , GL_DEBUG_SEVERITY_HIGH or
///     GL_DEBUG_SEVERITY_NOTIFICATION. id is available for application defined use and may be any
///     value. This value will be recorded and used to identify the message. length contains a count
///     of the characters in the character array whose address is given in message. If length is
///     negative then message is treated as a null-terminated string. The length of the message,
///     whether specified explicitly or implicitly, must be less than or equal to the implementation
///     defined constant GL_MAX_DEBUG_MESSAGE_LENGTH.
///   </para>
/// </summary>
/// <param name='source'>The source of the debug message to insert.</param>
/// <param name='type'>The type of the debug message insert.</param>
/// <param name='id'>The user-supplied identifier of the message to insert.</param>
/// <param name='severity'>The severity of the debug messages to insert.</param>
/// <param name='length'>The length string contained in the character array whose address is given
/// by</param> <param name='message'>The address of a character array containing the message to
/// insert.</param>
#define glDebugMessageInsert glad_debug_glDebugMessageInsert
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTAMDPROC glad_glDebugMessageInsertAMD;
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTAMDPROC glad_debug_glDebugMessageInsertAMD;
#define glDebugMessageInsertAMD glad_debug_glDebugMessageInsertAMD
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTARBPROC glad_glDebugMessageInsertARB;
    GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTARBPROC glad_debug_glDebugMessageInsertARB;
#define glDebugMessageInsertARB glad_debug_glDebugMessageInsertARB
    GLAD_API_CALL PFNGLDEFORMSGIXPROC glad_glDeformSGIX;
    GLAD_API_CALL PFNGLDEFORMSGIXPROC glad_debug_glDeformSGIX;
#define glDeformSGIX glad_debug_glDeformSGIX
    GLAD_API_CALL PFNGLDEFORMATIONMAP3DSGIXPROC glad_glDeformationMap3dSGIX;
    GLAD_API_CALL PFNGLDEFORMATIONMAP3DSGIXPROC glad_debug_glDeformationMap3dSGIX;
#define glDeformationMap3dSGIX glad_debug_glDeformationMap3dSGIX
    GLAD_API_CALL PFNGLDEFORMATIONMAP3FSGIXPROC glad_glDeformationMap3fSGIX;
    GLAD_API_CALL PFNGLDEFORMATIONMAP3FSGIXPROC glad_debug_glDeformationMap3fSGIX;
#define glDeformationMap3fSGIX glad_debug_glDeformationMap3fSGIX
    GLAD_API_CALL PFNGLDELETEASYNCMARKERSSGIXPROC glad_glDeleteAsyncMarkersSGIX;
    GLAD_API_CALL PFNGLDELETEASYNCMARKERSSGIXPROC glad_debug_glDeleteAsyncMarkersSGIX;
#define glDeleteAsyncMarkersSGIX glad_debug_glDeleteAsyncMarkersSGIX
    GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
    GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_debug_glDeleteBuffers;

/// <summary>
///   delete named buffer objects
///   <para>
///     glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a
///     buffer object is deleted, it has no contents, and its name is free for reuse (for example by
///     glGenBuffers ). If a buffer object that is currently bound is deleted, the binding reverts
///     to 0 (the absence of any buffer object). glDeleteBuffers silently ignores 0's and names that
///     do not correspond to existing buffer objects.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of buffer objects to be deleted.</param>
/// <param name='buffers'>Specifies an array of buffer objects to be deleted.</param>
#define glDeleteBuffers glad_debug_glDeleteBuffers
    GLAD_API_CALL PFNGLDELETEBUFFERSARBPROC glad_glDeleteBuffersARB;
    GLAD_API_CALL PFNGLDELETEBUFFERSARBPROC glad_debug_glDeleteBuffersARB;
#define glDeleteBuffersARB glad_debug_glDeleteBuffersARB
    GLAD_API_CALL PFNGLDELETECOMMANDLISTSNVPROC glad_glDeleteCommandListsNV;
    GLAD_API_CALL PFNGLDELETECOMMANDLISTSNVPROC glad_debug_glDeleteCommandListsNV;
#define glDeleteCommandListsNV glad_debug_glDeleteCommandListsNV
    GLAD_API_CALL PFNGLDELETEFENCESAPPLEPROC glad_glDeleteFencesAPPLE;
    GLAD_API_CALL PFNGLDELETEFENCESAPPLEPROC glad_debug_glDeleteFencesAPPLE;
#define glDeleteFencesAPPLE glad_debug_glDeleteFencesAPPLE
    GLAD_API_CALL PFNGLDELETEFENCESNVPROC glad_glDeleteFencesNV;
    GLAD_API_CALL PFNGLDELETEFENCESNVPROC glad_debug_glDeleteFencesNV;
#define glDeleteFencesNV glad_debug_glDeleteFencesNV
    GLAD_API_CALL PFNGLDELETEFRAGMENTSHADERATIPROC glad_glDeleteFragmentShaderATI;
    GLAD_API_CALL PFNGLDELETEFRAGMENTSHADERATIPROC glad_debug_glDeleteFragmentShaderATI;
#define glDeleteFragmentShaderATI glad_debug_glDeleteFragmentShaderATI
    GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
    GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_debug_glDeleteFramebuffers;

/// <summary>
///   delete framebuffer objects
///   <para>
///     glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array
///     addressed by framebuffers. The name zero is reserved by the GL and is silently ignored,
///     should it occur in framebuffers , as are other unused names. Once a framebuffer object is
///     deleted, its name is again unused and it has no attachments. If a framebuffer that is
///     currently bound to one or more of the targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is
///     deleted, it is as though glBindFramebuffer had been executed with the corresponding target
///     and framebuffer zero.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of framebuffer objects to be deleted.</param>
/// <param name='framebuffers'>A pointer to an array containing</param>
#define glDeleteFramebuffers glad_debug_glDeleteFramebuffers
    GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSEXTPROC glad_glDeleteFramebuffersEXT;
    GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSEXTPROC glad_debug_glDeleteFramebuffersEXT;
#define glDeleteFramebuffersEXT glad_debug_glDeleteFramebuffersEXT
    GLAD_API_CALL PFNGLDELETEMEMORYOBJECTSEXTPROC glad_glDeleteMemoryObjectsEXT;
    GLAD_API_CALL PFNGLDELETEMEMORYOBJECTSEXTPROC glad_debug_glDeleteMemoryObjectsEXT;
#define glDeleteMemoryObjectsEXT glad_debug_glDeleteMemoryObjectsEXT
    GLAD_API_CALL PFNGLDELETENAMEDSTRINGARBPROC glad_glDeleteNamedStringARB;
    GLAD_API_CALL PFNGLDELETENAMEDSTRINGARBPROC glad_debug_glDeleteNamedStringARB;
#define glDeleteNamedStringARB glad_debug_glDeleteNamedStringARB
    GLAD_API_CALL PFNGLDELETENAMESAMDPROC glad_glDeleteNamesAMD;
    GLAD_API_CALL PFNGLDELETENAMESAMDPROC glad_debug_glDeleteNamesAMD;
#define glDeleteNamesAMD glad_debug_glDeleteNamesAMD
    GLAD_API_CALL PFNGLDELETEOBJECTARBPROC glad_glDeleteObjectARB;
    GLAD_API_CALL PFNGLDELETEOBJECTARBPROC glad_debug_glDeleteObjectARB;
#define glDeleteObjectARB glad_debug_glDeleteObjectARB
    GLAD_API_CALL PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_glDeleteOcclusionQueriesNV;
    GLAD_API_CALL PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_debug_glDeleteOcclusionQueriesNV;
#define glDeleteOcclusionQueriesNV glad_debug_glDeleteOcclusionQueriesNV
    GLAD_API_CALL PFNGLDELETEPATHSNVPROC glad_glDeletePathsNV;
    GLAD_API_CALL PFNGLDELETEPATHSNVPROC glad_debug_glDeletePathsNV;
#define glDeletePathsNV glad_debug_glDeletePathsNV
    GLAD_API_CALL PFNGLDELETEPERFMONITORSAMDPROC glad_glDeletePerfMonitorsAMD;
    GLAD_API_CALL PFNGLDELETEPERFMONITORSAMDPROC glad_debug_glDeletePerfMonitorsAMD;
#define glDeletePerfMonitorsAMD glad_debug_glDeletePerfMonitorsAMD
    GLAD_API_CALL PFNGLDELETEPERFQUERYINTELPROC glad_glDeletePerfQueryINTEL;
    GLAD_API_CALL PFNGLDELETEPERFQUERYINTELPROC glad_debug_glDeletePerfQueryINTEL;
#define glDeletePerfQueryINTEL glad_debug_glDeletePerfQueryINTEL
    GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
    GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_debug_glDeleteProgram;

/// <summary>
///   Deletes a program object
///   <para>
///     glDeleteProgram frees the memory and invalidates the name associated with the program object
///     specified by program. This command effectively undoes the effects of a call to
///     glCreateProgram. If a program object is in use as part of current rendering state, it will
///     be flagged for deletion, but it will not be deleted until it is no longer part of current
///     state for any rendering context. If a program object to be deleted has shader objects
///     attached to it, those shader objects will be automatically detached but not deleted unless
///     they have already been flagged for deletion by a previous call to glDeleteShader. A value of
///     0 for program will be silently ignored. To determine whether a program object has been
///     flagged for deletion, call glGetProgram with arguments program and GL_DELETE_STATUS.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be deleted.</param>
#define glDeleteProgram glad_debug_glDeleteProgram
    GLAD_API_CALL PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;
    GLAD_API_CALL PFNGLDELETEPROGRAMPIPELINESPROC glad_debug_glDeleteProgramPipelines;

/// <summary>
///   delete program pipeline objects
///   <para>
///     glDeleteProgramPipelines deletes the n program pipeline objects whose names are stored in
///     the array pipelines. Unused names in pipelines are ignored, as is the name zero. After a
///     program pipeline object is deleted, its name is again unused and it has no contents. If
///     program pipeline object that is currently bound is deleted, the binding for that object
///     reverts to zero and no program pipeline object becomes current.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of program pipeline objects to delete.</param>
/// <param name='pipelines'>Specifies an array of names of program pipeline objects to
/// delete.</param>
#define glDeleteProgramPipelines glad_debug_glDeleteProgramPipelines
    GLAD_API_CALL PFNGLDELETEPROGRAMSARBPROC glad_glDeleteProgramsARB;
    GLAD_API_CALL PFNGLDELETEPROGRAMSARBPROC glad_debug_glDeleteProgramsARB;
#define glDeleteProgramsARB glad_debug_glDeleteProgramsARB
    GLAD_API_CALL PFNGLDELETEPROGRAMSNVPROC glad_glDeleteProgramsNV;
    GLAD_API_CALL PFNGLDELETEPROGRAMSNVPROC glad_debug_glDeleteProgramsNV;
#define glDeleteProgramsNV glad_debug_glDeleteProgramsNV
    GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
    GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_debug_glDeleteQueries;

/// <summary>
///   delete named query objects
///   <para>
///     glDeleteQueries deletes n query objects named by the elements of the array ids. After a
///     query object is deleted, it has no contents, and its name is free for reuse (for example by
///     glGenQueries ). glDeleteQueries silently ignores 0's and names that do not correspond to
///     existing query objects.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of query objects to be deleted.</param>
/// <param name='ids'>Specifies an array of query objects to be deleted.</param>
#define glDeleteQueries glad_debug_glDeleteQueries
    GLAD_API_CALL PFNGLDELETEQUERIESARBPROC glad_glDeleteQueriesARB;
    GLAD_API_CALL PFNGLDELETEQUERIESARBPROC glad_debug_glDeleteQueriesARB;
#define glDeleteQueriesARB glad_debug_glDeleteQueriesARB
    GLAD_API_CALL PFNGLDELETEQUERYRESOURCETAGNVPROC glad_glDeleteQueryResourceTagNV;
    GLAD_API_CALL PFNGLDELETEQUERYRESOURCETAGNVPROC glad_debug_glDeleteQueryResourceTagNV;
#define glDeleteQueryResourceTagNV glad_debug_glDeleteQueryResourceTagNV
    GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
    GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_debug_glDeleteRenderbuffers;

/// <summary>
///   delete renderbuffer objects
///   <para>
///     glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array
///     addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored,
///     should it occur in renderbuffers , as are other unused names. Once a renderbuffer object is
///     deleted, its name is again unused and it has no contents. If a renderbuffer that is
///     currently bound to the target GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer
///     had been executed with a target of GL_RENDERBUFFER and a name of zero. If a renderbuffer
///     object is attached to one or more attachment points in the currently bound framebuffer, then
///     it as if glFramebufferRenderbuffer had been called, with a renderbuffer of zero for each
///     attachment point to which this image was attached in the currently bound framebuffer. In
///     other words, this renderbuffer object is first detached from all attachment ponits in the
///     currently bound framebuffer. Note that the renderbuffer image is specifically not detached
///     from any non-bound framebuffers.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of renderbuffer objects to be deleted.</param>
/// <param name='renderbuffers'>A pointer to an array containing</param>
#define glDeleteRenderbuffers glad_debug_glDeleteRenderbuffers
    GLAD_API_CALL PFNGLDELETERENDERBUFFERSEXTPROC glad_glDeleteRenderbuffersEXT;
    GLAD_API_CALL PFNGLDELETERENDERBUFFERSEXTPROC glad_debug_glDeleteRenderbuffersEXT;
#define glDeleteRenderbuffersEXT glad_debug_glDeleteRenderbuffersEXT
    GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
    GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_debug_glDeleteSamplers;

/// <summary>
///   delete named sampler objects
///   <para>
///     glDeleteSamplers deletes n sampler objects named by the elements of the array samplers.
///     After a sampler object is deleted, its name is again unused. If a sampler object that is
///     currently bound to a sampler unit is deleted, it is as though glBindSampler is called with
///     unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are
///     silently ignored, as is the reserved name zero.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of sampler objects to be deleted.</param>
/// <param name='samplers'>Specifies an array of sampler objects to be deleted.</param>
#define glDeleteSamplers glad_debug_glDeleteSamplers
    GLAD_API_CALL PFNGLDELETESEMAPHORESEXTPROC glad_glDeleteSemaphoresEXT;
    GLAD_API_CALL PFNGLDELETESEMAPHORESEXTPROC glad_debug_glDeleteSemaphoresEXT;
#define glDeleteSemaphoresEXT glad_debug_glDeleteSemaphoresEXT
    GLAD_API_CALL PFNGLDELETESHADERPROC glad_glDeleteShader;
    GLAD_API_CALL PFNGLDELETESHADERPROC glad_debug_glDeleteShader;

/// <summary>
///   Deletes a shader object
///   <para>
///     glDeleteShader frees the memory and invalidates the name associated with the shader object
///     specified by shader. This command effectively undoes the effects of a call to
///     glCreateShader. If a shader object to be deleted is attached to a program object, it will be
///     flagged for deletion, but it will not be deleted until it is no longer attached to any
///     program object, for any rendering context (i.e., it must be detached from wherever it was
///     attached before it will be deleted). A value of 0 for shader will be silently ignored. To
///     determine whether an object has been flagged for deletion, call glGetShader with arguments
///     shader and GL_DELETE_STATUS.
///   </para>
/// </summary>
/// <param name='shader'>Specifies the shader object to be deleted.</param>
#define glDeleteShader glad_debug_glDeleteShader
    GLAD_API_CALL PFNGLDELETESTATESNVPROC glad_glDeleteStatesNV;
    GLAD_API_CALL PFNGLDELETESTATESNVPROC glad_debug_glDeleteStatesNV;
#define glDeleteStatesNV glad_debug_glDeleteStatesNV
    GLAD_API_CALL PFNGLDELETESYNCPROC glad_glDeleteSync;
    GLAD_API_CALL PFNGLDELETESYNCPROC glad_debug_glDeleteSync;

/// <summary>
///   delete a sync object
///   <para>
///     glDeleteSync deletes the sync object specified by sync. If the fence command corresponding
///     to the specified sync object has completed, or if no glWaitSync or glClientWaitSync commands
///     are blocking on sync , the object is deleted immediately. Otherwise, sync is flagged for
///     deletion and will be deleted when it is no longer associated with any fence command and is
///     no longer blocking any glWaitSync or glClientWaitSync command. In either case, after
///     glDeleteSync returns, the name sync is invalid and can no longer be used to refer to the
///     sync object. glDeleteSync will silently ignore a sync value of zero.
///   </para>
/// </summary>
/// <param name='sync'>The sync object to be deleted.</param>
#define glDeleteSync glad_debug_glDeleteSync
    GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
    GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_debug_glDeleteTextures;

/// <summary>
///   delete named textures
///   <para>
///     glDeleteTextures deletes n textures named by the elements of the array textures. After a
///     texture is deleted, it has no contents or dimensionality, and its name is free for reuse
///     (for example by glGenTextures ). If a texture that is currently bound is deleted, the
///     binding reverts to 0 (the default texture). glDeleteTextures silently ignores 0's and names
///     that do not correspond to existing textures.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of textures to be deleted.</param>
/// <param name='textures'>Specifies an array of textures to be deleted.</param>
#define glDeleteTextures glad_debug_glDeleteTextures
    GLAD_API_CALL PFNGLDELETETEXTURESEXTPROC glad_glDeleteTexturesEXT;
    GLAD_API_CALL PFNGLDELETETEXTURESEXTPROC glad_debug_glDeleteTexturesEXT;
#define glDeleteTexturesEXT glad_debug_glDeleteTexturesEXT
    GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
    GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_debug_glDeleteTransformFeedbacks;

/// <summary>
///   delete transform feedback objects
///   <para>
///     glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored
///     in the array ids. Unused names in ids are ignored, as is the name zero. After a transform
///     feedback object is deleted, its name is again unused and it has no contents. If an active
///     transform feedback object is deleted, its name immediately becomes unused, but the
///     underlying object is not deleted until it is no longer active.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of transform feedback objects to delete.</param>
/// <param name='ids'>Specifies an array of names of transform feedback objects to delete.</param>
#define glDeleteTransformFeedbacks glad_debug_glDeleteTransformFeedbacks
    GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_glDeleteTransformFeedbacksNV;
    GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_debug_glDeleteTransformFeedbacksNV;
#define glDeleteTransformFeedbacksNV glad_debug_glDeleteTransformFeedbacksNV
    GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
    GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_debug_glDeleteVertexArrays;

/// <summary>
///   delete vertex array objects
///   <para>
///     glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array
///     addressed by arrays. Once a vertex array object is deleted it has no contents and its name
///     is again unused. If a vertex array object that is currently bound is deleted, the binding
///     for that object reverts to zero and the default vertex array becomes current. Unused names
///     in arrays are silently ignored, as is the value zero.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of vertex array objects to be deleted.</param>
/// <param name='arrays'>Specifies the address of an array containing the</param>
#define glDeleteVertexArrays glad_debug_glDeleteVertexArrays
    GLAD_API_CALL PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_glDeleteVertexArraysAPPLE;
    GLAD_API_CALL PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_debug_glDeleteVertexArraysAPPLE;
#define glDeleteVertexArraysAPPLE glad_debug_glDeleteVertexArraysAPPLE
    GLAD_API_CALL PFNGLDELETEVERTEXSHADEREXTPROC glad_glDeleteVertexShaderEXT;
    GLAD_API_CALL PFNGLDELETEVERTEXSHADEREXTPROC glad_debug_glDeleteVertexShaderEXT;
#define glDeleteVertexShaderEXT glad_debug_glDeleteVertexShaderEXT
    GLAD_API_CALL PFNGLDEPTHBOUNDSEXTPROC glad_glDepthBoundsEXT;
    GLAD_API_CALL PFNGLDEPTHBOUNDSEXTPROC glad_debug_glDepthBoundsEXT;
#define glDepthBoundsEXT glad_debug_glDepthBoundsEXT
    GLAD_API_CALL PFNGLDEPTHBOUNDSDNVPROC glad_glDepthBoundsdNV;
    GLAD_API_CALL PFNGLDEPTHBOUNDSDNVPROC glad_debug_glDepthBoundsdNV;
#define glDepthBoundsdNV glad_debug_glDepthBoundsdNV
    GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_glDepthFunc;
    GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_debug_glDepthFunc;

/// <summary>
///   specify the value used for depth buffer comparisons
///   <para>
///     glDepthFunc specifies the function used to compare each incoming pixel depth value with the
///     depth value present in the depth buffer. The comparison is performed only if depth testing
///     is enabled. (See glEnable and glDisable of GL_DEPTH_TEST.) func specifies the conditions
///     under which the pixel will be drawn. The comparison functions are as follows: Never passes.
///     Passes if the incoming depth value is less than the stored depth value. Passes if the
///     incoming depth value is equal to the stored depth value. Passes if the incoming depth value
///     is less than or equal to the stored depth value. Passes if the incoming depth value is
///     greater than the stored depth value. Passes if the incoming depth value is not equal to the
///     stored depth value. Passes if the incoming depth value is greater than or equal to the
///     stored depth value. Always passes. The initial value of func is GL_LESS. Initially, depth
///     testing is disabled. If depth testing is disabled or if no depth buffer exists, it is as if
///     the depth test always passes.
///   </para>
/// </summary>
/// <param name='func'>Specifies the depth comparison function. Symbolic constants</param>
#define glDepthFunc glad_debug_glDepthFunc
    GLAD_API_CALL PFNGLDEPTHMASKPROC glad_glDepthMask;
    GLAD_API_CALL PFNGLDEPTHMASKPROC glad_debug_glDepthMask;

/// <summary>
///   enable or disable writing into the depth buffer
///   <para>
///     glDepthMask specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE ,
///     depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing
///     is enabled.
///   </para>
/// </summary>
/// <param name='flag'>Specifies whether the depth buffer is enabled for writing. If</param>
#define glDepthMask glad_debug_glDepthMask
    GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_glDepthRange;
    GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_debug_glDepthRange;

/// <summary>
///   specify mapping of depth values from normalized device coordinates to window coordinates
///   <para>
///     After clipping and division by w , depth coordinates range from -1 to 1, corresponding to
///     the near and far clipping planes. glDepthRange specifies a linear mapping of the normalized
///     depth coordinates in this range to window depth coordinates. Regardless of the actual depth
///     buffer implementation, window coordinate depth values are treated as though they range from
///     0 through 1 (like color components). Thus, the values accepted by glDepthRange are both
///     clamped to this range before they are accepted. The setting of (0,1) maps the near plane to
///     0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
///   </para>
/// </summary>
/// <param name='nearVal'>Specifies the mapping of the near clipping plane to window coordinates.
/// The initial value is 0.</param> <param name='farVal'>Specifies the mapping of the far clipping
/// plane to window coordinates. The initial value is 1.</param>
#define glDepthRange glad_debug_glDepthRange
    GLAD_API_CALL PFNGLDEPTHRANGEARRAYDVNVPROC glad_glDepthRangeArraydvNV;
    GLAD_API_CALL PFNGLDEPTHRANGEARRAYDVNVPROC glad_debug_glDepthRangeArraydvNV;
#define glDepthRangeArraydvNV glad_debug_glDepthRangeArraydvNV
    GLAD_API_CALL PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;
    GLAD_API_CALL PFNGLDEPTHRANGEARRAYVPROC glad_debug_glDepthRangeArrayv;
#define glDepthRangeArrayv glad_debug_glDepthRangeArrayv
    GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;
    GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDPROC glad_debug_glDepthRangeIndexed;

/// <summary>
///   specify mapping of depth values from normalized device coordinates to window coordinates for a
///   specified viewport <para>
///     After clipping and division by w , depth coordinates range from -1 to 1, corresponding to
///     the near and far clipping planes. Each viewport has an independent depth range specified as
///     a linear mapping of the normalized depth coordinates in this range to window depth
///     coordinates. Regardless of the actual depth buffer implementation, window coordinate depth
///     values are treated as though they range from 0 through 1 (like color components).
///     glDepthRangeIndexed specifies a linear mapping of the normalized depth coordinates in this
///     range to window depth coordinates for a specified viewport. Thus, the values accepted by
///     glDepthRangeIndexed are both clamped to this range before they are accepted. The index
///     parameter specifies the index of first viewport whose depth range to modify and must be less
///     than the value of GL_MAX_VIEWPORTS. nearVal and farVal specify near and far values of the
///     depth range for the specified viewport, respectively. The setting of (0,1) maps the near
///     plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully
///     utilized.
///   </para>
/// </summary>
/// <param name='index'>Specifies the index of the viewport whose depth range to update.</param>
/// <param name='nearVal'>Specifies the mapping of the near clipping plane to window coordinates.
/// The initial value is 0.</param> <param name='farVal'>Specifies the mapping of the far clipping
/// plane to window coordinates. The initial value is 1.</param>
#define glDepthRangeIndexed glad_debug_glDepthRangeIndexed
    GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDDNVPROC glad_glDepthRangeIndexeddNV;
    GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDDNVPROC glad_debug_glDepthRangeIndexeddNV;
#define glDepthRangeIndexeddNV glad_debug_glDepthRangeIndexeddNV
    GLAD_API_CALL PFNGLDEPTHRANGEDNVPROC glad_glDepthRangedNV;
    GLAD_API_CALL PFNGLDEPTHRANGEDNVPROC glad_debug_glDepthRangedNV;
#define glDepthRangedNV glad_debug_glDepthRangedNV
    GLAD_API_CALL PFNGLDEPTHRANGEFPROC glad_glDepthRangef;
    GLAD_API_CALL PFNGLDEPTHRANGEFPROC glad_debug_glDepthRangef;
#define glDepthRangef glad_debug_glDepthRangef
    GLAD_API_CALL PFNGLDEPTHRANGEFOESPROC glad_glDepthRangefOES;
    GLAD_API_CALL PFNGLDEPTHRANGEFOESPROC glad_debug_glDepthRangefOES;
#define glDepthRangefOES glad_debug_glDepthRangefOES
    GLAD_API_CALL PFNGLDEPTHRANGEXOESPROC glad_glDepthRangexOES;
    GLAD_API_CALL PFNGLDEPTHRANGEXOESPROC glad_debug_glDepthRangexOES;
#define glDepthRangexOES glad_debug_glDepthRangexOES
    GLAD_API_CALL PFNGLDETACHOBJECTARBPROC glad_glDetachObjectARB;
    GLAD_API_CALL PFNGLDETACHOBJECTARBPROC glad_debug_glDetachObjectARB;
#define glDetachObjectARB glad_debug_glDetachObjectARB
    GLAD_API_CALL PFNGLDETACHSHADERPROC glad_glDetachShader;
    GLAD_API_CALL PFNGLDETACHSHADERPROC glad_debug_glDetachShader;

/// <summary>
///   Detaches a shader object from a program object to which it is attached
///   <para>
///     glDetachShader detaches the shader object specified by shader from the program object
///     specified by program. This command can be used to undo the effect of the command
///     glAttachShader. If shader has already been flagged for deletion by a call to glDeleteShader
///     and it is not attached to any other program object, it will be deleted after it has been
///     detached.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object from which to detach the shader
/// object.</param> <param name='shader'>Specifies the shader object to be detached.</param>
#define glDetachShader glad_debug_glDetachShader
    GLAD_API_CALL PFNGLDETAILTEXFUNCSGISPROC glad_glDetailTexFuncSGIS;
    GLAD_API_CALL PFNGLDETAILTEXFUNCSGISPROC glad_debug_glDetailTexFuncSGIS;
#define glDetailTexFuncSGIS glad_debug_glDetailTexFuncSGIS
    GLAD_API_CALL PFNGLDISABLEPROC glad_glDisable;
    GLAD_API_CALL PFNGLDISABLEPROC glad_debug_glDisable;
#define glDisable glad_debug_glDisable
    GLAD_API_CALL PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_glDisableClientStateIndexedEXT;
    GLAD_API_CALL PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_debug_glDisableClientStateIndexedEXT;
#define glDisableClientStateIndexedEXT glad_debug_glDisableClientStateIndexedEXT
    GLAD_API_CALL PFNGLDISABLECLIENTSTATEIEXTPROC glad_glDisableClientStateiEXT;
    GLAD_API_CALL PFNGLDISABLECLIENTSTATEIEXTPROC glad_debug_glDisableClientStateiEXT;
#define glDisableClientStateiEXT glad_debug_glDisableClientStateiEXT
    GLAD_API_CALL PFNGLDISABLEINDEXEDEXTPROC glad_glDisableIndexedEXT;
    GLAD_API_CALL PFNGLDISABLEINDEXEDEXTPROC glad_debug_glDisableIndexedEXT;
#define glDisableIndexedEXT glad_debug_glDisableIndexedEXT
    GLAD_API_CALL PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_glDisableVariantClientStateEXT;
    GLAD_API_CALL PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_debug_glDisableVariantClientStateEXT;
#define glDisableVariantClientStateEXT glad_debug_glDisableVariantClientStateEXT
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_debug_glDisableVertexArrayAttrib;
#define glDisableVertexArrayAttrib glad_debug_glDisableVertexArrayAttrib
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_glDisableVertexArrayAttribEXT;
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_debug_glDisableVertexArrayAttribEXT;
#define glDisableVertexArrayAttribEXT glad_debug_glDisableVertexArrayAttribEXT
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYEXTPROC glad_glDisableVertexArrayEXT;
    GLAD_API_CALL PFNGLDISABLEVERTEXARRAYEXTPROC glad_debug_glDisableVertexArrayEXT;
#define glDisableVertexArrayEXT glad_debug_glDisableVertexArrayEXT
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_glDisableVertexAttribAPPLE;
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_debug_glDisableVertexAttribAPPLE;
#define glDisableVertexAttribAPPLE glad_debug_glDisableVertexAttribAPPLE
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_debug_glDisableVertexAttribArray;
#define glDisableVertexAttribArray glad_debug_glDisableVertexAttribArray
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_glDisableVertexAttribArrayARB;
    GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_debug_glDisableVertexAttribArrayARB;
#define glDisableVertexAttribArrayARB glad_debug_glDisableVertexAttribArrayARB
    GLAD_API_CALL PFNGLDISABLEIPROC glad_glDisablei;
    GLAD_API_CALL PFNGLDISABLEIPROC glad_debug_glDisablei;
#define glDisablei glad_debug_glDisablei
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEPROC glad_debug_glDispatchCompute;

/// <summary>
///   launch one or more compute work groups
///   <para>
///     glDispatchCompute launches one or more compute work groups. Each work group is processed by
///     the active program object for the compute shader stage. While the individual shader
///     invocations within a work group are executed as a unit, work groups are executed completely
///     independently and in unspecified order. num_groups_x , num_groups_y and num_groups_z specify
///     the number of local work groups that will be dispatched in the X, Y and Z dimensions,
///     respectively.
///   </para>
/// </summary>
/// <param name='num_groups_x'>The number of work groups to be launched in the X dimension.</param>
/// <param name='num_groups_y'>The number of work groups to be launched in the Y dimension.</param>
/// <param name='num_groups_z'>The number of work groups to be launched in the Z dimension.</param>
#define glDispatchCompute glad_debug_glDispatchCompute
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_glDispatchComputeGroupSizeARB;
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_debug_glDispatchComputeGroupSizeARB;
#define glDispatchComputeGroupSizeARB glad_debug_glDispatchComputeGroupSizeARB
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;
    GLAD_API_CALL PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_debug_glDispatchComputeIndirect;

/// <summary>
///   launch one or more compute work groups using parameters stored in a buffer
///   <para>
///     glDispatchComputeIndirect launches one or more compute work groups using parameters stored
///     in the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER target. Each work
///     group is processed by the active program object for the compute shader stage. While the
///     individual shader invocations within a work group are executed as a unit, work groups are
///     executed completely independently and in unspecified order. indirect contains the offset
///     into the data store of the buffer object bound to the GL_DISPATCH_INDIRECT_BUFFER target at
///     which the parameters are stored. The parameters addressed by indirect are packed a
///     structure, which takes the form (in C): A call to glDispatchComputeIndirect is equivalent,
///     assuming no errors are generated, to: Unlike glDispatchCompute , no error is generated if
///     any of the num_groups_x , num_groups_y or num_groups_z members of the
///     DispatchIndirectCommand is larger than the value of GL_MAX_COMPUTE_WORK_GROUP_COUNT for the
///     corresponding dimension. In such circumstances, behavior is undefined and may lead to
///     application termination.
///   </para>
/// </summary>
/// <param name='indirect'>The offset into the buffer object currently bound to the</param>
#define glDispatchComputeIndirect glad_debug_glDispatchComputeIndirect
    GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_glDrawArrays;
    GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_debug_glDrawArrays;

/// <summary>
///   render primitives from array data
///   <para>
///     glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead
///     of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
///     flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use
///     them to construct a sequence of primitives with a single call to glDrawArrays. When
///     glDrawArrays is called, it uses count sequential elements from each enabled array to
///     construct a sequence of geometric primitives, beginning with element first. mode specifies
///     what kind of primitives are constructed and how the array elements construct those
///     primitives. Vertex attributes that are modified by glDrawArrays have an unspecified value
///     after glDrawArrays returns. Attributes that aren't modified remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='first'>Specifies the starting index in the enabled arrays.</param>
/// <param name='count'>Specifies the number of indices to be rendered.</param>
#define glDrawArrays glad_debug_glDrawArrays
    GLAD_API_CALL PFNGLDRAWARRAYSEXTPROC glad_glDrawArraysEXT;
    GLAD_API_CALL PFNGLDRAWARRAYSEXTPROC glad_debug_glDrawArraysEXT;
#define glDrawArraysEXT glad_debug_glDrawArraysEXT
    GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
    GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_debug_glDrawArraysIndirect;

/// <summary>
///   render primitives from array data, taking parameters from memory
///   <para>
///     glDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls.
///     glDrawArraysIndirect behaves similarly to glDrawArraysInstancedBaseInstance , execept that
///     the parameters to glDrawArraysInstancedBaseInstance are stored in memory at the address
///     given by indirect. The parameters addressed by indirect are packed into a structure that
///     takes the form (in C): If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the
///     time of a call to glDrawArraysIndirect , indirect is interpreted as an offset, in basic
///     machine units, into that buffer and the parameter data is read from the buffer rather than
///     from client memory. In contrast to glDrawArraysInstancedBaseInstance , the first member of
///     the parameter structure is unsigned, and out-of-range indices do not generate an error.
///     Vertex attributes that are modified by glDrawArraysIndirect have an unspecified value after
///     glDrawArraysIndirect returns. Attributes that aren't modified remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='indirect'>Specifies the address of a structure containing the draw
/// parameters.</param>
#define glDrawArraysIndirect glad_debug_glDrawArraysIndirect
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_debug_glDrawArraysInstanced;

/// <summary>
///   draw multiple instances of a range of elements
///   <para>
///     glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of
///     the range of elements are executed and the value of the internal counter instanceID advances
///     for each iteration. instanceID is an internal 32-bit integer counter that may be read by a
///     vertex shader as gl_InstanceID. glDrawArraysInstanced has the same effect as:
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='first'>Specifies the starting index in the enabled arrays.</param>
/// <param name='count'>Specifies the number of indices to be rendered.</param>
/// <param name='primcount'>Specifies the number of instances of the specified range of indices to
/// be rendered.</param>
#define glDrawArraysInstanced glad_debug_glDrawArraysInstanced
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDARBPROC glad_glDrawArraysInstancedARB;
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDARBPROC glad_debug_glDrawArraysInstancedARB;
#define glDrawArraysInstancedARB glad_debug_glDrawArraysInstancedARB
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC
        glad_debug_glDrawArraysInstancedBaseInstance;

/// <summary>
///   draw multiple instances of a range of elements with offset applied to instanced attributes
///   <para>
///     glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays except that primcount
///     instances of the range of elements are executed and the value of the internal counter
///     instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
///     that may be read by a vertex shader as gl_InstanceID. glDrawArraysInstancedBaseInstance has
///     the same effect as: Specific vertex attributes may be classified as instanced through the
///     use of glVertexAttribDivisor. Instanced vertex attributes supply per-instance vertex data to
///     the vertex shader. The index of the vertex fetched from the enabled instanced vertex
///     attribute arrays is calculated as: gl _ InstanceID divisor + baseInstance. Note that
///     baseinstance does not affect the shader-visible value of gl_InstanceID.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='first'>Specifies the starting index in the enabled arrays.</param>
/// <param name='count'>Specifies the number of indices to be rendered.</param>
/// <param name='primcount'>Specifies the number of instances of the specified range of indices to
/// be rendered.</param> <param name='baseinstance'>Specifies the base instance for use in fetching
/// instanced vertex attributes.</param>
#define glDrawArraysInstancedBaseInstance glad_debug_glDrawArraysInstancedBaseInstance
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_glDrawArraysInstancedEXT;
    GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_debug_glDrawArraysInstancedEXT;
#define glDrawArraysInstancedEXT glad_debug_glDrawArraysInstancedEXT
    GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
    GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_debug_glDrawBuffer;

/// <summary>
///   specify which color buffers are to be drawn into
///   <para>
///     When colors are written to the frame buffer, they are written into the color buffers
///     specified by glDrawBuffer. One of the following values can be used for default framebuffer:
///     No color buffers are written. Only the front left color buffer is written. Only the front
///     right color buffer is written. Only the back left color buffer is written. Only the back
///     right color buffer is written. Only the front left and front right color buffers are
///     written. If there is no front right color buffer, only the front left color buffer is
///     written. Only the back left and back right color buffers are written. If there is no back
///     right color buffer, only the back left color buffer is written. Only the front left and back
///     left color buffers are written. If there is no back left color buffer, only the front left
///     color buffer is written. Only the front right and back right color buffers are written. If
///     there is no back right color buffer, only the front right color buffer is written. All the
///     front and back color buffers (front left, front right, back left, back right) are written.
///     If there are no back color buffers, only the front left and front right color buffers are
///     written. If there are no right color buffers, only the front left and back left color
///     buffers are written. If there are no right or back color buffers, only the front left color
///     buffer is written. If more than one color buffer is selected for drawing, then blending or
///     logical operations are computed and applied independently for each color buffer and can
///     produce different results in each buffer. Monoscopic contexts include only left buffers, and
///     stereoscopic contexts include both left and right buffers. Likewise, single-buffered
///     contexts include only front buffers, and double-buffered contexts include both front and
///     back buffers. The context is selected at GL initialization. For framebuffer objects,
///     GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and
///     GL_MAX_COLOR_ATTACHMENTS. glDrawBuffer will set the draw buffer for fragment colors other
///     than zero to GL_NONE.
///   </para>
/// </summary>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='buf'>For default framebuffer, the argument specifies up to four color buffers to be
/// drawn into. Symbolic constants</param>
#define glDrawBuffer glad_debug_glDrawBuffer
    GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
    GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_debug_glDrawBuffers;

/// <summary>
///   Specifies a list of color buffers to be drawn into
///   <para>
///     glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into which
///     outputs from the fragment shader data will be written. If a fragment shader writes a value
///     to one or more user defined output variables, then the value of each variable will be
///     written into the buffer specified at a location within bufs corresponding to the location
///     assigned to that user defined output. The draw buffer used for user defined outputs assigned
///     to locations greater than or equal to n is implicitly set to GL_NONE and any data written to
///     such an output is discarded. For glDrawBuffers , the framebuffer object that is bound to the
///     GL_DRAW_FRAMEBUFFER binding will be used. For glNamedFramebufferDrawBuffers , framebuffer is
///     the name of the framebuffer object. If framebuffer is zero, then the default framebuffer is
///     affected. The symbolic constants contained in bufs may be any of the following: The fragment
///     shader output value is not written into any color buffer. The fragment shader output value
///     is written into the front left color buffer. The fragment shader output value is written
///     into the front right color buffer. The fragment shader output value is written into the back
///     left color buffer. The fragment shader output value is written into the back right color
///     buffer. The fragment shader output value is written into the n th color attachment of the
///     current framebuffer. n may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS. Except
///     for GL_NONE , the preceding symbolic constants may not appear more than once in bufs. The
///     maximum number of draw buffers supported is implementation dependent and can be queried by
///     calling glGet with the argument GL_MAX_DRAW_BUFFERS.
///   </para>
/// </summary>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='n'>Specifies the number of buffers in</param>
/// <param name='bufs'>Points to an array of symbolic constants specifying the buffers into which
/// fragment colors or data values will be written.</param>
#define glDrawBuffers glad_debug_glDrawBuffers
    GLAD_API_CALL PFNGLDRAWBUFFERSARBPROC glad_glDrawBuffersARB;
    GLAD_API_CALL PFNGLDRAWBUFFERSARBPROC glad_debug_glDrawBuffersARB;
#define glDrawBuffersARB glad_debug_glDrawBuffersARB
    GLAD_API_CALL PFNGLDRAWBUFFERSATIPROC glad_glDrawBuffersATI;
    GLAD_API_CALL PFNGLDRAWBUFFERSATIPROC glad_debug_glDrawBuffersATI;
#define glDrawBuffersATI glad_debug_glDrawBuffersATI
    GLAD_API_CALL PFNGLDRAWCOMMANDSADDRESSNVPROC glad_glDrawCommandsAddressNV;
    GLAD_API_CALL PFNGLDRAWCOMMANDSADDRESSNVPROC glad_debug_glDrawCommandsAddressNV;
#define glDrawCommandsAddressNV glad_debug_glDrawCommandsAddressNV
    GLAD_API_CALL PFNGLDRAWCOMMANDSNVPROC glad_glDrawCommandsNV;
    GLAD_API_CALL PFNGLDRAWCOMMANDSNVPROC glad_debug_glDrawCommandsNV;
#define glDrawCommandsNV glad_debug_glDrawCommandsNV
    GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_glDrawCommandsStatesAddressNV;
    GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_debug_glDrawCommandsStatesAddressNV;
#define glDrawCommandsStatesAddressNV glad_debug_glDrawCommandsStatesAddressNV
    GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESNVPROC glad_glDrawCommandsStatesNV;
    GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESNVPROC glad_debug_glDrawCommandsStatesNV;
#define glDrawCommandsStatesNV glad_debug_glDrawCommandsStatesNV
    GLAD_API_CALL PFNGLDRAWELEMENTARRAYAPPLEPROC glad_glDrawElementArrayAPPLE;
    GLAD_API_CALL PFNGLDRAWELEMENTARRAYAPPLEPROC glad_debug_glDrawElementArrayAPPLE;
#define glDrawElementArrayAPPLE glad_debug_glDrawElementArrayAPPLE
    GLAD_API_CALL PFNGLDRAWELEMENTARRAYATIPROC glad_glDrawElementArrayATI;
    GLAD_API_CALL PFNGLDRAWELEMENTARRAYATIPROC glad_debug_glDrawElementArrayATI;
#define glDrawElementArrayATI glad_debug_glDrawElementArrayATI
    GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_glDrawElements;
    GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_debug_glDrawElements;

/// <summary>
///   render primitives from array data
///   <para>
///     glDrawElements specifies multiple geometric primitives with very few subroutine calls.
///     Instead of calling a GL function to pass each individual vertex, normal, texture coordinate,
///     edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and
///     use them to construct a sequence of primitives with a single call to glDrawElements. When
///     glDrawElements is called, it uses count sequential elements from an enabled array, starting
///     at indices to construct a sequence of geometric primitives. mode specifies what kind of
///     primitives are constructed and how the array elements construct these primitives. If more
///     than one array is enabled, each is used. Vertex attributes that are modified by
///     glDrawElements have an unspecified value after glDrawElements returns. Attributes that
///     aren't modified maintain their previous values.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies an offset of the first index in the array in the data store of
/// the buffer currently bound to the GL_ELEMENT_ARRAY_BUFFER target.</param>
#define glDrawElements glad_debug_glDrawElements
    GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
    GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_debug_glDrawElementsBaseVertex;

/// <summary>
///   render primitives from array data with a per-element offset
///   <para>
///     glDrawElementsBaseVertex behaves identically to glDrawElements except that the i th element
///     transferred by the corresponding draw call will be taken from element indices [i] +
///     basevertex of each enabled array. If the resulting value is larger than the maximum value
///     representable by type , it is as if the calculation were upconverted to 32-bit unsigned
///     integers (with wrapping on overflow conditions). The operation is undefined if the sum would
///     be negative.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in indices. Must be one of</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='basevertex'>Specifies a constant that should be added to each element of</param>
#define glDrawElementsBaseVertex glad_debug_glDrawElementsBaseVertex
    GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
    GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_debug_glDrawElementsIndirect;

/// <summary>
///   render indexed primitives from array data, taking parameters from memory
///   <para>
///     glDrawElementsIndirect specifies multiple indexed geometric primitives with very few
///     subroutine calls. glDrawElementsIndirect behaves similarly to
///     glDrawElementsInstancedBaseVertexBaseInstance , execpt that the parameters to
///     glDrawElementsInstancedBaseVertexBaseInstance are stored in memory at the address given by
///     indirect. The parameters addressed by indirect are packed into a structure that takes the
///     form (in C): glDrawElementsIndirect is equivalent to: If a buffer is bound to the
///     GL_DRAW_INDIRECT_BUFFER binding at the time of a call to glDrawElementsIndirect , indirect
///     is interpreted as an offset, in basic machine units, into that buffer and the parameter data
///     is read from the buffer rather than from client memory. Note that indices stored in client
///     memory are not supported. If no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, an
///     error will be generated. The results of the operation are undefined if the
///     reservedMustBeZero member of the parameter structure is non-zero. However, no error is
///     generated in this case. Vertex attributes that are modified by glDrawElementsIndirect have
///     an unspecified value after glDrawElementsIndirect returns. Attributes that aren't modified
///     remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='type'>Specifies the type of data in the buffer bound to the</param>
/// <param name='indirect'>Specifies the address of a structure containing the draw
/// parameters.</param>
#define glDrawElementsIndirect glad_debug_glDrawElementsIndirect
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_debug_glDrawElementsInstanced;

/// <summary>
///   draw multiple instances of a set of elements
///   <para>
///     glDrawElementsInstanced behaves identically to glDrawElements except that primcount
///     instances of the set of elements are executed and the value of the internal counter
///     instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
///     that may be read by a vertex shader as gl_InstanceID. glDrawElementsInstanced has the same
///     effect as:
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='primcount'>Specifies the number of instances of the specified range of indices to
/// be rendered.</param>
#define glDrawElementsInstanced glad_debug_glDrawElementsInstanced
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_glDrawElementsInstancedARB;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_debug_glDrawElementsInstancedARB;
#define glDrawElementsInstancedARB glad_debug_glDrawElementsInstancedARB
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC
        glad_glDrawElementsInstancedBaseInstance;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC
        glad_debug_glDrawElementsInstancedBaseInstance;

/// <summary>
///   draw multiple instances of a set of elements with offset applied to instanced attributes
///   <para>
///     glDrawElementsInstancedBaseInstance behaves identically to glDrawElements except that
///     primcount instances of the set of elements are executed and the value of the internal
///     counter instanceID advances for each iteration. instanceID is an internal 32-bit integer
///     counter that may be read by a vertex shader as gl_InstanceID.
///     glDrawElementsInstancedBaseInstance has the same effect as: Specific vertex attributes may
///     be classified as instanced through the use of glVertexAttribDivisor. Instanced vertex
///     attributes supply per-instance vertex data to the vertex shader. The index of the vertex
///     fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID
///     divisor + baseInstance. Note that baseinstance does not affect the shader-visible value of
///     gl_InstanceID.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='primcount'>Specifies the number of instances of the specified range of indices to
/// be rendered.</param> <param name='baseinstance'>Specifies the base instance for use in fetching
/// instanced vertex attributes.</param>
#define glDrawElementsInstancedBaseInstance glad_debug_glDrawElementsInstancedBaseInstance
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC
        glad_debug_glDrawElementsInstancedBaseVertex;

/// <summary>
///   render multiple instances of a set of primitives from array data with a per-element offset
///   <para>
///     glDrawElementsInstancedBaseVertex behaves identically to glDrawElementsInstanced except that
///     the i th element transferred by the corresponding draw call will be taken from element
///     indices [i] + basevertex of each enabled array. If the resulting value is larger than the
///     maximum value representable by type , it is as if the calculation were upconverted to 32-bit
///     unsigned integers (with wrapping on overflow conditions). The operation is undefined if the
///     sum would be negative.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in indices. Must be one of</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='primcount'>Specifies the number of instances of the indexed geometry that should be
/// drawn.</param> <param name='basevertex'>Specifies a constant that should be added to each
/// element of</param>
#define glDrawElementsInstancedBaseVertex glad_debug_glDrawElementsInstancedBaseVertex
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC
        glad_glDrawElementsInstancedBaseVertexBaseInstance;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC
        glad_debug_glDrawElementsInstancedBaseVertexBaseInstance;

/// <summary>
///   render multiple instances of a set of primitives from array data with a per-element offset
///   <para>
///     glDrawElementsInstancedBaseVertexBaseInstance behaves identically to glDrawElementsInstanced
///     except that the i th element transferred by the corresponding draw call will be taken from
///     element indices [i] + basevertex of each enabled array. If the resulting value is larger
///     than the maximum value representable by type , it is as if the calculation were upconverted
///     to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is
///     undefined if the sum would be negative. The basevertex has no effect on the shader-visible
///     value of gl_VertexID. Specific vertex attributes may be classified as instanced through the
///     use of glVertexAttribDivisor. Instanced vertex attributes supply per-instance vertex data to
///     the vertex shader. The index of the vertex fetched from the enabled instanced vertex
///     attribute arrays is calculated as gl _ InstanceID divisor + baseInstance. Note that
///     baseinstance does not affect the shader-visible value of gl_InstanceID.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in indices. Must be one of</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='primcount'>Specifies the number of instances of the indexed geometry that should be
/// drawn.</param> <param name='basevertex'>Specifies a constant that should be added to each
/// element of</param> <param name='baseinstance'>Specifies the base instance for use in fetching
/// instanced vertex attributes.</param>
#define glDrawElementsInstancedBaseVertexBaseInstance \
    glad_debug_glDrawElementsInstancedBaseVertexBaseInstance
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_glDrawElementsInstancedEXT;
    GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_debug_glDrawElementsInstancedEXT;
#define glDrawElementsInstancedEXT glad_debug_glDrawElementsInstancedEXT
    GLAD_API_CALL PFNGLDRAWMESHARRAYSSUNPROC glad_glDrawMeshArraysSUN;
    GLAD_API_CALL PFNGLDRAWMESHARRAYSSUNPROC glad_debug_glDrawMeshArraysSUN;
#define glDrawMeshArraysSUN glad_debug_glDrawMeshArraysSUN
    GLAD_API_CALL PFNGLDRAWMESHTASKSINDIRECTNVPROC glad_glDrawMeshTasksIndirectNV;
    GLAD_API_CALL PFNGLDRAWMESHTASKSINDIRECTNVPROC glad_debug_glDrawMeshTasksIndirectNV;
#define glDrawMeshTasksIndirectNV glad_debug_glDrawMeshTasksIndirectNV
    GLAD_API_CALL PFNGLDRAWMESHTASKSNVPROC glad_glDrawMeshTasksNV;
    GLAD_API_CALL PFNGLDRAWMESHTASKSNVPROC glad_debug_glDrawMeshTasksNV;
#define glDrawMeshTasksNV glad_debug_glDrawMeshTasksNV
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_glDrawRangeElementArrayAPPLE;
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_debug_glDrawRangeElementArrayAPPLE;
#define glDrawRangeElementArrayAPPLE glad_debug_glDrawRangeElementArrayAPPLE
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_glDrawRangeElementArrayATI;
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_debug_glDrawRangeElementArrayATI;
#define glDrawRangeElementArrayATI glad_debug_glDrawRangeElementArrayATI
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_debug_glDrawRangeElements;

/// <summary>
///   render primitives from array data
///   <para>
///     glDrawRangeElements is a restricted form of glDrawElements. mode , start , end , and count
///     match the corresponding arguments to glDrawElements , with the additional constraint that
///     all values in the arrays count must lie between start and end , inclusive. Implementations
///     denote recommended maximum amounts of vertex and index data, which may be queried by calling
///     glGet with argument GL_MAX_ELEMENTS_VERTICES and GL_MAX_ELEMENTS_INDICES. If end - start + 1
///     is greater than the value of GL_MAX_ELEMENTS_VERTICES , or if count is greater than the
///     value of GL_MAX_ELEMENTS_INDICES , then the call may operate at reduced performance. There
///     is no requirement that all vertices in the range start end be referenced. However, the
///     implementation may partially process unused vertices, reducing performance from what could
///     be achieved with an optimal index set. When glDrawRangeElements is called, it uses count
///     sequential elements from an enabled array, starting at start to construct a sequence of
///     geometric primitives. mode specifies what kind of primitives are constructed, and how the
///     array elements construct these primitives. If more than one array is enabled, each is used.
///     Vertex attributes that are modified by glDrawRangeElements have an unspecified value after
///     glDrawRangeElements returns. Attributes that aren't modified maintain their previous values.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='start'>Specifies the minimum array index contained in</param>
/// <param name='end'>Specifies the maximum array index contained in</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
#define glDrawRangeElements glad_debug_glDrawRangeElements
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_debug_glDrawRangeElementsBaseVertex;

/// <summary>
///   render primitives from array data with a per-element offset
///   <para>
///     glDrawRangeElementsBaseVertex is a restricted form of glDrawElementsBaseVertex. mode , start
///     , end , count and basevertex match the corresponding arguments to glDrawElementsBaseVertex ,
///     with the additional constraint that all values in the array indices must lie between start
///     and end , inclusive, prior to adding basevertex. Index values lying outside the range [
///     start , end ] are treated in the same way as glDrawElementsBaseVertex. The i th element
///     transferred by the corresponding draw call will be taken from element indices [i] +
///     basevertex of each enabled array. If the resulting value is larger than the maximum value
///     representable by type , it is as if the calculation were upconverted to 32-bit unsigned
///     integers (with wrapping on overflow conditions). The operation is undefined if the sum would
///     be negative.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='start'>Specifies the minimum array index contained in</param>
/// <param name='end'>Specifies the maximum array index contained in</param>
/// <param name='count'>Specifies the number of elements to be rendered.</param>
/// <param name='type'>Specifies the type of the values in indices. Must be one of</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='basevertex'>Specifies a constant that should be added to each element of</param>
#define glDrawRangeElementsBaseVertex glad_debug_glDrawRangeElementsBaseVertex
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSEXTPROC glad_glDrawRangeElementsEXT;
    GLAD_API_CALL PFNGLDRAWRANGEELEMENTSEXTPROC glad_debug_glDrawRangeElementsEXT;
#define glDrawRangeElementsEXT glad_debug_glDrawRangeElementsEXT
    GLAD_API_CALL PFNGLDRAWTEXTURENVPROC glad_glDrawTextureNV;
    GLAD_API_CALL PFNGLDRAWTEXTURENVPROC glad_debug_glDrawTextureNV;
#define glDrawTextureNV glad_debug_glDrawTextureNV
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_debug_glDrawTransformFeedback;

/// <summary>
///   render primitives using a count derived from a transform feedback object
///   <para>
///     glDrawTransformFeedback draws primitives of a type specified by mode using a count retrieved
///     from the transform feedback specified by id. Calling glDrawTransformFeedback is equivalent
///     to calling glDrawArrays with mode as specified, first set to zero, and count set to the
///     number of vertices captured on vertex stream zero the last time transform feedback was
///     active on the transform feedback object named by id.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='id'>Specifies the name of a transform feedback object from which to retrieve a
/// primitive count.</param>
#define glDrawTransformFeedback glad_debug_glDrawTransformFeedback
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC
        glad_debug_glDrawTransformFeedbackInstanced;

/// <summary>
///   render multiple instances of primitives using a count derived from a transform feedback object
///   <para>
///     glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type
///     specified by mode using a count retrieved from the transform feedback stream specified by
///     stream of the transform feedback object specified by id. Calling
///     glDrawTransformFeedbackInstanced is equivalent to calling glDrawArraysInstanced with mode
///     and primcount as specified, first set to zero, and count set to the number of vertices
///     captured on vertex stream zero the last time transform feedback was active on the transform
///     feedback object named by id. Calling glDrawTransformFeedbackInstanced is equivalent to
///     calling glDrawTransformFeedbackStreamInstanced with stream set to zero.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='id'>Specifies the name of a transform feedback object from which to retrieve a
/// primitive count.</param> <param name='primcount'>Specifies the number of instances of the
/// geometry to render.</param>
#define glDrawTransformFeedbackInstanced glad_debug_glDrawTransformFeedbackInstanced
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_glDrawTransformFeedbackNV;
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_debug_glDrawTransformFeedbackNV;
#define glDrawTransformFeedbackNV glad_debug_glDrawTransformFeedbackNV
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_debug_glDrawTransformFeedbackStream;

/// <summary>
///   render primitives using a count derived from a specifed stream of a transform feedback object
///   <para>
///     glDrawTransformFeedbackStream draws primitives of a type specified by mode using a count
///     retrieved from the transform feedback stream specified by stream of the transform feedback
///     object specified by id. Calling glDrawTransformFeedbackStream is equivalent to calling
///     glDrawArrays with mode as specified, first set to zero, and count set to the number of
///     vertices captured on vertex stream stream the last time transform feedback was active on the
///     transform feedback object named by id. Calling glDrawTransformFeedback is equivalent to
///     calling glDrawTransformFeedbackStream with stream set to zero.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='id'>Specifies the name of a transform feedback object from which to retrieve a
/// primitive count.</param> <param name='stream'>Specifies the index of the transform feedback
/// stream from which to retrieve a primitive count.</param>
#define glDrawTransformFeedbackStream glad_debug_glDrawTransformFeedbackStream
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC
        glad_glDrawTransformFeedbackStreamInstanced;
    GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC
        glad_debug_glDrawTransformFeedbackStreamInstanced;

/// <summary>
///   render multiple instances of primitives using a count derived from a specifed stream of a
///   transform feedback object <para>
///     glDrawTransformFeedbackStreamInstanced draws multiple copies of a range of primitives of a
///     type specified by mode using a count retrieved from the transform feedback stream specified
///     by stream of the transform feedback object specified by id. Calling
///     glDrawTransformFeedbackStreamInstanced is equivalent to calling glDrawArraysInstanced with
///     mode and primcount as specified, first set to zero, and count set to the number of vertices
///     captured on vertex stream stream the last time transform feedback was active on the
///     transform feedback object named by id. Calling glDrawTransformFeedbackInstanced is
///     equivalent to calling glDrawTransformFeedbackStreamInstanced with stream set to zero.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='id'>Specifies the name of a transform feedback object from which to retrieve a
/// primitive count.</param> <param name='stream'>Specifies the index of the transform feedback
/// stream from which to retrieve a primitive count.</param> <param name='primcount'>Specifies the
/// number of instances of the geometry to render.</param>
#define glDrawTransformFeedbackStreamInstanced glad_debug_glDrawTransformFeedbackStreamInstanced
    GLAD_API_CALL PFNGLDRAWVKIMAGENVPROC glad_glDrawVkImageNV;
    GLAD_API_CALL PFNGLDRAWVKIMAGENVPROC glad_debug_glDrawVkImageNV;
#define glDrawVkImageNV glad_debug_glDrawVkImageNV
    GLAD_API_CALL PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC glad_glEGLImageTargetTexStorageEXT;
    GLAD_API_CALL PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC glad_debug_glEGLImageTargetTexStorageEXT;
#define glEGLImageTargetTexStorageEXT glad_debug_glEGLImageTargetTexStorageEXT
    GLAD_API_CALL PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC glad_glEGLImageTargetTextureStorageEXT;
    GLAD_API_CALL PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC
        glad_debug_glEGLImageTargetTextureStorageEXT;
#define glEGLImageTargetTextureStorageEXT glad_debug_glEGLImageTargetTextureStorageEXT
    GLAD_API_CALL PFNGLEDGEFLAGFORMATNVPROC glad_glEdgeFlagFormatNV;
    GLAD_API_CALL PFNGLEDGEFLAGFORMATNVPROC glad_debug_glEdgeFlagFormatNV;
#define glEdgeFlagFormatNV glad_debug_glEdgeFlagFormatNV
    GLAD_API_CALL PFNGLEDGEFLAGPOINTEREXTPROC glad_glEdgeFlagPointerEXT;
    GLAD_API_CALL PFNGLEDGEFLAGPOINTEREXTPROC glad_debug_glEdgeFlagPointerEXT;
#define glEdgeFlagPointerEXT glad_debug_glEdgeFlagPointerEXT
    GLAD_API_CALL PFNGLEDGEFLAGPOINTERLISTIBMPROC glad_glEdgeFlagPointerListIBM;
    GLAD_API_CALL PFNGLEDGEFLAGPOINTERLISTIBMPROC glad_debug_glEdgeFlagPointerListIBM;
#define glEdgeFlagPointerListIBM glad_debug_glEdgeFlagPointerListIBM
    GLAD_API_CALL PFNGLELEMENTPOINTERAPPLEPROC glad_glElementPointerAPPLE;
    GLAD_API_CALL PFNGLELEMENTPOINTERAPPLEPROC glad_debug_glElementPointerAPPLE;
#define glElementPointerAPPLE glad_debug_glElementPointerAPPLE
    GLAD_API_CALL PFNGLELEMENTPOINTERATIPROC glad_glElementPointerATI;
    GLAD_API_CALL PFNGLELEMENTPOINTERATIPROC glad_debug_glElementPointerATI;
#define glElementPointerATI glad_debug_glElementPointerATI
    GLAD_API_CALL PFNGLENABLEPROC glad_glEnable;
    GLAD_API_CALL PFNGLENABLEPROC glad_debug_glEnable;

/// <summary>
///   enable or disable server-side GL capabilities
///   <para>
///     glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
///     determine the current setting of any capability. The initial value for each capability with
///     the exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER
///     and GL_MULTISAMPLE is GL_TRUE. Both glEnable and glDisable take a single argument, cap ,
///     which can assume one of the following values: Some of the GL's capabilities are indexed.
///     glEnablei and glDisablei enable and disable indexed capabilities. If enabled, blend the
///     computed fragment color values with the values in the color buffers. See glBlendFunc. If
///     enabled, clip geometry against user-defined half space i. If enabled, apply the currently
///     selected logical operation to the computed fragment color and color buffer values. See
///     glLogicOp. If enabled, cull polygons based on their winding in window coordinates. See
///     glCullFace. If enabled, debug messages are produced by a debug context. When disabled, the
///     debug message log is silenced. Note that in a non-debug context, very few, if any messages
///     might be produced, even when GL_DEBUG_OUTPUT is enabled. If enabled, debug messages are
///     produced synchronously by a debug context. If disabled, debug messages may be produced
///     asynchronously. In particular, they may be delayed relative to the execution of GL commands,
///     and the debug callback function may be called from a thread other than that in which the
///     commands are executed. See glDebugMessageCallback. If enabled, the - w c ≤ z c ≤ w c plane
///     equation is ignored by view volume clipping (effectively, there is no near or far plane
///     clipping). See glDepthRange. If enabled, do depth comparisons and update the depth buffer.
///     Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer
///     is not updated if the depth test is disabled. See glDepthFunc and glDepthRange. If enabled,
///     dither color components or indices before they are written to the color buffer. If enabled
///     and the value of GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the framebuffer attachment
///     corresponding to the destination buffer is GL_SRGB , the R, G, and B destination color
///     values (after conversion from fixed-point to floating-point) are considered to be encoded
///     for the sRGB color space and hence are linearized prior to their use in blending. If
///     enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See glLineWidth.
///     If enabled, use multiple fragment samples in computing the final color of a pixel. See
///     glSampleCoverage. If enabled, and if the polygon is rendered in GL_FILL mode, an offset is
///     added to depth values of a polygon's fragments before the depth comparison is performed. See
///     glPolygonOffset. If enabled, and if the polygon is rendered in GL_LINE mode, an offset is
///     added to depth values of a polygon's fragments before the depth comparison is performed. See
///     glPolygonOffset. If enabled, an offset is added to depth values of a polygon's fragments
///     before the depth comparison is performed, if the polygon is rendered in GL_POINT mode. See
///     glPolygonOffset. If enabled, draw polygons with proper filtering. Otherwise, draw aliased
///     polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must
///     be sorted front to back. Enables primitive restarting. If enabled, any one of the draw
///     commands which transfers a set of generic attribute array elements to the GL will restart
///     the primitive when the index of the vertex is equal to the primitive restart index. See
///     glPrimitiveRestartIndex. Enables primitive restarting with a fixed index. If enabled, any
///     one of the draw commands which transfers a set of generic attribute array elements to the GL
///     will restart the primitive when the index of the vertex is equal to the fixed primitive
///     index for the specified index type. The fixed index is equal to 2 n − 1 where n is equal to
///     8 for GL_UNSIGNED_BYTE , 16 for GL_UNSIGNED_SHORT and 32 for GL_UNSIGNED_INT. If enabled,
///     primitives are discarded after the optional transform feedback stage, but before
///     rasterization. Furthermore, when enabled, glClear , glClearBufferData , glClearBufferSubData
///     , glClearTexImage , and glClearTexSubImage are ignored. If enabled, compute a temporary
///     coverage value where each bit is determined by the alpha value at the corresponding sample
///     location. The temporary coverage value is then ANDed with the fragment coverage value. If
///     enabled, each sample alpha value is replaced by the maximum representable alpha value. If
///     enabled, the fragment's coverage is ANDed with the temporary coverage value. If
///     GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE , invert the coverage value. See
///     glSampleCoverage. If enabled, the active fragment shader is run once for each covered
///     sample, or at fraction of this rate as determined by the current value of
///     GL_MIN_SAMPLE_SHADING_VALUE. See glMinSampleShading. If enabled, the sample coverage mask
///     generated for a fragment during rasterization will be ANDed with the value of
///     GL_SAMPLE_MASK_VALUE before shading occurs. See glSampleMaski. If enabled, discard fragments
///     that are outside the scissor rectangle. See glScissor. If enabled, do stencil testing and
///     update the stencil buffer. See glStencilFunc and glStencilOp. If enabled, cubemap textures
///     are sampled such that when linearly sampling from the border between two adjacent faces,
///     texels from both faces are used to generate the final sample value. When disabled, texels
///     from only a single face are used to construct the final sample value. If enabled and a
///     vertex or geometry shader is active, then the derived point size is taken from the
///     (potentially clipped) shader builtin gl_PointSize and clamped to the
///     implementation-dependent point size range.
///   </para>
/// </summary>
/// <param name='cap'>Specifies a symbolic constant indicating a GL capability.</param>
/// <param name='index'>Specifies the index of the switch to disable (for</param>
#define glEnable glad_debug_glEnable
    GLAD_API_CALL PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_glEnableClientStateIndexedEXT;
    GLAD_API_CALL PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_debug_glEnableClientStateIndexedEXT;
#define glEnableClientStateIndexedEXT glad_debug_glEnableClientStateIndexedEXT
    GLAD_API_CALL PFNGLENABLECLIENTSTATEIEXTPROC glad_glEnableClientStateiEXT;
    GLAD_API_CALL PFNGLENABLECLIENTSTATEIEXTPROC glad_debug_glEnableClientStateiEXT;
#define glEnableClientStateiEXT glad_debug_glEnableClientStateiEXT
    GLAD_API_CALL PFNGLENABLEINDEXEDEXTPROC glad_glEnableIndexedEXT;
    GLAD_API_CALL PFNGLENABLEINDEXEDEXTPROC glad_debug_glEnableIndexedEXT;
#define glEnableIndexedEXT glad_debug_glEnableIndexedEXT
    GLAD_API_CALL PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_glEnableVariantClientStateEXT;
    GLAD_API_CALL PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_debug_glEnableVariantClientStateEXT;
#define glEnableVariantClientStateEXT glad_debug_glEnableVariantClientStateEXT
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBPROC glad_debug_glEnableVertexArrayAttrib;
#define glEnableVertexArrayAttrib glad_debug_glEnableVertexArrayAttrib
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_glEnableVertexArrayAttribEXT;
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_debug_glEnableVertexArrayAttribEXT;
#define glEnableVertexArrayAttribEXT glad_debug_glEnableVertexArrayAttribEXT
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYEXTPROC glad_glEnableVertexArrayEXT;
    GLAD_API_CALL PFNGLENABLEVERTEXARRAYEXTPROC glad_debug_glEnableVertexArrayEXT;
#define glEnableVertexArrayEXT glad_debug_glEnableVertexArrayEXT
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_glEnableVertexAttribAPPLE;
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_debug_glEnableVertexAttribAPPLE;
#define glEnableVertexAttribAPPLE glad_debug_glEnableVertexAttribAPPLE
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_debug_glEnableVertexAttribArray;

/// <summary>
///   Enable or disable a generic vertex attribute array
///   <para>
///     glEnableVertexAttribArray and glEnableVertexArrayAttrib enable the generic vertex attribute
///     array specified by index. glEnableVertexAttribArray uses currently bound vertex array object
///     for the operation, whereas glEnableVertexArrayAttrib updates state of the vertex array
///     object with ID vaobj. glDisableVertexAttribArray and glDisableVertexArrayAttrib disable the
///     generic vertex attribute array specified by index. glDisableVertexAttribArray uses currently
///     bound vertex array object for the operation, whereas glDisableVertexArrayAttrib updates
///     state of the vertex array object with ID vaobj. By default, all client-side capabilities are
///     disabled, including all generic vertex attribute arrays. If enabled, the values in the
///     generic vertex attribute array will be accessed and used for rendering when calls are made
///     to vertex array commands such as glDrawArrays , glDrawElements , glDrawRangeElements ,
///     glMultiDrawElements , or glMultiDrawArrays.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object for</param>
/// <param name='index'>Specifies the index of the generic vertex attribute to be enabled or
/// disabled.</param>
#define glEnableVertexAttribArray glad_debug_glEnableVertexAttribArray
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_glEnableVertexAttribArrayARB;
    GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_debug_glEnableVertexAttribArrayARB;
#define glEnableVertexAttribArrayARB glad_debug_glEnableVertexAttribArrayARB
    GLAD_API_CALL PFNGLENABLEIPROC glad_glEnablei;
    GLAD_API_CALL PFNGLENABLEIPROC glad_debug_glEnablei;
#define glEnablei glad_debug_glEnablei
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_debug_glEndConditionalRender;
#define glEndConditionalRender glad_debug_glEndConditionalRender
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVPROC glad_glEndConditionalRenderNV;
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVPROC glad_debug_glEndConditionalRenderNV;
#define glEndConditionalRenderNV glad_debug_glEndConditionalRenderNV
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVXPROC glad_glEndConditionalRenderNVX;
    GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVXPROC glad_debug_glEndConditionalRenderNVX;
#define glEndConditionalRenderNVX glad_debug_glEndConditionalRenderNVX
    GLAD_API_CALL PFNGLENDFRAGMENTSHADERATIPROC glad_glEndFragmentShaderATI;
    GLAD_API_CALL PFNGLENDFRAGMENTSHADERATIPROC glad_debug_glEndFragmentShaderATI;
#define glEndFragmentShaderATI glad_debug_glEndFragmentShaderATI
    GLAD_API_CALL PFNGLENDOCCLUSIONQUERYNVPROC glad_glEndOcclusionQueryNV;
    GLAD_API_CALL PFNGLENDOCCLUSIONQUERYNVPROC glad_debug_glEndOcclusionQueryNV;
#define glEndOcclusionQueryNV glad_debug_glEndOcclusionQueryNV
    GLAD_API_CALL PFNGLENDPERFMONITORAMDPROC glad_glEndPerfMonitorAMD;
    GLAD_API_CALL PFNGLENDPERFMONITORAMDPROC glad_debug_glEndPerfMonitorAMD;
#define glEndPerfMonitorAMD glad_debug_glEndPerfMonitorAMD
    GLAD_API_CALL PFNGLENDPERFQUERYINTELPROC glad_glEndPerfQueryINTEL;
    GLAD_API_CALL PFNGLENDPERFQUERYINTELPROC glad_debug_glEndPerfQueryINTEL;
#define glEndPerfQueryINTEL glad_debug_glEndPerfQueryINTEL
    GLAD_API_CALL PFNGLENDQUERYPROC glad_glEndQuery;
    GLAD_API_CALL PFNGLENDQUERYPROC glad_debug_glEndQuery;
#define glEndQuery glad_debug_glEndQuery
    GLAD_API_CALL PFNGLENDQUERYARBPROC glad_glEndQueryARB;
    GLAD_API_CALL PFNGLENDQUERYARBPROC glad_debug_glEndQueryARB;
#define glEndQueryARB glad_debug_glEndQueryARB
    GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
    GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_debug_glEndQueryIndexed;
#define glEndQueryIndexed glad_debug_glEndQueryIndexed
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_debug_glEndTransformFeedback;
#define glEndTransformFeedback glad_debug_glEndTransformFeedback
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_glEndTransformFeedbackEXT;
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_debug_glEndTransformFeedbackEXT;
#define glEndTransformFeedbackEXT glad_debug_glEndTransformFeedbackEXT
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKNVPROC glad_glEndTransformFeedbackNV;
    GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKNVPROC glad_debug_glEndTransformFeedbackNV;
#define glEndTransformFeedbackNV glad_debug_glEndTransformFeedbackNV
    GLAD_API_CALL PFNGLENDVERTEXSHADEREXTPROC glad_glEndVertexShaderEXT;
    GLAD_API_CALL PFNGLENDVERTEXSHADEREXTPROC glad_debug_glEndVertexShaderEXT;
#define glEndVertexShaderEXT glad_debug_glEndVertexShaderEXT
    GLAD_API_CALL PFNGLENDVIDEOCAPTURENVPROC glad_glEndVideoCaptureNV;
    GLAD_API_CALL PFNGLENDVIDEOCAPTURENVPROC glad_debug_glEndVideoCaptureNV;
#define glEndVideoCaptureNV glad_debug_glEndVideoCaptureNV
    GLAD_API_CALL PFNGLEVALCOORD1XOESPROC glad_glEvalCoord1xOES;
    GLAD_API_CALL PFNGLEVALCOORD1XOESPROC glad_debug_glEvalCoord1xOES;
#define glEvalCoord1xOES glad_debug_glEvalCoord1xOES
    GLAD_API_CALL PFNGLEVALCOORD1XVOESPROC glad_glEvalCoord1xvOES;
    GLAD_API_CALL PFNGLEVALCOORD1XVOESPROC glad_debug_glEvalCoord1xvOES;
#define glEvalCoord1xvOES glad_debug_glEvalCoord1xvOES
    GLAD_API_CALL PFNGLEVALCOORD2XOESPROC glad_glEvalCoord2xOES;
    GLAD_API_CALL PFNGLEVALCOORD2XOESPROC glad_debug_glEvalCoord2xOES;
#define glEvalCoord2xOES glad_debug_glEvalCoord2xOES
    GLAD_API_CALL PFNGLEVALCOORD2XVOESPROC glad_glEvalCoord2xvOES;
    GLAD_API_CALL PFNGLEVALCOORD2XVOESPROC glad_debug_glEvalCoord2xvOES;
#define glEvalCoord2xvOES glad_debug_glEvalCoord2xvOES
    GLAD_API_CALL PFNGLEVALMAPSNVPROC glad_glEvalMapsNV;
    GLAD_API_CALL PFNGLEVALMAPSNVPROC glad_debug_glEvalMapsNV;
#define glEvalMapsNV glad_debug_glEvalMapsNV
    GLAD_API_CALL PFNGLEVALUATEDEPTHVALUESARBPROC glad_glEvaluateDepthValuesARB;
    GLAD_API_CALL PFNGLEVALUATEDEPTHVALUESARBPROC glad_debug_glEvaluateDepthValuesARB;
#define glEvaluateDepthValuesARB glad_debug_glEvaluateDepthValuesARB
    GLAD_API_CALL PFNGLEXECUTEPROGRAMNVPROC glad_glExecuteProgramNV;
    GLAD_API_CALL PFNGLEXECUTEPROGRAMNVPROC glad_debug_glExecuteProgramNV;
#define glExecuteProgramNV glad_debug_glExecuteProgramNV
    GLAD_API_CALL PFNGLEXTRACTCOMPONENTEXTPROC glad_glExtractComponentEXT;
    GLAD_API_CALL PFNGLEXTRACTCOMPONENTEXTPROC glad_debug_glExtractComponentEXT;
#define glExtractComponentEXT glad_debug_glExtractComponentEXT
    GLAD_API_CALL PFNGLFEEDBACKBUFFERXOESPROC glad_glFeedbackBufferxOES;
    GLAD_API_CALL PFNGLFEEDBACKBUFFERXOESPROC glad_debug_glFeedbackBufferxOES;
#define glFeedbackBufferxOES glad_debug_glFeedbackBufferxOES
    GLAD_API_CALL PFNGLFENCESYNCPROC glad_glFenceSync;
    GLAD_API_CALL PFNGLFENCESYNCPROC glad_debug_glFenceSync;

/// <summary>
///   create a new sync object and insert it into the GL command stream
///   <para>
///     glFenceSync creates a new fence sync object, inserts a fence command into the GL command
///     stream and associates it with that sync object, and returns a non-zero name corresponding to
///     the sync object. When the specified condition of the sync object is satisfied by the fence
///     command, the sync object is signaled by the GL, causing any glWaitSync , glClientWaitSync
///     commands blocking in sync to unblock. No other state is affected by glFenceSync or by the
///     execution of the associated fence command. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.
///     This condition is satisfied by completion of the fence command corresponding to the sync
///     object and all preceding commands in the same command stream. The sync object will not be
///     signaled until all effects from these commands on GL client and server state and the
///     framebuffer are fully realized. Note that completion of the fence command occurs once the
///     state of the corresponding sync object has been changed, but commands waiting on that sync
///     object may not be unblocked until after the fence command completes.
///   </para>
/// </summary>
/// <param name='condition'>Specifies the condition that must be met to set the sync object's state
/// to signaled.</param> <param name='flags'>Specifies a bitwise combination of flags controlling
/// the behavior of the sync object. No flags are presently defined for this operation and</param>
#define glFenceSync glad_debug_glFenceSync
    GLAD_API_CALL PFNGLFINALCOMBINERINPUTNVPROC glad_glFinalCombinerInputNV;
    GLAD_API_CALL PFNGLFINALCOMBINERINPUTNVPROC glad_debug_glFinalCombinerInputNV;
#define glFinalCombinerInputNV glad_debug_glFinalCombinerInputNV
    GLAD_API_CALL PFNGLFINISHPROC glad_glFinish;
    GLAD_API_CALL PFNGLFINISHPROC glad_debug_glFinish;

/// <summary>
///   block until all GL execution is complete
///   <para>
///     glFinish does not return until the effects of all previously called GL commands are
///     complete. Such effects include all changes to GL state, all changes to connection state, and
///     all changes to the frame buffer contents.
///   </para>
/// </summary>
#define glFinish glad_debug_glFinish
    GLAD_API_CALL PFNGLFINISHASYNCSGIXPROC glad_glFinishAsyncSGIX;
    GLAD_API_CALL PFNGLFINISHASYNCSGIXPROC glad_debug_glFinishAsyncSGIX;
#define glFinishAsyncSGIX glad_debug_glFinishAsyncSGIX
    GLAD_API_CALL PFNGLFINISHFENCEAPPLEPROC glad_glFinishFenceAPPLE;
    GLAD_API_CALL PFNGLFINISHFENCEAPPLEPROC glad_debug_glFinishFenceAPPLE;
#define glFinishFenceAPPLE glad_debug_glFinishFenceAPPLE
    GLAD_API_CALL PFNGLFINISHFENCENVPROC glad_glFinishFenceNV;
    GLAD_API_CALL PFNGLFINISHFENCENVPROC glad_debug_glFinishFenceNV;
#define glFinishFenceNV glad_debug_glFinishFenceNV
    GLAD_API_CALL PFNGLFINISHOBJECTAPPLEPROC glad_glFinishObjectAPPLE;
    GLAD_API_CALL PFNGLFINISHOBJECTAPPLEPROC glad_debug_glFinishObjectAPPLE;
#define glFinishObjectAPPLE glad_debug_glFinishObjectAPPLE
    GLAD_API_CALL PFNGLFINISHTEXTURESUNXPROC glad_glFinishTextureSUNX;
    GLAD_API_CALL PFNGLFINISHTEXTURESUNXPROC glad_debug_glFinishTextureSUNX;
#define glFinishTextureSUNX glad_debug_glFinishTextureSUNX
    GLAD_API_CALL PFNGLFLUSHPROC glad_glFlush;
    GLAD_API_CALL PFNGLFLUSHPROC glad_debug_glFlush;

/// <summary>
///   force execution of GL commands in finite time
///   <para>
///     Different GL implementations buffer commands in several different locations, including
///     network buffers and the graphics accelerator itself. glFlush empties all of these buffers,
///     causing all issued commands to be executed as quickly as they are accepted by the actual
///     rendering engine. Though this execution may not be completed in any particular time period,
///     it does complete in finite time. Because any GL program might be executed over a network, or
///     on an accelerator that buffers commands, all programs should call glFlush whenever they
///     count on having all of their previously issued commands completed. For example, call glFlush
///     before waiting for user input that depends on the generated image.
///   </para>
/// </summary>
#define glFlush glad_debug_glFlush
    GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
    GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_debug_glFlushMappedBufferRange;

/// <summary>
///   indicate modifications to a range of a mapped buffer
///   <para>
///     glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped
///     buffer object. The buffer object must previously have been mapped with the
///     GL_MAP_FLUSH_EXPLICIT_BIT flag. offset and length indicate the modified subrange of the
///     mapping, in basic machine units. The specified subrange to flush is relative to the start of
///     the currently mapped range of the buffer. These commands may be called multiple times to
///     indicate distinct subranges of the mapping which require flushing. If a buffer range is
///     mapped with both GL_MAP_PERSISTENT_BIT and GL_MAP_FLUSH_EXPLICIT_BIT set, then these
///     commands may be called to ensure that data written by the client into the flushed region
///     becomes visible to the server. Data written to a coherent store will always become visible
///     to the server after an unspecified period of time.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='offset'>Specifies the start of the buffer subrange, in basic machine units.</param>
/// <param name='length'>Specifies the length of the buffer subrange, in basic machine
/// units.</param>
#define glFlushMappedBufferRange glad_debug_glFlushMappedBufferRange
    GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_glFlushMappedBufferRangeAPPLE;
    GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_debug_glFlushMappedBufferRangeAPPLE;
#define glFlushMappedBufferRangeAPPLE glad_debug_glFlushMappedBufferRangeAPPLE
    GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;
    GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_debug_glFlushMappedNamedBufferRange;
#define glFlushMappedNamedBufferRange glad_debug_glFlushMappedNamedBufferRange
    GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glad_glFlushMappedNamedBufferRangeEXT;
    GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC
        glad_debug_glFlushMappedNamedBufferRangeEXT;
#define glFlushMappedNamedBufferRangeEXT glad_debug_glFlushMappedNamedBufferRangeEXT
    GLAD_API_CALL PFNGLFLUSHPIXELDATARANGENVPROC glad_glFlushPixelDataRangeNV;
    GLAD_API_CALL PFNGLFLUSHPIXELDATARANGENVPROC glad_debug_glFlushPixelDataRangeNV;
#define glFlushPixelDataRangeNV glad_debug_glFlushPixelDataRangeNV
    GLAD_API_CALL PFNGLFLUSHRASTERSGIXPROC glad_glFlushRasterSGIX;
    GLAD_API_CALL PFNGLFLUSHRASTERSGIXPROC glad_debug_glFlushRasterSGIX;
#define glFlushRasterSGIX glad_debug_glFlushRasterSGIX
    GLAD_API_CALL PFNGLFLUSHSTATICDATAIBMPROC glad_glFlushStaticDataIBM;
    GLAD_API_CALL PFNGLFLUSHSTATICDATAIBMPROC glad_debug_glFlushStaticDataIBM;
#define glFlushStaticDataIBM glad_debug_glFlushStaticDataIBM
    GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_glFlushVertexArrayRangeAPPLE;
    GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_debug_glFlushVertexArrayRangeAPPLE;
#define glFlushVertexArrayRangeAPPLE glad_debug_glFlushVertexArrayRangeAPPLE
    GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_glFlushVertexArrayRangeNV;
    GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_debug_glFlushVertexArrayRangeNV;
#define glFlushVertexArrayRangeNV glad_debug_glFlushVertexArrayRangeNV
    GLAD_API_CALL PFNGLFOGCOORDFORMATNVPROC glad_glFogCoordFormatNV;
    GLAD_API_CALL PFNGLFOGCOORDFORMATNVPROC glad_debug_glFogCoordFormatNV;
#define glFogCoordFormatNV glad_debug_glFogCoordFormatNV
    GLAD_API_CALL PFNGLFOGCOORDPOINTEREXTPROC glad_glFogCoordPointerEXT;
    GLAD_API_CALL PFNGLFOGCOORDPOINTEREXTPROC glad_debug_glFogCoordPointerEXT;
#define glFogCoordPointerEXT glad_debug_glFogCoordPointerEXT
    GLAD_API_CALL PFNGLFOGCOORDPOINTERLISTIBMPROC glad_glFogCoordPointerListIBM;
    GLAD_API_CALL PFNGLFOGCOORDPOINTERLISTIBMPROC glad_debug_glFogCoordPointerListIBM;
#define glFogCoordPointerListIBM glad_debug_glFogCoordPointerListIBM
    GLAD_API_CALL PFNGLFOGCOORDDEXTPROC glad_glFogCoorddEXT;
    GLAD_API_CALL PFNGLFOGCOORDDEXTPROC glad_debug_glFogCoorddEXT;
#define glFogCoorddEXT glad_debug_glFogCoorddEXT
    GLAD_API_CALL PFNGLFOGCOORDDVEXTPROC glad_glFogCoorddvEXT;
    GLAD_API_CALL PFNGLFOGCOORDDVEXTPROC glad_debug_glFogCoorddvEXT;
#define glFogCoorddvEXT glad_debug_glFogCoorddvEXT
    GLAD_API_CALL PFNGLFOGCOORDFEXTPROC glad_glFogCoordfEXT;
    GLAD_API_CALL PFNGLFOGCOORDFEXTPROC glad_debug_glFogCoordfEXT;
#define glFogCoordfEXT glad_debug_glFogCoordfEXT
    GLAD_API_CALL PFNGLFOGCOORDFVEXTPROC glad_glFogCoordfvEXT;
    GLAD_API_CALL PFNGLFOGCOORDFVEXTPROC glad_debug_glFogCoordfvEXT;
#define glFogCoordfvEXT glad_debug_glFogCoordfvEXT
    GLAD_API_CALL PFNGLFOGCOORDHNVPROC glad_glFogCoordhNV;
    GLAD_API_CALL PFNGLFOGCOORDHNVPROC glad_debug_glFogCoordhNV;
#define glFogCoordhNV glad_debug_glFogCoordhNV
    GLAD_API_CALL PFNGLFOGCOORDHVNVPROC glad_glFogCoordhvNV;
    GLAD_API_CALL PFNGLFOGCOORDHVNVPROC glad_debug_glFogCoordhvNV;
#define glFogCoordhvNV glad_debug_glFogCoordhvNV
    GLAD_API_CALL PFNGLFOGFUNCSGISPROC glad_glFogFuncSGIS;
    GLAD_API_CALL PFNGLFOGFUNCSGISPROC glad_debug_glFogFuncSGIS;
#define glFogFuncSGIS glad_debug_glFogFuncSGIS
    GLAD_API_CALL PFNGLFOGXOESPROC glad_glFogxOES;
    GLAD_API_CALL PFNGLFOGXOESPROC glad_debug_glFogxOES;
#define glFogxOES glad_debug_glFogxOES
    GLAD_API_CALL PFNGLFOGXVOESPROC glad_glFogxvOES;
    GLAD_API_CALL PFNGLFOGXVOESPROC glad_debug_glFogxvOES;
#define glFogxvOES glad_debug_glFogxvOES
    GLAD_API_CALL PFNGLFRAGMENTCOLORMATERIALSGIXPROC glad_glFragmentColorMaterialSGIX;
    GLAD_API_CALL PFNGLFRAGMENTCOLORMATERIALSGIXPROC glad_debug_glFragmentColorMaterialSGIX;
#define glFragmentColorMaterialSGIX glad_debug_glFragmentColorMaterialSGIX
    GLAD_API_CALL PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_glFragmentCoverageColorNV;
    GLAD_API_CALL PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_debug_glFragmentCoverageColorNV;
#define glFragmentCoverageColorNV glad_debug_glFragmentCoverageColorNV
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELFSGIXPROC glad_glFragmentLightModelfSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELFSGIXPROC glad_debug_glFragmentLightModelfSGIX;
#define glFragmentLightModelfSGIX glad_debug_glFragmentLightModelfSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELFVSGIXPROC glad_glFragmentLightModelfvSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELFVSGIXPROC glad_debug_glFragmentLightModelfvSGIX;
#define glFragmentLightModelfvSGIX glad_debug_glFragmentLightModelfvSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELISGIXPROC glad_glFragmentLightModeliSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELISGIXPROC glad_debug_glFragmentLightModeliSGIX;
#define glFragmentLightModeliSGIX glad_debug_glFragmentLightModeliSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELIVSGIXPROC glad_glFragmentLightModelivSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTMODELIVSGIXPROC glad_debug_glFragmentLightModelivSGIX;
#define glFragmentLightModelivSGIX glad_debug_glFragmentLightModelivSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTFSGIXPROC glad_glFragmentLightfSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTFSGIXPROC glad_debug_glFragmentLightfSGIX;
#define glFragmentLightfSGIX glad_debug_glFragmentLightfSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTFVSGIXPROC glad_glFragmentLightfvSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTFVSGIXPROC glad_debug_glFragmentLightfvSGIX;
#define glFragmentLightfvSGIX glad_debug_glFragmentLightfvSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTISGIXPROC glad_glFragmentLightiSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTISGIXPROC glad_debug_glFragmentLightiSGIX;
#define glFragmentLightiSGIX glad_debug_glFragmentLightiSGIX
    GLAD_API_CALL PFNGLFRAGMENTLIGHTIVSGIXPROC glad_glFragmentLightivSGIX;
    GLAD_API_CALL PFNGLFRAGMENTLIGHTIVSGIXPROC glad_debug_glFragmentLightivSGIX;
#define glFragmentLightivSGIX glad_debug_glFragmentLightivSGIX
    GLAD_API_CALL PFNGLFRAGMENTMATERIALFSGIXPROC glad_glFragmentMaterialfSGIX;
    GLAD_API_CALL PFNGLFRAGMENTMATERIALFSGIXPROC glad_debug_glFragmentMaterialfSGIX;
#define glFragmentMaterialfSGIX glad_debug_glFragmentMaterialfSGIX
    GLAD_API_CALL PFNGLFRAGMENTMATERIALFVSGIXPROC glad_glFragmentMaterialfvSGIX;
    GLAD_API_CALL PFNGLFRAGMENTMATERIALFVSGIXPROC glad_debug_glFragmentMaterialfvSGIX;
#define glFragmentMaterialfvSGIX glad_debug_glFragmentMaterialfvSGIX
    GLAD_API_CALL PFNGLFRAGMENTMATERIALISGIXPROC glad_glFragmentMaterialiSGIX;
    GLAD_API_CALL PFNGLFRAGMENTMATERIALISGIXPROC glad_debug_glFragmentMaterialiSGIX;
#define glFragmentMaterialiSGIX glad_debug_glFragmentMaterialiSGIX
    GLAD_API_CALL PFNGLFRAGMENTMATERIALIVSGIXPROC glad_glFragmentMaterialivSGIX;
    GLAD_API_CALL PFNGLFRAGMENTMATERIALIVSGIXPROC glad_debug_glFragmentMaterialivSGIX;
#define glFragmentMaterialivSGIX glad_debug_glFragmentMaterialivSGIX
    GLAD_API_CALL PFNGLFRAMETERMINATORGREMEDYPROC glad_glFrameTerminatorGREMEDY;
    GLAD_API_CALL PFNGLFRAMETERMINATORGREMEDYPROC glad_debug_glFrameTerminatorGREMEDY;
#define glFrameTerminatorGREMEDY glad_debug_glFrameTerminatorGREMEDY
    GLAD_API_CALL PFNGLFRAMEZOOMSGIXPROC glad_glFrameZoomSGIX;
    GLAD_API_CALL PFNGLFRAMEZOOMSGIXPROC glad_debug_glFrameZoomSGIX;
#define glFrameZoomSGIX glad_debug_glFrameZoomSGIX
    GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_glFramebufferDrawBufferEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_debug_glFramebufferDrawBufferEXT;
#define glFramebufferDrawBufferEXT glad_debug_glFramebufferDrawBufferEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_glFramebufferDrawBuffersEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_debug_glFramebufferDrawBuffersEXT;
#define glFramebufferDrawBuffersEXT glad_debug_glFramebufferDrawBuffersEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC glad_glFramebufferFetchBarrierEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC glad_debug_glFramebufferFetchBarrierEXT;
#define glFramebufferFetchBarrierEXT glad_debug_glFramebufferFetchBarrierEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;
    GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIPROC glad_debug_glFramebufferParameteri;

/// <summary>
///   set a named parameter of a framebuffer object
///   <para>
///     glFramebufferParameteri and glNamedFramebufferParameteri modify the value of the parameter
///     named pname in the specified framebuffer object. There are no modifiable parameters of the
///     default draw and read framebuffer, so they are not valid targets of these commands. For
///     glFramebufferParameteri , the framebuffer object is that bound to target , which must be
///     GL_DRAW_FRAMEBUFFER , GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to
///     GL_DRAW_FRAMEBUFFER. For glNamedFramebufferParameteri , framebuffer is the name of the
///     framebuffer object. pname specifies the parameter to be modified. The following values are
///     accepted: param specifies the assumed width for a framebuffer object with no attachments. If
///     a framebuffer has attachments then the width of those attachments is used, otherwise the
///     value of GL_FRAMEBUFFER_DEFAULT_WIDTH is used for the framebuffer. param must be greater
///     than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_WIDTH. param
///     specifies the assumed height for a framebuffer object with no attachments. If a framebuffer
///     has attachments then the height of those attachments is used, otherwise the value of
///     GL_FRAMEBUFFER_DEFAULT_HEIGHT is used for the framebuffer. param must be greater than or
///     equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_HEIGHT. param
///     specifies the assumed number of layers for a framebuffer object with no attachments. If a
///     framebuffer has attachments then the layer count of those attachments is used, otherwise the
///     value of GL_FRAMEBUFFER_DEFAULT_LAYERS is used for the framebuffer. param must be greater
///     than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_LAYERS.
///     param specifies the assumed number of samples in a framebuffer object with no attachments.
///     If a framebuffer has attachments then the sample count of those attachments is used,
///     otherwise the value of GL_FRAMEBUFFER_DEFAULT_SAMPLES is used for the framebuffer. param
///     must be greater than or equal to zero and less than or equal to the value of
///     GL_MAX_FRAMEBUFFER_SAMPLE. param specifies whether the framebuffer should assume identical
///     sample locations and the same number of samples for all texels in the virtual image. If
///     param is zero, then the implementation may vary the position or the count of samples within
///     the virtual image from pixel to pixel, otherwise it will use the same sample position and
///     count for all pixels in the virtual image.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer is bound for</param>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='pname'>Specifies the framebuffer parameter to be modified.</param>
/// <param name='param'>The new value for the parameter named</param>
#define glFramebufferParameteri glad_debug_glFramebufferParameteri
    GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIMESAPROC glad_glFramebufferParameteriMESA;
    GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIMESAPROC glad_debug_glFramebufferParameteriMESA;
#define glFramebufferParameteriMESA glad_debug_glFramebufferParameteriMESA
    GLAD_API_CALL PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_glFramebufferReadBufferEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_debug_glFramebufferReadBufferEXT;
#define glFramebufferReadBufferEXT glad_debug_glFramebufferReadBufferEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
    GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_debug_glFramebufferRenderbuffer;

/// <summary>
///   attach a renderbuffer as a logical buffer of a framebuffer object
///   <para>
///     glFramebufferRenderbuffer and glNamedFramebufferRenderbuffer attaches a renderbuffer as one
///     of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached
///     to the default draw and read framebuffer, so they are not valid targets of these commands.
///     For glFramebufferRenderbuffer , the framebuffer object is that bound to target , which must
///     be GL_DRAW_FRAMEBUFFER , GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent
///     to GL_DRAW_FRAMEBUFFER. For glNamedFramebufferRenderbuffer , framebuffer is the name of the
///     framebuffer object. renderbuffertarget must be GL_RENDERBUFFER. renderbuffer must be zero or
///     the name of an existing renderbuffer object of type renderbuffertarget. If renderbuffer is
///     not zero, then the specified renderbuffer will be used as the logical buffer identified by
///     attachment of the specified framebuffer object. If renderbuffer is zero, then the value of
///     renderbuffertarget is ignored. attachment specifies the logical attachment of the
///     framebuffer and must be GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT
///     or GL_DEPTH_STENCIL_ATTACHMENT. i in may range from zero to the value of
///     GL_MAX_COLOR_ATTACHMENTS minus one. Setting attachment to the value
///     GL_DEPTH_STENCIL_ATTACHMENT is a special case causing both the depth and stencil attachments
///     of the specified framebuffer object to be set to renderbuffer , which should have the base
///     internal format GL_DEPTH_STENCIL. The value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the
///     specified attachment point is set to GL_RENDERBUFFER and the value of
///     GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to renderbuffer. All other state values of
///     specified attachment point are set to their default values. No change is made to the state
///     of the renderbuuffer object and any previous attachment to the attachment logical buffer of
///     the specified framebuffer object is broken. If renderbuffer is zero, these commands will
///     detach the image, if any, identified by the specified attachment point of the specified
///     framebuffer object. All state values of the attachment point are set to their default
///     values.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer is bound for</param>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='attachment'>Specifies the attachment point of the framebuffer.</param>
/// <param name='renderbuffertarget'>Specifies the renderbuffer target. Must be</param>
/// <param name='renderbuffer'>Specifies the name of an existing renderbuffer object of type</param>
#define glFramebufferRenderbuffer glad_debug_glFramebufferRenderbuffer
    GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_glFramebufferRenderbufferEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_debug_glFramebufferRenderbufferEXT;
#define glFramebufferRenderbufferEXT glad_debug_glFramebufferRenderbufferEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glFramebufferSampleLocationsfvARB;
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC
        glad_debug_glFramebufferSampleLocationsfvARB;
#define glFramebufferSampleLocationsfvARB glad_debug_glFramebufferSampleLocationsfvARB
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glFramebufferSampleLocationsfvNV;
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC
        glad_debug_glFramebufferSampleLocationsfvNV;
#define glFramebufferSampleLocationsfvNV glad_debug_glFramebufferSampleLocationsfvNV
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glFramebufferSamplePositionsfvAMD;
    GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC
        glad_debug_glFramebufferSamplePositionsfvAMD;
#define glFramebufferSamplePositionsfvAMD glad_debug_glFramebufferSamplePositionsfvAMD
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_debug_glFramebufferTexture;

/// <summary>
///   attach a level of a texture object as a logical buffer of a framebuffer object
///   <para>
///     These commands attach a selected mipmap level or image of a texture object as one of the
///     logical buffers of the specified framebuffer object. Textures cannot be attached to the
///     default draw and read framebuffer, so they are not valid targets of these commands. For all
///     commands except glNamedFramebufferTexture , the framebuffer object is that bound to target ,
///     which must be GL_DRAW_FRAMEBUFFER , GL_READ_FRAMEBUFFER , or GL_FRAMEBUFFER. GL_FRAMEBUFFER
///     is equivalent to GL_DRAW_FRAMEBUFFER. For glNamedFramebufferTexture , framebuffer is the
///     name of the framebuffer object. attachment specifies the logical attachment of the
///     framebuffer and must be GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT
///     or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENT i may range from zero to the value
///     of GL_MAX_COLOR_ATTACHMENTS minus one. Attaching a level of a texture to
///     GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching that level to both the
///     GL_DEPTH_ATTACHMENT and the GL_STENCIL_ATTACHMENT attachment points simultaneously. For
///     glFramebufferTexture1D , glFramebufferTexture2D and glFramebufferTexture3D , textarget
///     specifies what type of texture is named by texture , and for cube map textures, specifies
///     the face that is to be attached. If texture is not zero, it must be the name of an existing
///     texture object with effective target textarget unless it is a cube map texture, in which
///     case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_X GL_TEXTURE_CUBE_MAP_NEGATIVE_X ,
///     GL_TEXTURE_CUBE_MAP_POSITIVE_Y , GL_TEXTURE_CUBE_MAP_NEGATIVE_Y ,
///     GL_TEXTURE_CUBE_MAP_POSITIVE_Z , or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. If texture is non-zero,
///     the specified level of the texture object named texture is attached to the framebuffer
///     attachment point named by attachment. For glFramebufferTexture1D , glFramebufferTexture2D ,
///     and glFramebufferTexture3D , texture must be zero or the name of an existing texture with an
///     effective target of textarget , or texture must be the name of an existing cube-map texture
///     and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X , GL_TEXTURE_CUBE_MAP_POSITIVE_Y
///     , GL_TEXTURE_CUBE_MAP_POSITIVE_Z , GL_TEXTURE_CUBE_MAP_NEGATIVE_X ,
///     GL_TEXTURE_CUBE_MAP_NEGATIVE_Y , or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. If textarget is
///     GL_TEXTURE_RECTANGLE , GL_TEXTURE_2D_MULTISAMPLE , or GL_TEXTURE_2D_MULTISAMPLE_ARRAY , then
///     level must be zero. If textarget is GL_TEXTURE_3D , then level must be greater than or equal
///     to zero and less than or equal to $log_2$ of the value of GL_MAX_3D_TEXTURE_SIZE. If
///     textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X , GL_TEXTURE_CUBE_MAP_POSITIVE_Y ,
///     GL_TEXTURE_CUBE_MAP_POSITIVE_Z , GL_TEXTURE_CUBE_MAP_NEGATIVE_X ,
///     GL_TEXTURE_CUBE_MAP_NEGATIVE_Y , or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z , then level must be
///     greater than or equal to zero and less than or equal to $log_2$ of the value of
///     GL_MAX_CUBE_MAP_TEXTURE_SIZE. For all other values of textarget , level must be greater than
///     or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_TEXTURE_SIZE.
///     layer specifies the layer of a 2-dimensional image within a 3-dimensional texture. For
///     glFramebufferTexture1D , if texture is not zero, then textarget must be GL_TEXTURE_1D. For
///     glFramebufferTexture2D , if texture is not zero, textarget must be one of GL_TEXTURE_2D ,
///     GL_TEXTURE_RECTANGLE , GL_TEXTURE_CUBE_MAP_POSITIVE_X , GL_TEXTURE_CUBE_MAP_POSITIVE_Y ,
///     GL_TEXTURE_CUBE_MAP_POSITIVE_Z , GL_TEXTURE_CUBE_MAP_NEGATIVE_X ,
///     GL_TEXTURE_CUBE_MAP_NEGATIVE_Y , GL_TEXTURE_CUBE_MAP_NEGATIVE_Z , or
///     GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D , if texture is not zero, then
///     textarget must be GL_TEXTURE_3D. For glFramebufferTexture and glNamedFramebufferTexture , if
///     texture is the name of a three-dimensional, cube map array, cube map, one- or
///     two-dimensional array, or two-dimensional multisample array texture, the specified texture
///     level is an array of images, and the framebuffer attachment is considered to be layered.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer is bound for all
/// commands</param> <param name='framebuffer'>Specifies the name of the framebuffer object
/// for</param> <param name='attachment'>Specifies the attachment point of the framebuffer.</param>
/// <param name='textarget'>For</param>
/// <param name='texture'>Specifies the name of an existing texture object to attach.</param>
/// <param name='level'>Specifies the mipmap level of the texture object to attach.</param>
#define glFramebufferTexture glad_debug_glFramebufferTexture
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_debug_glFramebufferTexture1D;
#define glFramebufferTexture1D glad_debug_glFramebufferTexture1D
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_glFramebufferTexture1DEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_debug_glFramebufferTexture1DEXT;
#define glFramebufferTexture1DEXT glad_debug_glFramebufferTexture1DEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_debug_glFramebufferTexture2D;
#define glFramebufferTexture2D glad_debug_glFramebufferTexture2D
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_glFramebufferTexture2DEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_debug_glFramebufferTexture2DEXT;
#define glFramebufferTexture2DEXT glad_debug_glFramebufferTexture2DEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_debug_glFramebufferTexture3D;
#define glFramebufferTexture3D glad_debug_glFramebufferTexture3D
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_glFramebufferTexture3DEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_debug_glFramebufferTexture3DEXT;
#define glFramebufferTexture3DEXT glad_debug_glFramebufferTexture3DEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREARBPROC glad_glFramebufferTextureARB;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREARBPROC glad_debug_glFramebufferTextureARB;
#define glFramebufferTextureARB glad_debug_glFramebufferTextureARB
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_glFramebufferTextureEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_debug_glFramebufferTextureEXT;
#define glFramebufferTextureEXT glad_debug_glFramebufferTextureEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_glFramebufferTextureFaceARB;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_debug_glFramebufferTextureFaceARB;
#define glFramebufferTextureFaceARB glad_debug_glFramebufferTextureFaceARB
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_glFramebufferTextureFaceEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_debug_glFramebufferTextureFaceEXT;
#define glFramebufferTextureFaceEXT glad_debug_glFramebufferTextureFaceEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_debug_glFramebufferTextureLayer;

/// <summary>
///   attach a single layer of a texture object as a logical buffer of a framebuffer object
///   <para>
///     glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a
///     three-dimensional or array texture object as one of the logical buffers of the specified
///     framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so
///     they are not valid targets of these commands. For glFramebufferTextureLayer , the
///     framebuffer object is that bound to target , which must be GL_DRAW_FRAMEBUFFER ,
///     GL_READ_FRAMEBUFFER , or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to
///     GL_DRAW_FRAMEBUFFER. For glNamedFramebufferTextureLayer , framebuffer is the name of the
///     framebuffer object. attachment specifies the logical attachment of the framebuffer and must
///     be GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or
///     GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENT i may range from zero to the value of
///     GL_MAX_COLOR_ATTACHMENTS minus one. Attaching a level of a texture to
///     GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching that level to both the
///     GL_DEPTH_ATTACHMENT and the GL_STENCIL_ATTACHMENT attachment points simultaneously. If
///     texture is not zero, it must be the name of a three-dimensional, two-dimensional multisample
///     array, one- or two-dimensional array, or cube map array texture. If texture is a
///     three-dimensional texture, then level must be greater than or equal to zero and less than or
///     equal to $log_2$ of the value of GL_MAX_3D_TEXTURE_SIZE. If texture is a two-dimensional
///     array texture, then level must be greater than or equal to zero and less than or equal to
///     $log_2$ of the value of GL_MAX_TEXTURE_SIZE. For cube map textures, layer is translated into
///     a cube map face according to $$ face = k \bmod 6. $$ For cube map array textures, layer is
///     translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6
///     } \right\rfloor$$ and $$ face = k \bmod 6. $$
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer is bound for</param>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='attachment'>Specifies the attachment point of the framebuffer.</param>
/// <param name='texture'>Specifies the name of an existing texture object to attach.</param>
/// <param name='level'>Specifies the mipmap level of the texture object to attach.</param>
/// <param name='layer'>Specifies the layer of the texture object to attach.</param>
#define glFramebufferTextureLayer glad_debug_glFramebufferTextureLayer
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_glFramebufferTextureLayerARB;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_debug_glFramebufferTextureLayerARB;
#define glFramebufferTextureLayerARB glad_debug_glFramebufferTextureLayerARB
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_glFramebufferTextureLayerEXT;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_debug_glFramebufferTextureLayerEXT;
#define glFramebufferTextureLayerEXT glad_debug_glFramebufferTextureLayerEXT
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glad_glFramebufferTextureMultiviewOVR;
    GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC
        glad_debug_glFramebufferTextureMultiviewOVR;
#define glFramebufferTextureMultiviewOVR glad_debug_glFramebufferTextureMultiviewOVR
    GLAD_API_CALL PFNGLFREEOBJECTBUFFERATIPROC glad_glFreeObjectBufferATI;
    GLAD_API_CALL PFNGLFREEOBJECTBUFFERATIPROC glad_debug_glFreeObjectBufferATI;
#define glFreeObjectBufferATI glad_debug_glFreeObjectBufferATI
    GLAD_API_CALL PFNGLFRONTFACEPROC glad_glFrontFace;
    GLAD_API_CALL PFNGLFRONTFACEPROC glad_debug_glFrontFace;

/// <summary>
///   define front- and back-facing polygons
///   <para>
///     In a scene composed entirely of opaque closed surfaces, back-facing polygons are never
///     visible. Eliminating these invisible polygons has the obvious benefit of speeding up the
///     rendering of the image. To enable and disable elimination of back-facing polygons, call
///     glEnable and glDisable with argument GL_CULL_FACE. The projection of a polygon to window
///     coordinates is said to have clockwise winding if an imaginary object following the path from
///     its first vertex, its second vertex, and so on, to its last vertex, and finally back to its
///     first vertex, moves in a clockwise direction about the interior of the polygon. The
///     polygon's winding is said to be counterclockwise if the imaginary object following the same
///     path moves in a counterclockwise direction about the interior of the polygon. glFrontFace
///     specifies whether polygons with clockwise winding in window coordinates, or counterclockwise
///     winding in window coordinates, are taken to be front-facing. Passing GL_CCW to mode selects
///     counterclockwise polygons as front-facing; GL_CW selects clockwise polygons as front-facing.
///     By default, counterclockwise polygons are taken to be front-facing.
///   </para>
/// </summary>
/// <param name='mode'>Specifies the orientation of front-facing polygons.</param>
#define glFrontFace glad_debug_glFrontFace
    GLAD_API_CALL PFNGLFRUSTUMFOESPROC glad_glFrustumfOES;
    GLAD_API_CALL PFNGLFRUSTUMFOESPROC glad_debug_glFrustumfOES;
#define glFrustumfOES glad_debug_glFrustumfOES
    GLAD_API_CALL PFNGLFRUSTUMXOESPROC glad_glFrustumxOES;
    GLAD_API_CALL PFNGLFRUSTUMXOESPROC glad_debug_glFrustumxOES;
#define glFrustumxOES glad_debug_glFrustumxOES
    GLAD_API_CALL PFNGLGENASYNCMARKERSSGIXPROC glad_glGenAsyncMarkersSGIX;
    GLAD_API_CALL PFNGLGENASYNCMARKERSSGIXPROC glad_debug_glGenAsyncMarkersSGIX;
#define glGenAsyncMarkersSGIX glad_debug_glGenAsyncMarkersSGIX
    GLAD_API_CALL PFNGLGENBUFFERSPROC glad_glGenBuffers;
    GLAD_API_CALL PFNGLGENBUFFERSPROC glad_debug_glGenBuffers;

/// <summary>
///   generate buffer object names
///   <para>
///     glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names
///     form a contiguous set of integers; however, it is guaranteed that none of the returned names
///     was in use immediately before the call to glGenBuffers. Buffer object names returned by a
///     call to glGenBuffers are not returned by subsequent calls, unless they are first deleted
///     with glDeleteBuffers. No buffer objects are associated with the returned buffer object names
///     until they are first bound by calling glBindBuffer.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of buffer object names to be generated.</param>
/// <param name='buffers'>Specifies an array in which the generated buffer object names are
/// stored.</param>
#define glGenBuffers glad_debug_glGenBuffers
    GLAD_API_CALL PFNGLGENBUFFERSARBPROC glad_glGenBuffersARB;
    GLAD_API_CALL PFNGLGENBUFFERSARBPROC glad_debug_glGenBuffersARB;
#define glGenBuffersARB glad_debug_glGenBuffersARB
    GLAD_API_CALL PFNGLGENFENCESAPPLEPROC glad_glGenFencesAPPLE;
    GLAD_API_CALL PFNGLGENFENCESAPPLEPROC glad_debug_glGenFencesAPPLE;
#define glGenFencesAPPLE glad_debug_glGenFencesAPPLE
    GLAD_API_CALL PFNGLGENFENCESNVPROC glad_glGenFencesNV;
    GLAD_API_CALL PFNGLGENFENCESNVPROC glad_debug_glGenFencesNV;
#define glGenFencesNV glad_debug_glGenFencesNV
    GLAD_API_CALL PFNGLGENFRAGMENTSHADERSATIPROC glad_glGenFragmentShadersATI;
    GLAD_API_CALL PFNGLGENFRAGMENTSHADERSATIPROC glad_debug_glGenFragmentShadersATI;
#define glGenFragmentShadersATI glad_debug_glGenFragmentShadersATI
    GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
    GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_debug_glGenFramebuffers;

/// <summary>
///   generate framebuffer object names
///   <para>
///     glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the
///     names form a contiguous set of integers; however, it is guaranteed that none of the returned
///     names was in use immediately before the call to glGenFramebuffers. Framebuffer object names
///     returned by a call to glGenFramebuffers are not returned by subsequent calls, unless they
///     are first deleted with glDeleteFramebuffers. The names returned in ids are marked as used,
///     for the purposes of glGenFramebuffers only, but they acquire state and type only when they
///     are first bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of framebuffer object names to generate.</param>
/// <param name='ids'>Specifies an array in which the generated framebuffer object names are
/// stored.</param>
#define glGenFramebuffers glad_debug_glGenFramebuffers
    GLAD_API_CALL PFNGLGENFRAMEBUFFERSEXTPROC glad_glGenFramebuffersEXT;
    GLAD_API_CALL PFNGLGENFRAMEBUFFERSEXTPROC glad_debug_glGenFramebuffersEXT;
#define glGenFramebuffersEXT glad_debug_glGenFramebuffersEXT
    GLAD_API_CALL PFNGLGENNAMESAMDPROC glad_glGenNamesAMD;
    GLAD_API_CALL PFNGLGENNAMESAMDPROC glad_debug_glGenNamesAMD;
#define glGenNamesAMD glad_debug_glGenNamesAMD
    GLAD_API_CALL PFNGLGENOCCLUSIONQUERIESNVPROC glad_glGenOcclusionQueriesNV;
    GLAD_API_CALL PFNGLGENOCCLUSIONQUERIESNVPROC glad_debug_glGenOcclusionQueriesNV;
#define glGenOcclusionQueriesNV glad_debug_glGenOcclusionQueriesNV
    GLAD_API_CALL PFNGLGENPATHSNVPROC glad_glGenPathsNV;
    GLAD_API_CALL PFNGLGENPATHSNVPROC glad_debug_glGenPathsNV;
#define glGenPathsNV glad_debug_glGenPathsNV
    GLAD_API_CALL PFNGLGENPERFMONITORSAMDPROC glad_glGenPerfMonitorsAMD;
    GLAD_API_CALL PFNGLGENPERFMONITORSAMDPROC glad_debug_glGenPerfMonitorsAMD;
#define glGenPerfMonitorsAMD glad_debug_glGenPerfMonitorsAMD
    GLAD_API_CALL PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;
    GLAD_API_CALL PFNGLGENPROGRAMPIPELINESPROC glad_debug_glGenProgramPipelines;

/// <summary>
///   reserve program pipeline object names
///   <para>
///     glGenProgramPipelines returns n previously unused program pipeline object names in
///     pipelines. These names are marked as used, for the purposes of glGenProgramPipelines only,
///     but they acquire program pipeline state only when they are first bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of program pipeline object names to reserve.</param>
/// <param name='pipelines'>Specifies an array of into which the reserved names will be
/// written.</param>
#define glGenProgramPipelines glad_debug_glGenProgramPipelines
    GLAD_API_CALL PFNGLGENPROGRAMSARBPROC glad_glGenProgramsARB;
    GLAD_API_CALL PFNGLGENPROGRAMSARBPROC glad_debug_glGenProgramsARB;
#define glGenProgramsARB glad_debug_glGenProgramsARB
    GLAD_API_CALL PFNGLGENPROGRAMSNVPROC glad_glGenProgramsNV;
    GLAD_API_CALL PFNGLGENPROGRAMSNVPROC glad_debug_glGenProgramsNV;
#define glGenProgramsNV glad_debug_glGenProgramsNV
    GLAD_API_CALL PFNGLGENQUERIESPROC glad_glGenQueries;
    GLAD_API_CALL PFNGLGENQUERIESPROC glad_debug_glGenQueries;

/// <summary>
///   generate query object names
///   <para>
///     glGenQueries returns n query object names in ids. There is no guarantee that the names form
///     a contiguous set of integers; however, it is guaranteed that none of the returned names was
///     in use immediately before the call to glGenQueries. Query object names returned by a call to
///     glGenQueries are not returned by subsequent calls, unless they are first deleted with
///     glDeleteQueries. No query objects are associated with the returned query object names until
///     they are first used by calling glBeginQuery.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of query object names to be generated.</param>
/// <param name='ids'>Specifies an array in which the generated query object names are
/// stored.</param>
#define glGenQueries glad_debug_glGenQueries
    GLAD_API_CALL PFNGLGENQUERIESARBPROC glad_glGenQueriesARB;
    GLAD_API_CALL PFNGLGENQUERIESARBPROC glad_debug_glGenQueriesARB;
#define glGenQueriesARB glad_debug_glGenQueriesARB
    GLAD_API_CALL PFNGLGENQUERYRESOURCETAGNVPROC glad_glGenQueryResourceTagNV;
    GLAD_API_CALL PFNGLGENQUERYRESOURCETAGNVPROC glad_debug_glGenQueryResourceTagNV;
#define glGenQueryResourceTagNV glad_debug_glGenQueryResourceTagNV
    GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
    GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_debug_glGenRenderbuffers;

/// <summary>
///   generate renderbuffer object names
///   <para>
///     glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no
///     guarantee that the names form a contiguous set of integers; however, it is guaranteed that
///     none of the returned names was in use immediately before the call to glGenRenderbuffers.
///     Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by
///     subsequent calls, unless they are first deleted with glDeleteRenderbuffers. The names
///     returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only,
///     but they acquire state and type only when they are first bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of renderbuffer object names to generate.</param>
/// <param name='renderbuffers'>Specifies an array in which the generated renderbuffer object names
/// are stored.</param>
#define glGenRenderbuffers glad_debug_glGenRenderbuffers
    GLAD_API_CALL PFNGLGENRENDERBUFFERSEXTPROC glad_glGenRenderbuffersEXT;
    GLAD_API_CALL PFNGLGENRENDERBUFFERSEXTPROC glad_debug_glGenRenderbuffersEXT;
#define glGenRenderbuffersEXT glad_debug_glGenRenderbuffersEXT
    GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_glGenSamplers;
    GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_debug_glGenSamplers;

/// <summary>
///   generate sampler object names
///   <para>
///     glGenSamplers returns n sampler object names in samplers. There is no guarantee that the
///     names form a contiguous set of integers; however, it is guaranteed that none of the returned
///     names was in use immediately before the call to glGenSamplers. Sampler object names returned
///     by a call to glGenSamplers are not returned by subsequent calls, unless they are first
///     deleted with glDeleteSamplers. The names returned in samplers are marked as used, for the
///     purposes of glGenSamplers only, but they acquire state and type only when they are first
///     bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of sampler object names to generate.</param>
/// <param name='samplers'>Specifies an array in which the generated sampler object names are
/// stored.</param>
#define glGenSamplers glad_debug_glGenSamplers
    GLAD_API_CALL PFNGLGENSEMAPHORESEXTPROC glad_glGenSemaphoresEXT;
    GLAD_API_CALL PFNGLGENSEMAPHORESEXTPROC glad_debug_glGenSemaphoresEXT;
#define glGenSemaphoresEXT glad_debug_glGenSemaphoresEXT
    GLAD_API_CALL PFNGLGENSYMBOLSEXTPROC glad_glGenSymbolsEXT;
    GLAD_API_CALL PFNGLGENSYMBOLSEXTPROC glad_debug_glGenSymbolsEXT;
#define glGenSymbolsEXT glad_debug_glGenSymbolsEXT
    GLAD_API_CALL PFNGLGENTEXTURESPROC glad_glGenTextures;
    GLAD_API_CALL PFNGLGENTEXTURESPROC glad_debug_glGenTextures;

/// <summary>
///   generate texture names
///   <para>
///     glGenTextures returns n texture names in textures. There is no guarantee that the names form
///     a contiguous set of integers; however, it is guaranteed that none of the returned names was
///     in use immediately before the call to glGenTextures. The generated textures have no
///     dimensionality; they assume the dimensionality of the texture target to which they are first
///     bound (see glBindTexture ). Texture names returned by a call to glGenTextures are not
///     returned by subsequent calls, unless they are first deleted with glDeleteTextures.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of texture names to be generated.</param>
/// <param name='textures'>Specifies an array in which the generated texture names are
/// stored.</param>
#define glGenTextures glad_debug_glGenTextures
    GLAD_API_CALL PFNGLGENTEXTURESEXTPROC glad_glGenTexturesEXT;
    GLAD_API_CALL PFNGLGENTEXTURESEXTPROC glad_debug_glGenTexturesEXT;
#define glGenTexturesEXT glad_debug_glGenTexturesEXT
    GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
    GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_debug_glGenTransformFeedbacks;

/// <summary>
///   reserve transform feedback object names
///   <para>
///     glGenTransformFeedbacks returns n previously unused transform feedback object names in ids.
///     These names are marked as used, for the purposes of glGenTransformFeedbacks only, but they
///     acquire transform feedback state only when they are first bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of transform feedback object names to reserve.</param>
/// <param name='ids'>Specifies an array of into which the reserved names will be written.</param>
#define glGenTransformFeedbacks glad_debug_glGenTransformFeedbacks
    GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_glGenTransformFeedbacksNV;
    GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_debug_glGenTransformFeedbacksNV;
#define glGenTransformFeedbacksNV glad_debug_glGenTransformFeedbacksNV
    GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
    GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_debug_glGenVertexArrays;

/// <summary>
///   generate vertex array object names
///   <para>
///     glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that
///     the names form a contiguous set of integers; however, it is guaranteed that none of the
///     returned names was in use immediately before the call to glGenVertexArrays. Vertex array
///     object names returned by a call to glGenVertexArrays are not returned by subsequent calls,
///     unless they are first deleted with glDeleteVertexArrays. The names returned in arrays are
///     marked as used, for the purposes of glGenVertexArrays only, but they acquire state and type
///     only when they are first bound.
///   </para>
/// </summary>
/// <param name='n'>Specifies the number of vertex array object names to generate.</param>
/// <param name='arrays'>Specifies an array in which the generated vertex array object names are
/// stored.</param>
#define glGenVertexArrays glad_debug_glGenVertexArrays
    GLAD_API_CALL PFNGLGENVERTEXARRAYSAPPLEPROC glad_glGenVertexArraysAPPLE;
    GLAD_API_CALL PFNGLGENVERTEXARRAYSAPPLEPROC glad_debug_glGenVertexArraysAPPLE;
#define glGenVertexArraysAPPLE glad_debug_glGenVertexArraysAPPLE
    GLAD_API_CALL PFNGLGENVERTEXSHADERSEXTPROC glad_glGenVertexShadersEXT;
    GLAD_API_CALL PFNGLGENVERTEXSHADERSEXTPROC glad_debug_glGenVertexShadersEXT;
#define glGenVertexShadersEXT glad_debug_glGenVertexShadersEXT
    GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
    GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_debug_glGenerateMipmap;

/// <summary>
///   generate mipmaps for a specified texture object
///   <para>
///     glGenerateMipmap and glGenerateTextureMipmap generates mipmaps for the specified texture
///     object. For glGenerateMipmap , the texture object is that bound to to target. For
///     glGenerateTextureMipmap , texture is the name of the texture object. For cube map and cube
///     map array textures, the texture object must be cube complete or cube array complete
///     respectively. Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$
///     with images derived from the $level_{base}$ image, regardless of their previous contents.
///     All other mimap images, including the $level_{base}+1$ image, are left unchanged by this
///     computation. The internal formats of the derived mipmap images all match those of the
///     $level_{base}$ image. The contents of the derived images are computed by repeated, filtered
///     reduction of the $level_{base} + 1$ image. For one- and two-dimensional array and cube map
///     array textures, each layer is filtered independently.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
#define glGenerateMipmap glad_debug_glGenerateMipmap
    GLAD_API_CALL PFNGLGENERATEMIPMAPEXTPROC glad_glGenerateMipmapEXT;
    GLAD_API_CALL PFNGLGENERATEMIPMAPEXTPROC glad_debug_glGenerateMipmapEXT;
#define glGenerateMipmapEXT glad_debug_glGenerateMipmapEXT
    GLAD_API_CALL PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_glGenerateMultiTexMipmapEXT;
    GLAD_API_CALL PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_debug_glGenerateMultiTexMipmapEXT;
#define glGenerateMultiTexMipmapEXT glad_debug_glGenerateMultiTexMipmapEXT
    GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;
    GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPPROC glad_debug_glGenerateTextureMipmap;
#define glGenerateTextureMipmap glad_debug_glGenerateTextureMipmap
    GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_glGenerateTextureMipmapEXT;
    GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_debug_glGenerateTextureMipmapEXT;
#define glGenerateTextureMipmapEXT glad_debug_glGenerateTextureMipmapEXT
    GLAD_API_CALL PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;
    GLAD_API_CALL PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC
        glad_debug_glGetActiveAtomicCounterBufferiv;

/// <summary>
///   retrieve information about the set of active atomic counter buffers for a program
///   <para>
///     glGetActiveAtomicCounterBufferiv retrieves information about the set of active atomic
///     counter buffers for a program object. program is the name of a program object for which the
///     command glLinkProgram has been issued in the past. It is not necessary for program to have
///     been linked successfully. The link may have failed because the number of active atomic
///     counters exceeded the limits. bufferIndex specifies the index of an active atomic counter
///     buffer and must be in the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS minus
///     one. The value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the number of
///     active atomic counter buffer and can be queried with glGetProgram. If no error occurs, the
///     parameter(s) specified by pname are returned in params. If an error is generated, the
///     contents of params are not modified. If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING , then the
///     index of the counter buffer binding point associated with the active atomic counter buffer
///     bufferIndex for program is returned. If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE , then
///     the implementation-dependent minimum total buffer object size, in baseic machine units,
///     required to hold all active atomic counters in the atomic counter binding point identified
///     by bufferIndex is returned. If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS ,
///     then the number of active atomic counters for the atomic counter buffer identified by
///     bufferIndex is returned. If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES
///     , then a list of the active atomic counter indices for the atomic counter buffer identified
///     by bufferIndex is returned. The number of elements that will be written into params is the
///     value of GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex. If pname is
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER ,
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER ,
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER ,
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER ,
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER ,
///     GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER then a boolean value indicating
///     whether the atomic counter buffer identified by bufferIndex is referenced by the vertex,
///     tessellation control, tessellation evaluation, geometry, fragment or compute processing
///     stages of program , respectively, is returned.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object from which to retrieve information.</param>
/// <param name='bufferIndex'>Specifies index of an active atomic counter buffer.</param>
/// <param name='pname'>Specifies which parameter of the atomic counter buffer to retrieve.</param>
/// <param name='params'>Specifies the address of a variable into which to write the retrieved
/// information.</param>
#define glGetActiveAtomicCounterBufferiv glad_debug_glGetActiveAtomicCounterBufferiv
    GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
    GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_debug_glGetActiveAttrib;

/// <summary>
///   Returns information about an active attribute variable for the specified program object
///   <para>
///     glGetActiveAttrib returns information about an active attribute variable in the program
///     object specified by program. The number of active attributes can be obtained by calling
///     glGetProgram with the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first
///     active attribute variable. Permissible values for index range from zero to the number of
///     active attribute variables minus one. A vertex shader may use either built-in attribute
///     variables, user-defined attribute variables, or both. Built-in attribute variables have a
///     prefix of "gl_" and reference conventional OpenGL vertex attribtes (e.g., gl_Vertex ,
///     gl_Normal , etc., see the OpenGL Shading Language specification for a complete list.)
///     User-defined attribute variables have arbitrary names and obtain their values through
///     numbered generic vertex attributes. An attribute variable (either built-in or user-defined)
///     is considered active if it is determined during the link operation that it may be accessed
///     during program execution. Therefore, program should have previously been the target of a
///     call to glLinkProgram , but it is not necessary for it to have been linked successfully. The
///     size of the character buffer required to store the longest attribute variable name in
///     program can be obtained by calling glGetProgram with the value
///     GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value should be used to allocate a buffer of sufficient
///     size to store the returned attribute name. The size of this character buffer is passed in
///     bufSize , and a pointer to this character buffer is passed in name. glGetActiveAttrib
///     returns the name of the attribute variable indicated by index , storing it in the character
///     buffer specified by name. The string returned will be null terminated. The actual number of
///     characters written into this buffer is returned in length , and this count does not include
///     the null termination character. If the length of the returned string is not required, a
///     value of NULL can be passed in the length argument. The type argument specifies a pointer to
///     a variable into which the attribute variable's data type will be written. The symbolic
///     constants GL_FLOAT , GL_FLOAT_VEC2 , GL_FLOAT_VEC3 , GL_FLOAT_VEC4 , GL_FLOAT_MAT2 ,
///     GL_FLOAT_MAT3 , GL_FLOAT_MAT4 , GL_FLOAT_MAT2x3 , GL_FLOAT_MAT2x4 , GL_FLOAT_MAT3x2 ,
///     GL_FLOAT_MAT3x4 , GL_FLOAT_MAT4x2 , GL_FLOAT_MAT4x3 , GL_INT , GL_INT_VEC2 , GL_INT_VEC3 ,
///     GL_INT_VEC4 , GL_UNSIGNED_INT , GL_UNSIGNED_INT_VEC2 , GL_UNSIGNED_INT_VEC3 ,
///     GL_UNSIGNED_INT_VEC4 , GL_DOUBLE , GL_DOUBLE_VEC2 , GL_DOUBLE_VEC3 , GL_DOUBLE_VEC4 ,
///     GL_DOUBLE_MAT2 , GL_DOUBLE_MAT3 , GL_DOUBLE_MAT4 , GL_DOUBLE_MAT2x3 , GL_DOUBLE_MAT2x4 ,
///     GL_DOUBLE_MAT3x2 , GL_DOUBLE_MAT3x4 , GL_DOUBLE_MAT4x2 , or GL_DOUBLE_MAT4x3 may be
///     returned. The size argument will return the size of the attribute, in units of the type
///     returned in type. The list of active attribute variables may include both built-in attribute
///     variables (which begin with the prefix "gl_") as well as user-defined attribute variable
///     names. This function will return as much information as it can about the specified active
///     attribute variable. If no information is available, length will be 0, and name will be an
///     empty string. This situation could occur if this function is called after a link operation
///     that failed. If an error occurs, the return values length , size , type , and name will be
///     unmodified.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='index'>Specifies the index of the attribute variable to be queried.</param>
/// <param name='bufSize'>Specifies the maximum number of characters OpenGL is allowed to write in
/// the character buffer indicated by</param> <param name='length'>Returns the number of characters
/// actually written by OpenGL in the string indicated by</param> <param name='size'>Returns the
/// size of the attribute variable.</param> <param name='type'>Returns the data type of the
/// attribute variable.</param> <param name='name'>Returns a null terminated string containing the
/// name of the attribute variable.</param>
#define glGetActiveAttrib glad_debug_glGetActiveAttrib
    GLAD_API_CALL PFNGLGETACTIVEATTRIBARBPROC glad_glGetActiveAttribARB;
    GLAD_API_CALL PFNGLGETACTIVEATTRIBARBPROC glad_debug_glGetActiveAttribARB;
#define glGetActiveAttribARB glad_debug_glGetActiveAttribARB
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_debug_glGetActiveSubroutineName;

/// <summary>
///   query the name of an active shader subroutine
///   <para>
///     glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the
///     program object given in program. index specifies the index of the shader subroutine uniform
///     within the shader stage given by stage , and must between zero and the value of
///     GL_ACTIVE_SUBROUTINES minus one for the shader stage. The name of the selected subroutine is
///     returned as a null-terminated string in name. The actual number of characters written into
///     name , not including the null-terminator, is is returned in length. If length is NULL , no
///     length is returned. The maximum number of characters that may be written into name ,
///     including the null-terminator, is given in bufsize.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of the program containing the subroutine.</param>
/// <param name='shadertype'>Specifies the shader stage from which to query the subroutine
/// name.</param> <param name='index'>Specifies the index of the shader subroutine uniform.</param>
/// <param name='bufsize'>Specifies the size of the buffer whose address is given in</param>
/// <param name='length'>Specifies the address of a variable which is to receive the length of the
/// shader subroutine uniform name.</param> <param name='name'>Specifies the address of an array
/// into which the name of the shader subroutine uniform will be written.</param>
#define glGetActiveSubroutineName glad_debug_glGetActiveSubroutineName
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC
        glad_debug_glGetActiveSubroutineUniformName;

/// <summary>
///   query the name of an active shader subroutine uniform
///   <para>
///     glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform.
///     program contains the name of the program containing the uniform. shadertype specifies the
///     stage for which which the uniform location, given by index , is valid. index must be between
///     zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage. The
///     uniform name is returned as a null-terminated string in name. The actual number of
///     characters written into name , excluding the null terminator is returned in length. If
///     length is NULL , no length is returned. The maximum number of characters that may be written
///     into name , including the null terminator, is specified by bufsize. The length of the
///     longest subroutine uniform name in program and shadertype is given by the value of
///     GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH , which can be queried with glGetProgramStage.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of the program containing the subroutine.</param>
/// <param name='shadertype'>Specifies the shader stage from which to query for the subroutine
/// parameter.</param> <param name='index'>Specifies the index of the shader subroutine
/// uniform.</param> <param name='bufsize'>Specifies the size of the buffer whose address is given
/// in</param> <param name='length'>Specifies the address of a variable into which is written the
/// number of characters copied into</param> <param name='name'>Specifies the address of a buffer
/// that will receive the name of the specified shader subroutine uniform.</param>
#define glGetActiveSubroutineUniformName glad_debug_glGetActiveSubroutineUniformName
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
    GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_debug_glGetActiveSubroutineUniformiv;
#define glGetActiveSubroutineUniformiv glad_debug_glGetActiveSubroutineUniformiv
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_debug_glGetActiveUniform;

/// <summary>
///   Returns information about an active uniform variable for the specified program object
///   <para>
///     glGetActiveUniform returns information about an active uniform variable in the program
///     object specified by program. The number of active uniform variables can be obtained by
///     calling glGetProgram with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the
///     first active uniform variable. Permissible values for index range from zero to the number of
///     active uniform variables minus one. Shaders may use either built-in uniform variables,
///     user-defined uniform variables, or both. Built-in uniform variables have a prefix of "gl_"
///     and reference existing OpenGL state or values derived from such state (e.g.,
///     gl_DepthRangeParameters , see the OpenGL Shading Language specification for a complete
///     list.) User-defined uniform variables have arbitrary names and obtain their values from the
///     application through calls to glUniform. A uniform variable (either built-in or user-defined)
///     is considered active if it is determined during the link operation that it may be accessed
///     during program execution. Therefore, program should have previously been the target of a
///     call to glLinkProgram , but it is not necessary for it to have been linked successfully. The
///     size of the character buffer required to store the longest uniform variable name in program
///     can be obtained by calling glGetProgram with the value GL_ACTIVE_UNIFORM_MAX_LENGTH. This
///     value should be used to allocate a buffer of sufficient size to store the returned uniform
///     variable name. The size of this character buffer is passed in bufSize , and a pointer to
///     this character buffer is passed in name. glGetActiveUniform returns the name of the uniform
///     variable indicated by index , storing it in the character buffer specified by name. The
///     string returned will be null terminated. The actual number of characters written into this
///     buffer is returned in length , and this count does not include the null termination
///     character. If the length of the returned string is not required, a value of NULL can be
///     passed in the length argument. The type argument will return a pointer to the uniform
///     variable's data type. The symbolic constants returned for uniform types are shown in the
///     table below. If one or more elements of an array are active, the name of the array is
///     returned in name , the type is returned in type , and the size parameter returns the highest
///     array element index used, plus one, as determined by the compiler and/or linker. Only one
///     active uniform variable will be reported for a uniform array. Uniform variables that are
///     declared as structures or arrays of structures will not be returned directly by this
///     function. Instead, each of these uniform variables will be reduced to its fundamental
///     components containing the "." and "[]" operators such that each of the names is valid as an
///     argument to glGetUniformLocation. Each of these reduced uniform variables is counted as one
///     active uniform variable and is assigned an index. A valid name cannot be a structure, an
///     array of structures, or a subcomponent of a vector or matrix. The size of the uniform
///     variable will be returned in size. Uniform variables other than arrays will have a size
///     of 1. Structures and arrays of structures will be reduced as described earlier, such that
///     each of the names returned will be a data type in the earlier list. If this reduction
///     results in an array, the size returned will be as described for uniform arrays; otherwise,
///     the size returned will be 1. The list of active uniform variables may include both built-in
///     uniform variables (which begin with the prefix "gl_") as well as user-defined uniform
///     variable names. This function will return as much information as it can about the specified
///     active uniform variable. If no information is available, length will be 0, and name will be
///     an empty string. This situation could occur if this function is called after a link
///     operation that failed. If an error occurs, the return values length , size , type , and name
///     will be unmodified.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='index'>Specifies the index of the uniform variable to be queried.</param>
/// <param name='bufSize'>Specifies the maximum number of characters OpenGL is allowed to write in
/// the character buffer indicated by</param> <param name='length'>Returns the number of characters
/// actually written by OpenGL in the string indicated by</param> <param name='size'>Returns the
/// size of the uniform variable.</param> <param name='type'>Returns the data type of the uniform
/// variable.</param> <param name='name'>Returns a null terminated string containing the name of the
/// uniform variable.</param>
#define glGetActiveUniform glad_debug_glGetActiveUniform
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMARBPROC glad_glGetActiveUniformARB;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMARBPROC glad_debug_glGetActiveUniformARB;
#define glGetActiveUniformARB glad_debug_glGetActiveUniformARB
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_debug_glGetActiveUniformBlockName;

/// <summary>
///   retrieve the name of an active uniform block
///   <para>
///     glGetActiveUniformBlockName retrieves the name of the active uniform block at
///     uniformBlockIndex within program. program must be the name of a program object for which the
///     command glLinkProgram must have been called in the past, although it is not required that
///     glLinkProgram must have succeeded. The link could have failed because the number of active
///     uniforms exceeded the limit. uniformBlockIndex is an active uniform block index of program ,
///     and must be less than the value of GL_ACTIVE_UNIFORM_BLOCKS. Upon success, the name of the
///     uniform block identified by unifomBlockIndex is returned into uniformBlockName. The name is
///     nul-terminated. The actual number of characters written into uniformBlockName , excluding
///     the nul terminator, is returned in length. If length is NULL , no length is returned.
///     bufSize contains the maximum number of characters (including the nul terminator) that will
///     be written into uniformBlockName. If an error occurs, nothing will be written to
///     uniformBlockName or length.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of a program containing the uniform block.</param>
/// <param name='uniformBlockIndex'>Specifies the index of the uniform block within</param>
/// <param name='bufSize'>Specifies the size of the buffer addressed by</param>
/// <param name='length'>Specifies the address of a variable to receive the number of characters
/// that were written to</param> <param name='uniformBlockName'>Specifies the address an array of
/// characters to receive the name of the uniform block at</param>
#define glGetActiveUniformBlockName glad_debug_glGetActiveUniformBlockName
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_debug_glGetActiveUniformBlockiv;
#define glGetActiveUniformBlockiv glad_debug_glGetActiveUniformBlockiv
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_debug_glGetActiveUniformName;

/// <summary>
///   query the name of an active uniform
///   <para>
///     glGetActiveUniformName returns the name of the active uniform at uniformIndex within
///     program. If uniformName is not NULL , up to bufSize characters (including a nul-terminator)
///     will be written into the array whose address is specified by uniformName. If length is not
///     NULL , the number of characters that were (or would have been) written into uniformName (not
///     including the nul-terminator) will be placed in the variable whose address is specified in
///     length. If length is NULL , no length is returned. The length of the longest uniform name in
///     program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH , which can be queried with
///     glGetProgram. If glGetActiveUniformName is not successful, nothing is written to length or
///     uniformName. program must be the name of a program for which the command glLinkProgram has
///     been issued in the past. It is not necessary for program to have been linked successfully.
///     The link could have failed because the number of active uniforms exceeded the limit.
///     uniformIndex must be an active uniform index of the program program , in the range zero to
///     the value of GL_ACTIVE_UNIFORMS minus one. The value of GL_ACTIVE_UNIFORMS can be queried
///     with glGetProgram.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program containing the active uniform index</param>
/// <param name='uniformIndex'>Specifies the index of the active uniform whose name to
/// query.</param> <param name='bufSize'>Specifies the size of the buffer, in units of</param>
/// <param name='length'>Specifies the address of a variable that will receive the number of
/// characters that were or would have been written to the buffer addressed by</param> <param
/// name='uniformName'>Specifies the address of a buffer into which the GL will place the name of
/// the active uniform at</param>
#define glGetActiveUniformName glad_debug_glGetActiveUniformName
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
    GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_debug_glGetActiveUniformsiv;

/// <summary>
///   Returns information about several active uniform variables for the specified program object
///   <para>
///     glGetActiveUniformsiv queries the value of the parameter named pname for each of the
///     uniforms within program whose indices are specified in the array of uniformCount unsigned
///     integers uniformIndices. Upon success, the value of the parameter for each uniform is
///     written into the corresponding entry in the array whose address is given in params. If an
///     error is generated, nothing is written into params. If pname is GL_UNIFORM_TYPE , then an
///     array identifying the types of uniforms specified by the corresponding array of
///     uniformIndices is returned. The returned types can be any of the values from the following
///     table: If pname is GL_UNIFORM_SIZE , then an array identifying the size of the uniforms
///     specified by the corresponding array of uniformIndices is returned. The sizes returned are
///     in units of the type returned by a query of GL_UNIFORM_TYPE. For active uniforms that are
///     arrays, the size is the number of active elements in the array; for all other uniforms, the
///     size is one. If pname is GL_UNIFORM_NAME_LENGTH , then an array identifying the length,
///     including the terminating null character, of the uniform name strings specified by the
///     corresponding array of uniformIndices is returned. If pname is GL_UNIFORM_BLOCK_INDEX , then
///     an array identifying the the uniform block index of each of the uniforms specified by the
///     corresponding array of uniformIndices is returned. The uniform block index of a uniform
///     associated with the default uniform block is -1. If pname is GL_UNIFORM_OFFSET , then an
///     array of uniform buffer offsets is returned. For uniforms in a named uniform block, the
///     returned value will be its offset, in basic machine units, relative to the beginning of the
///     uniform block in the buffer object data store. For atomic counter uniforms, the returned
///     value will be its offset relative to the beginning of its active atomic counter buffer. For
///     all other uniforms, -1 will be returned. If pname is GL_UNIFORM_ARRAY_STRIDE , then an array
///     identifying the stride between elements of each of the uniforms specified by the
///     corresponding array of uniformIndices is returned. For uniforms in named uniform blocks and
///     for uniforms declared as atomic counters, the stride is the difference, in basic machine
///     units, of consecutive elements in an array, or zero for uniforms not declared as an array.
///     For all other uniforms, a stride of -1 will be returned. If pname is
///     GL_UNIFORM_MATRIX_STRIDE , then an array identifying the stride between columns of a
///     column-major matrix or rows of a row-major matrix, in basic machine units, of each of the
///     uniforms specified by the corresponding array of uniformIndices is returned. The matrix
///     stride of a uniform associated with the default uniform block is -1. Note that this
///     information only makes sense for uniforms that are matrices. For uniforms that are not
///     matrices, but are declared in a named uniform block, a matrix stride of zero is returned. If
///     pname is GL_UNIFORM_IS_ROW_MAJOR , then an array identifying whether each of the uniforms
///     specified by the corresponding array of uniformIndices is a row-major matrix or not is
///     returned. A value of one indicates a row-major matrix, and a value of zero indicates a
///     column-major matrix, a matrix in the default uniform block, or a non-matrix. If pname is
///     GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX , then an array identifying the active atomic counter
///     buffer index of each of the uniforms specified by the corresponding array of uniformIndices
///     is returned. For uniforms other than atomic counters, the returned buffer index is -1. The
///     returned indices may be passed to glGetActiveAtomicCounterBufferiv to query the properties
///     of the associated buffer, and not necessarily the binding point specified in the uniform
///     declaration.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='uniformCount'>Specifies both the number of elements in the array of indices</param>
/// <param name='uniformIndices'>Specifies the address of an array of</param>
/// <param name='pname'>Specifies the property of each uniform in</param>
/// <param name='params'>Specifies the address of an array of</param>
#define glGetActiveUniformsiv glad_debug_glGetActiveUniformsiv
    GLAD_API_CALL PFNGLGETACTIVEVARYINGNVPROC glad_glGetActiveVaryingNV;
    GLAD_API_CALL PFNGLGETACTIVEVARYINGNVPROC glad_debug_glGetActiveVaryingNV;
#define glGetActiveVaryingNV glad_debug_glGetActiveVaryingNV
    GLAD_API_CALL PFNGLGETARRAYOBJECTFVATIPROC glad_glGetArrayObjectfvATI;
    GLAD_API_CALL PFNGLGETARRAYOBJECTFVATIPROC glad_debug_glGetArrayObjectfvATI;
#define glGetArrayObjectfvATI glad_debug_glGetArrayObjectfvATI
    GLAD_API_CALL PFNGLGETARRAYOBJECTIVATIPROC glad_glGetArrayObjectivATI;
    GLAD_API_CALL PFNGLGETARRAYOBJECTIVATIPROC glad_debug_glGetArrayObjectivATI;
#define glGetArrayObjectivATI glad_debug_glGetArrayObjectivATI
    GLAD_API_CALL PFNGLGETATTACHEDOBJECTSARBPROC glad_glGetAttachedObjectsARB;
    GLAD_API_CALL PFNGLGETATTACHEDOBJECTSARBPROC glad_debug_glGetAttachedObjectsARB;
#define glGetAttachedObjectsARB glad_debug_glGetAttachedObjectsARB
    GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
    GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_debug_glGetAttachedShaders;

/// <summary>
///   Returns the handles of the shader objects attached to a program object
///   <para>
///     glGetAttachedShaders returns the names of the shader objects attached to program. The names
///     of shader objects that are attached to program will be returned in shaders. The actual
///     number of shader names written into shaders is returned in count. If no shader objects are
///     attached to program , count is set to 0. The maximum number of shader names that may be
///     returned in shaders is specified by maxCount. If the number of names actually returned is
///     not required (for instance, if it has just been obtained by calling glGetProgram ), a value
///     of NULL may be passed for count. If no shader objects are attached to program , a value of 0
///     will be returned in count. The actual number of attached shaders can be obtained by calling
///     glGetProgram with the value GL_ATTACHED_SHADERS.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='maxCount'>Specifies the size of the array for storing the returned object
/// names.</param> <param name='count'>Returns the number of names actually returned in</param>
/// <param name='shaders'>Specifies an array that is used to return the names of attached shader
/// objects.</param>
#define glGetAttachedShaders glad_debug_glGetAttachedShaders
    GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
    GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_debug_glGetAttribLocation;

/// <summary>
///   Returns the location of an attribute variable
///   <para>
///     glGetAttribLocation queries the previously linked program object specified by program for
///     the attribute variable specified by name and returns the index of the generic vertex
///     attribute that is bound to that attribute variable. If name is a matrix attribute variable,
///     the index of the first column of the matrix is returned. If the named attribute variable is
///     not an active attribute in the specified program object or if name starts with the reserved
///     prefix "gl_", a value of -1 is returned. The association between an attribute variable name
///     and a generic attribute index can be specified at any time by calling glBindAttribLocation.
///     Attribute bindings do not go into effect until glLinkProgram is called. After a program
///     object has been linked successfully, the index values for attribute variables remain fixed
///     until the next link command occurs. The attribute values can only be queried after a link if
///     the link was successful. glGetAttribLocation returns the binding that actually went into
///     effect the last time glLinkProgram was called for the specified program object. Attribute
///     bindings that have been specified since the last link operation are not returned by
///     glGetAttribLocation.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='name'>Points to a null terminated string containing the name of the attribute
/// variable whose location is to be queried.</param>
#define glGetAttribLocation glad_debug_glGetAttribLocation
    GLAD_API_CALL PFNGLGETATTRIBLOCATIONARBPROC glad_glGetAttribLocationARB;
    GLAD_API_CALL PFNGLGETATTRIBLOCATIONARBPROC glad_debug_glGetAttribLocationARB;
#define glGetAttribLocationARB glad_debug_glGetAttribLocationARB
    GLAD_API_CALL PFNGLGETBOOLEANINDEXEDVEXTPROC glad_glGetBooleanIndexedvEXT;
    GLAD_API_CALL PFNGLGETBOOLEANINDEXEDVEXTPROC glad_debug_glGetBooleanIndexedvEXT;
#define glGetBooleanIndexedvEXT glad_debug_glGetBooleanIndexedvEXT
    GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
    GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_debug_glGetBooleani_v;
#define glGetBooleani_v glad_debug_glGetBooleani_v
    GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
    GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_debug_glGetBooleanv;

/// <summary>
///   These commands return values for simple state variables in GL. pname is a symbolic constant indicating the state variable to be returned, and data is a pointer to an array of the indicated type in which to place the returned data.
///   <para>
///     Type conversion is performed if data has a different type than the state variable value being requested. If glGetBooleanv is called, a floating-point (or integer) value is converted to GL_FALSE if and only if it is 0.0 (or 0). Otherwise, it is converted to GL_TRUE. If glGetIntegerv is called, boolean values are returned as GL_TRUE or GL_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0
///     to the most negative representable integer value. If glGetFloatv or glGetDoublev is called, boolean values are returned as GL_TRUE or GL_FALSE, and integer values are converted to floating-point values.
///     The following symbolic constants are accepted by pname:
///         GL_ACTIVE_TEXTURE
///           data returns a single value indicating the active multitexture unit. The initial value is GL_TEXTURE0. See glActiveTexture.
///         GL_ALIASED_LINE_WIDTH_RANGE
///           data returns a pair of values indicating the range of widths supported for aliased lines. See glLineWidth.
///         GL_ARRAY_BUFFER_BINDING
///           data returns a single value, the name of the buffer object currently bound to the target GL_ARRAY_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.
///         GL_BLEND
///           data returns a single boolean value indicating whether blending is enabled. The initial value is GL_FALSE. See glBlendFunc.
///         GL_BLEND_COLOR
///           data returns four values, the red, green, blue, and alpha values which are the components of the blend color. See glBlendColor.
///         GL_BLEND_DST_ALPHA
///           data returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is GL_ZERO. See glBlendFunc and glBlendFuncSeparate.
///         GL_BLEND_DST_RGB
///           data returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is GL_ZERO. See glBlendFunc and glBlendFuncSeparate.
///         GL_BLEND_EQUATION_RGB
///           data returns one value, a symbolic constant indicating whether the RGB blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN or GL_MAX. See glBlendEquationSeparate.
///         GL_BLEND_EQUATION_ALPHA
///           data returns one value, a symbolic constant indicating whether the Alpha blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN or GL_MAX. See glBlendEquationSeparate.
///         GL_BLEND_SRC_ALPHA
///           data returns one value, the symbolic constant identifying the alpha source blend function. The initial value is GL_ONE. See glBlendFunc and glBlendFuncSeparate.
///         GL_BLEND_SRC_RGB
///           data returns one value, the symbolic constant identifying the RGB source blend function. The initial value is GL_ONE. See glBlendFunc and glBlendFuncSeparate.
///         GL_COLOR_CLEAR_VALUE
///           data returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0
///           returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearColor.
///         GL_COLOR_LOGIC_OP
///           data returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is GL_FALSE. See glLogicOp.
///         GL_COLOR_WRITEMASK
///           data returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is (GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE). See glColorMask.
///         GL_COMPRESSED_TEXTURE_FORMATS
///           data returns a list of symbolic constants of length GL_NUM_COMPRESSED_TEXTURE_FORMATS indicating which compressed texture formats are available. See glCompressedTexImage2D.
///         GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a compute shader.
///         GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum total number of active shader storage blocks that may be accessed by all active shaders.
///         GL_MAX_COMPUTE_UNIFORM_BLOCKS
///           data returns one value, the maximum number of uniform blocks per compute shader. The value must be at least 14. See glUniformBlockBinding.
///         GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS
///           data returns one value, the maximum supported texture image units that can be used to access texture maps from the compute shader. The value may be at least 16. See glActiveTexture.
///         GL_MAX_COMPUTE_UNIFORM_COMPONENTS
///           data returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a compute shader. The value must be at least 1024. See glUniform.
///         GL_MAX_COMPUTE_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to compute shaders.
///         GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS
///           data returns a single value, the maximum number of atomic counter buffers that may be accessed by a compute shader.
///         GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS
///           data returns one value, the number of words for compute shader uniform variables in all uniform blocks (including default). The value must be at least 1. See glUniform.
///         GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS
///           data returns one value, the number of invocations in a single local work group (i.e., the product of the three dimensions) that may be dispatched to a compute shader.
///         GL_MAX_COMPUTE_WORK_GROUP_COUNT
///           Accepted by the indexed versions of glGet. data the maximum number of work groups that may be dispatched to a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.
///         GL_MAX_COMPUTE_WORK_GROUP_SIZE
///           Accepted by the indexed versions of glGet. data the maximum size of a work groups that may be used during compilation of a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.
///         GL_DISPATCH_INDIRECT_BUFFER_BINDING
///           data returns a single value, the name of the buffer object currently bound to the target GL_DISPATCH_INDIRECT_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.
///         GL_MAX_DEBUG_GROUP_STACK_DEPTH
///           data returns a single value, the maximum depth of the debug message group stack.
///         GL_DEBUG_GROUP_STACK_DEPTH
///           data returns a single value, the current depth of the debug message group stack.
///         GL_CONTEXT_FLAGS
///           data returns one value, the flags with which the context was created (such as debugging functionality).
///         GL_CULL_FACE
///           data returns a single boolean value indicating whether polygon culling is enabled. The initial value is GL_BACK. See glCullFace.
///         GL_CURRENT_PROGRAM
///           data returns one value, the name of the program object that is currently active, or 0 if no program object is active. See glUseProgram.
///         GL_DEPTH_CLEAR_VALUE
///           data returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0
///           returns the most negative representable integer value. The initial value is 1. See glClearDepth.
///         GL_DEPTH_FUNC
///           data returns one value, the symbolic constant that indicates the depth comparison function. The initial value is GL_LESS. See glDepthFunc.
///         GL_DEPTH_RANGE
///           data returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0
///           returns the most negative representable integer value. The initial value is (0, 1). See glDepthRange.
///         GL_DEPTH_TEST
///           data returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is GL_FALSE. See glDepthFunc and glDepthRange.
///         GL_DEPTH_WRITEMASK
///           data returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is GL_TRUE. See glDepthMask.
///         GL_DITHER
///           data returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is GL_TRUE.
///         GL_DOUBLEBUFFER
///           data returns a single boolean value indicating whether double buffering is supported.
///         GL_DRAW_BUFFER
///           data returns one value, a symbolic constant indicating which buffers are being drawn to. See glDrawBuffer. The initial value is GL_BACK if there are back buffers, otherwise it is GL_FRONT.
///         GL_DRAW_BUFFER i
///           data returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See glDrawBuffers. The initial value of GL_DRAW_BUFFER0 is GL_BACK if there are back buffers, otherwise it is GL_FRONT. The initial values of draw buffers for all other output colors is GL_NONE.
///         GL_DRAW_FRAMEBUFFER_BINDING
///           data returns one value, the name of the framebuffer object currently bound to the GL_DRAW_FRAMEBUFFER target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See glBindFramebuffer.
///         GL_READ_FRAMEBUFFER_BINDING
///           data returns one value, the name of the framebuffer object currently bound to the GL_READ_FRAMEBUFFER target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See glBindFramebuffer.
///         GL_ELEMENT_ARRAY_BUFFER_BINDING
///           data returns a single value, the name of the buffer object currently bound to the target GL_ELEMENT_ARRAY_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.
///         GL_FRAGMENT_SHADER_DERIVATIVE_HINT
///           data returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is GL_DONT_CARE. See glHint.
///         GL_IMPLEMENTATION_COLOR_READ_FORMAT
///           data returns a single GLenum value indicating the implementation's preferred pixel data format. See glReadPixels.
///         GL_IMPLEMENTATION_COLOR_READ_TYPE
///           data returns a single GLenum value indicating the implementation's preferred pixel data type. See glReadPixels.
///         GL_LINE_SMOOTH
///           data returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is GL_FALSE. See glLineWidth.
///         GL_LINE_SMOOTH_HINT
///           data returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is GL_DONT_CARE. See glHint.
///         GL_LINE_WIDTH
///           data returns one value, the line width as specified with glLineWidth. The initial value is 1.
///         GL_LAYER_PROVOKING_VERTEX
///           data returns one value, the implementation dependent specifc vertex of a primitive that is used to select the rendering layer. If the value returned is equivalent to GL_PROVOKING_VERTEX, then the vertex selection follows the convention specified by glProvokingVertex. If the value returned is equivalent to GL_FIRST_VERTEX_CONVENTION, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to GL_LAST_VERTEX_CONVENTION, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to GL_UNDEFINED_VERTEX, then the selection is not guaranteed to be taken from any specific vertex in the primitive.
///         GL_LOGIC_OP_MODE
///           data returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is GL_COPY. See glLogicOp.
///         GL_MAJOR_VERSION
///           data returns one value, the major version number of the OpenGL API supported by the current context.
///         GL_MAX_3D_TEXTURE_SIZE
///           data returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use GL_PROXY_TEXTURE_3D to determine if a texture is too large. See glTexImage3D.
///         GL_MAX_ARRAY_TEXTURE_LAYERS
///           data returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See glTexImage2D.
///         GL_MAX_CLIP_DISTANCES
///           data returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.
///         GL_MAX_COLOR_TEXTURE_SAMPLES
///           data returns one value, the maximum number of samples in a color multisample texture.
///         GL_MAX_COMBINED_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to all active shaders.
///         GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
///           data returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See glUniform.
///         GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
///           data returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See glUniform.
///         GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
///           data returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See glActiveTexture.
///         GL_MAX_COMBINED_UNIFORM_BLOCKS
///           data returns one value, the maximum number of uniform blocks per program. The value must be at least 70. See glUniformBlockBinding.
///         GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
///           data returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See glUniform.
///         GL_MAX_CUBE_MAP_TEXTURE_SIZE
///           data returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use GL_PROXY_TEXTURE_CUBE_MAP to determine if a texture is too large. See glTexImage2D.
///         GL_MAX_DEPTH_TEXTURE_SAMPLES
///           data returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
///         GL_MAX_DRAW_BUFFERS
///           data returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See glDrawBuffers.
///         GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
///           data returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See glBlendFunc and glBlendFuncSeparate.
///         GL_MAX_ELEMENTS_INDICES
///           data returns one value, the recommended maximum number of vertex array indices. See glDrawRangeElements.
///         GL_MAX_ELEMENTS_VERTICES
///           data returns one value, the recommended maximum number of vertex array vertices. See glDrawRangeElements.
///         GL_MAX_FRAGMENT_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to fragment shaders.
///         GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a fragment shader.
///         GL_MAX_FRAGMENT_INPUT_COMPONENTS
///           data returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
///         GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
///           data returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See glUniform.
///         GL_MAX_FRAGMENT_UNIFORM_VECTORS
///           data returns one value, the maximum number of individual 4-vectors of floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value is equal to the value of GL_MAX_FRAGMENT_UNIFORM_COMPONENTS divided by 4 and must be at least 256. See glUniform.
///         GL_MAX_FRAGMENT_UNIFORM_BLOCKS
///           data returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See glUniformBlockBinding.
///         GL_MAX_FRAMEBUFFER_WIDTH
///           data returns one value, the maximum width for a framebuffer that has no attachments, which must be at least 16384. See glFramebufferParameter.
///         GL_MAX_FRAMEBUFFER_HEIGHT
///           data returns one value, the maximum height for a framebuffer that has no attachments, which must be at least 16384. See glFramebufferParameter.
///         GL_MAX_FRAMEBUFFER_LAYERS
///           data returns one value, the maximum number of layers for a framebuffer that has no attachments, which must be at least 2048. See glFramebufferParameter.
///         GL_MAX_FRAMEBUFFER_SAMPLES
///           data returns one value, the maximum samples in a framebuffer that has no attachments, which must be at least 4. See glFramebufferParameter.
///         GL_MAX_GEOMETRY_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to geometry shaders.
///         GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a geometry shader.
///         GL_MAX_GEOMETRY_INPUT_COMPONENTS
///           data returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.
///         GL_MAX_GEOMETRY_OUTPUT_COMPONENTS
///           data returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.
///         GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
///           data returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See glActiveTexture.
///         GL_MAX_GEOMETRY_UNIFORM_BLOCKS
///           data returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See glUniformBlockBinding.
///         GL_MAX_GEOMETRY_UNIFORM_COMPONENTS
///           data returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See glUniform.
///         GL_MAX_INTEGER_SAMPLES
///           data returns one value, the maximum number of samples supported in integer format multisample buffers.
///         GL_MIN_MAP_BUFFER_ALIGNMENT
///           data returns one value, the minimum alignment in basic machine units of pointers returned fromglMapBuffer and glMapBufferRange. This value must be a power of two and must be at least 64.
///         GL_MAX_LABEL_LENGTH
///           data returns one value, the maximum length of a label that may be assigned to an object. See glObjectLabel and glObjectPtrLabel.
///         GL_MAX_PROGRAM_TEXEL_OFFSET
///           data returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.
///         GL_MIN_PROGRAM_TEXEL_OFFSET
///           data returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.
///         GL_MAX_RECTANGLE_TEXTURE_SIZE
///           data returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use GL_PROXY_TEXTURE_RECTANGLE to determine if a texture is too large. See glTexImage2D.
///         GL_MAX_RENDERBUFFER_SIZE
///           data returns one value. The value indicates the maximum supported size for renderbuffers. See glFramebufferRenderbuffer.
///         GL_MAX_SAMPLE_MASK_WORDS
///           data returns one value, the maximum number of sample mask words.
///         GL_MAX_SERVER_WAIT_TIMEOUT
///           data returns one value, the maximum glWaitSync timeout interval.
///         GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS
///           data returns one value, the maximum number of shader storage buffer binding points on the context, which must be at least 8.
///         GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to tessellation control shaders.
///         GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to tessellation evaluation shaders.
///         GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation control shader.
///         GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation evaluation shader.
///         GL_MAX_TEXTURE_BUFFER_SIZE
///           data returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.
///         GL_MAX_TEXTURE_IMAGE_UNITS
///           data returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See glActiveTexture.
///         GL_MAX_TEXTURE_LOD_BIAS
///           data returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.
///         GL_MAX_TEXTURE_SIZE
///           data returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as GL_PROXY_TEXTURE_1D or GL_PROXY_TEXTURE_2D to determine if a texture is too large. See glTexImage1D and glTexImage2D.
///         GL_MAX_UNIFORM_BUFFER_BINDINGS
///           data returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.
///         GL_MAX_UNIFORM_BLOCK_SIZE
///           data returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.
///         GL_MAX_UNIFORM_LOCATIONS
///           data returns one value, the maximum number of explicitly assignable uniform locations, which must be at least 1024.
///         GL_MAX_VARYING_COMPONENTS
///           data returns one value, the number components for varying variables, which must be at least 60.
///         GL_MAX_VARYING_VECTORS
///           data returns one value, the number 4-vectors for varying variables, which is equal to the value of GL_MAX_VARYING_COMPONENTS and must be at least 15.
///         GL_MAX_VARYING_FLOATS
///           data returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.
///         GL_MAX_VERTEX_ATOMIC_COUNTERS
///           data returns a single value, the maximum number of atomic counters available to vertex shaders.
///         GL_MAX_VERTEX_ATTRIBS
///           data returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See glVertexAttrib.
///         GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS
///           data returns one value, the maximum number of active shader storage blocks that may be accessed by a vertex shader.
///         GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
///           data returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See glActiveTexture.
///         GL_MAX_VERTEX_UNIFORM_COMPONENTS
///           data returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See glUniform.
///         GL_MAX_VERTEX_UNIFORM_VECTORS
///           data returns one value, the maximum number of 4-vectors that may be held in uniform variable storage for the vertex shader. The value of GL_MAX_VERTEX_UNIFORM_VECTORS is equal to the value of GL_MAX_VERTEX_UNIFORM_COMPONENTS and must be at least 256.
///         GL_MAX_VERTEX_OUTPUT_COMPONENTS
///           data returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.
///         GL_MAX_VERTEX_UNIFORM_BLOCKS
///           data returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See glUniformBlockBinding.
///         GL_MAX_VIEWPORT_DIMS
///           data returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See glViewport.
///         GL_MAX_VIEWPORTS
///           data returns one value, the maximum number of simultaneous viewports that are supported. The value must be at least 16. See glViewportIndexed.
///         GL_MINOR_VERSION
///           data returns one value, the minor version number of the OpenGL API supported by the current context.
///         GL_NUM_COMPRESSED_TEXTURE_FORMATS
///           data returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See glCompressedTexImage2D.
///         GL_NUM_EXTENSIONS
///           data returns one value, the number of extensions supported by the GL implementation for the current context. See glGetString.
///         GL_NUM_PROGRAM_BINARY_FORMATS
///           data returns one value, the number of program binary formats supported by the implementation.
///         GL_NUM_SHADER_BINARY_FORMATS
///           data returns one value, the number of binary shader formats supported by the implementation. If this value is greater than zero, then the implementation supports loading binary shaders. If it is zero, then the loading of binary shaders by the implementation is not supported.
///         GL_PACK_ALIGNMENT
///           data returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See glPixelStore.
///         GL_PACK_IMAGE_HEIGHT
///           data returns one value, the image height used for writing pixel data to memory. The initial value is 0. See glPixelStore.
///         GL_PACK_LSB_FIRST
///           data returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.
///         GL_PACK_ROW_LENGTH
///           data returns one value, the row length used for writing pixel data to memory. The initial value is 0. See glPixelStore.
///         GL_PACK_SKIP_IMAGES
///           data returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.
///         GL_PACK_SKIP_PIXELS
///           data returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.
///         GL_PACK_SKIP_ROWS
///           data returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.
///         GL_PACK_SWAP_BYTES
///           data returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is GL_FALSE. See glPixelStore.
///         GL_PIXEL_PACK_BUFFER_BINDING
///           data returns a single value, the name of the buffer object currently bound to the target GL_PIXEL_PACK_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.
///         GL_PIXEL_UNPACK_BUFFER_BINDING
///           data returns a single value, the name of the buffer object currently bound to the target GL_PIXEL_UNPACK_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.
///         GL_POINT_FADE_THRESHOLD_SIZE
///           data returns one value, the point size threshold for determining the point size. See glPointParameter.
///         GL_PRIMITIVE_RESTART_INDEX
///           data returns one value, the current primitive restart index. The initial value is 0. See glPrimitiveRestartIndex.
///         GL_PROGRAM_BINARY_FORMATS
///           data an array of GL_NUM_PROGRAM_BINARY_FORMATS values, indicating the proram binary formats supported by the implementation.
///         GL_PROGRAM_PIPELINE_BINDING
///           data a single value, the name of the currently bound program pipeline object, or zero if no program pipeline object is bound. See glBindProgramPipeline.
///         GL_PROGRAM_POINT_SIZE
///           data returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified by glPointSize. The initial value is GL_FALSE.
///         GL_PROVOKING_VERTEX
///           data returns one value, the currently selected provoking vertex convention. The initial value is GL_LAST_VERTEX_CONVENTION. See glProvokingVertex.
///         GL_POINT_SIZE
///           data returns one value, the point size as specified by glPointSize. The initial value is 1.
///         GL_POINT_SIZE_GRANULARITY
///           data returns one value, the size difference between adjacent supported sizes for antialiased points. See glPointSize.
///         GL_POINT_SIZE_RANGE
///           data returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See glPointSize.
///         GL_POLYGON_OFFSET_FACTOR
///           data returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.
///         GL_POLYGON_OFFSET_UNITS
///           data returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.
///         GL_POLYGON_OFFSET_FILL
///           data returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is GL_FALSE. See glPolygonOffset.
///         GL_POLYGON_OFFSET_LINE
///           data returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is GL_FALSE. See glPolygonOffset.
///         GL_POLYGON_OFFSET_POINT
///           data returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is GL_FALSE. See glPolygonOffset.
///         GL_POLYGON_SMOOTH
///           data returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is GL_FALSE. See glPolygonMode.
///         GL_POLYGON_SMOOTH_HINT
///           data returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is GL_DONT_CARE. See glHint.
///         GL_READ_BUFFER
///           data returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is GL_BACK if there is a back buffer, otherwise it is GL_FRONT. See glReadPixels.
///         GL_RENDERBUFFER_BINDING
///           data returns a single value, the name of the renderbuffer object currently bound to the target GL_RENDERBUFFER. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See glBindRenderbuffer.
///         GL_SAMPLE_BUFFERS
///           data returns a single integer value indicating the number of sample buffers associated with the framebuffer. See glSampleCoverage.
///         GL_SAMPLE_COVERAGE_VALUE
///           data returns a single positive floating-point value indicating the current sample coverage value. See glSampleCoverage.
///         GL_SAMPLE_COVERAGE_INVERT
///           data returns a single boolean value indicating if the temporary coverage value should be inverted. See glSampleCoverage.
///         GL_SAMPLE_MASK_VALUE
///           When used with indexed variants of glGet (such as glGetIntegeri_v), data returns one value, the 32-bit sub-word of the sample mask that specifies which samples to update. The index must be less than GL_MAX_SAMPLE_MASK_WORDS. The initial value is all 1's. See glSampleMaski.
///         GL_SAMPLER_BINDING
///           data returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See glBindSampler.
///         GL_SAMPLES
///           data returns a single integer value indicating the coverage mask size. See glSampleCoverage.
///         GL_SCISSOR_BOX
///           data returns four values: the x
///           and y
///           window coordinates of the scissor box, followed by its width and height. Initially the x
///           and y
///           window coordinates are both 0 and the width and height are set to the size of the window. See glScissor.
///         GL_SCISSOR_TEST
///           data returns a single boolean value indicating whether scissoring is enabled. The initial value is GL_FALSE. See glScissor.
///         GL_SHADER_COMPILER
///           data returns a single boolean value indicating whether an online shader compiler is present in the implementation. All desktop OpenGL implementations must support online shader compilations, and therefore the value of GL_SHADER_COMPILER will always be GL_TRUE.
///         GL_SHADER_STORAGE_BUFFER_BINDING
///           When used with non-indexed variants of glGet (such as glGetIntegerv), data returns a single value, the name of the buffer object currently bound to the target GL_SHADER_STORAGE_BUFFER. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of glGet (such as glGetIntegeri_v), data returns a single value, the name of the buffer object bound to the indexed shader storage buffer binding points. The initial value is 0 for all targets. See glBindBuffer, glBindBufferBase, and glBindBufferRange.
///         GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
///           data returns a single value, the minimum required alignment for shader storage buffer sizes and offset. The initial value is 1. See glShaderStorateBlockBinding.
///         GL_SHADER_STORAGE_BUFFER_START
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the start offset of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See glBindBufferRange.
///         GL_SHADER_STORAGE_BUFFER_SIZE
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the size of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See glBindBufferRange.
///         GL_SMOOTH_LINE_WIDTH_RANGE
///           data returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See glLineWidth.
///         GL_SMOOTH_LINE_WIDTH_GRANULARITY
///           data returns a single value indicating the level of quantization applied to smooth line width parameters.
///         GL_STENCIL_BACK_FAIL
///           data returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is GL_KEEP. See glStencilOpSeparate.
///         GL_STENCIL_BACK_FUNC
///           data returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is GL_ALWAYS. See glStencilFuncSeparate.
///         GL_STENCIL_BACK_PASS_DEPTH_FAIL
///           data returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is GL_KEEP. See glStencilOpSeparate.
///         GL_STENCIL_BACK_PASS_DEPTH_PASS
///           data returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is GL_KEEP. See glStencilOpSeparate.
///         GL_STENCIL_BACK_REF
///           data returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See glStencilFuncSeparate.
///         GL_STENCIL_BACK_VALUE_MASK
///           data returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See glStencilFuncSeparate.
///         GL_STENCIL_BACK_WRITEMASK
///           data returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See glStencilMaskSeparate.
///         GL_STENCIL_CLEAR_VALUE
///           data returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See glClearStencil.
///         GL_STENCIL_FAIL
///           data returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is GL_KEEP. See glStencilOp. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilOpSeparate.
///         GL_STENCIL_FUNC
///           data returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is GL_ALWAYS. See glStencilFunc. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilFuncSeparate.
///         GL_STENCIL_PASS_DEPTH_FAIL
///           data returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is GL_KEEP. See glStencilOp. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilOpSeparate.
///         GL_STENCIL_PASS_DEPTH_PASS
///           data returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is GL_KEEP. See glStencilOp. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilOpSeparate.
///         GL_STENCIL_REF
///           data returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See glStencilFunc. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilFuncSeparate.
///         GL_STENCIL_TEST
///           data returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is GL_FALSE. See glStencilFunc and glStencilOp.
///         GL_STENCIL_VALUE_MASK
///           data returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See glStencilFunc. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilFuncSeparate.
///         GL_STENCIL_WRITEMASK
///           data returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See glStencilMask. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See glStencilMaskSeparate.
///         GL_STEREO
///           data returns a single boolean value indicating whether stereo buffers (left and right) are supported.
///         GL_SUBPIXEL_BITS
///           data returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.
///         GL_TEXTURE_BINDING_1D
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_1D. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_1D_ARRAY
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_1D_ARRAY. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_2D
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_2D_ARRAY
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D_ARRAY. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_2D_MULTISAMPLE
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D_MULTISAMPLE. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D_MULTISAMPLE_ARRAY. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_3D
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_3D. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_BUFFER
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_BUFFER. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_CUBE_MAP
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_CUBE_MAP. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_BINDING_RECTANGLE
///           data returns a single value, the name of the texture currently bound to the target GL_TEXTURE_RECTANGLE. The initial value is 0. See glBindTexture.
///         GL_TEXTURE_COMPRESSION_HINT
///           data returns a single value indicating the mode of the texture compression hint. The initial value is GL_DONT_CARE.
///         GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
///           data returns a single value, the minimum required alignment for texture buffer sizes and offset. The initial value is 1. See glUniformBlockBinding.
///         GL_TIMESTAMP
///           data returns a single value, the 64-bit value of the current GL time. See glQueryCounter.
///         GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
///           When used with non-indexed variants of glGet (such as glGetIntegerv), data returns a single value, the name of the buffer object currently bound to the target GL_TRANSFORM_FEEDBACK_BUFFER. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of glGet (such as glGetIntegeri_v), data returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See glBindBuffer, glBindBufferBase, and glBindBufferRange.
///         GL_TRANSFORM_FEEDBACK_BUFFER_START
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See glBindBufferRange.
///         GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See glBindBufferRange.
///         GL_UNIFORM_BUFFER_BINDING
///           When used with non-indexed variants of glGet (such as glGetIntegerv), data returns a single value, the name of the buffer object currently bound to the target GL_UNIFORM_BUFFER. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of glGet (such as glGetIntegeri_v), data returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See glBindBuffer, glBindBufferBase, and glBindBufferRange.
///         GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
///           data returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See glUniformBlockBinding.
///         GL_UNIFORM_BUFFER_SIZE
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See glBindBufferRange.
///         GL_UNIFORM_BUFFER_START
///           When used with indexed variants of glGet (such as glGetInteger64i_v), data returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See glBindBufferRange.
///         GL_UNPACK_ALIGNMENT
///           data returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See glPixelStore.
///         GL_UNPACK_IMAGE_HEIGHT
///           data returns one value, the image height used for reading pixel data from memory. The initial is 0. See glPixelStore.
///         GL_UNPACK_LSB_FIRST
///           data returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.
///         GL_UNPACK_ROW_LENGTH
///           data returns one value, the row length used for reading pixel data from memory. The initial value is 0. See glPixelStore.
///         GL_UNPACK_SKIP_IMAGES
///           data returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.
///         GL_UNPACK_SKIP_PIXELS
///           data returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.
///         GL_UNPACK_SKIP_ROWS
///           data returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.
///         GL_UNPACK_SWAP_BYTES
///           data returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is GL_FALSE. See glPixelStore.
///         GL_VERTEX_ARRAY_BINDING
///           data returns a single value, the name of the vertex array object currently bound to the context. If no vertex array object is bound to the context, 0 is returned. The initial value is 0. See glBindVertexArray.
///         GL_VERTEX_BINDING_DIVISOR
///           Accepted by the indexed forms. data returns a single integer value representing the instance step divisor of the first element in the bound buffer's data store for vertex attribute bound to index.
///         GL_VERTEX_BINDING_OFFSET
///           Accepted by the indexed forms. data returns a single integer value representing the byte offset of the first element in the bound buffer's data store for vertex attribute bound to index.
///         GL_VERTEX_BINDING_STRIDE
///           Accepted by the indexed forms. data returns a single integer value representing the byte offset between the start of each element in the bound buffer's data store for vertex attribute bound to index.
///         GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET
///           data returns a single integer value containing the maximum offset that may be added to a vertex binding offset.
///         GL_MAX_VERTEX_ATTRIB_BINDINGS
///           data returns a single integer value containing the maximum number of vertex buffers that may be bound.
///         GL_VIEWPORT
///           When used with non-indexed variants of glGet (such as glGetIntegerv), data returns four values: the x and y
///             window coordinates of the viewport, followed by its width and height. Initially the x and y
///             window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See glViewport.
///           When used with indexed variants of glGet (such as glGetIntegeri_v), data returns four values: the x and y
///             window coordinates of the indexed viewport, followed by its width and height. Initially the x and y
///             window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See glViewportIndexedf.
///         GL_VIEWPORT_BOUNDS_RANGE
///           data returns two values, the minimum and maximum viewport bounds range. The minimum range should be at least [-32768, 32767].
///         GL_VIEWPORT_INDEX_PROVOKING_VERTEX
///           data returns one value, the implementation dependent specifc vertex of a primitive that is used to select the viewport index. If the value returned is equivalent to GL_PROVOKING_VERTEX, then the vertex selection follows the convention specified by glProvokingVertex. If the value returned is equivalent to GL_FIRST_VERTEX_CONVENTION, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to GL_LAST_VERTEX_CONVENTION, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to GL_UNDEFINED_VERTEX, then the selection is not guaranteed to be taken from any specific vertex in the primitive.
///         GL_VIEWPORT_SUBPIXEL_BITS
///           data returns a single value, the number of bits of sub-pixel precision which the GL uses to interpret the floating point viewport bounds. The minimum value is 0.
///         GL_MAX_ELEMENT_INDEX
///           data returns a single value, the maximum index that may be specified during the transfer of generic vertex attributes to the GL.
///   </para>
/// </summary>
#define glGetBooleanv glad_debug_glGetBooleanv
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_debug_glGetBufferParameteri64v;
#define glGetBufferParameteri64v glad_debug_glGetBufferParameteri64v
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_debug_glGetBufferParameteriv;
#define glGetBufferParameteriv glad_debug_glGetBufferParameteriv
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVARBPROC glad_glGetBufferParameterivARB;
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVARBPROC glad_debug_glGetBufferParameterivARB;
#define glGetBufferParameterivARB glad_debug_glGetBufferParameterivARB
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_glGetBufferParameterui64vNV;
    GLAD_API_CALL PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_debug_glGetBufferParameterui64vNV;
#define glGetBufferParameterui64vNV glad_debug_glGetBufferParameterui64vNV
    GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
    GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_debug_glGetBufferPointerv;

/// <summary>
///   return the pointer to a mapped buffer object's data store
///   <para>
///     glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname , which
///     must be GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL
///     pointer is returned if the buffer object's data store is not currently mapped; or if the
///     requesting context did not map the buffer object's data store, and the implementation is
///     unable to support mappings on multiple clients.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='pname'>Specifies the name of the pointer to be returned. Must be</param>
/// <param name='params'>Returns the pointer value specified by</param>
#define glGetBufferPointerv glad_debug_glGetBufferPointerv
    GLAD_API_CALL PFNGLGETBUFFERPOINTERVARBPROC glad_glGetBufferPointervARB;
    GLAD_API_CALL PFNGLGETBUFFERPOINTERVARBPROC glad_debug_glGetBufferPointervARB;
#define glGetBufferPointervARB glad_debug_glGetBufferPointervARB
    GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
    GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_debug_glGetBufferSubData;

/// <summary>
///   returns a subset of a buffer object's data store
///   <para>
///     glGetBufferSubData and glGetNamedBufferSubData return some or all of the data contents of
///     the data store of the specified buffer object. Data starting at byte offset offset and
///     extending for size bytes is copied from the buffer object's data store to the memory pointed
///     to by data. An error is thrown if the buffer object is currently mapped, or if offset and
///     size together define a range beyond the bounds of the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='offset'>Specifies the offset into the buffer object's data store from which data
/// will be returned, measured in bytes.</param> <param name='size'>Specifies the size in bytes of
/// the data store region being returned.</param> <param name='data'>Specifies a pointer to the
/// location where buffer object data is returned.</param>
#define glGetBufferSubData glad_debug_glGetBufferSubData
    GLAD_API_CALL PFNGLGETBUFFERSUBDATAARBPROC glad_glGetBufferSubDataARB;
    GLAD_API_CALL PFNGLGETBUFFERSUBDATAARBPROC glad_debug_glGetBufferSubDataARB;
#define glGetBufferSubDataARB glad_debug_glGetBufferSubDataARB
    GLAD_API_CALL PFNGLGETCLIPPLANEFOESPROC glad_glGetClipPlanefOES;
    GLAD_API_CALL PFNGLGETCLIPPLANEFOESPROC glad_debug_glGetClipPlanefOES;
#define glGetClipPlanefOES glad_debug_glGetClipPlanefOES
    GLAD_API_CALL PFNGLGETCLIPPLANEXOESPROC glad_glGetClipPlanexOES;
    GLAD_API_CALL PFNGLGETCLIPPLANEXOESPROC glad_debug_glGetClipPlanexOES;
#define glGetClipPlanexOES glad_debug_glGetClipPlanexOES
    GLAD_API_CALL PFNGLGETCOLORTABLEEXTPROC glad_glGetColorTableEXT;
    GLAD_API_CALL PFNGLGETCOLORTABLEEXTPROC glad_debug_glGetColorTableEXT;
#define glGetColorTableEXT glad_debug_glGetColorTableEXT
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_glGetColorTableParameterfvEXT;
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_debug_glGetColorTableParameterfvEXT;
#define glGetColorTableParameterfvEXT glad_debug_glGetColorTableParameterfvEXT
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVSGIPROC glad_glGetColorTableParameterfvSGI;
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVSGIPROC glad_debug_glGetColorTableParameterfvSGI;
#define glGetColorTableParameterfvSGI glad_debug_glGetColorTableParameterfvSGI
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_glGetColorTableParameterivEXT;
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_debug_glGetColorTableParameterivEXT;
#define glGetColorTableParameterivEXT glad_debug_glGetColorTableParameterivEXT
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVSGIPROC glad_glGetColorTableParameterivSGI;
    GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVSGIPROC glad_debug_glGetColorTableParameterivSGI;
#define glGetColorTableParameterivSGI glad_debug_glGetColorTableParameterivSGI
    GLAD_API_CALL PFNGLGETCOLORTABLESGIPROC glad_glGetColorTableSGI;
    GLAD_API_CALL PFNGLGETCOLORTABLESGIPROC glad_debug_glGetColorTableSGI;
#define glGetColorTableSGI glad_debug_glGetColorTableSGI
    GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_glGetCombinerInputParameterfvNV;
    GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_debug_glGetCombinerInputParameterfvNV;
#define glGetCombinerInputParameterfvNV glad_debug_glGetCombinerInputParameterfvNV
    GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_glGetCombinerInputParameterivNV;
    GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_debug_glGetCombinerInputParameterivNV;
#define glGetCombinerInputParameterivNV glad_debug_glGetCombinerInputParameterivNV
    GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC glad_glGetCombinerOutputParameterfvNV;
    GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC
        glad_debug_glGetCombinerOutputParameterfvNV;
#define glGetCombinerOutputParameterfvNV glad_debug_glGetCombinerOutputParameterfvNV
    GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC glad_glGetCombinerOutputParameterivNV;
    GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC
        glad_debug_glGetCombinerOutputParameterivNV;
#define glGetCombinerOutputParameterivNV glad_debug_glGetCombinerOutputParameterivNV
    GLAD_API_CALL PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_glGetCombinerStageParameterfvNV;
    GLAD_API_CALL PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_debug_glGetCombinerStageParameterfvNV;
#define glGetCombinerStageParameterfvNV glad_debug_glGetCombinerStageParameterfvNV
    GLAD_API_CALL PFNGLGETCOMMANDHEADERNVPROC glad_glGetCommandHeaderNV;
    GLAD_API_CALL PFNGLGETCOMMANDHEADERNVPROC glad_debug_glGetCommandHeaderNV;
#define glGetCommandHeaderNV glad_debug_glGetCommandHeaderNV
    GLAD_API_CALL PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_glGetCompressedMultiTexImageEXT;
    GLAD_API_CALL PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_debug_glGetCompressedMultiTexImageEXT;
#define glGetCompressedMultiTexImageEXT glad_debug_glGetCompressedMultiTexImageEXT
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_debug_glGetCompressedTexImage;

/// <summary>
///   return a compressed texture image
///   <para>
///     glGetCompressedTexImage and glGetnCompressedTexImage return the compressed texture image
///     associated with target and lod into pixels. glGetCompressedTextureImage serves the same
///     purpose, but instead of taking a texture target, it takes the ID of the texture object.
///     pixels should be an array of bufSize bytes for glGetnCompresedTexImage and
///     glGetCompressedTextureImage functions, and of GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes in case
///     of glGetCompressedTexImage. If the actual data takes less space than bufSize , the remaining
///     bytes will not be touched. target specifies the texture target, to which the texture the
///     data the function should extract the data from is bound to. lod specifies the
///     level-of-detail number of the desired image. If a non-zero named buffer object is bound to
///     the GL_PIXEL_PACK_BUFFER target (see glBindBuffer ) while a texture image is requested,
///     pixels is treated as a byte offset into the buffer object's data store. To minimize errors,
///     first verify that the texture is compressed by calling glGetTexLevelParameter with argument
///     GL_TEXTURE_COMPRESSED. If the texture is compressed, you can determine the amount of memory
///     required to store the compressed texture by calling glGetTexLevelParameter with argument
///     GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve the internal format of the texture by
///     calling glGetTexLevelParameter with argument GL_TEXTURE_INTERNAL_FORMAT. To store the
///     texture for later use, associate the internal format and size with the retrieved texture
///     image. These data can be used by the respective texture or subtexture loading routine used
///     for loading target textures.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number of the desired image. Level 0 is the
/// base image level. Level $n$ is the $n$-th mipmap reduction image.</param> <param
/// name='bufSize'>Specifies the size of the buffer</param> <param name='pixels'>Returns the
/// compressed texture image.</param>
#define glGetCompressedTexImage glad_debug_glGetCompressedTexImage
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_glGetCompressedTexImageARB;
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_debug_glGetCompressedTexImageARB;
#define glGetCompressedTexImageARB glad_debug_glGetCompressedTexImageARB
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_debug_glGetCompressedTextureImage;
#define glGetCompressedTextureImage glad_debug_glGetCompressedTextureImage
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_glGetCompressedTextureImageEXT;
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_debug_glGetCompressedTextureImageEXT;
#define glGetCompressedTextureImageEXT glad_debug_glGetCompressedTextureImageEXT
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;
    GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_debug_glGetCompressedTextureSubImage;

/// <summary>
///   retrieve a sub-region of a compressed texture image from a compressed texture object
///   <para>
///     glGetCompressedTextureSubImage can be used to obtain a sub-region of a compressed texture
///     image instead of the whole image, as long as the compressed data are arranged into
///     fixed-size blocks of texels. texture is the name of the texture object, and must not be a
///     buffer or multisample texture. The effective target is the value of GL_TEXTURE_TARGET for
///     texture. level and pixels have the same meaning as the corresponding arguments of
///     glCompressedTexSubImage3D. bufSize indicates the size of the buffer to receive the retrieved
///     pixel data. For cube map textures, the behavior is as though glGetCompressedTexImage were
///     called once for each requested face (selected by zoffset and depth , as described below)
///     with target corresponding to the requested texture cube map face as indicated by the table
///     presented below. pixels is offset appropriately for each successive image. xoffset , yoffset
///     and zoffset indicate the position of the subregion to return. width , height and depth
///     indicate the size of the region to return. These arguments have the same meaning as for
///     glCompressedTexSubImage3D , though there are extra restrictions, described in the errors
///     section below. The mapping between the xoffset , yoffset , zoffset , width , height and
///     depth parameters and the faces, layers, and layer-faces for cube map, array, and cube map
///     array textures is the same as for glGetTextureSubImage. The xoffset , yoffset , zoffset
///     offsets and width , height and depth sizes must be multiples of the values of
///     GL_PACK_COMPRESSED_BLOCK_WIDTH , GL_PACK_COMPRESSED_BLOCK_HEIGHT , and
///     GL_PACK_COMPRESSED_BLOCK_DEPTH respectively, unless offset is zero and the corresponding
///     size is the same as the texture size in that dimension. Pixel storage modes are treated as
///     for glGetCompressedTexSubImage. The texel at ( xoffset , yoffset , zoffset ) will be stored
///     at the location indicated by pixels and the current pixel packing parameters.
///   </para>
/// </summary>
/// <param name='texture'>Specifies the name of the source texture object. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level. Level
/// $n$ is the $n$th mipmap reduction image.</param> <param name='xoffset'>Specifies a texel offset
/// in the x direction within the texture array.</param> <param name='yoffset'>Specifies a texel
/// offset in the y direction within the texture array.</param> <param name='zoffset'>Specifies a
/// texel offset in the z direction within the texture array.</param> <param name='width'>Specifies
/// the width of the texture subimage. Must be a multiple of the compressed block's width, unless
/// the</param> <param name='height'>Specifies the height of the texture subimage. Must be a
/// multiple of the compressed block's height, unless the</param> <param name='depth'>Specifies the
/// depth of the texture subimage. Must be a multiple of the compressed block's depth, unless
/// the</param> <param name='bufSize'>Specifies the size of the buffer to receive the retrieved
/// pixel data.</param> <param name='pixels'>Returns the texture subimage. Should be a pointer to an
/// array of the type specified by type.</param>
#define glGetCompressedTextureSubImage glad_debug_glGetCompressedTextureSubImage
    GLAD_API_CALL PFNGLGETCONVOLUTIONFILTEREXTPROC glad_glGetConvolutionFilterEXT;
    GLAD_API_CALL PFNGLGETCONVOLUTIONFILTEREXTPROC glad_debug_glGetConvolutionFilterEXT;
#define glGetConvolutionFilterEXT glad_debug_glGetConvolutionFilterEXT
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_glGetConvolutionParameterfvEXT;
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_debug_glGetConvolutionParameterfvEXT;
#define glGetConvolutionParameterfvEXT glad_debug_glGetConvolutionParameterfvEXT
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_glGetConvolutionParameterivEXT;
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_debug_glGetConvolutionParameterivEXT;
#define glGetConvolutionParameterivEXT glad_debug_glGetConvolutionParameterivEXT
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERXVOESPROC glad_glGetConvolutionParameterxvOES;
    GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERXVOESPROC glad_debug_glGetConvolutionParameterxvOES;
#define glGetConvolutionParameterxvOES glad_debug_glGetConvolutionParameterxvOES
    GLAD_API_CALL PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_glGetCoverageModulationTableNV;
    GLAD_API_CALL PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_debug_glGetCoverageModulationTableNV;
#define glGetCoverageModulationTableNV glad_debug_glGetCoverageModulationTableNV
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGPROC glad_debug_glGetDebugMessageLog;

/// <summary>
///   retrieve messages from the debug message log
///   <para>
///     glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count
///     messages are retrieved from the log. If sources is not NULL then the source of each message
///     is written into up to count elements of the array. If types is not NULL then the type of
///     each message is written into up to count elements of the array. If id is not NULL then the
///     identifier of each message is written into up to count elements of the array. If severities
///     is not NULL then the severity of each message is written into up to count elements of the
///     array. If lengths is not NULL then the length of each message is written into up to count
///     elements of the array. messageLog specifies the address of a character array into which the
///     debug messages will be written. Each message will be concatenated onto the array starting at
///     the first element of messageLog. bufSize specifies the size of the array messageLog. If a
///     message will not fit into the remaining space in messageLog then the function terminates and
///     returns the number of messages written so far, which may be zero. If glGetDebugMessageLog
///     returns zero then no messages are present in the debug log, or there was not enough space in
///     messageLog to retrieve the first message in the queue. If messageLog is NULL then no
///     messages are written and the value of bufSize is ignored.
///   </para>
/// </summary>
/// <param name='count'>The number of debug messages to retrieve from the log.</param>
/// <param name='bufSize'>The size of the buffer whose address is given by</param>
/// <param name='sources'>The address of an array of variables to receive the sources of the
/// retrieved messages.</param> <param name='types'>The address of an array of variables to receive
/// the types of the retrieved messages.</param> <param name='ids'>The address of an array of
/// unsigned integers to receive the ids of the retrieved messages.</param> <param
/// name='severities'>The address of an array of variables to receive the severites of the retrieved
/// messages.</param> <param name='lengths'>The address of an array of variables to receive the
/// lengths of the received messages.</param> <param name='messageLog'>The address of an array of
/// characters that will receive the messages.</param>
#define glGetDebugMessageLog glad_debug_glGetDebugMessageLog
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGAMDPROC glad_glGetDebugMessageLogAMD;
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGAMDPROC glad_debug_glGetDebugMessageLogAMD;
#define glGetDebugMessageLogAMD glad_debug_glGetDebugMessageLogAMD
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGARBPROC glad_glGetDebugMessageLogARB;
    GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGARBPROC glad_debug_glGetDebugMessageLogARB;
#define glGetDebugMessageLogARB glad_debug_glGetDebugMessageLogARB
    GLAD_API_CALL PFNGLGETDETAILTEXFUNCSGISPROC glad_glGetDetailTexFuncSGIS;
    GLAD_API_CALL PFNGLGETDETAILTEXFUNCSGISPROC glad_debug_glGetDetailTexFuncSGIS;
#define glGetDetailTexFuncSGIS glad_debug_glGetDetailTexFuncSGIS
    GLAD_API_CALL PFNGLGETDOUBLEINDEXEDVEXTPROC glad_glGetDoubleIndexedvEXT;
    GLAD_API_CALL PFNGLGETDOUBLEINDEXEDVEXTPROC glad_debug_glGetDoubleIndexedvEXT;
#define glGetDoubleIndexedvEXT glad_debug_glGetDoubleIndexedvEXT
    GLAD_API_CALL PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;
    GLAD_API_CALL PFNGLGETDOUBLEI_VPROC glad_debug_glGetDoublei_v;
#define glGetDoublei_v glad_debug_glGetDoublei_v
    GLAD_API_CALL PFNGLGETDOUBLEI_VEXTPROC glad_glGetDoublei_vEXT;
    GLAD_API_CALL PFNGLGETDOUBLEI_VEXTPROC glad_debug_glGetDoublei_vEXT;
#define glGetDoublei_vEXT glad_debug_glGetDoublei_vEXT
    GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_glGetDoublev;
    GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_debug_glGetDoublev;
#define glGetDoublev glad_debug_glGetDoublev
    GLAD_API_CALL PFNGLGETERRORPROC glad_glGetError;
    GLAD_API_CALL PFNGLGETERRORPROC glad_debug_glGetError;

/// <summary>
///   return error information
///   <para>
///     glGetError returns the value of the error flag. Each detectable error is assigned a numeric
///     code and symbolic name. When an error occurs, the error flag is set to the appropriate error
///     code value. No other errors are recorded until glGetError is called, the error code is
///     returned, and the flag is reset to GL_NO_ERROR. If a call to glGetError returns GL_NO_ERROR
///     , there has been no detectable error since the last call to glGetError , or since the GL was
///     initialized. To allow for distributed implementations, there may be several error flags. If
///     any single error flag has recorded an error, the value of that flag is returned and that
///     flag is reset to GL_NO_ERROR when glGetError is called. If more than one flag has recorded
///     an error, glGetError returns and clears an arbitrary error flag value. Thus, glGetError
///     should always be called in a loop, until it returns GL_NO_ERROR , if all error flags are to
///     be reset. Initially, all error flags are set to GL_NO_ERROR. The following errors are
///     currently defined: No error has been recorded. The value of this symbolic constant is
///     guaranteed to be 0. An unacceptable value is specified for an enumerated argument. The
///     offending command is ignored and has no other side effect than to set the error flag. A
///     numeric argument is out of range. The offending command is ignored and has no other side
///     effect than to set the error flag. The specified operation is not allowed in the current
///     state. The offending command is ignored and has no other side effect than to set the error
///     flag. The framebuffer object is not complete. The offending command is ignored and has no
///     other side effect than to set the error flag. There is not enough memory left to execute the
///     command. The state of the GL is undefined, except for the state of the error flags, after
///     this error is recorded. An attempt has been made to perform an operation that would cause an
///     internal stack to underflow. An attempt has been made to perform an operation that would
///     cause an internal stack to overflow. When an error flag is set, results of a GL operation
///     are undefined only if GL_OUT_OF_MEMORY has occurred. In all other cases, the command
///     generating the error is ignored and has no effect on the GL state or frame buffer contents.
///     If the generating command returns a value, it returns 0. If glGetError itself generates an
///     error, it returns 0.
///   </para>
/// </summary>
#define glGetError glad_debug_glGetError
    GLAD_API_CALL PFNGLGETFENCEIVNVPROC glad_glGetFenceivNV;
    GLAD_API_CALL PFNGLGETFENCEIVNVPROC glad_debug_glGetFenceivNV;
#define glGetFenceivNV glad_debug_glGetFenceivNV
    GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC
        glad_glGetFinalCombinerInputParameterfvNV;
    GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC
        glad_debug_glGetFinalCombinerInputParameterfvNV;
#define glGetFinalCombinerInputParameterfvNV glad_debug_glGetFinalCombinerInputParameterfvNV
    GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC
        glad_glGetFinalCombinerInputParameterivNV;
    GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC
        glad_debug_glGetFinalCombinerInputParameterivNV;
#define glGetFinalCombinerInputParameterivNV glad_debug_glGetFinalCombinerInputParameterivNV
    GLAD_API_CALL PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_glGetFirstPerfQueryIdINTEL;
    GLAD_API_CALL PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_debug_glGetFirstPerfQueryIdINTEL;
#define glGetFirstPerfQueryIdINTEL glad_debug_glGetFirstPerfQueryIdINTEL
    GLAD_API_CALL PFNGLGETFIXEDVOESPROC glad_glGetFixedvOES;
    GLAD_API_CALL PFNGLGETFIXEDVOESPROC glad_debug_glGetFixedvOES;
#define glGetFixedvOES glad_debug_glGetFixedvOES
    GLAD_API_CALL PFNGLGETFLOATINDEXEDVEXTPROC glad_glGetFloatIndexedvEXT;
    GLAD_API_CALL PFNGLGETFLOATINDEXEDVEXTPROC glad_debug_glGetFloatIndexedvEXT;
#define glGetFloatIndexedvEXT glad_debug_glGetFloatIndexedvEXT
    GLAD_API_CALL PFNGLGETFLOATI_VPROC glad_glGetFloati_v;
    GLAD_API_CALL PFNGLGETFLOATI_VPROC glad_debug_glGetFloati_v;
#define glGetFloati_v glad_debug_glGetFloati_v
    GLAD_API_CALL PFNGLGETFLOATI_VEXTPROC glad_glGetFloati_vEXT;
    GLAD_API_CALL PFNGLGETFLOATI_VEXTPROC glad_debug_glGetFloati_vEXT;
#define glGetFloati_vEXT glad_debug_glGetFloati_vEXT
    GLAD_API_CALL PFNGLGETFLOATVPROC glad_glGetFloatv;
    GLAD_API_CALL PFNGLGETFLOATVPROC glad_debug_glGetFloatv;
#define glGetFloatv glad_debug_glGetFloatv
    GLAD_API_CALL PFNGLGETFOGFUNCSGISPROC glad_glGetFogFuncSGIS;
    GLAD_API_CALL PFNGLGETFOGFUNCSGISPROC glad_debug_glGetFogFuncSGIS;
#define glGetFogFuncSGIS glad_debug_glGetFogFuncSGIS
    GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
    GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_debug_glGetFragDataIndex;

/// <summary>
///   query the bindings of color indices to user-defined varying out variables
///   <para>
///     glGetFragDataIndex returns the index of the fragment color to which the variable name was
///     bound when the program object program was last linked. If name is not a varying out variable
///     of program , or if an error occurs, -1 will be returned.
///   </para>
/// </summary>
/// <param name='program'>The name of the program containing varying out variable whose binding to
/// query</param> <param name='name'>The name of the user-defined varying out variable whose index
/// to query</param>
#define glGetFragDataIndex glad_debug_glGetFragDataIndex
    GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
    GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_debug_glGetFragDataLocation;

/// <summary>
///   query the bindings of color numbers to user-defined varying out variables
///   <para>
///     glGetFragDataLocation retrieves the assigned color number binding for the user-defined
///     varying out variable name for program program. program must have previously been linked.
///     name must be a null-terminated string. If name is not the name of an active user-defined
///     varying out fragment shader variable within program , -1 will be returned.
///   </para>
/// </summary>
/// <param name='program'>The name of the program containing varying out variable whose binding to
/// query</param> <param name='name'>The name of the user-defined varying out variable whose binding
/// to query</param>
#define glGetFragDataLocation glad_debug_glGetFragDataLocation
    GLAD_API_CALL PFNGLGETFRAGDATALOCATIONEXTPROC glad_glGetFragDataLocationEXT;
    GLAD_API_CALL PFNGLGETFRAGDATALOCATIONEXTPROC glad_debug_glGetFragDataLocationEXT;
#define glGetFragDataLocationEXT glad_debug_glGetFragDataLocationEXT
    GLAD_API_CALL PFNGLGETFRAGMENTLIGHTFVSGIXPROC glad_glGetFragmentLightfvSGIX;
    GLAD_API_CALL PFNGLGETFRAGMENTLIGHTFVSGIXPROC glad_debug_glGetFragmentLightfvSGIX;
#define glGetFragmentLightfvSGIX glad_debug_glGetFragmentLightfvSGIX
    GLAD_API_CALL PFNGLGETFRAGMENTLIGHTIVSGIXPROC glad_glGetFragmentLightivSGIX;
    GLAD_API_CALL PFNGLGETFRAGMENTLIGHTIVSGIXPROC glad_debug_glGetFragmentLightivSGIX;
#define glGetFragmentLightivSGIX glad_debug_glGetFragmentLightivSGIX
    GLAD_API_CALL PFNGLGETFRAGMENTMATERIALFVSGIXPROC glad_glGetFragmentMaterialfvSGIX;
    GLAD_API_CALL PFNGLGETFRAGMENTMATERIALFVSGIXPROC glad_debug_glGetFragmentMaterialfvSGIX;
#define glGetFragmentMaterialfvSGIX glad_debug_glGetFragmentMaterialfvSGIX
    GLAD_API_CALL PFNGLGETFRAGMENTMATERIALIVSGIXPROC glad_glGetFragmentMaterialivSGIX;
    GLAD_API_CALL PFNGLGETFRAGMENTMATERIALIVSGIXPROC glad_debug_glGetFragmentMaterialivSGIX;
#define glGetFragmentMaterialivSGIX glad_debug_glGetFragmentMaterialivSGIX
    GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC
        glad_glGetFramebufferAttachmentParameteriv;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC
        glad_debug_glGetFramebufferAttachmentParameteriv;

/// <summary>
///   glGetFramebufferAttachmentParameteriv and glGetNamedFramebufferAttachmentParameteriv return
///   parameters of attachments of a specified framebuffer object.
///   <para>
///     For glGetFramebufferAttachmentParameteriv, the framebuffer object is that bound to target,
///     which must be one of GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. GL_FRAMEBUFFER
///     is equivalent to GL_DRAW_FRAMEBUFFER. Buffers of default framebuffers may also be queried if bound to target.
///     For glGetNamedFramebufferAttachmentParameteriv, framebuffer is the name of the framebuffer object.
///     If framebuffer is zero, the default draw framebuffer is queried.
///     If the specified framebuffer is a framebuffer object, attachment must be one of GL_DEPTH_ATTACHMENT,
///     GL_STENCIL_ATTACHMENT GL_DEPTH_STENCIL_ATTACHMENT, or GL_COLOR_ATTACHMENTi, where i is between zero
///     and the value of GL_MAX_COLOR_ATTACHMENTS minus one.
///     If the specified framebuffer is a default framebuffer, target, attachment must be one of GL_FRONT_LEFT,
///     GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_DEPTH or GL_STENCIL, identifying the corresponding buffer.
///     If attachment is GL_DEPTH_STENCIL_ATTACHMENT, the same object must be bound to both the depth and stencil
///     attachment points of the framebuffer object, and information about that object is returned.
///     Upon successful return, if pname is GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then params will contain one
///     of GL_NONE, GL_FRAMEBUFFER_DEFAULT, GL_TEXTURE, or GL_RENDERBUFFER, identifying the type of object which
///     contains the attached image. Other values accepted for pname depend on the type of object, as described below.
///     If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE, then either no framebuffer is bound to target;
///     or a default framebuffer is queried, attachment is GL_DEPTH or GL_STENCIL, and the number of depth or stencil bits,
///     respectively, is zero. In this case querying pname GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME will return zero, and
///     all other queries will generate an error.
/// 
///     If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not GL_NONE, these queries apply to all other framebuffer
///     types:
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE, GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE,
///         GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE
///         or GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, then params will contain the number of bits in the corresponding red,
///         green, blue, alpha, depth, or stencil component of the specified attachment. If the requested component is not
///         present in the attachment, or if no data storage or texture image has been specified for the attachment, then
///         params will contain zero.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, then params will contain the format of components of the
///         specified attachment, one of GL_FLOAT, GL_INT, GL_UNSIGNED_INT, GL_SIGNED_NORMALIZED, or GL_UNSIGNED_NORMALIZED
///         for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized
///         fixed-point components respectively. Only color buffers may have integer components. If no data storage or
///         texture image has been specified for the attachment, then params will contain GL_NONE. This query cannot be
///         performed for a combined depth+stencil attachment, since it does not have a single format.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, then params will contain the encoding of components of
///         the specified attachment, one of GL_LINEAR or GL_SRGB for linear or sRGB-encoded components, respectively.
///         Only color buffer components may be sRGB-encoded; such components are treated as described in the OpenGL
///         Specification. For a default framebuffer, color encoding is determined by the implementation. For framebuffer
///         objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable
///         SRGB formats. If the attachment is not a color attachment, or if no data storage or texture image has been specified
///         for the attachment, then params will contain GL_LINEAR.
///       * If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_RENDERBUFFER, then
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will contain the name of the renderbuffer object which contains the attached image.
///       * If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_TEXTURE, then
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will contain the name of the texture object which contains the attached image.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params will contain the mipmap level of the texture object which contains the attached image.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is the name of a cube map texture object, then params will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise params will contain zero.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_LAYERED, then params will contain GL_TRUE if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, params will contain GL_FALSE.
///       * If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER; the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is the name of a three-dimensional, or a one- or two-dimensional array texture; and the value of GL_FRAMEBUFFER_ATTACHMENT_LAYERED is GL_FALSE, then params will contain the texture layer which contains the attached image. Otherwise params will contain zero.
///   </para>
/// </summary>
#define glGetFramebufferAttachmentParameteriv glad_debug_glGetFramebufferAttachmentParameteriv
    GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC
        glad_glGetFramebufferAttachmentParameterivEXT;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC
        glad_debug_glGetFramebufferAttachmentParameterivEXT;
#define glGetFramebufferAttachmentParameterivEXT glad_debug_glGetFramebufferAttachmentParameterivEXT
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetFramebufferParameterfvAMD;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_debug_glGetFramebufferParameterfvAMD;
#define glGetFramebufferParameterfvAMD glad_debug_glGetFramebufferParameterfvAMD
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_debug_glGetFramebufferParameteriv;
#define glGetFramebufferParameteriv glad_debug_glGetFramebufferParameteriv
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetFramebufferParameterivEXT;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_debug_glGetFramebufferParameterivEXT;
#define glGetFramebufferParameterivEXT glad_debug_glGetFramebufferParameterivEXT
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC glad_glGetFramebufferParameterivMESA;
    GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC glad_debug_glGetFramebufferParameterivMESA;
#define glGetFramebufferParameterivMESA glad_debug_glGetFramebufferParameterivMESA
    GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;
    GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSPROC glad_debug_glGetGraphicsResetStatus;

/// <summary>
///   check if the rendering context has not been lost due to software or hardware issues
///   <para>
///     Certain events can result in a reset of the GL context. Such a reset causes all context
///     state to be lost and requires the application to recreate all objects in the affected
///     context. glGetGraphicsResetStatus can return one of the following constants: Indicates that
///     the GL context has not been in a reset state since the last call. Indicates that a reset has
///     been detected that is attributable to the current GL context. Indicates a reset has been
///     detected that is not attributable to the current GL context. Indicates a detected graphics
///     reset whose cause is unknown. If a reset status other than GL_NO_ERROR is returned and
///     subsequent calls return GL_NO_ERROR , the context reset was encountered and completed. If a
///     reset status is repeatedly returned, the context may be in the process of resetting. Reset
///     notification behavior is determined at context creation time, and may be queried by calling
///     GetIntegerv with the symbolic constant GL_RESET_NOTIFICATION_STRATEGY. If the reset
///     notification behavior is GL_NO_RESET_NOTIFICATION , then the implementation will never
///     deliver notification of reset events, and glGetGraphicsResetStatus will always return
///     GL_NO_ERROR. If the behavior is GL_LOSE_CONTEXT_ON_RESET , a graphics reset will result in
///     the loss of all context state, requiring the recreation of all associated objects. In this
///     case glGetGraphicsResetStatus may return any of the values described above. If a graphics
///     reset notification occurs in a context, a notification must also occur in all other contexts
///     which share objects with that context. After a graphics reset has occurred on a context,
///     subsequent GL commands on that context (or any context which shares with that context) will
///     generate a GL_CONTEXT_LOST error. Such commands will not have side effects (in particular,
///     they will not modify memory passed by pointer for query results), and will not block
///     indefinitely or cause termination of the application. There are two important exceptions to
///     this behavior: glGetError and glGetGraphicsResetStatus behave normally following a graphics
///     reset, so that the application can determine a reset has occurred, and when it is safe to
///     destroy and re-create the context. Any commands which might cause a polling application to
///     block indefinitely will generate a GL_CONTEXT_LOST error, but will also return a value
///     indicating completion to the application. Such commands include: glGetSynciv with pname
///     GL_SYNC_STATUS ignores the other parameters and returns GL_SIGNALED in values.
///     glGetQueryObjectuiv with pname GL_QUERY_RESULT_AVAILABLE ignores the other parameters and
///     returns TRUE in params.
///   </para>
/// </summary>
#define glGetGraphicsResetStatus glad_debug_glGetGraphicsResetStatus
    GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB;
    GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_debug_glGetGraphicsResetStatusARB;
#define glGetGraphicsResetStatusARB glad_debug_glGetGraphicsResetStatusARB
    GLAD_API_CALL PFNGLGETHANDLEARBPROC glad_glGetHandleARB;
    GLAD_API_CALL PFNGLGETHANDLEARBPROC glad_debug_glGetHandleARB;
#define glGetHandleARB glad_debug_glGetHandleARB
    GLAD_API_CALL PFNGLGETHISTOGRAMEXTPROC glad_glGetHistogramEXT;
    GLAD_API_CALL PFNGLGETHISTOGRAMEXTPROC glad_debug_glGetHistogramEXT;
#define glGetHistogramEXT glad_debug_glGetHistogramEXT
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_glGetHistogramParameterfvEXT;
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_debug_glGetHistogramParameterfvEXT;
#define glGetHistogramParameterfvEXT glad_debug_glGetHistogramParameterfvEXT
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_glGetHistogramParameterivEXT;
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_debug_glGetHistogramParameterivEXT;
#define glGetHistogramParameterivEXT glad_debug_glGetHistogramParameterivEXT
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERXVOESPROC glad_glGetHistogramParameterxvOES;
    GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERXVOESPROC glad_debug_glGetHistogramParameterxvOES;
#define glGetHistogramParameterxvOES glad_debug_glGetHistogramParameterxvOES
    GLAD_API_CALL PFNGLGETIMAGEHANDLEARBPROC glad_glGetImageHandleARB;
    GLAD_API_CALL PFNGLGETIMAGEHANDLEARBPROC glad_debug_glGetImageHandleARB;
#define glGetImageHandleARB glad_debug_glGetImageHandleARB
    GLAD_API_CALL PFNGLGETIMAGEHANDLENVPROC glad_glGetImageHandleNV;
    GLAD_API_CALL PFNGLGETIMAGEHANDLENVPROC glad_debug_glGetImageHandleNV;
#define glGetImageHandleNV glad_debug_glGetImageHandleNV
    GLAD_API_CALL PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC glad_glGetImageTransformParameterfvHP;
    GLAD_API_CALL PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC
        glad_debug_glGetImageTransformParameterfvHP;
#define glGetImageTransformParameterfvHP glad_debug_glGetImageTransformParameterfvHP
    GLAD_API_CALL PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC glad_glGetImageTransformParameterivHP;
    GLAD_API_CALL PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC
        glad_debug_glGetImageTransformParameterivHP;
#define glGetImageTransformParameterivHP glad_debug_glGetImageTransformParameterivHP
    GLAD_API_CALL PFNGLGETINFOLOGARBPROC glad_glGetInfoLogARB;
    GLAD_API_CALL PFNGLGETINFOLOGARBPROC glad_debug_glGetInfoLogARB;
#define glGetInfoLogARB glad_debug_glGetInfoLogARB
    GLAD_API_CALL PFNGLGETINSTRUMENTSSGIXPROC glad_glGetInstrumentsSGIX;
    GLAD_API_CALL PFNGLGETINSTRUMENTSSGIXPROC glad_debug_glGetInstrumentsSGIX;
#define glGetInstrumentsSGIX glad_debug_glGetInstrumentsSGIX
    GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
    GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_debug_glGetInteger64i_v;
#define glGetInteger64i_v glad_debug_glGetInteger64i_v
    GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
    GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_debug_glGetInteger64v;
#define glGetInteger64v glad_debug_glGetInteger64v
    GLAD_API_CALL PFNGLGETINTEGERINDEXEDVEXTPROC glad_glGetIntegerIndexedvEXT;
    GLAD_API_CALL PFNGLGETINTEGERINDEXEDVEXTPROC glad_debug_glGetIntegerIndexedvEXT;
#define glGetIntegerIndexedvEXT glad_debug_glGetIntegerIndexedvEXT
    GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
    GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_debug_glGetIntegeri_v;
#define glGetIntegeri_v glad_debug_glGetIntegeri_v
    GLAD_API_CALL PFNGLGETINTEGERUI64I_VNVPROC glad_glGetIntegerui64i_vNV;
    GLAD_API_CALL PFNGLGETINTEGERUI64I_VNVPROC glad_debug_glGetIntegerui64i_vNV;
#define glGetIntegerui64i_vNV glad_debug_glGetIntegerui64i_vNV
    GLAD_API_CALL PFNGLGETINTEGERUI64VNVPROC glad_glGetIntegerui64vNV;
    GLAD_API_CALL PFNGLGETINTEGERUI64VNVPROC glad_debug_glGetIntegerui64vNV;
#define glGetIntegerui64vNV glad_debug_glGetIntegerui64vNV
    GLAD_API_CALL PFNGLGETINTEGERVPROC glad_glGetIntegerv;
    GLAD_API_CALL PFNGLGETINTEGERVPROC glad_debug_glGetIntegerv;
#define glGetIntegerv glad_debug_glGetIntegerv
    GLAD_API_CALL PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_glGetInternalformatSampleivNV;
    GLAD_API_CALL PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_debug_glGetInternalformatSampleivNV;
#define glGetInternalformatSampleivNV glad_debug_glGetInternalformatSampleivNV
    GLAD_API_CALL PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;
    GLAD_API_CALL PFNGLGETINTERNALFORMATI64VPROC glad_debug_glGetInternalformati64v;
#define glGetInternalformati64v glad_debug_glGetInternalformati64v
    GLAD_API_CALL PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;
    GLAD_API_CALL PFNGLGETINTERNALFORMATIVPROC glad_debug_glGetInternalformativ;
#define glGetInternalformativ glad_debug_glGetInternalformativ
    GLAD_API_CALL PFNGLGETINVARIANTBOOLEANVEXTPROC glad_glGetInvariantBooleanvEXT;
    GLAD_API_CALL PFNGLGETINVARIANTBOOLEANVEXTPROC glad_debug_glGetInvariantBooleanvEXT;
#define glGetInvariantBooleanvEXT glad_debug_glGetInvariantBooleanvEXT
    GLAD_API_CALL PFNGLGETINVARIANTFLOATVEXTPROC glad_glGetInvariantFloatvEXT;
    GLAD_API_CALL PFNGLGETINVARIANTFLOATVEXTPROC glad_debug_glGetInvariantFloatvEXT;
#define glGetInvariantFloatvEXT glad_debug_glGetInvariantFloatvEXT
    GLAD_API_CALL PFNGLGETINVARIANTINTEGERVEXTPROC glad_glGetInvariantIntegervEXT;
    GLAD_API_CALL PFNGLGETINVARIANTINTEGERVEXTPROC glad_debug_glGetInvariantIntegervEXT;
#define glGetInvariantIntegervEXT glad_debug_glGetInvariantIntegervEXT
    GLAD_API_CALL PFNGLGETLIGHTXOESPROC glad_glGetLightxOES;
    GLAD_API_CALL PFNGLGETLIGHTXOESPROC glad_debug_glGetLightxOES;
#define glGetLightxOES glad_debug_glGetLightxOES
    GLAD_API_CALL PFNGLGETLISTPARAMETERFVSGIXPROC glad_glGetListParameterfvSGIX;
    GLAD_API_CALL PFNGLGETLISTPARAMETERFVSGIXPROC glad_debug_glGetListParameterfvSGIX;
#define glGetListParameterfvSGIX glad_debug_glGetListParameterfvSGIX
    GLAD_API_CALL PFNGLGETLISTPARAMETERIVSGIXPROC glad_glGetListParameterivSGIX;
    GLAD_API_CALL PFNGLGETLISTPARAMETERIVSGIXPROC glad_debug_glGetListParameterivSGIX;
#define glGetListParameterivSGIX glad_debug_glGetListParameterivSGIX
    GLAD_API_CALL PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_glGetLocalConstantBooleanvEXT;
    GLAD_API_CALL PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_debug_glGetLocalConstantBooleanvEXT;
#define glGetLocalConstantBooleanvEXT glad_debug_glGetLocalConstantBooleanvEXT
    GLAD_API_CALL PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_glGetLocalConstantFloatvEXT;
    GLAD_API_CALL PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_debug_glGetLocalConstantFloatvEXT;
#define glGetLocalConstantFloatvEXT glad_debug_glGetLocalConstantFloatvEXT
    GLAD_API_CALL PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_glGetLocalConstantIntegervEXT;
    GLAD_API_CALL PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_debug_glGetLocalConstantIntegervEXT;
#define glGetLocalConstantIntegervEXT glad_debug_glGetLocalConstantIntegervEXT
    GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_glGetMapAttribParameterfvNV;
    GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_debug_glGetMapAttribParameterfvNV;
#define glGetMapAttribParameterfvNV glad_debug_glGetMapAttribParameterfvNV
    GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_glGetMapAttribParameterivNV;
    GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_debug_glGetMapAttribParameterivNV;
#define glGetMapAttribParameterivNV glad_debug_glGetMapAttribParameterivNV
    GLAD_API_CALL PFNGLGETMAPCONTROLPOINTSNVPROC glad_glGetMapControlPointsNV;
    GLAD_API_CALL PFNGLGETMAPCONTROLPOINTSNVPROC glad_debug_glGetMapControlPointsNV;
#define glGetMapControlPointsNV glad_debug_glGetMapControlPointsNV
    GLAD_API_CALL PFNGLGETMAPPARAMETERFVNVPROC glad_glGetMapParameterfvNV;
    GLAD_API_CALL PFNGLGETMAPPARAMETERFVNVPROC glad_debug_glGetMapParameterfvNV;
#define glGetMapParameterfvNV glad_debug_glGetMapParameterfvNV
    GLAD_API_CALL PFNGLGETMAPPARAMETERIVNVPROC glad_glGetMapParameterivNV;
    GLAD_API_CALL PFNGLGETMAPPARAMETERIVNVPROC glad_debug_glGetMapParameterivNV;
#define glGetMapParameterivNV glad_debug_glGetMapParameterivNV
    GLAD_API_CALL PFNGLGETMAPXVOESPROC glad_glGetMapxvOES;
    GLAD_API_CALL PFNGLGETMAPXVOESPROC glad_debug_glGetMapxvOES;
#define glGetMapxvOES glad_debug_glGetMapxvOES
    GLAD_API_CALL PFNGLGETMATERIALXOESPROC glad_glGetMaterialxOES;
    GLAD_API_CALL PFNGLGETMATERIALXOESPROC glad_debug_glGetMaterialxOES;
#define glGetMaterialxOES glad_debug_glGetMaterialxOES
    GLAD_API_CALL PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC
        glad_glGetMemoryObjectDetachedResourcesuivNV;
    GLAD_API_CALL PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC
        glad_debug_glGetMemoryObjectDetachedResourcesuivNV;
#define glGetMemoryObjectDetachedResourcesuivNV glad_debug_glGetMemoryObjectDetachedResourcesuivNV
    GLAD_API_CALL PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_glGetMemoryObjectParameterivEXT;
    GLAD_API_CALL PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_debug_glGetMemoryObjectParameterivEXT;
#define glGetMemoryObjectParameterivEXT glad_debug_glGetMemoryObjectParameterivEXT
    GLAD_API_CALL PFNGLGETMINMAXEXTPROC glad_glGetMinmaxEXT;
    GLAD_API_CALL PFNGLGETMINMAXEXTPROC glad_debug_glGetMinmaxEXT;
#define glGetMinmaxEXT glad_debug_glGetMinmaxEXT
    GLAD_API_CALL PFNGLGETMINMAXPARAMETERFVEXTPROC glad_glGetMinmaxParameterfvEXT;
    GLAD_API_CALL PFNGLGETMINMAXPARAMETERFVEXTPROC glad_debug_glGetMinmaxParameterfvEXT;
#define glGetMinmaxParameterfvEXT glad_debug_glGetMinmaxParameterfvEXT
    GLAD_API_CALL PFNGLGETMINMAXPARAMETERIVEXTPROC glad_glGetMinmaxParameterivEXT;
    GLAD_API_CALL PFNGLGETMINMAXPARAMETERIVEXTPROC glad_debug_glGetMinmaxParameterivEXT;
#define glGetMinmaxParameterivEXT glad_debug_glGetMinmaxParameterivEXT
    GLAD_API_CALL PFNGLGETMULTITEXENVFVEXTPROC glad_glGetMultiTexEnvfvEXT;
    GLAD_API_CALL PFNGLGETMULTITEXENVFVEXTPROC glad_debug_glGetMultiTexEnvfvEXT;
#define glGetMultiTexEnvfvEXT glad_debug_glGetMultiTexEnvfvEXT
    GLAD_API_CALL PFNGLGETMULTITEXENVIVEXTPROC glad_glGetMultiTexEnvivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXENVIVEXTPROC glad_debug_glGetMultiTexEnvivEXT;
#define glGetMultiTexEnvivEXT glad_debug_glGetMultiTexEnvivEXT
    GLAD_API_CALL PFNGLGETMULTITEXGENDVEXTPROC glad_glGetMultiTexGendvEXT;
    GLAD_API_CALL PFNGLGETMULTITEXGENDVEXTPROC glad_debug_glGetMultiTexGendvEXT;
#define glGetMultiTexGendvEXT glad_debug_glGetMultiTexGendvEXT
    GLAD_API_CALL PFNGLGETMULTITEXGENFVEXTPROC glad_glGetMultiTexGenfvEXT;
    GLAD_API_CALL PFNGLGETMULTITEXGENFVEXTPROC glad_debug_glGetMultiTexGenfvEXT;
#define glGetMultiTexGenfvEXT glad_debug_glGetMultiTexGenfvEXT
    GLAD_API_CALL PFNGLGETMULTITEXGENIVEXTPROC glad_glGetMultiTexGenivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXGENIVEXTPROC glad_debug_glGetMultiTexGenivEXT;
#define glGetMultiTexGenivEXT glad_debug_glGetMultiTexGenivEXT
    GLAD_API_CALL PFNGLGETMULTITEXIMAGEEXTPROC glad_glGetMultiTexImageEXT;
    GLAD_API_CALL PFNGLGETMULTITEXIMAGEEXTPROC glad_debug_glGetMultiTexImageEXT;
#define glGetMultiTexImageEXT glad_debug_glGetMultiTexImageEXT
    GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glad_glGetMultiTexLevelParameterfvEXT;
    GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC
        glad_debug_glGetMultiTexLevelParameterfvEXT;
#define glGetMultiTexLevelParameterfvEXT glad_debug_glGetMultiTexLevelParameterfvEXT
    GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glad_glGetMultiTexLevelParameterivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC
        glad_debug_glGetMultiTexLevelParameterivEXT;
#define glGetMultiTexLevelParameterivEXT glad_debug_glGetMultiTexLevelParameterivEXT
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_glGetMultiTexParameterIivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_debug_glGetMultiTexParameterIivEXT;
#define glGetMultiTexParameterIivEXT glad_debug_glGetMultiTexParameterIivEXT
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_glGetMultiTexParameterIuivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_debug_glGetMultiTexParameterIuivEXT;
#define glGetMultiTexParameterIuivEXT glad_debug_glGetMultiTexParameterIuivEXT
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_glGetMultiTexParameterfvEXT;
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_debug_glGetMultiTexParameterfvEXT;
#define glGetMultiTexParameterfvEXT glad_debug_glGetMultiTexParameterfvEXT
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_glGetMultiTexParameterivEXT;
    GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_debug_glGetMultiTexParameterivEXT;
#define glGetMultiTexParameterivEXT glad_debug_glGetMultiTexParameterivEXT
    GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
    GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_debug_glGetMultisamplefv;
#define glGetMultisamplefv glad_debug_glGetMultisamplefv
    GLAD_API_CALL PFNGLGETMULTISAMPLEFVNVPROC glad_glGetMultisamplefvNV;
    GLAD_API_CALL PFNGLGETMULTISAMPLEFVNVPROC glad_debug_glGetMultisamplefvNV;
#define glGetMultisamplefvNV glad_debug_glGetMultisamplefvNV
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_debug_glGetNamedBufferParameteri64v;
#define glGetNamedBufferParameteri64v glad_debug_glGetNamedBufferParameteri64v
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_debug_glGetNamedBufferParameteriv;
#define glGetNamedBufferParameteriv glad_debug_glGetNamedBufferParameteriv
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_glGetNamedBufferParameterivEXT;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_debug_glGetNamedBufferParameterivEXT;
#define glGetNamedBufferParameterivEXT glad_debug_glGetNamedBufferParameterivEXT
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glad_glGetNamedBufferParameterui64vNV;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC
        glad_debug_glGetNamedBufferParameterui64vNV;
#define glGetNamedBufferParameterui64vNV glad_debug_glGetNamedBufferParameterui64vNV
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVPROC glad_debug_glGetNamedBufferPointerv;
#define glGetNamedBufferPointerv glad_debug_glGetNamedBufferPointerv
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_glGetNamedBufferPointervEXT;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_debug_glGetNamedBufferPointervEXT;
#define glGetNamedBufferPointervEXT glad_debug_glGetNamedBufferPointervEXT
    GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAPROC glad_debug_glGetNamedBufferSubData;
#define glGetNamedBufferSubData glad_debug_glGetNamedBufferSubData
    GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_glGetNamedBufferSubDataEXT;
    GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_debug_glGetNamedBufferSubDataEXT;
#define glGetNamedBufferSubDataEXT glad_debug_glGetNamedBufferSubDataEXT
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC
        glad_glGetNamedFramebufferAttachmentParameteriv;
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC
        glad_debug_glGetNamedFramebufferAttachmentParameteriv;
#define glGetNamedFramebufferAttachmentParameteriv \
    glad_debug_glGetNamedFramebufferAttachmentParameteriv
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC
        glad_glGetNamedFramebufferAttachmentParameterivEXT;
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC
        glad_debug_glGetNamedFramebufferAttachmentParameterivEXT;
#define glGetNamedFramebufferAttachmentParameterivEXT \
    glad_debug_glGetNamedFramebufferAttachmentParameterivEXT
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC
        glad_glGetNamedFramebufferParameterfvAMD;
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC
        glad_debug_glGetNamedFramebufferParameterfvAMD;
#define glGetNamedFramebufferParameterfvAMD glad_debug_glGetNamedFramebufferParameterfvAMD
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC
        glad_debug_glGetNamedFramebufferParameteriv;
#define glGetNamedFramebufferParameteriv glad_debug_glGetNamedFramebufferParameteriv
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC
        glad_glGetNamedFramebufferParameterivEXT;
    GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC
        glad_debug_glGetNamedFramebufferParameterivEXT;
#define glGetNamedFramebufferParameterivEXT glad_debug_glGetNamedFramebufferParameterivEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC
        glad_glGetNamedProgramLocalParameterIivEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC
        glad_debug_glGetNamedProgramLocalParameterIivEXT;
#define glGetNamedProgramLocalParameterIivEXT glad_debug_glGetNamedProgramLocalParameterIivEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC
        glad_glGetNamedProgramLocalParameterIuivEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC
        glad_debug_glGetNamedProgramLocalParameterIuivEXT;
#define glGetNamedProgramLocalParameterIuivEXT glad_debug_glGetNamedProgramLocalParameterIuivEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC
        glad_glGetNamedProgramLocalParameterdvEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC
        glad_debug_glGetNamedProgramLocalParameterdvEXT;
#define glGetNamedProgramLocalParameterdvEXT glad_debug_glGetNamedProgramLocalParameterdvEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC
        glad_glGetNamedProgramLocalParameterfvEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC
        glad_debug_glGetNamedProgramLocalParameterfvEXT;
#define glGetNamedProgramLocalParameterfvEXT glad_debug_glGetNamedProgramLocalParameterfvEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_glGetNamedProgramStringEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_debug_glGetNamedProgramStringEXT;
#define glGetNamedProgramStringEXT glad_debug_glGetNamedProgramStringEXT
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMIVEXTPROC glad_glGetNamedProgramivEXT;
    GLAD_API_CALL PFNGLGETNAMEDPROGRAMIVEXTPROC glad_debug_glGetNamedProgramivEXT;
#define glGetNamedProgramivEXT glad_debug_glGetNamedProgramivEXT
    GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;
    GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC
        glad_debug_glGetNamedRenderbufferParameteriv;
#define glGetNamedRenderbufferParameteriv glad_debug_glGetNamedRenderbufferParameteriv
    GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC
        glad_glGetNamedRenderbufferParameterivEXT;
    GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC
        glad_debug_glGetNamedRenderbufferParameterivEXT;
#define glGetNamedRenderbufferParameterivEXT glad_debug_glGetNamedRenderbufferParameterivEXT
    GLAD_API_CALL PFNGLGETNAMEDSTRINGARBPROC glad_glGetNamedStringARB;
    GLAD_API_CALL PFNGLGETNAMEDSTRINGARBPROC glad_debug_glGetNamedStringARB;
#define glGetNamedStringARB glad_debug_glGetNamedStringARB
    GLAD_API_CALL PFNGLGETNAMEDSTRINGIVARBPROC glad_glGetNamedStringivARB;
    GLAD_API_CALL PFNGLGETNAMEDSTRINGIVARBPROC glad_debug_glGetNamedStringivARB;
#define glGetNamedStringivARB glad_debug_glGetNamedStringivARB
    GLAD_API_CALL PFNGLGETNEXTPERFQUERYIDINTELPROC glad_glGetNextPerfQueryIdINTEL;
    GLAD_API_CALL PFNGLGETNEXTPERFQUERYIDINTELPROC glad_debug_glGetNextPerfQueryIdINTEL;
#define glGetNextPerfQueryIdINTEL glad_debug_glGetNextPerfQueryIdINTEL
    GLAD_API_CALL PFNGLGETOBJECTBUFFERFVATIPROC glad_glGetObjectBufferfvATI;
    GLAD_API_CALL PFNGLGETOBJECTBUFFERFVATIPROC glad_debug_glGetObjectBufferfvATI;
#define glGetObjectBufferfvATI glad_debug_glGetObjectBufferfvATI
    GLAD_API_CALL PFNGLGETOBJECTBUFFERIVATIPROC glad_glGetObjectBufferivATI;
    GLAD_API_CALL PFNGLGETOBJECTBUFFERIVATIPROC glad_debug_glGetObjectBufferivATI;
#define glGetObjectBufferivATI glad_debug_glGetObjectBufferivATI
    GLAD_API_CALL PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;
    GLAD_API_CALL PFNGLGETOBJECTLABELPROC glad_debug_glGetObjectLabel;

/// <summary>
///   retrieve the label of a named object identified within a namespace
///   <para>
///     glGetObjectLabel retrieves the label of the object identified by name within the namespace
///     given by identifier. identifier must be one of GL_BUFFER , GL_SHADER , GL_PROGRAM ,
///     GL_VERTEX_ARRAY , GL_QUERY , GL_PROGRAM_PIPELINE , GL_TRANSFORM_FEEDBACK , GL_SAMPLER ,
///     GL_TEXTURE , GL_RENDERBUFFER , GL_FRAMEBUFFER , to indicate the namespace containing the
///     names of buffers, shaders, programs, vertex array objects, query objects, program pipelines,
///     transform feedback objects, samplers, textures, renderbuffers and frame buffers,
///     respectively. label is the address of a string that will be used to store the object label.
///     bufSize specifies the number of characters in the array identified by label. length contains
///     the address of a variable which will receive the the number of characters in the object
///     label. If length is NULL, then it is ignored and no data is written. Likewise, if label is
///     NULL, or if bufSize is zero then no data is written to label.
///   </para>
/// </summary>
/// <param name='identifier'>The namespace from which the name of the object is allocated.</param>
/// <param name='name'>The name of the object whose label to retrieve.</param>
/// <param name='bufSize'>The length of the buffer whose address is in</param>
/// <param name='length'>The address of a variable to receive the length of the object
/// label.</param> <param name='label'>The address of a string that will receive the object
/// label.</param>
#define glGetObjectLabel glad_debug_glGetObjectLabel
    GLAD_API_CALL PFNGLGETOBJECTLABELEXTPROC glad_glGetObjectLabelEXT;
    GLAD_API_CALL PFNGLGETOBJECTLABELEXTPROC glad_debug_glGetObjectLabelEXT;
#define glGetObjectLabelEXT glad_debug_glGetObjectLabelEXT
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERFVARBPROC glad_glGetObjectParameterfvARB;
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERFVARBPROC glad_debug_glGetObjectParameterfvARB;
#define glGetObjectParameterfvARB glad_debug_glGetObjectParameterfvARB
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_glGetObjectParameterivAPPLE;
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_debug_glGetObjectParameterivAPPLE;
#define glGetObjectParameterivAPPLE glad_debug_glGetObjectParameterivAPPLE
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVARBPROC glad_glGetObjectParameterivARB;
    GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVARBPROC glad_debug_glGetObjectParameterivARB;
#define glGetObjectParameterivARB glad_debug_glGetObjectParameterivARB
    GLAD_API_CALL PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;
    GLAD_API_CALL PFNGLGETOBJECTPTRLABELPROC glad_debug_glGetObjectPtrLabel;

/// <summary>
///   retrieve the label of a sync object identified by a pointer
///   <para>
///     glGetObjectPtrLabel retrieves the label of the sync object identified by ptr. label is the
///     address of a string that will be used to store the object label. bufSize specifies the
///     number of characters in the array identified by label. length contains the address of a
///     variable which will receive the the number of characters in the object label. If length is
///     NULL, then it is ignored and no data is written. Likewise, if label is NULL, or if bufSize
///     is zero then no data is written to label.
///   </para>
/// </summary>
/// <param name='ptr'>The name of the sync object whose label to retrieve.</param>
/// <param name='bufSize'>The length of the buffer whose address is in</param>
/// <param name='length'>The address of a variable to receive the length of the object
/// label.</param> <param name='label'>The address of a string that will receive the object
/// label.</param>
#define glGetObjectPtrLabel glad_debug_glGetObjectPtrLabel
    GLAD_API_CALL PFNGLGETOCCLUSIONQUERYIVNVPROC glad_glGetOcclusionQueryivNV;
    GLAD_API_CALL PFNGLGETOCCLUSIONQUERYIVNVPROC glad_debug_glGetOcclusionQueryivNV;
#define glGetOcclusionQueryivNV glad_debug_glGetOcclusionQueryivNV
    GLAD_API_CALL PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_glGetOcclusionQueryuivNV;
    GLAD_API_CALL PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_debug_glGetOcclusionQueryuivNV;
#define glGetOcclusionQueryuivNV glad_debug_glGetOcclusionQueryuivNV
    GLAD_API_CALL PFNGLGETPATHCOMMANDSNVPROC glad_glGetPathCommandsNV;
    GLAD_API_CALL PFNGLGETPATHCOMMANDSNVPROC glad_debug_glGetPathCommandsNV;
#define glGetPathCommandsNV glad_debug_glGetPathCommandsNV
    GLAD_API_CALL PFNGLGETPATHCOORDSNVPROC glad_glGetPathCoordsNV;
    GLAD_API_CALL PFNGLGETPATHCOORDSNVPROC glad_debug_glGetPathCoordsNV;
#define glGetPathCoordsNV glad_debug_glGetPathCoordsNV
    GLAD_API_CALL PFNGLGETPATHDASHARRAYNVPROC glad_glGetPathDashArrayNV;
    GLAD_API_CALL PFNGLGETPATHDASHARRAYNVPROC glad_debug_glGetPathDashArrayNV;
#define glGetPathDashArrayNV glad_debug_glGetPathDashArrayNV
    GLAD_API_CALL PFNGLGETPATHLENGTHNVPROC glad_glGetPathLengthNV;
    GLAD_API_CALL PFNGLGETPATHLENGTHNVPROC glad_debug_glGetPathLengthNV;
#define glGetPathLengthNV glad_debug_glGetPathLengthNV
    GLAD_API_CALL PFNGLGETPATHMETRICRANGENVPROC glad_glGetPathMetricRangeNV;
    GLAD_API_CALL PFNGLGETPATHMETRICRANGENVPROC glad_debug_glGetPathMetricRangeNV;
#define glGetPathMetricRangeNV glad_debug_glGetPathMetricRangeNV
    GLAD_API_CALL PFNGLGETPATHMETRICSNVPROC glad_glGetPathMetricsNV;
    GLAD_API_CALL PFNGLGETPATHMETRICSNVPROC glad_debug_glGetPathMetricsNV;
#define glGetPathMetricsNV glad_debug_glGetPathMetricsNV
    GLAD_API_CALL PFNGLGETPATHPARAMETERFVNVPROC glad_glGetPathParameterfvNV;
    GLAD_API_CALL PFNGLGETPATHPARAMETERFVNVPROC glad_debug_glGetPathParameterfvNV;
#define glGetPathParameterfvNV glad_debug_glGetPathParameterfvNV
    GLAD_API_CALL PFNGLGETPATHPARAMETERIVNVPROC glad_glGetPathParameterivNV;
    GLAD_API_CALL PFNGLGETPATHPARAMETERIVNVPROC glad_debug_glGetPathParameterivNV;
#define glGetPathParameterivNV glad_debug_glGetPathParameterivNV
    GLAD_API_CALL PFNGLGETPATHSPACINGNVPROC glad_glGetPathSpacingNV;
    GLAD_API_CALL PFNGLGETPATHSPACINGNVPROC glad_debug_glGetPathSpacingNV;
#define glGetPathSpacingNV glad_debug_glGetPathSpacingNV
    GLAD_API_CALL PFNGLGETPERFCOUNTERINFOINTELPROC glad_glGetPerfCounterInfoINTEL;
    GLAD_API_CALL PFNGLGETPERFCOUNTERINFOINTELPROC glad_debug_glGetPerfCounterInfoINTEL;
#define glGetPerfCounterInfoINTEL glad_debug_glGetPerfCounterInfoINTEL
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_glGetPerfMonitorCounterDataAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_debug_glGetPerfMonitorCounterDataAMD;
#define glGetPerfMonitorCounterDataAMD glad_debug_glGetPerfMonitorCounterDataAMD
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_glGetPerfMonitorCounterInfoAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_debug_glGetPerfMonitorCounterInfoAMD;
#define glGetPerfMonitorCounterInfoAMD glad_debug_glGetPerfMonitorCounterInfoAMD
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glad_glGetPerfMonitorCounterStringAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC
        glad_debug_glGetPerfMonitorCounterStringAMD;
#define glGetPerfMonitorCounterStringAMD glad_debug_glGetPerfMonitorCounterStringAMD
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_glGetPerfMonitorCountersAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_debug_glGetPerfMonitorCountersAMD;
#define glGetPerfMonitorCountersAMD glad_debug_glGetPerfMonitorCountersAMD
    GLAD_API_CALL PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_glGetPerfMonitorGroupStringAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_debug_glGetPerfMonitorGroupStringAMD;
#define glGetPerfMonitorGroupStringAMD glad_debug_glGetPerfMonitorGroupStringAMD
    GLAD_API_CALL PFNGLGETPERFMONITORGROUPSAMDPROC glad_glGetPerfMonitorGroupsAMD;
    GLAD_API_CALL PFNGLGETPERFMONITORGROUPSAMDPROC glad_debug_glGetPerfMonitorGroupsAMD;
#define glGetPerfMonitorGroupsAMD glad_debug_glGetPerfMonitorGroupsAMD
    GLAD_API_CALL PFNGLGETPERFQUERYDATAINTELPROC glad_glGetPerfQueryDataINTEL;
    GLAD_API_CALL PFNGLGETPERFQUERYDATAINTELPROC glad_debug_glGetPerfQueryDataINTEL;
#define glGetPerfQueryDataINTEL glad_debug_glGetPerfQueryDataINTEL
    GLAD_API_CALL PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_glGetPerfQueryIdByNameINTEL;
    GLAD_API_CALL PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_debug_glGetPerfQueryIdByNameINTEL;
#define glGetPerfQueryIdByNameINTEL glad_debug_glGetPerfQueryIdByNameINTEL
    GLAD_API_CALL PFNGLGETPERFQUERYINFOINTELPROC glad_glGetPerfQueryInfoINTEL;
    GLAD_API_CALL PFNGLGETPERFQUERYINFOINTELPROC glad_debug_glGetPerfQueryInfoINTEL;
#define glGetPerfQueryInfoINTEL glad_debug_glGetPerfQueryInfoINTEL
    GLAD_API_CALL PFNGLGETPIXELMAPXVPROC glad_glGetPixelMapxv;
    GLAD_API_CALL PFNGLGETPIXELMAPXVPROC glad_debug_glGetPixelMapxv;
#define glGetPixelMapxv glad_debug_glGetPixelMapxv
    GLAD_API_CALL PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC glad_glGetPixelTexGenParameterfvSGIS;
    GLAD_API_CALL PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC glad_debug_glGetPixelTexGenParameterfvSGIS;
#define glGetPixelTexGenParameterfvSGIS glad_debug_glGetPixelTexGenParameterfvSGIS
    GLAD_API_CALL PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC glad_glGetPixelTexGenParameterivSGIS;
    GLAD_API_CALL PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC glad_debug_glGetPixelTexGenParameterivSGIS;
#define glGetPixelTexGenParameterivSGIS glad_debug_glGetPixelTexGenParameterivSGIS
    GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC glad_glGetPixelTransformParameterfvEXT;
    GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC
        glad_debug_glGetPixelTransformParameterfvEXT;
#define glGetPixelTransformParameterfvEXT glad_debug_glGetPixelTransformParameterfvEXT
    GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC glad_glGetPixelTransformParameterivEXT;
    GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC
        glad_debug_glGetPixelTransformParameterivEXT;
#define glGetPixelTransformParameterivEXT glad_debug_glGetPixelTransformParameterivEXT
    GLAD_API_CALL PFNGLGETPOINTERINDEXEDVEXTPROC glad_glGetPointerIndexedvEXT;
    GLAD_API_CALL PFNGLGETPOINTERINDEXEDVEXTPROC glad_debug_glGetPointerIndexedvEXT;
#define glGetPointerIndexedvEXT glad_debug_glGetPointerIndexedvEXT
    GLAD_API_CALL PFNGLGETPOINTERI_VEXTPROC glad_glGetPointeri_vEXT;
    GLAD_API_CALL PFNGLGETPOINTERI_VEXTPROC glad_debug_glGetPointeri_vEXT;
#define glGetPointeri_vEXT glad_debug_glGetPointeri_vEXT
    GLAD_API_CALL PFNGLGETPOINTERVPROC glad_glGetPointerv;
    GLAD_API_CALL PFNGLGETPOINTERVPROC glad_debug_glGetPointerv;

/// <summary>
///   return the address of the specified pointer
///   <para>
///     glGetPointerv returns pointer information. pname indicates the pointer to be returned, and
///     params is a pointer to a location in which to place the returned data. The parameters that
///     may be queried include: Returns the current callback function set with the callback argument
///     of glDebugMessageCallback. Returns the user parameter to the current callback function set
///     with the userParam argument of glDebugMessageCallback.
///   </para>
/// </summary>
/// <param name='pname'>Specifies the pointer to be returned. Must be one of</param>
/// <param name='params'>Returns the pointer value specified by</param>
#define glGetPointerv glad_debug_glGetPointerv
    GLAD_API_CALL PFNGLGETPOINTERVEXTPROC glad_glGetPointervEXT;
    GLAD_API_CALL PFNGLGETPOINTERVEXTPROC glad_debug_glGetPointervEXT;
#define glGetPointervEXT glad_debug_glGetPointervEXT
    GLAD_API_CALL PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;
    GLAD_API_CALL PFNGLGETPROGRAMBINARYPROC glad_debug_glGetProgramBinary;

/// <summary>
///   return a binary representation of a program object's compiled and linked executable source
///   <para>
///     glGetProgramBinary returns a binary representation of the compiled and linked executable for
///     program into the array of bytes whose address is specified in binary. The maximum number of
///     bytes that may be written into binary is specified by bufSize. If the program binary is
///     greater in size than bufSize bytes, then an error is generated, otherwise the actual number
///     of bytes written into binary is returned in the variable whose address is given by length.
///     If length is NULL , then no length is returned. The format of the program binary written
///     into binary is returned in the variable whose address is given by binaryFormat , and may be
///     implementation dependent. The binary produced by the GL may subsequently be returned to the
///     GL by calling glProgramBinary , with binaryFormat and length set to the values returned by
///     glGetProgramBinary , and passing the returned binary data in the binary parameter.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of a program object whose binary representation to
/// retrieve.</param> <param name='bufSize'>Specifies the size of the buffer whose address is given
/// by</param> <param name='length'>Specifies the address of a variable to receive the number of
/// bytes written into</param> <param name='binaryFormat'>Specifies the address of a variable to
/// receive a token indicating the format of the binary data returned by the GL.</param> <param
/// name='binary'>Specifies the address an array into which the GL will return</param>
#define glGetProgramBinary glad_debug_glGetProgramBinary
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_glGetProgramEnvParameterIivNV;
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_debug_glGetProgramEnvParameterIivNV;
#define glGetProgramEnvParameterIivNV glad_debug_glGetProgramEnvParameterIivNV
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_glGetProgramEnvParameterIuivNV;
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_debug_glGetProgramEnvParameterIuivNV;
#define glGetProgramEnvParameterIuivNV glad_debug_glGetProgramEnvParameterIuivNV
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_glGetProgramEnvParameterdvARB;
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_debug_glGetProgramEnvParameterdvARB;
#define glGetProgramEnvParameterdvARB glad_debug_glGetProgramEnvParameterdvARB
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_glGetProgramEnvParameterfvARB;
    GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_debug_glGetProgramEnvParameterfvARB;
#define glGetProgramEnvParameterfvARB glad_debug_glGetProgramEnvParameterfvARB
    GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
    GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_debug_glGetProgramInfoLog;

/// <summary>
///   Returns the information log for a program object
///   <para>
///     glGetProgramInfoLog returns the information log for the specified program object. The
///     information log for a program object is modified when the program object is linked or
///     validated. The string that is returned will be null terminated. glGetProgramInfoLog returns
///     in infoLog as much of the information log as it can, up to a maximum of maxLength
///     characters. The number of characters actually returned, excluding the null termination
///     character, is specified by length. If the length of the returned string is not required, a
///     value of NULL can be passed in the length argument. The size of the buffer required to store
///     the returned information log can be obtained by calling glGetProgram with the value
///     GL_INFO_LOG_LENGTH. The information log for a program object is either an empty string, or a
///     string containing information about the last link operation, or a string containing
///     information about the last validation operation. It may contain diagnostic messages, warning
///     messages, and other information. When a program object is created, its information log will
///     be a string of length 0.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object whose information log is to be
/// queried.</param> <param name='maxLength'>Specifies the size of the character buffer for storing
/// the returned information log.</param> <param name='length'>Returns the length of the string
/// returned in</param> <param name='infoLog'>Specifies an array of characters that is used to
/// return the information log.</param>
#define glGetProgramInfoLog glad_debug_glGetProgramInfoLog
    GLAD_API_CALL PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;
    GLAD_API_CALL PFNGLGETPROGRAMINTERFACEIVPROC glad_debug_glGetProgramInterfaceiv;
#define glGetProgramInterfaceiv glad_debug_glGetProgramInterfaceiv
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_glGetProgramLocalParameterIivNV;
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_debug_glGetProgramLocalParameterIivNV;
#define glGetProgramLocalParameterIivNV glad_debug_glGetProgramLocalParameterIivNV
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC glad_glGetProgramLocalParameterIuivNV;
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC
        glad_debug_glGetProgramLocalParameterIuivNV;
#define glGetProgramLocalParameterIuivNV glad_debug_glGetProgramLocalParameterIuivNV
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_glGetProgramLocalParameterdvARB;
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_debug_glGetProgramLocalParameterdvARB;
#define glGetProgramLocalParameterdvARB glad_debug_glGetProgramLocalParameterdvARB
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_glGetProgramLocalParameterfvARB;
    GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_debug_glGetProgramLocalParameterfvARB;
#define glGetProgramLocalParameterfvARB glad_debug_glGetProgramLocalParameterfvARB
    GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_glGetProgramNamedParameterdvNV;
    GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_debug_glGetProgramNamedParameterdvNV;
#define glGetProgramNamedParameterdvNV glad_debug_glGetProgramNamedParameterdvNV
    GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_glGetProgramNamedParameterfvNV;
    GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_debug_glGetProgramNamedParameterfvNV;
#define glGetProgramNamedParameterfvNV glad_debug_glGetProgramNamedParameterfvNV
    GLAD_API_CALL PFNGLGETPROGRAMPARAMETERDVNVPROC glad_glGetProgramParameterdvNV;
    GLAD_API_CALL PFNGLGETPROGRAMPARAMETERDVNVPROC glad_debug_glGetProgramParameterdvNV;
#define glGetProgramParameterdvNV glad_debug_glGetProgramParameterdvNV
    GLAD_API_CALL PFNGLGETPROGRAMPARAMETERFVNVPROC glad_glGetProgramParameterfvNV;
    GLAD_API_CALL PFNGLGETPROGRAMPARAMETERFVNVPROC glad_debug_glGetProgramParameterfvNV;
#define glGetProgramParameterfvNV glad_debug_glGetProgramParameterfvNV
    GLAD_API_CALL PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;
    GLAD_API_CALL PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_debug_glGetProgramPipelineInfoLog;

/// <summary>
///   retrieve the info log string from a program pipeline object
///   <para>
///     glGetProgramPipelineInfoLog retrieves the info log for the program pipeline object pipeline.
///     The info log, including its null terminator, is written into the array of characters whose
///     address is given by infoLog. The maximum number of characters that may be written into
///     infoLog is given by bufSize , and the actual number of characters written into infoLog is
///     returned in the integer whose address is given by length. If length is NULL , no length is
///     returned. The actual length of the info log for the program pipeline may be determined by
///     calling glGetProgramPipeline with pname set to GL_INFO_LOG_LENGTH.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies the name of a program pipeline object from which to retrieve
/// the info log.</param> <param name='bufSize'>Specifies the maximum number of characters,
/// including the null terminator, that may be written into</param> <param name='length'>Specifies
/// the address of a variable into which will be written the number of characters written
/// into</param> <param name='infoLog'>Specifies the address of an array of characters into which
/// will be written the info log for</param>
#define glGetProgramPipelineInfoLog glad_debug_glGetProgramPipelineInfoLog
    GLAD_API_CALL PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;
    GLAD_API_CALL PFNGLGETPROGRAMPIPELINEIVPROC glad_debug_glGetProgramPipelineiv;
#define glGetProgramPipelineiv glad_debug_glGetProgramPipelineiv
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEINDEXPROC glad_debug_glGetProgramResourceIndex;

/// <summary>
///   query the index of a named resource within a program
///   <para>
///     glGetProgramResourceIndex returns the unsigned integer index assigned to a resource named
///     name in the interface type programInterface of program object program. program must be the
///     name of an existing program object. programInterface is the name of the interface within
///     program which contains the resource named name and must be one of the following values: The
///     query is targeted at the set of active uniforms within program. The query is targeted at the
///     set of active uniform blocks within program. The query is targeted at the set of active
///     input variables used by the first shader stage of program. If program contains multiple
///     shader stages then input variables from any stage other than the first will not be
///     enumerated. The query is targeted at the set of active output variables produced by the last
///     shader stage of program. If program contains multiple shader stages then output variables
///     from any stage other than the last will not be enumerated. The query is targeted at the set
///     of active subroutines for the vertex, tessellation control, tessellation evaluation,
///     geometry, fragment and compute shader stages of program , respectively. The query is
///     targeted at the set of active subroutine uniform variables used by the vertex, tessellation
///     control, tessellation evaluation, geometry, fragment and compute shader stages of program ,
///     respectively. The query is targeted at the set of output variables from the last
///     non-fragment stage of program that would be captured if transform feedback were active. The
///     query is targeted at the set of active buffer binding points to which output variables in
///     the GL_TRANSFORM_FEEDBACK_VARYING interface are written. The query is targeted at the set of
///     active buffer variables used by program. The query is targeted at the set of active shader
///     storage blocks used by program. If name exactly matches the name string of one of the active
///     resources for programInterface , the index of the matched resource is returned.
///     Additionally, if name would exactly match the name string of an active resource if "[0]"
///     were appended to name , the index of the matched resource is returned. Otherwise, name is
///     considered not to be the name of an active resource, and GL_INVALID_INDEX is returned. For
///     the interface GL_TRANSFORM_FEEDBACK_VARYING , the value GL_INVALID_INDEX should be returned
///     when querying the index assigned to the special names gl_NextBuffer , gl_SkipComponents1 ,
///     gl_SkipComponents2 , gl_SkipComponents3 , or gl_SkipComponents4.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object whose resources to query.</param>
/// <param name='programInterface'>A token identifying the interface within</param>
/// <param name='name'>The name of the resource to query the index of.</param>
#define glGetProgramResourceIndex glad_debug_glGetProgramResourceIndex
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_debug_glGetProgramResourceLocation;

/// <summary>
///   query the location of a named resource within a program
///   <para>
///     glGetProgramResourceLocation returns the location assigned to the variable named name in
///     interface programInterface of program object program. program must be the name of a program
///     that has been linked successfully. programInterface must be one of GL_UNIFORM ,
///     GL_PROGRAM_INPUT , GL_PROGRAM_OUTPUT , GL_VERTEX_SUBROUTINE_UNIFORM ,
///     GL_TESS_CONTROL_SUBROUTINE_UNIFORM , GL_TESS_EVALUATION_SUBROUTINE_UNIFORM ,
///     GL_GEOMETRY_SUBROUTINE_UNIFORM , GL_FRAGMENT_SUBROUTINE_UNIFORM ,
///     GL_COMPUTE_SUBROUTINE_UNIFORM , or GL_TRANSFORM_FEEDBACK_BUFFER. The value -1 will be
///     returned if an error occurs, if name does not identify an active variable on
///     programInterface , or if name identifies an active variable that does not have a valid
///     location assigned, as described above. The locations returned by these commands are the same
///     locations returned when querying the GL_LOCATION and GL_LOCATION_INDEX resource properties.
///     A string provided to glGetProgramResourceLocation is considered to match an active variable
///     if: the string exactly matches the name of the active variable if the string identifies the
///     base name of an active array, where the string would exactly match the name of the variable
///     if the suffix "[0]" were appended to the string if the string identifies an active element
///     of the array, where the string ends with the concatenation of the "[" character, an integer
///     with no "+" sign, extra leading zeroes, or whitespace identifying an array element, and the
///     "]" character, the integer is less than the number of active elements of the array variable,
///     and where the string would exactly match the enumerated name of the array if the decimal
///     integer were replaced with zero. Any other string is considered not to identify an active
///     variable. If the string specifies an element of an array variable,
///     glGetProgramResourceLocation returns the location assigned to that element. If it specifies
///     the base name of an array, it identifies the resources associated with the first element of
///     the array.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object whose resources to query.</param>
/// <param name='programInterface'>A token identifying the interface within</param>
/// <param name='name'>The name of the resource to query the location of.</param>
#define glGetProgramResourceLocation glad_debug_glGetProgramResourceLocation
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC
        glad_debug_glGetProgramResourceLocationIndex;

/// <summary>
///   query the fragment color index of a named variable within a program
///   <para>
///     glGetProgramResourceLocationIndex returns the fragment color index assigned to the variable
///     named name in interface programInterface of program object program. program must be the name
///     of a program that has been linked successfully. programInterface must be GL_PROGRAM_OUTPUT.
///     The value -1 will be returned if an error occurs, if name does not identify an active
///     variable on programInterface , or if name identifies an active variable that does not have a
///     valid location assigned, as described above. The locations returned by these commands are
///     the same locations returned when querying the GL_LOCATION and GL_LOCATION_INDEX resource
///     properties. A string provided to glGetProgramResourceLocationIndex is considered to match an
///     active variable if: the string exactly matches the name of the active variable if the string
///     identifies the base name of an active array, where the string would exactly match the name
///     of the variable if the suffix "[0]" were appended to the string if the string identifies an
///     active element of the array, where the string ends with the concatenation of the "["
///     character, an integer with no "+" sign, extra leading zeroes, or whitespace identifying an
///     array element, and the "]" character, the integer is less than the number of active elements
///     of the array variable, and where the string would exactly match the enumerated name of the
///     array if the decimal integer were replaced with zero. Any other string is considered not to
///     identify an active variable. If the string specifies an element of an array variable,
///     glGetProgramResourceLocation returns the location assigned to that element. If it specifies
///     the base name of an array, it identifies the resources associated with the first element of
///     the array.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object whose resources to query.</param>
/// <param name='programInterface'>A token identifying the interface within</param>
/// <param name='name'>The name of the resource to query the location of.</param>
#define glGetProgramResourceLocationIndex glad_debug_glGetProgramResourceLocationIndex
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCENAMEPROC glad_debug_glGetProgramResourceName;

/// <summary>
///   query the name of an indexed resource within a program
///   <para>
///     glGetProgramResourceName retrieves the name string assigned to the single active resource
///     with an index of index in the interface programInterface of program object program. index
///     must be less than the number of entries in the active resource list for programInterface.
///     program must be the name of an existing program object. programInterface is the name of the
///     interface within program which contains the resource and must be one of the following
///     values: The query is targeted at the set of active uniforms within program. The query is
///     targeted at the set of active uniform blocks within program. The query is targeted at the
///     set of active input variables used by the first shader stage of program. If program contains
///     multiple shader stages then input variables from any stage other than the first will not be
///     enumerated. The query is targeted at the set of active output variables produced by the last
///     shader stage of program. If program contains multiple shader stages then output variables
///     from any stage other than the last will not be enumerated. The query is targeted at the set
///     of active subroutines for the vertex, tessellation control, tessellation evaluation,
///     geometry, fragment and compute shader stages of program , respectively. The query is
///     targeted at the set of active subroutine uniform variables used by the vertex, tessellation
///     control, tessellation evaluation, geometry, fragment and compute shader stages of program ,
///     respectively. The query is targeted at the set of output variables from the last
///     non-fragment stage of program that would be captured if transform feedback were active. The
///     query is targeted at the set of active buffer variables used by program. The query is
///     targeted at the set of active shader storage blocks used by program. The name string
///     assigned to the active resource identified by index is returned as a null-terminated string
///     in the character array whose address is given in name. The actual number of characters
///     written into name , excluding the null terminator, is returned in length. If length is NULL,
///     no length is returned. The maximum number of characters that may be written into name ,
///     including the null terminator, is specified by bufSize. If the length of the name string
///     including the null terminator is greater than bufSize , the first bufSize -1 characters of
///     the name string will be written to name , followed by a null terminator. If bufSize is zero,
///     no error will be generated but no characters will be written to name. The length of the
///     longest name string for programInterface >, including a null terminator, can be queried by
///     calling glGetProgramInterface with a pname of GL_MAX_NAME_LENGTH.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object whose resources to query.</param>
/// <param name='programInterface'>A token identifying the interface within</param>
/// <param name='index'>The index of the resource within</param>
/// <param name='bufSize'>The size of the character array whose address is given by</param>
/// <param name='length'>The address of a variable which will receive the length of the resource
/// name.</param> <param name='name'>The address of a character array into which will be written the
/// name of the resource.</param>
#define glGetProgramResourceName glad_debug_glGetProgramResourceName
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEFVNVPROC glad_glGetProgramResourcefvNV;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEFVNVPROC glad_debug_glGetProgramResourcefvNV;
#define glGetProgramResourcefvNV glad_debug_glGetProgramResourcefvNV
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;
    GLAD_API_CALL PFNGLGETPROGRAMRESOURCEIVPROC glad_debug_glGetProgramResourceiv;
#define glGetProgramResourceiv glad_debug_glGetProgramResourceiv
    GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
    GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_debug_glGetProgramStageiv;
#define glGetProgramStageiv glad_debug_glGetProgramStageiv
    GLAD_API_CALL PFNGLGETPROGRAMSTRINGARBPROC glad_glGetProgramStringARB;
    GLAD_API_CALL PFNGLGETPROGRAMSTRINGARBPROC glad_debug_glGetProgramStringARB;
#define glGetProgramStringARB glad_debug_glGetProgramStringARB
    GLAD_API_CALL PFNGLGETPROGRAMSTRINGNVPROC glad_glGetProgramStringNV;
    GLAD_API_CALL PFNGLGETPROGRAMSTRINGNVPROC glad_debug_glGetProgramStringNV;
#define glGetProgramStringNV glad_debug_glGetProgramStringNV
    GLAD_API_CALL PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC
        glad_glGetProgramSubroutineParameteruivNV;
    GLAD_API_CALL PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC
        glad_debug_glGetProgramSubroutineParameteruivNV;
#define glGetProgramSubroutineParameteruivNV glad_debug_glGetProgramSubroutineParameteruivNV
    GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
    GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_debug_glGetProgramiv;
#define glGetProgramiv glad_debug_glGetProgramiv
    GLAD_API_CALL PFNGLGETPROGRAMIVARBPROC glad_glGetProgramivARB;
    GLAD_API_CALL PFNGLGETPROGRAMIVARBPROC glad_debug_glGetProgramivARB;
#define glGetProgramivARB glad_debug_glGetProgramivARB
    GLAD_API_CALL PFNGLGETPROGRAMIVNVPROC glad_glGetProgramivNV;
    GLAD_API_CALL PFNGLGETPROGRAMIVNVPROC glad_debug_glGetProgramivNV;
#define glGetProgramivNV glad_debug_glGetProgramivNV
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_debug_glGetQueryBufferObjecti64v;
#define glGetQueryBufferObjecti64v glad_debug_glGetQueryBufferObjecti64v
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTIVPROC glad_debug_glGetQueryBufferObjectiv;
#define glGetQueryBufferObjectiv glad_debug_glGetQueryBufferObjectiv
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_debug_glGetQueryBufferObjectui64v;
#define glGetQueryBufferObjectui64v glad_debug_glGetQueryBufferObjectui64v
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;
    GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_debug_glGetQueryBufferObjectuiv;
#define glGetQueryBufferObjectuiv glad_debug_glGetQueryBufferObjectuiv
    GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
    GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_debug_glGetQueryIndexediv;
#define glGetQueryIndexediv glad_debug_glGetQueryIndexediv
    GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
    GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_debug_glGetQueryObjecti64v;
#define glGetQueryObjecti64v glad_debug_glGetQueryObjecti64v
    GLAD_API_CALL PFNGLGETQUERYOBJECTI64VEXTPROC glad_glGetQueryObjecti64vEXT;
    GLAD_API_CALL PFNGLGETQUERYOBJECTI64VEXTPROC glad_debug_glGetQueryObjecti64vEXT;
#define glGetQueryObjecti64vEXT glad_debug_glGetQueryObjecti64vEXT
    GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
    GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_debug_glGetQueryObjectiv;
#define glGetQueryObjectiv glad_debug_glGetQueryObjectiv
    GLAD_API_CALL PFNGLGETQUERYOBJECTIVARBPROC glad_glGetQueryObjectivARB;
    GLAD_API_CALL PFNGLGETQUERYOBJECTIVARBPROC glad_debug_glGetQueryObjectivARB;
#define glGetQueryObjectivARB glad_debug_glGetQueryObjectivARB
    GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
    GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_debug_glGetQueryObjectui64v;
#define glGetQueryObjectui64v glad_debug_glGetQueryObjectui64v
    GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VEXTPROC glad_glGetQueryObjectui64vEXT;
    GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VEXTPROC glad_debug_glGetQueryObjectui64vEXT;
#define glGetQueryObjectui64vEXT glad_debug_glGetQueryObjectui64vEXT
    GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
    GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_debug_glGetQueryObjectuiv;
#define glGetQueryObjectuiv glad_debug_glGetQueryObjectuiv
    GLAD_API_CALL PFNGLGETQUERYOBJECTUIVARBPROC glad_glGetQueryObjectuivARB;
    GLAD_API_CALL PFNGLGETQUERYOBJECTUIVARBPROC glad_debug_glGetQueryObjectuivARB;
#define glGetQueryObjectuivARB glad_debug_glGetQueryObjectuivARB
    GLAD_API_CALL PFNGLGETQUERYIVPROC glad_glGetQueryiv;
    GLAD_API_CALL PFNGLGETQUERYIVPROC glad_debug_glGetQueryiv;

/// <summary>
///   return parameters of a query object target
///   <para>
///     glGetQueryiv returns in params a selected parameter of the query object target specified by
///     target. pname names a specific query object target parameter. When pname is GL_CURRENT_QUERY
///     , the name of the currently active query for target , or zero if no query is active, will be
///     placed in params. If pname is GL_QUERY_COUNTER_BITS , the implementation-dependent number of
///     bits used to hold the result of queries for target is returned in params.
///   </para>
/// </summary>
/// <param name='target'>Specifies a query object target. Must be</param>
/// <param name='pname'>Specifies the symbolic name of a query object target parameter. Accepted
/// values are</param> <param name='params'>Returns the requested data.</param>
#define glGetQueryiv glad_debug_glGetQueryiv
    GLAD_API_CALL PFNGLGETQUERYIVARBPROC glad_glGetQueryivARB;
    GLAD_API_CALL PFNGLGETQUERYIVARBPROC glad_debug_glGetQueryivARB;
#define glGetQueryivARB glad_debug_glGetQueryivARB
    GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
    GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_debug_glGetRenderbufferParameteriv;
#define glGetRenderbufferParameteriv glad_debug_glGetRenderbufferParameteriv
    GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_glGetRenderbufferParameterivEXT;
    GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_debug_glGetRenderbufferParameterivEXT;
#define glGetRenderbufferParameterivEXT glad_debug_glGetRenderbufferParameterivEXT
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_debug_glGetSamplerParameterIiv;
#define glGetSamplerParameterIiv glad_debug_glGetSamplerParameterIiv
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_debug_glGetSamplerParameterIuiv;
#define glGetSamplerParameterIuiv glad_debug_glGetSamplerParameterIuiv
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_debug_glGetSamplerParameterfv;
#define glGetSamplerParameterfv glad_debug_glGetSamplerParameterfv
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
    GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_debug_glGetSamplerParameteriv;
#define glGetSamplerParameteriv glad_debug_glGetSamplerParameteriv
    GLAD_API_CALL PFNGLGETSEMAPHOREPARAMETERIVNVPROC glad_glGetSemaphoreParameterivNV;
    GLAD_API_CALL PFNGLGETSEMAPHOREPARAMETERIVNVPROC glad_debug_glGetSemaphoreParameterivNV;
#define glGetSemaphoreParameterivNV glad_debug_glGetSemaphoreParameterivNV
    GLAD_API_CALL PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_glGetSemaphoreParameterui64vEXT;
    GLAD_API_CALL PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_debug_glGetSemaphoreParameterui64vEXT;
#define glGetSemaphoreParameterui64vEXT glad_debug_glGetSemaphoreParameterui64vEXT
    GLAD_API_CALL PFNGLGETSEPARABLEFILTEREXTPROC glad_glGetSeparableFilterEXT;
    GLAD_API_CALL PFNGLGETSEPARABLEFILTEREXTPROC glad_debug_glGetSeparableFilterEXT;
#define glGetSeparableFilterEXT glad_debug_glGetSeparableFilterEXT
    GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
    GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_debug_glGetShaderInfoLog;

/// <summary>
///   Returns the information log for a shader object
///   <para>
///     glGetShaderInfoLog returns the information log for the specified shader object. The
///     information log for a shader object is modified when the shader is compiled. The string that
///     is returned will be null terminated. glGetShaderInfoLog returns in infoLog as much of the
///     information log as it can, up to a maximum of maxLength characters. The number of characters
///     actually returned, excluding the null termination character, is specified by length. If the
///     length of the returned string is not required, a value of NULL can be passed in the length
///     argument. The size of the buffer required to store the returned information log can be
///     obtained by calling glGetShader with the value GL_INFO_LOG_LENGTH. The information log for a
///     shader object is a string that may contain diagnostic messages, warning messages, and other
///     information about the last compile operation. When a shader object is created, its
///     information log will be a string of length 0.
///   </para>
/// </summary>
/// <param name='shader'>Specifies the shader object whose information log is to be queried.</param>
/// <param name='maxLength'>Specifies the size of the character buffer for storing the returned
/// information log.</param> <param name='length'>Returns the length of the string returned
/// in</param> <param name='infoLog'>Specifies an array of characters that is used to return the
/// information log.</param>
#define glGetShaderInfoLog glad_debug_glGetShaderInfoLog
    GLAD_API_CALL PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;
    GLAD_API_CALL PFNGLGETSHADERPRECISIONFORMATPROC glad_debug_glGetShaderPrecisionFormat;

/// <summary>
///   retrieve the range and precision for numeric formats supported by the shader compiler
///   <para>
///     glGetShaderPrecisionFormat retrieves the numeric range and precision for the
///     implementation's representation of quantities in different numeric formats in specified
///     shader type. shaderType specifies the type of shader for which the numeric precision and
///     range is to be retrieved and must be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
///     precisionType specifies the numeric format to query and must be one of GL_LOW_FLOAT ,
///     GL_MEDIUM_FLOAT GL_HIGH_FLOAT , GL_LOW_INT , GL_MEDIUM_INT , or GL_HIGH_INT. range points to
///     an array of two integers into which the format's numeric range will be returned. If min and
///     max are the smallest values representable in the format, then the values returned are
///     defined to be: range [0] = floor(log2(|min|)) and range [1] = floor(log2(|max|)). precision
///     specifies the address of an integer into which will be written the log2 value of the number
///     of bits of precision of the format. If the smallest representable value greater than 1 is 1
///     + eps , then the integer addressed by precision will contain floor(-log2(eps)).
///   </para>
/// </summary>
/// <param name='shaderType'>Specifies the type of shader whose precision to query.</param>
/// <param name='precisionType'>Specifies the numeric format whose precision and range to
/// query.</param> <param name='range'>Specifies the address of array of two integers into which
/// encodings of the implementation's numeric range are returned.</param> <param
/// name='precision'>Specifies the address of an integer into which the numeric precision of the
/// implementation is written.</param>
#define glGetShaderPrecisionFormat glad_debug_glGetShaderPrecisionFormat
    GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
    GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_debug_glGetShaderSource;

/// <summary>
///   Returns the source code string from a shader object
///   <para>
///     glGetShaderSource returns the concatenation of the source code strings from the shader
///     object specified by shader. The source code strings for a shader object are the result of a
///     previous call to glShaderSource. The string returned by the function will be null
///     terminated. glGetShaderSource returns in source as much of the source code string as it can,
///     up to a maximum of bufSize characters. The number of characters actually returned, excluding
///     the null termination character, is specified by length. If the length of the returned string
///     is not required, a value of NULL can be passed in the length argument. The size of the
///     buffer required to store the returned source code string can be obtained by calling
///     glGetShader with the value GL_SHADER_SOURCE_LENGTH.
///   </para>
/// </summary>
/// <param name='shader'>Specifies the shader object to be queried.</param>
/// <param name='bufSize'>Specifies the size of the character buffer for storing the returned source
/// code string.</param> <param name='length'>Returns the length of the string returned in</param>
/// <param name='source'>Specifies an array of characters that is used to return the source code
/// string.</param>
#define glGetShaderSource glad_debug_glGetShaderSource
    GLAD_API_CALL PFNGLGETSHADERSOURCEARBPROC glad_glGetShaderSourceARB;
    GLAD_API_CALL PFNGLGETSHADERSOURCEARBPROC glad_debug_glGetShaderSourceARB;
#define glGetShaderSourceARB glad_debug_glGetShaderSourceARB
    GLAD_API_CALL PFNGLGETSHADERIVPROC glad_glGetShaderiv;
    GLAD_API_CALL PFNGLGETSHADERIVPROC glad_debug_glGetShaderiv;
#define glGetShaderiv glad_debug_glGetShaderiv
    GLAD_API_CALL PFNGLGETSHADINGRATEIMAGEPALETTENVPROC glad_glGetShadingRateImagePaletteNV;
    GLAD_API_CALL PFNGLGETSHADINGRATEIMAGEPALETTENVPROC glad_debug_glGetShadingRateImagePaletteNV;
#define glGetShadingRateImagePaletteNV glad_debug_glGetShadingRateImagePaletteNV
    GLAD_API_CALL PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC glad_glGetShadingRateSampleLocationivNV;
    GLAD_API_CALL PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC
        glad_debug_glGetShadingRateSampleLocationivNV;
#define glGetShadingRateSampleLocationivNV glad_debug_glGetShadingRateSampleLocationivNV
    GLAD_API_CALL PFNGLGETSHARPENTEXFUNCSGISPROC glad_glGetSharpenTexFuncSGIS;
    GLAD_API_CALL PFNGLGETSHARPENTEXFUNCSGISPROC glad_debug_glGetSharpenTexFuncSGIS;
#define glGetSharpenTexFuncSGIS glad_debug_glGetSharpenTexFuncSGIS
    GLAD_API_CALL PFNGLGETSTAGEINDEXNVPROC glad_glGetStageIndexNV;
    GLAD_API_CALL PFNGLGETSTAGEINDEXNVPROC glad_debug_glGetStageIndexNV;
#define glGetStageIndexNV glad_debug_glGetStageIndexNV
    GLAD_API_CALL PFNGLGETSTRINGPROC glad_glGetString;
    GLAD_API_CALL PFNGLGETSTRINGPROC glad_debug_glGetString;

/// <summary>
///   return a string describing the current GL connection
///   <para>
///     glGetString returns a pointer to a static string describing some aspect of the current GL
///     connection. name can be one of the following: Returns the company responsible for this GL
///     implementation. This name does not change from release to release. Returns the name of the
///     renderer. This name is typically specific to a particular configuration of a hardware
///     platform. It does not change from release to release. Returns a version or release number.
///     Returns a version or release number for the shading language. glGetStringi returns a pointer
///     to a static string indexed by index. name can be one of the following: For glGetStringi
///     only, returns the extension string supported by the implementation at index. Strings
///     GL_VENDOR and GL_RENDERER together uniquely specify a platform. They do not change from
///     release to release and should be used by platform-recognition algorithms. The GL_VERSION and
///     GL_SHADING_LANGUAGE_VERSION strings begin with a version number. The version number uses one
///     of these forms: major_number.minor_number major_number.minor_number.release_number
///     Vendor-specific information may follow the version number. Its format depends on the
///     implementation, but a space always separates the version number and the vendor-specific
///     information. All strings are null-terminated.
///   </para>
/// </summary>
/// <param name='name'>Specifies a symbolic constant, one of</param>
/// <param name='index'>For</param>
#define glGetString glad_debug_glGetString
    GLAD_API_CALL PFNGLGETSTRINGIPROC glad_glGetStringi;
    GLAD_API_CALL PFNGLGETSTRINGIPROC glad_debug_glGetStringi;
#define glGetStringi glad_debug_glGetStringi
    GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
    GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_debug_glGetSubroutineIndex;

/// <summary>
///   retrieve the index of a subroutine uniform of a given shader stage within a program
///   <para>
///     glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage
///     attached to a program object. program contains the name of the program to which the shader
///     is attached. shadertype specifies the stage from which to query shader subroutine index.
///     name contains the null-terminated name of the subroutine uniform whose name to query. If
///     name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX is
///     returned, but no error is generated. If name is the name of a subroutine uniform in the
///     shader stage, a value between zero and the value of GL_ACTIVE_SUBROUTINES minus one will be
///     returned. Subroutine indices are assigned using consecutive integers in the range from zero
///     to the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of the program containing shader stage.</param>
/// <param name='shadertype'>Specifies the shader stage from which to query for subroutine uniform
/// index.</param> <param name='name'>Specifies the name of the subroutine uniform whose index to
/// query.</param>
#define glGetSubroutineIndex glad_debug_glGetSubroutineIndex
    GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
    GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_debug_glGetSubroutineUniformLocation;

/// <summary>
///   retrieve the location of a subroutine uniform of a given shader stage within a program
///   <para>
///     glGetSubroutineUniformLocation returns the location of the subroutine uniform variable name
///     in the shader stage of type shadertype attached to program , with behavior otherwise
///     identical to glGetUniformLocation. If name is not the name of a subroutine uniform in the
///     shader stage, -1 is returned, but no error is generated. If name is the name of a subroutine
///     uniform in the shader stage, a value between zero and the value of
///     GL_ACTIVE_SUBROUTINE_LOCATIONS minus one will be returned. Subroutine locations are assigned
///     using consecutive integers in the range from zero to the value of
///     GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage. For active subroutine
///     uniforms declared as arrays, the declared array elements are assigned consecutive locations.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of the program containing shader stage.</param>
/// <param name='shadertype'>Specifies the shader stage from which to query for subroutine uniform
/// index.</param> <param name='name'>Specifies the name of the subroutine uniform whose index to
/// query.</param>
#define glGetSubroutineUniformLocation glad_debug_glGetSubroutineUniformLocation
    GLAD_API_CALL PFNGLGETSYNCIVPROC glad_glGetSynciv;
    GLAD_API_CALL PFNGLGETSYNCIVPROC glad_debug_glGetSynciv;
#define glGetSynciv glad_debug_glGetSynciv
    GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_glGetTexBumpParameterfvATI;
    GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_debug_glGetTexBumpParameterfvATI;
#define glGetTexBumpParameterfvATI glad_debug_glGetTexBumpParameterfvATI
    GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_glGetTexBumpParameterivATI;
    GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_debug_glGetTexBumpParameterivATI;
#define glGetTexBumpParameterivATI glad_debug_glGetTexBumpParameterivATI
    GLAD_API_CALL PFNGLGETTEXENVXVOESPROC glad_glGetTexEnvxvOES;
    GLAD_API_CALL PFNGLGETTEXENVXVOESPROC glad_debug_glGetTexEnvxvOES;
#define glGetTexEnvxvOES glad_debug_glGetTexEnvxvOES
    GLAD_API_CALL PFNGLGETTEXFILTERFUNCSGISPROC glad_glGetTexFilterFuncSGIS;
    GLAD_API_CALL PFNGLGETTEXFILTERFUNCSGISPROC glad_debug_glGetTexFilterFuncSGIS;
#define glGetTexFilterFuncSGIS glad_debug_glGetTexFilterFuncSGIS
    GLAD_API_CALL PFNGLGETTEXGENXVOESPROC glad_glGetTexGenxvOES;
    GLAD_API_CALL PFNGLGETTEXGENXVOESPROC glad_debug_glGetTexGenxvOES;
#define glGetTexGenxvOES glad_debug_glGetTexGenxvOES
    GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
    GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_debug_glGetTexImage;

/// <summary>
///   return a texture image
///   <para>
///     glGetTexImage , glGetnTexImage and glGetTextureImage functions return a texture image into
///     pixels. For glGetTexImage and glGetnTexImage , target specifies whether the desired texture
///     image is one specified by glTexImage1D ( GL_TEXTURE_1D ), glTexImage2D ( GL_TEXTURE_1D_ARRAY
///     , GL_TEXTURE_RECTANGLE , GL_TEXTURE_2D or any of GL_TEXTURE_CUBE_MAP_* ), or glTexImage3D (
///     GL_TEXTURE_2D_ARRAY , GL_TEXTURE_3D , GL_TEXTURE_CUBE_MAP_ARRAY ). For glGetTextureImage ,
///     texture specifies the texture object name. In addition to types of textures accepted by
///     glGetTexImage and glGetnTexImage , the function also accepts cube map texture objects (with
///     effective target GL_TEXTURE_CUBE_MAP ). level specifies the level-of-detail number of the
///     desired image. format and type specify the format and type of the desired image array. See
///     the reference page for glTexImage1D for a description of the acceptable values for the
///     format and type parameters, respectively. For glGetnTexImage and glGetTextureImage
///     functions, bufSize tells the size of the buffer to receive the retrieved pixel data.
///     glGetnTexImage and glGetTextureImage do not write more than bufSize bytes into pixels. If a
///     non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer )
///     while a texture image is requested, pixels is treated as a byte offset into the buffer
///     object's data store. To understand the operation of glGetTexImage , consider the selected
///     internal four-component texture image to be an RGBA color buffer the size of the image. The
///     semantics of glGetTexImage are then identical to those of glReadPixels , with the exception
///     that no pixel transfer operations are performed, when called with the same format and type ,
///     with x and y set to 0, width set to the width of the texture image and height set to 1 for
///     1D images, or to the height of the texture image for 2D images. If the selected texture
///     image does not contain four components, the following mappings are applied. Single-component
///     textures are treated as RGBA buffers with red set to the single-component value, green set
///     to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers
///     with red set to the value of component zero, alpha set to the value of component one, and
///     green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with
///     red set to component zero, green set to component one, blue set to component two, and alpha
///     set to 1. To determine the required size of pixels , use glGetTexLevelParameter to determine
///     the dimensions of the internal texture image, then scale the required number of pixels by
///     the storage required for each pixel, based on format and type. Be sure to take the pixel
///     storage parameters into account, especially GL_PACK_ALIGNMENT. If glGetTextureImage is used
///     against a cube map texture object, the texture is treated as a three-dimensional image of a
///     depth of 6, where the cube map faces are ordered as image layers, in an order presented in
///     the table below:
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name.</param>
/// <param name='level'>Specifies the level-of-detail number of the desired image. Level 0 is the
/// base image level. Level</param> <param name='format'>Specifies a pixel format for the returned
/// data. The supported formats are</param> <param name='type'>Specifies a pixel type for the
/// returned data. The supported types are</param> <param name='bufSize'>Specifies the size of the
/// buffer</param> <param name='pixels'>Returns the texture image. Should be a pointer to an array
/// of the type specified by</param>
#define glGetTexImage glad_debug_glGetTexImage
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_debug_glGetTexLevelParameterfv;
#define glGetTexLevelParameterfv glad_debug_glGetTexLevelParameterfv
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_debug_glGetTexLevelParameteriv;
#define glGetTexLevelParameteriv glad_debug_glGetTexLevelParameteriv
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERXVOESPROC glad_glGetTexLevelParameterxvOES;
    GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERXVOESPROC glad_debug_glGetTexLevelParameterxvOES;
#define glGetTexLevelParameterxvOES glad_debug_glGetTexLevelParameterxvOES
    GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
    GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_debug_glGetTexParameterIiv;
#define glGetTexParameterIiv glad_debug_glGetTexParameterIiv
    GLAD_API_CALL PFNGLGETTEXPARAMETERIIVEXTPROC glad_glGetTexParameterIivEXT;
    GLAD_API_CALL PFNGLGETTEXPARAMETERIIVEXTPROC glad_debug_glGetTexParameterIivEXT;
#define glGetTexParameterIivEXT glad_debug_glGetTexParameterIivEXT
    GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
    GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_debug_glGetTexParameterIuiv;
#define glGetTexParameterIuiv glad_debug_glGetTexParameterIuiv
    GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVEXTPROC glad_glGetTexParameterIuivEXT;
    GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVEXTPROC glad_debug_glGetTexParameterIuivEXT;
#define glGetTexParameterIuivEXT glad_debug_glGetTexParameterIuivEXT
    GLAD_API_CALL PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_glGetTexParameterPointervAPPLE;
    GLAD_API_CALL PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_debug_glGetTexParameterPointervAPPLE;
#define glGetTexParameterPointervAPPLE glad_debug_glGetTexParameterPointervAPPLE
    GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
    GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_debug_glGetTexParameterfv;
#define glGetTexParameterfv glad_debug_glGetTexParameterfv
    GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
    GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_debug_glGetTexParameteriv;
#define glGetTexParameteriv glad_debug_glGetTexParameteriv
    GLAD_API_CALL PFNGLGETTEXPARAMETERXVOESPROC glad_glGetTexParameterxvOES;
    GLAD_API_CALL PFNGLGETTEXPARAMETERXVOESPROC glad_debug_glGetTexParameterxvOES;
#define glGetTexParameterxvOES glad_debug_glGetTexParameterxvOES
    GLAD_API_CALL PFNGLGETTEXTUREHANDLEARBPROC glad_glGetTextureHandleARB;
    GLAD_API_CALL PFNGLGETTEXTUREHANDLEARBPROC glad_debug_glGetTextureHandleARB;
#define glGetTextureHandleARB glad_debug_glGetTextureHandleARB
    GLAD_API_CALL PFNGLGETTEXTUREHANDLENVPROC glad_glGetTextureHandleNV;
    GLAD_API_CALL PFNGLGETTEXTUREHANDLENVPROC glad_debug_glGetTextureHandleNV;
#define glGetTextureHandleNV glad_debug_glGetTextureHandleNV
    GLAD_API_CALL PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;
    GLAD_API_CALL PFNGLGETTEXTUREIMAGEPROC glad_debug_glGetTextureImage;
#define glGetTextureImage glad_debug_glGetTextureImage
    GLAD_API_CALL PFNGLGETTEXTUREIMAGEEXTPROC glad_glGetTextureImageEXT;
    GLAD_API_CALL PFNGLGETTEXTUREIMAGEEXTPROC glad_debug_glGetTextureImageEXT;
#define glGetTextureImageEXT glad_debug_glGetTextureImageEXT
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_debug_glGetTextureLevelParameterfv;
#define glGetTextureLevelParameterfv glad_debug_glGetTextureLevelParameterfv
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_glGetTextureLevelParameterfvEXT;
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_debug_glGetTextureLevelParameterfvEXT;
#define glGetTextureLevelParameterfvEXT glad_debug_glGetTextureLevelParameterfvEXT
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_debug_glGetTextureLevelParameteriv;
#define glGetTextureLevelParameteriv glad_debug_glGetTextureLevelParameteriv
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_glGetTextureLevelParameterivEXT;
    GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_debug_glGetTextureLevelParameterivEXT;
#define glGetTextureLevelParameterivEXT glad_debug_glGetTextureLevelParameterivEXT
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVPROC glad_debug_glGetTextureParameterIiv;
#define glGetTextureParameterIiv glad_debug_glGetTextureParameterIiv
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_glGetTextureParameterIivEXT;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_debug_glGetTextureParameterIivEXT;
#define glGetTextureParameterIivEXT glad_debug_glGetTextureParameterIivEXT
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVPROC glad_debug_glGetTextureParameterIuiv;
#define glGetTextureParameterIuiv glad_debug_glGetTextureParameterIuiv
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_glGetTextureParameterIuivEXT;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_debug_glGetTextureParameterIuivEXT;
#define glGetTextureParameterIuivEXT glad_debug_glGetTextureParameterIuivEXT
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVPROC glad_debug_glGetTextureParameterfv;
#define glGetTextureParameterfv glad_debug_glGetTextureParameterfv
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_glGetTextureParameterfvEXT;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_debug_glGetTextureParameterfvEXT;
#define glGetTextureParameterfvEXT glad_debug_glGetTextureParameterfvEXT
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVPROC glad_debug_glGetTextureParameteriv;
#define glGetTextureParameteriv glad_debug_glGetTextureParameteriv
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_glGetTextureParameterivEXT;
    GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_debug_glGetTextureParameterivEXT;
#define glGetTextureParameterivEXT glad_debug_glGetTextureParameterivEXT
    GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_glGetTextureSamplerHandleARB;
    GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_debug_glGetTextureSamplerHandleARB;
#define glGetTextureSamplerHandleARB glad_debug_glGetTextureSamplerHandleARB
    GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_glGetTextureSamplerHandleNV;
    GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_debug_glGetTextureSamplerHandleNV;
#define glGetTextureSamplerHandleNV glad_debug_glGetTextureSamplerHandleNV
    GLAD_API_CALL PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;
    GLAD_API_CALL PFNGLGETTEXTURESUBIMAGEPROC glad_debug_glGetTextureSubImage;

/// <summary>
///   retrieve a sub-region of a texture image from a texture object
///   <para>
///     glGetTextureSubImage returns a texture subimage into pixels. texture is the name of the
///     source texture object and must not be a buffer or multisample texture. The effective target
///     parameter is the value of GL_TEXTURE_TARGET for texture. Level , format , type and pixels
///     have the same meaning as for glGetTexImage. bufSize is the size of the buffer to receive the
///     retrieved pixel data. For cube map textures, the behavior is as though GetTextureImage were
///     called, but only texels from the requested cube map faces (selected by zoffset and depth ,
///     as described below) were returned. xoffset , yoffset and zoffset values indicate the
///     position of the subregion to return. width , height and depth indicate the size of the
///     region to return. These parameters have the same meaning as for glTexSubImage3D , though for
///     one- and two-dimensional textures there are extra restrictions, described in the errors
///     section below. For one-dimensional array textures, yoffset is interpreted as the first layer
///     to access and height is the number of layers to access. For two-dimensional array textures,
///     zoffset is interpreted as the first layer to access and depth is the number of layers to
///     access. Cube map textures are treated as an array of six slices in the z-dimension, where
///     the value of zoffset is interpreted as specifying the cube map face for the corresponding
///     layer (as presented in the table below) and depth is the number of faces to access: For cube
///     map array textures, zoffset is the first layer-face to access, and depth is the number of
///     layer-faces to access. A layer-face described by $k$ is translated into an array layer and
///     face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k
///     \bmod 6. $$ Component groups from the specified sub-region are packed and placed into memory
///     as described for glGetTextureImage , starting with the texel at ( xoffset , yoffset ,
///     zoffset ).
///   </para>
/// </summary>
/// <param name='texture'>Specifies the name of the source texture object. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level. Level
/// $n$ is the $n$th mipmap reduction image.</param> <param name='xoffset'>Specifies a texel offset
/// in the x direction within the texture array.</param> <param name='yoffset'>Specifies a texel
/// offset in the y direction within the texture array.</param> <param name='zoffset'>Specifies a
/// texel offset in the z direction within the texture array.</param> <param name='width'>Specifies
/// the width of the texture subimage.</param> <param name='height'>Specifies the height of the
/// texture subimage.</param> <param name='depth'>Specifies the depth of the texture
/// subimage.</param> <param name='format'>Specifies the format of the pixel data. The following
/// symbolic values are accepted:</param> <param name='type'>Specifies the data type of the pixel
/// data. The following symbolic values are accepted:</param> <param name='bufSize'>Specifies the
/// size of the buffer to receive the retrieved pixel data.</param> <param name='pixels'>Returns the
/// texture subimage. Should be a pointer to an array of the type specified by</param>
#define glGetTextureSubImage glad_debug_glGetTextureSubImage
    GLAD_API_CALL PFNGLGETTRACKMATRIXIVNVPROC glad_glGetTrackMatrixivNV;
    GLAD_API_CALL PFNGLGETTRACKMATRIXIVNVPROC glad_debug_glGetTrackMatrixivNV;
#define glGetTrackMatrixivNV glad_debug_glGetTrackMatrixivNV
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_debug_glGetTransformFeedbackVarying;

/// <summary>
///   retrieve information about varying variables selected for transform feedback
///   <para>
///     Information about the set of varying variables in a linked program that will be captured
///     during transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
///     glGetTransformFeedbackVarying provides information about the varying variable selected by
///     index. An index of 0 selects the first varying variable specified in the varyings array
///     passed to glTransformFeedbackVaryings , and an index of the value of
///     GL_TRANSFORM_FEEDBACK_VARYINGS minus one selects the last such variable. The name of the
///     selected varying is returned as a null-terminated string in name. The actual number of
///     characters written into name , excluding the null terminator, is returned in length. If
///     length is NULL, no length is returned. The maximum number of characters that may be written
///     into name , including the null terminator, is specified by bufSize. The length of the
///     longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH , which
///     can be queried with glGetProgram. For the selected varying variable, its type is returned
///     into type. The size of the varying is returned into size. The value in size is in units of
///     the type returned in type. The type returned can be any of the scalar, vector, or matrix
///     attribute types returned by glGetActiveAttrib. If an error occurred, the return parameters
///     length , size , type and name will be unmodified. This command will return as much
///     information about the varying variables as possible. If no information is available, length
///     will be set to zero and name will be an empty string. This situation could arise if
///     glGetTransformFeedbackVarying is called after a failed link.
///   </para>
/// </summary>
/// <param name='program'>The name of the target program object.</param>
/// <param name='index'>The index of the varying variable whose information to retrieve.</param>
/// <param name='bufSize'>The maximum number of characters, including the null terminator, that may
/// be written into</param> <param name='length'>The address of a variable which will receive the
/// number of characters written into</param> <param name='size'>The address of a variable that will
/// receive the size of the varying.</param> <param name='type'>The address of a variable that will
/// recieve the type of the varying.</param> <param name='name'>The address of a buffer into which
/// will be written the name of the varying.</param>
#define glGetTransformFeedbackVarying glad_debug_glGetTransformFeedbackVarying
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC glad_glGetTransformFeedbackVaryingEXT;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC
        glad_debug_glGetTransformFeedbackVaryingEXT;
#define glGetTransformFeedbackVaryingEXT glad_debug_glGetTransformFeedbackVaryingEXT
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_glGetTransformFeedbackVaryingNV;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_debug_glGetTransformFeedbackVaryingNV;
#define glGetTransformFeedbackVaryingNV glad_debug_glGetTransformFeedbackVaryingNV
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_debug_glGetTransformFeedbacki64_v;
#define glGetTransformFeedbacki64_v glad_debug_glGetTransformFeedbacki64_v
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_debug_glGetTransformFeedbacki_v;
#define glGetTransformFeedbacki_v glad_debug_glGetTransformFeedbacki_v
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;
    GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKIVPROC glad_debug_glGetTransformFeedbackiv;
#define glGetTransformFeedbackiv glad_debug_glGetTransformFeedbackiv
    GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
    GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_debug_glGetUniformBlockIndex;

/// <summary>
///   retrieve the index of a named uniform block
///   <para>
///     glGetUniformBlockIndex retrieves the index of a uniform block within program. program must
///     be the name of a program object for which the command glLinkProgram must have been called in
///     the past, although it is not required that glLinkProgram must have succeeded. The link could
///     have failed because the number of active uniforms exceeded the limit. uniformBlockName must
///     contain a nul-terminated string specifying the name of the uniform block.
///     glGetUniformBlockIndex returns the uniform block index for the uniform block named
///     uniformBlockName of program. If uniformBlockName does not identify an active uniform block
///     of program , glGetUniformBlockIndex returns the special identifier, GL_INVALID_INDEX.
///     Indices of the active uniform blocks of a program are assigned in consecutive order,
///     beginning with zero.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of a program containing the uniform block.</param>
/// <param name='uniformBlockName'>Specifies the address an array of characters to containing the
/// name of the uniform block whose index to retrieve.</param>
#define glGetUniformBlockIndex glad_debug_glGetUniformBlockIndex
    GLAD_API_CALL PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_glGetUniformBufferSizeEXT;
    GLAD_API_CALL PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_debug_glGetUniformBufferSizeEXT;
#define glGetUniformBufferSizeEXT glad_debug_glGetUniformBufferSizeEXT
    GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
    GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_debug_glGetUniformIndices;

/// <summary>
///   retrieve the index of a named uniform block
///   <para>
///     glGetUniformIndices retrieves the indices of a number of uniforms within program. program
///     must be the name of a program object for which the command glLinkProgram must have been
///     called in the past, although it is not required that glLinkProgram must have succeeded. The
///     link could have failed because the number of active uniforms exceeded the limit.
///     uniformCount indicates both the number of elements in the array of names uniformNames and
///     the number of indices that may be written to uniformIndices. uniformNames contains a list of
///     uniformCount name strings identifying the uniform names to be queried for indices. For each
///     name string in uniformNames , the index assigned to the active uniform of that name will be
///     written to the corresponding element of uniformIndices. If a string in uniformNames is not
///     the name of an active uniform, the special value GL_INVALID_INDEX will be written to the
///     corresponding element of uniformIndices. If an error occurs, nothing is written to
///     uniformIndices.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of a program containing uniforms whose indices to
/// query.</param> <param name='uniformCount'>Specifies the number of uniforms whose indices to
/// query.</param> <param name='uniformNames'>Specifies the address of an array of pointers to
/// buffers containing the names of the queried uniforms.</param> <param
/// name='uniformIndices'>Specifies the address of an array that will receive the indices of the
/// uniforms.</param>
#define glGetUniformIndices glad_debug_glGetUniformIndices
    GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
    GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_debug_glGetUniformLocation;

/// <summary>
///   Returns the location of a uniform variable
///   <para>
///     glGetUniformLocation returns an integer that represents the location of a specific uniform
///     variable within a program object. name must be a null terminated string that contains no
///     white space. name must be an active uniform variable name in program that is not a
///     structure, an array of structures, or a subcomponent of a vector or a matrix. This function
///     returns -1 if name does not correspond to an active uniform variable in program , if name
///     starts with the reserved prefix "gl_", or if name is associated with an atomic counter or a
///     named uniform block. Uniform variables that are structures or arrays of structures may be
///     queried by calling glGetUniformLocation for each field within the structure. The array
///     element operator "[]" and the structure field operator "." may be used in name in order to
///     select elements within an array or fields within a structure. The result of using these
///     operators is not allowed to be another structure, an array of structures, or a subcomponent
///     of a vector or a matrix. Except if the last part of name indicates a uniform variable array,
///     the location of the first element of an array can be retrieved by using the name of the
///     array, or by using the name appended by "[0]". The actual locations assigned to uniform
///     variables are not known until the program object is linked successfully. After linking has
///     occurred, the command glGetUniformLocation can be used to obtain the location of a uniform
///     variable. This location value can then be passed to glUniform to set the value of the
///     uniform variable or to glGetUniform in order to query the current value of the uniform
///     variable. After a program object has been linked successfully, the index values for uniform
///     variables remain fixed until the next link command occurs. Uniform variable locations and
///     values can only be queried after a link if the link was successful.
///   </para>
/// </summary>
/// <param name='program'>Specifies the program object to be queried.</param>
/// <param name='name'>Points to a null terminated string containing the name of the uniform
/// variable whose location is to be queried.</param>
#define glGetUniformLocation glad_debug_glGetUniformLocation
    GLAD_API_CALL PFNGLGETUNIFORMLOCATIONARBPROC glad_glGetUniformLocationARB;
    GLAD_API_CALL PFNGLGETUNIFORMLOCATIONARBPROC glad_debug_glGetUniformLocationARB;
#define glGetUniformLocationARB glad_debug_glGetUniformLocationARB
    GLAD_API_CALL PFNGLGETUNIFORMOFFSETEXTPROC glad_glGetUniformOffsetEXT;
    GLAD_API_CALL PFNGLGETUNIFORMOFFSETEXTPROC glad_debug_glGetUniformOffsetEXT;
#define glGetUniformOffsetEXT glad_debug_glGetUniformOffsetEXT
    GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
    GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_debug_glGetUniformSubroutineuiv;
#define glGetUniformSubroutineuiv glad_debug_glGetUniformSubroutineuiv
    GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
    GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_debug_glGetUniformdv;
#define glGetUniformdv glad_debug_glGetUniformdv
    GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
    GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_debug_glGetUniformfv;
#define glGetUniformfv glad_debug_glGetUniformfv
    GLAD_API_CALL PFNGLGETUNIFORMFVARBPROC glad_glGetUniformfvARB;
    GLAD_API_CALL PFNGLGETUNIFORMFVARBPROC glad_debug_glGetUniformfvARB;
#define glGetUniformfvARB glad_debug_glGetUniformfvARB
    GLAD_API_CALL PFNGLGETUNIFORMI64VARBPROC glad_glGetUniformi64vARB;
    GLAD_API_CALL PFNGLGETUNIFORMI64VARBPROC glad_debug_glGetUniformi64vARB;
#define glGetUniformi64vARB glad_debug_glGetUniformi64vARB
    GLAD_API_CALL PFNGLGETUNIFORMI64VNVPROC glad_glGetUniformi64vNV;
    GLAD_API_CALL PFNGLGETUNIFORMI64VNVPROC glad_debug_glGetUniformi64vNV;
#define glGetUniformi64vNV glad_debug_glGetUniformi64vNV
    GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
    GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_debug_glGetUniformiv;
#define glGetUniformiv glad_debug_glGetUniformiv
    GLAD_API_CALL PFNGLGETUNIFORMIVARBPROC glad_glGetUniformivARB;
    GLAD_API_CALL PFNGLGETUNIFORMIVARBPROC glad_debug_glGetUniformivARB;
#define glGetUniformivARB glad_debug_glGetUniformivARB
    GLAD_API_CALL PFNGLGETUNIFORMUI64VARBPROC glad_glGetUniformui64vARB;
    GLAD_API_CALL PFNGLGETUNIFORMUI64VARBPROC glad_debug_glGetUniformui64vARB;
#define glGetUniformui64vARB glad_debug_glGetUniformui64vARB
    GLAD_API_CALL PFNGLGETUNIFORMUI64VNVPROC glad_glGetUniformui64vNV;
    GLAD_API_CALL PFNGLGETUNIFORMUI64VNVPROC glad_debug_glGetUniformui64vNV;
#define glGetUniformui64vNV glad_debug_glGetUniformui64vNV
    GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
    GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_debug_glGetUniformuiv;
#define glGetUniformuiv glad_debug_glGetUniformuiv
    GLAD_API_CALL PFNGLGETUNIFORMUIVEXTPROC glad_glGetUniformuivEXT;
    GLAD_API_CALL PFNGLGETUNIFORMUIVEXTPROC glad_debug_glGetUniformuivEXT;
#define glGetUniformuivEXT glad_debug_glGetUniformuivEXT
    GLAD_API_CALL PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_glGetUnsignedBytei_vEXT;
    GLAD_API_CALL PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_debug_glGetUnsignedBytei_vEXT;
#define glGetUnsignedBytei_vEXT glad_debug_glGetUnsignedBytei_vEXT
    GLAD_API_CALL PFNGLGETUNSIGNEDBYTEVEXTPROC glad_glGetUnsignedBytevEXT;
    GLAD_API_CALL PFNGLGETUNSIGNEDBYTEVEXTPROC glad_debug_glGetUnsignedBytevEXT;
#define glGetUnsignedBytevEXT glad_debug_glGetUnsignedBytevEXT
    GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_glGetVariantArrayObjectfvATI;
    GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_debug_glGetVariantArrayObjectfvATI;
#define glGetVariantArrayObjectfvATI glad_debug_glGetVariantArrayObjectfvATI
    GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_glGetVariantArrayObjectivATI;
    GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_debug_glGetVariantArrayObjectivATI;
#define glGetVariantArrayObjectivATI glad_debug_glGetVariantArrayObjectivATI
    GLAD_API_CALL PFNGLGETVARIANTBOOLEANVEXTPROC glad_glGetVariantBooleanvEXT;
    GLAD_API_CALL PFNGLGETVARIANTBOOLEANVEXTPROC glad_debug_glGetVariantBooleanvEXT;
#define glGetVariantBooleanvEXT glad_debug_glGetVariantBooleanvEXT
    GLAD_API_CALL PFNGLGETVARIANTFLOATVEXTPROC glad_glGetVariantFloatvEXT;
    GLAD_API_CALL PFNGLGETVARIANTFLOATVEXTPROC glad_debug_glGetVariantFloatvEXT;
#define glGetVariantFloatvEXT glad_debug_glGetVariantFloatvEXT
    GLAD_API_CALL PFNGLGETVARIANTINTEGERVEXTPROC glad_glGetVariantIntegervEXT;
    GLAD_API_CALL PFNGLGETVARIANTINTEGERVEXTPROC glad_debug_glGetVariantIntegervEXT;
#define glGetVariantIntegervEXT glad_debug_glGetVariantIntegervEXT
    GLAD_API_CALL PFNGLGETVARIANTPOINTERVEXTPROC glad_glGetVariantPointervEXT;
    GLAD_API_CALL PFNGLGETVARIANTPOINTERVEXTPROC glad_debug_glGetVariantPointervEXT;
#define glGetVariantPointervEXT glad_debug_glGetVariantPointervEXT
    GLAD_API_CALL PFNGLGETVARYINGLOCATIONNVPROC glad_glGetVaryingLocationNV;
    GLAD_API_CALL PFNGLGETVARYINGLOCATIONNVPROC glad_debug_glGetVaryingLocationNV;
#define glGetVaryingLocationNV glad_debug_glGetVaryingLocationNV
    GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;
    GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_debug_glGetVertexArrayIndexed64iv;
#define glGetVertexArrayIndexed64iv glad_debug_glGetVertexArrayIndexed64iv
    GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;
    GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_debug_glGetVertexArrayIndexediv;
#define glGetVertexArrayIndexediv glad_debug_glGetVertexArrayIndexediv
    GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_glGetVertexArrayIntegeri_vEXT;
    GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_debug_glGetVertexArrayIntegeri_vEXT;
#define glGetVertexArrayIntegeri_vEXT glad_debug_glGetVertexArrayIntegeri_vEXT
    GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_glGetVertexArrayIntegervEXT;
    GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_debug_glGetVertexArrayIntegervEXT;
#define glGetVertexArrayIntegervEXT glad_debug_glGetVertexArrayIntegervEXT
    GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_glGetVertexArrayPointeri_vEXT;
    GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_debug_glGetVertexArrayPointeri_vEXT;
#define glGetVertexArrayPointeri_vEXT glad_debug_glGetVertexArrayPointeri_vEXT
    GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_glGetVertexArrayPointervEXT;
    GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_debug_glGetVertexArrayPointervEXT;
#define glGetVertexArrayPointervEXT glad_debug_glGetVertexArrayPointervEXT
    GLAD_API_CALL PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;
    GLAD_API_CALL PFNGLGETVERTEXARRAYIVPROC glad_debug_glGetVertexArrayiv;

/// <summary>
///   retrieve parameters of a vertex array object
///   <para>
///     This function provides a mean of querying properties of an existing vertex array object. The
///     vertex array object does not have to be bound to the rendering context at the time of the
///     call, but must have been bound at least once prior to this call. glGetVertexArrayiv can be
///     used to retrieve ID of a buffer object that will be bound to the GL_ELEMENT_ARRAY_BUFFER
///     binding point whenever the queried vertex array object is bound to the rendering context.
///     The binding can be changed for an active vertex array object with a glBindBuffer call.
///   </para>
/// </summary>
/// <param name='vaobj'>specifies the name of the vertex array object to use for the query.</param>
/// <param name='pname'>Name of the property to use for the query. Must be</param>
/// <param name='param'>Returns the requested value.</param>
#define glGetVertexArrayiv glad_debug_glGetVertexArrayiv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC glad_glGetVertexAttribArrayObjectfvATI;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC
        glad_debug_glGetVertexAttribArrayObjectfvATI;
#define glGetVertexAttribArrayObjectfvATI glad_debug_glGetVertexAttribArrayObjectfvATI
    GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC glad_glGetVertexAttribArrayObjectivATI;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC
        glad_debug_glGetVertexAttribArrayObjectivATI;
#define glGetVertexAttribArrayObjectivATI glad_debug_glGetVertexAttribArrayObjectivATI
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_debug_glGetVertexAttribIiv;
#define glGetVertexAttribIiv glad_debug_glGetVertexAttribIiv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVEXTPROC glad_glGetVertexAttribIivEXT;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVEXTPROC glad_debug_glGetVertexAttribIivEXT;
#define glGetVertexAttribIivEXT glad_debug_glGetVertexAttribIivEXT
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_debug_glGetVertexAttribIuiv;
#define glGetVertexAttribIuiv glad_debug_glGetVertexAttribIuiv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_glGetVertexAttribIuivEXT;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_debug_glGetVertexAttribIuivEXT;
#define glGetVertexAttribIuivEXT glad_debug_glGetVertexAttribIuivEXT
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVPROC glad_debug_glGetVertexAttribLdv;
#define glGetVertexAttribLdv glad_debug_glGetVertexAttribLdv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVEXTPROC glad_glGetVertexAttribLdvEXT;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVEXTPROC glad_debug_glGetVertexAttribLdvEXT;
#define glGetVertexAttribLdvEXT glad_debug_glGetVertexAttribLdvEXT
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLI64VNVPROC glad_glGetVertexAttribLi64vNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLI64VNVPROC glad_debug_glGetVertexAttribLi64vNV;
#define glGetVertexAttribLi64vNV glad_debug_glGetVertexAttribLi64vNV
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_glGetVertexAttribLui64vARB;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_debug_glGetVertexAttribLui64vARB;
#define glGetVertexAttribLui64vARB glad_debug_glGetVertexAttribLui64vARB
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_glGetVertexAttribLui64vNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_debug_glGetVertexAttribLui64vNV;
#define glGetVertexAttribLui64vNV glad_debug_glGetVertexAttribLui64vNV
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_debug_glGetVertexAttribPointerv;

/// <summary>
///   return the address of the specified generic vertex attribute pointer
///   <para>
///     glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute
///     to be queried, pname is a symbolic constant indicating the pointer to be returned, and
///     params is a pointer to a location in which to place the returned data. The pointer returned
///     is a byte offset into the data store of the buffer object that was bound to the
///     GL_ARRAY_BUFFER target (see glBindBuffer ) when the desired pointer was previously
///     specified.
///   </para>
/// </summary>
/// <param name='index'>Specifies the generic vertex attribute parameter to be returned.</param>
/// <param name='pname'>Specifies the symbolic name of the generic vertex attribute parameter to be
/// returned. Must be</param> <param name='pointer'>Returns the pointer value.</param>
#define glGetVertexAttribPointerv glad_debug_glGetVertexAttribPointerv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_glGetVertexAttribPointervARB;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_debug_glGetVertexAttribPointervARB;
#define glGetVertexAttribPointervARB glad_debug_glGetVertexAttribPointervARB
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_glGetVertexAttribPointervNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_debug_glGetVertexAttribPointervNV;
#define glGetVertexAttribPointervNV glad_debug_glGetVertexAttribPointervNV
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_debug_glGetVertexAttribdv;
#define glGetVertexAttribdv glad_debug_glGetVertexAttribdv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVARBPROC glad_glGetVertexAttribdvARB;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVARBPROC glad_debug_glGetVertexAttribdvARB;
#define glGetVertexAttribdvARB glad_debug_glGetVertexAttribdvARB
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVNVPROC glad_glGetVertexAttribdvNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBDVNVPROC glad_debug_glGetVertexAttribdvNV;
#define glGetVertexAttribdvNV glad_debug_glGetVertexAttribdvNV
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_debug_glGetVertexAttribfv;
#define glGetVertexAttribfv glad_debug_glGetVertexAttribfv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVARBPROC glad_glGetVertexAttribfvARB;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVARBPROC glad_debug_glGetVertexAttribfvARB;
#define glGetVertexAttribfvARB glad_debug_glGetVertexAttribfvARB
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVNVPROC glad_glGetVertexAttribfvNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBFVNVPROC glad_debug_glGetVertexAttribfvNV;
#define glGetVertexAttribfvNV glad_debug_glGetVertexAttribfvNV
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_debug_glGetVertexAttribiv;
#define glGetVertexAttribiv glad_debug_glGetVertexAttribiv
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVARBPROC glad_glGetVertexAttribivARB;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVARBPROC glad_debug_glGetVertexAttribivARB;
#define glGetVertexAttribivARB glad_debug_glGetVertexAttribivARB
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVNVPROC glad_glGetVertexAttribivNV;
    GLAD_API_CALL PFNGLGETVERTEXATTRIBIVNVPROC glad_debug_glGetVertexAttribivNV;
#define glGetVertexAttribivNV glad_debug_glGetVertexAttribivNV
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_glGetVideoCaptureStreamdvNV;
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_debug_glGetVideoCaptureStreamdvNV;
#define glGetVideoCaptureStreamdvNV glad_debug_glGetVideoCaptureStreamdvNV
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_glGetVideoCaptureStreamfvNV;
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_debug_glGetVideoCaptureStreamfvNV;
#define glGetVideoCaptureStreamfvNV glad_debug_glGetVideoCaptureStreamfvNV
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_glGetVideoCaptureStreamivNV;
    GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_debug_glGetVideoCaptureStreamivNV;
#define glGetVideoCaptureStreamivNV glad_debug_glGetVideoCaptureStreamivNV
    GLAD_API_CALL PFNGLGETVIDEOCAPTUREIVNVPROC glad_glGetVideoCaptureivNV;
    GLAD_API_CALL PFNGLGETVIDEOCAPTUREIVNVPROC glad_debug_glGetVideoCaptureivNV;
#define glGetVideoCaptureivNV glad_debug_glGetVideoCaptureivNV
    GLAD_API_CALL PFNGLGETVIDEOI64VNVPROC glad_glGetVideoi64vNV;
    GLAD_API_CALL PFNGLGETVIDEOI64VNVPROC glad_debug_glGetVideoi64vNV;
#define glGetVideoi64vNV glad_debug_glGetVideoi64vNV
    GLAD_API_CALL PFNGLGETVIDEOIVNVPROC glad_glGetVideoivNV;
    GLAD_API_CALL PFNGLGETVIDEOIVNVPROC glad_debug_glGetVideoivNV;
#define glGetVideoivNV glad_debug_glGetVideoivNV
    GLAD_API_CALL PFNGLGETVIDEOUI64VNVPROC glad_glGetVideoui64vNV;
    GLAD_API_CALL PFNGLGETVIDEOUI64VNVPROC glad_debug_glGetVideoui64vNV;
#define glGetVideoui64vNV glad_debug_glGetVideoui64vNV
    GLAD_API_CALL PFNGLGETVIDEOUIVNVPROC glad_glGetVideouivNV;
    GLAD_API_CALL PFNGLGETVIDEOUIVNVPROC glad_debug_glGetVideouivNV;
#define glGetVideouivNV glad_debug_glGetVideouivNV
    GLAD_API_CALL PFNGLGETVKPROCADDRNVPROC glad_glGetVkProcAddrNV;
    GLAD_API_CALL PFNGLGETVKPROCADDRNVPROC glad_debug_glGetVkProcAddrNV;
#define glGetVkProcAddrNV glad_debug_glGetVkProcAddrNV
    GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;
    GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_debug_glGetnCompressedTexImage;
#define glGetnCompressedTexImage glad_debug_glGetnCompressedTexImage
    GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB;
    GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_debug_glGetnCompressedTexImageARB;
#define glGetnCompressedTexImageARB glad_debug_glGetnCompressedTexImageARB
    GLAD_API_CALL PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;
    GLAD_API_CALL PFNGLGETNTEXIMAGEPROC glad_debug_glGetnTexImage;
#define glGetnTexImage glad_debug_glGetnTexImage
    GLAD_API_CALL PFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB;
    GLAD_API_CALL PFNGLGETNTEXIMAGEARBPROC glad_debug_glGetnTexImageARB;
#define glGetnTexImageARB glad_debug_glGetnTexImageARB
    GLAD_API_CALL PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;
    GLAD_API_CALL PFNGLGETNUNIFORMDVPROC glad_debug_glGetnUniformdv;
#define glGetnUniformdv glad_debug_glGetnUniformdv
    GLAD_API_CALL PFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB;
    GLAD_API_CALL PFNGLGETNUNIFORMDVARBPROC glad_debug_glGetnUniformdvARB;
#define glGetnUniformdvARB glad_debug_glGetnUniformdvARB
    GLAD_API_CALL PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;
    GLAD_API_CALL PFNGLGETNUNIFORMFVPROC glad_debug_glGetnUniformfv;
#define glGetnUniformfv glad_debug_glGetnUniformfv
    GLAD_API_CALL PFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB;
    GLAD_API_CALL PFNGLGETNUNIFORMFVARBPROC glad_debug_glGetnUniformfvARB;
#define glGetnUniformfvARB glad_debug_glGetnUniformfvARB
    GLAD_API_CALL PFNGLGETNUNIFORMI64VARBPROC glad_glGetnUniformi64vARB;
    GLAD_API_CALL PFNGLGETNUNIFORMI64VARBPROC glad_debug_glGetnUniformi64vARB;
#define glGetnUniformi64vARB glad_debug_glGetnUniformi64vARB
    GLAD_API_CALL PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;
    GLAD_API_CALL PFNGLGETNUNIFORMIVPROC glad_debug_glGetnUniformiv;
#define glGetnUniformiv glad_debug_glGetnUniformiv
    GLAD_API_CALL PFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB;
    GLAD_API_CALL PFNGLGETNUNIFORMIVARBPROC glad_debug_glGetnUniformivARB;
#define glGetnUniformivARB glad_debug_glGetnUniformivARB
    GLAD_API_CALL PFNGLGETNUNIFORMUI64VARBPROC glad_glGetnUniformui64vARB;
    GLAD_API_CALL PFNGLGETNUNIFORMUI64VARBPROC glad_debug_glGetnUniformui64vARB;
#define glGetnUniformui64vARB glad_debug_glGetnUniformui64vARB
    GLAD_API_CALL PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;
    GLAD_API_CALL PFNGLGETNUNIFORMUIVPROC glad_debug_glGetnUniformuiv;
#define glGetnUniformuiv glad_debug_glGetnUniformuiv
    GLAD_API_CALL PFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB;
    GLAD_API_CALL PFNGLGETNUNIFORMUIVARBPROC glad_debug_glGetnUniformuivARB;
#define glGetnUniformuivARB glad_debug_glGetnUniformuivARB
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORBSUNPROC glad_glGlobalAlphaFactorbSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORBSUNPROC glad_debug_glGlobalAlphaFactorbSUN;
#define glGlobalAlphaFactorbSUN glad_debug_glGlobalAlphaFactorbSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORDSUNPROC glad_glGlobalAlphaFactordSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORDSUNPROC glad_debug_glGlobalAlphaFactordSUN;
#define glGlobalAlphaFactordSUN glad_debug_glGlobalAlphaFactordSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORFSUNPROC glad_glGlobalAlphaFactorfSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORFSUNPROC glad_debug_glGlobalAlphaFactorfSUN;
#define glGlobalAlphaFactorfSUN glad_debug_glGlobalAlphaFactorfSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORISUNPROC glad_glGlobalAlphaFactoriSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORISUNPROC glad_debug_glGlobalAlphaFactoriSUN;
#define glGlobalAlphaFactoriSUN glad_debug_glGlobalAlphaFactoriSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORSSUNPROC glad_glGlobalAlphaFactorsSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORSSUNPROC glad_debug_glGlobalAlphaFactorsSUN;
#define glGlobalAlphaFactorsSUN glad_debug_glGlobalAlphaFactorsSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUBSUNPROC glad_glGlobalAlphaFactorubSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUBSUNPROC glad_debug_glGlobalAlphaFactorubSUN;
#define glGlobalAlphaFactorubSUN glad_debug_glGlobalAlphaFactorubSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUISUNPROC glad_glGlobalAlphaFactoruiSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUISUNPROC glad_debug_glGlobalAlphaFactoruiSUN;
#define glGlobalAlphaFactoruiSUN glad_debug_glGlobalAlphaFactoruiSUN
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUSSUNPROC glad_glGlobalAlphaFactorusSUN;
    GLAD_API_CALL PFNGLGLOBALALPHAFACTORUSSUNPROC glad_debug_glGlobalAlphaFactorusSUN;
#define glGlobalAlphaFactorusSUN glad_debug_glGlobalAlphaFactorusSUN
    GLAD_API_CALL PFNGLHINTPROC glad_glHint;
    GLAD_API_CALL PFNGLHINTPROC glad_debug_glHint;

/// <summary>
///   specify implementation-specific hints
///   <para>
///     Certain aspects of GL behavior, when there is room for interpretation, can be controlled
///     with hints. A hint is specified with two arguments. target is a symbolic constant indicating
///     the behavior to be controlled, and mode is another symbolic constant indicating the desired
///     behavior. The initial value for each target is GL_DONT_CARE. mode can be one of the
///     following: The most efficient option should be chosen. The most correct, or highest quality,
///     option should be chosen. No preference. Though the implementation aspects that can be hinted
///     are well defined, the interpretation of the hints depends on the implementation. The hint
///     aspects that can be specified with target , along with suggested semantics, are as follows:
///     Indicates the accuracy of the derivative calculation for the GL shading language fragment
///     processing built-in functions: dFdx , dFdy , and fwidth. Indicates the sampling quality of
///     antialiased lines. If a larger filter function is applied, hinting GL_NICEST can result in
///     more pixel fragments being generated during rasterization. Indicates the sampling quality of
///     antialiased polygons. Hinting GL_NICEST can result in more pixel fragments being generated
///     during rasterization, if a larger filter function is applied. Indicates the quality and
///     performance of the compressing texture images. Hinting GL_FASTEST indicates that texture
///     images should be compressed as quickly as possible, while GL_NICEST indicates that texture
///     images should be compressed with as little image quality loss as possible. GL_NICEST should
///     be selected if the texture is to be retrieved by glGetCompressedTexImage for reuse.
///   </para>
/// </summary>
/// <param name='target'>Specifies a symbolic constant indicating the behavior to be
/// controlled.</param> <param name='mode'>Specifies a symbolic constant indicating the desired
/// behavior.</param>
#define glHint glad_debug_glHint
    GLAD_API_CALL PFNGLHINTPGIPROC glad_glHintPGI;
    GLAD_API_CALL PFNGLHINTPGIPROC glad_debug_glHintPGI;
#define glHintPGI glad_debug_glHintPGI
    GLAD_API_CALL PFNGLHISTOGRAMEXTPROC glad_glHistogramEXT;
    GLAD_API_CALL PFNGLHISTOGRAMEXTPROC glad_debug_glHistogramEXT;
#define glHistogramEXT glad_debug_glHistogramEXT
    GLAD_API_CALL PFNGLIGLOOINTERFACESGIXPROC glad_glIglooInterfaceSGIX;
    GLAD_API_CALL PFNGLIGLOOINTERFACESGIXPROC glad_debug_glIglooInterfaceSGIX;
#define glIglooInterfaceSGIX glad_debug_glIglooInterfaceSGIX
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERFHPPROC glad_glImageTransformParameterfHP;
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERFHPPROC glad_debug_glImageTransformParameterfHP;
#define glImageTransformParameterfHP glad_debug_glImageTransformParameterfHP
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERFVHPPROC glad_glImageTransformParameterfvHP;
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERFVHPPROC glad_debug_glImageTransformParameterfvHP;
#define glImageTransformParameterfvHP glad_debug_glImageTransformParameterfvHP
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERIHPPROC glad_glImageTransformParameteriHP;
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERIHPPROC glad_debug_glImageTransformParameteriHP;
#define glImageTransformParameteriHP glad_debug_glImageTransformParameteriHP
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERIVHPPROC glad_glImageTransformParameterivHP;
    GLAD_API_CALL PFNGLIMAGETRANSFORMPARAMETERIVHPPROC glad_debug_glImageTransformParameterivHP;
#define glImageTransformParameterivHP glad_debug_glImageTransformParameterivHP
    GLAD_API_CALL PFNGLIMPORTMEMORYFDEXTPROC glad_glImportMemoryFdEXT;
    GLAD_API_CALL PFNGLIMPORTMEMORYFDEXTPROC glad_debug_glImportMemoryFdEXT;
#define glImportMemoryFdEXT glad_debug_glImportMemoryFdEXT
    GLAD_API_CALL PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_glImportMemoryWin32HandleEXT;
    GLAD_API_CALL PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_debug_glImportMemoryWin32HandleEXT;
#define glImportMemoryWin32HandleEXT glad_debug_glImportMemoryWin32HandleEXT
    GLAD_API_CALL PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_glImportMemoryWin32NameEXT;
    GLAD_API_CALL PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_debug_glImportMemoryWin32NameEXT;
#define glImportMemoryWin32NameEXT glad_debug_glImportMemoryWin32NameEXT
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREFDEXTPROC glad_glImportSemaphoreFdEXT;
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREFDEXTPROC glad_debug_glImportSemaphoreFdEXT;
#define glImportSemaphoreFdEXT glad_debug_glImportSemaphoreFdEXT
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_glImportSemaphoreWin32HandleEXT;
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_debug_glImportSemaphoreWin32HandleEXT;
#define glImportSemaphoreWin32HandleEXT glad_debug_glImportSemaphoreWin32HandleEXT
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_glImportSemaphoreWin32NameEXT;
    GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_debug_glImportSemaphoreWin32NameEXT;
#define glImportSemaphoreWin32NameEXT glad_debug_glImportSemaphoreWin32NameEXT
    GLAD_API_CALL PFNGLIMPORTSYNCEXTPROC glad_glImportSyncEXT;
    GLAD_API_CALL PFNGLIMPORTSYNCEXTPROC glad_debug_glImportSyncEXT;
#define glImportSyncEXT glad_debug_glImportSyncEXT
    GLAD_API_CALL PFNGLINDEXFORMATNVPROC glad_glIndexFormatNV;
    GLAD_API_CALL PFNGLINDEXFORMATNVPROC glad_debug_glIndexFormatNV;
#define glIndexFormatNV glad_debug_glIndexFormatNV
    GLAD_API_CALL PFNGLINDEXFUNCEXTPROC glad_glIndexFuncEXT;
    GLAD_API_CALL PFNGLINDEXFUNCEXTPROC glad_debug_glIndexFuncEXT;
#define glIndexFuncEXT glad_debug_glIndexFuncEXT
    GLAD_API_CALL PFNGLINDEXMATERIALEXTPROC glad_glIndexMaterialEXT;
    GLAD_API_CALL PFNGLINDEXMATERIALEXTPROC glad_debug_glIndexMaterialEXT;
#define glIndexMaterialEXT glad_debug_glIndexMaterialEXT
    GLAD_API_CALL PFNGLINDEXPOINTEREXTPROC glad_glIndexPointerEXT;
    GLAD_API_CALL PFNGLINDEXPOINTEREXTPROC glad_debug_glIndexPointerEXT;
#define glIndexPointerEXT glad_debug_glIndexPointerEXT
    GLAD_API_CALL PFNGLINDEXPOINTERLISTIBMPROC glad_glIndexPointerListIBM;
    GLAD_API_CALL PFNGLINDEXPOINTERLISTIBMPROC glad_debug_glIndexPointerListIBM;
#define glIndexPointerListIBM glad_debug_glIndexPointerListIBM
    GLAD_API_CALL PFNGLINDEXXOESPROC glad_glIndexxOES;
    GLAD_API_CALL PFNGLINDEXXOESPROC glad_debug_glIndexxOES;
#define glIndexxOES glad_debug_glIndexxOES
    GLAD_API_CALL PFNGLINDEXXVOESPROC glad_glIndexxvOES;
    GLAD_API_CALL PFNGLINDEXXVOESPROC glad_debug_glIndexxvOES;
#define glIndexxvOES glad_debug_glIndexxvOES
    GLAD_API_CALL PFNGLINSERTCOMPONENTEXTPROC glad_glInsertComponentEXT;
    GLAD_API_CALL PFNGLINSERTCOMPONENTEXTPROC glad_debug_glInsertComponentEXT;
#define glInsertComponentEXT glad_debug_glInsertComponentEXT
    GLAD_API_CALL PFNGLINSERTEVENTMARKEREXTPROC glad_glInsertEventMarkerEXT;
    GLAD_API_CALL PFNGLINSERTEVENTMARKEREXTPROC glad_debug_glInsertEventMarkerEXT;
#define glInsertEventMarkerEXT glad_debug_glInsertEventMarkerEXT
    GLAD_API_CALL PFNGLINSTRUMENTSBUFFERSGIXPROC glad_glInstrumentsBufferSGIX;
    GLAD_API_CALL PFNGLINSTRUMENTSBUFFERSGIXPROC glad_debug_glInstrumentsBufferSGIX;
#define glInstrumentsBufferSGIX glad_debug_glInstrumentsBufferSGIX
    GLAD_API_CALL PFNGLINTERPOLATEPATHSNVPROC glad_glInterpolatePathsNV;
    GLAD_API_CALL PFNGLINTERPOLATEPATHSNVPROC glad_debug_glInterpolatePathsNV;
#define glInterpolatePathsNV glad_debug_glInterpolatePathsNV
    GLAD_API_CALL PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;
    GLAD_API_CALL PFNGLINVALIDATEBUFFERDATAPROC glad_debug_glInvalidateBufferData;

/// <summary>
///   invalidate the content of a buffer object's data store
///   <para>
///     glInvalidateBufferData invalidates all of the content of the data store of a buffer object.
///     After invalidation, the content of the buffer's data store becomes undefined.
///   </para>
/// </summary>
/// <param name='buffer'>The name of a buffer object whose data store to invalidate.</param>
#define glInvalidateBufferData glad_debug_glInvalidateBufferData
    GLAD_API_CALL PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;
    GLAD_API_CALL PFNGLINVALIDATEBUFFERSUBDATAPROC glad_debug_glInvalidateBufferSubData;

/// <summary>
///   invalidate a region of a buffer object's data store
///   <para>
///     glInvalidateBufferSubData invalidates all or part of the content of the data store of a
///     buffer object. After invalidation, the content of the specified range of the buffer's data
///     store becomes undefined. The start of the range is given by offset and its size is given by
///     length , both measured in basic machine units.
///   </para>
/// </summary>
/// <param name='buffer'>The name of a buffer object, a subrange of whose data store to
/// invalidate.</param> <param name='offset'>The offset within the buffer's data store of the start
/// of the range to be invalidated.</param> <param name='length'>The length of the range within the
/// buffer's data store to be invalidated.</param>
#define glInvalidateBufferSubData glad_debug_glInvalidateBufferSubData
    GLAD_API_CALL PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;
    GLAD_API_CALL PFNGLINVALIDATEFRAMEBUFFERPROC glad_debug_glInvalidateFramebuffer;

/// <summary>
///   invalidate the content of some or all of a framebuffer's attachments
///   <para>
///     glInvalidateFramebuffer and glInvalidateNamedFramebufferData invalidate the entire contents
///     of a specified set of attachments of a framebuffer. For glInvalidateFramebuffer , the
///     framebuffer object is that bound to target. target must be GL_FRAMEBUFFER ,
///     GL_READ_FRAMEBUFFER or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to
///     GL_DRAW_FRAMEBUFFER. Default framebuffers may also be invalidated if bound to target. For
///     glInvalidateNamedFramebufferData , framebuffer is the name of the framebuffer object. If
///     framebuffer is zero, the default draw framebuffer is affected. The set of attachments whose
///     contents are to be invalidated are specified in the attachments array, which contains
///     numAttachments elements. If the specified framebuffer is a framebuffer object, each element
///     of attachments must be one of GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT
///     GL_DEPTH_STENCIL_ATTACHMENT , or GL_COLOR_ATTACHMENT i , where i is between zero and the
///     value of GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one. If the specified framebuffer is a default
///     framebuffer, each element of attachments must be one of GL_FRONT_LEFT , GL_FRONT_RIGHT ,
///     GL_BACK_LEFT , GL_BACK_RIGHT , GL_AUX i , GL_ACCUM , GL_COLOR , GL_DEPTH , or GL_STENCIL.
///     GL_COLOR , is treated as GL_BACK_LEFT for a double-buffered context and GL_FRONT_LEFT for a
///     single-buffered context. The other attachments identify the corresponding specific buffer.
///     The entire contents of each specified attachment become undefined after execution of
///     glInvalidateFramebuffer or glInvalidateNamedFramebufferData. If the framebuffer object is
///     not complete, glInvalidateFramebuffer and glInvalidateNamedFramebufferData may be ignored.
///     This is not an error.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer object is attached
/// for</param> <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='numAttachments'>Specifies the number of entries in the</param>
/// <param name='attachments'>Specifies a pointer to an array identifying the attachments to be
/// invalidated.</param>
#define glInvalidateFramebuffer glad_debug_glInvalidateFramebuffer
    GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;
    GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC
        glad_debug_glInvalidateNamedFramebufferData;
#define glInvalidateNamedFramebufferData glad_debug_glInvalidateNamedFramebufferData
    GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC
        glad_glInvalidateNamedFramebufferSubData;
    GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC
        glad_debug_glInvalidateNamedFramebufferSubData;
#define glInvalidateNamedFramebufferSubData glad_debug_glInvalidateNamedFramebufferSubData
    GLAD_API_CALL PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;
    GLAD_API_CALL PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_debug_glInvalidateSubFramebuffer;

/// <summary>
///   invalidate the content of a region of some or all of a framebuffer's attachments
///   <para>
///     glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData invalidate the contents
///     of a specified region of a specified set of attachments of a framebuffer. For
///     glInvalidateSubFramebuffer , the framebuffer object is that bound to target , which must be
///     one of GL_FRAMEBUFFER , GL_READ_FRAMEBUFFER or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is
///     equivalent to GL_DRAW_FRAMEBUFFER. Default framebuffers may also be invalidated if bound to
///     target. For glInvalidateNamedFramebufferSubData , framebuffer is the name of the framebuffer
///     object. If framebuffer is zero, the default draw framebuffer is affected. The set of
///     attachments of which a region is to be invalidated are specified in the attachments array,
///     which contains numAttachments elements. If the specified framebuffer is a framebuffer
///     object, each element of attachments must be one of GL_DEPTH_ATTACHMENT ,
///     GL_STENCIL_ATTACHMENT GL_DEPTH_STENCIL_ATTACHMENT , or GL_COLOR_ATTACHMENT i , where i is
///     between zero and the value of GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one. If the specified
///     framebuffer is a default framebuffer, each element of attachments must be one of
///     GL_FRONT_LEFT , GL_FRONT_RIGHT , GL_BACK_LEFT , GL_BACK_RIGHT , GL_AUX i , GL_ACCUM ,
///     GL_COLOR , GL_DEPTH , or GL_STENCIL. GL_COLOR , is treated as GL_BACK_LEFT for a
///     double-buffered context and GL_FRONT_LEFT for a single-buffered context. The other
///     attachments identify the corresponding specific buffer. The contents of the specified region
///     of each specified attachment become undefined after execution of glInvalidateSubFramebuffer
///     or glInvalidateNamedFramebufferSubData. The region to be invalidated is specified by x , y ,
///     width and height where x and y give the offset from the origin (with lower-left corner at
///     $(0,0)$) and width and height are the width and height, respectively, of the region. Any
///     pixels lying outside of the window allocated to the current GL context (for the default
///     framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the
///     framebuffer object is not complete, these commands may be ignored. If the framebuffer object
///     is not complete, glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData may be
///     ignored. This is not an error.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the framebuffer object is attached
/// for</param> <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='numAttachments'>Specifies the number of entries in the</param>
/// <param name='attachments'>Specifies a pointer to an array identifying the attachments to be
/// invalidated.</param> <param name='x'>Specifies the X offset of the region to be
/// invalidated.</param> <param name='y'>Specifies the Y offset of the region to be
/// invalidated.</param> <param name='width'>Specifies the width of the region to be
/// invalidated.</param> <param name='height'>Specifies the height of the region to be
/// invalidated.</param>
#define glInvalidateSubFramebuffer glad_debug_glInvalidateSubFramebuffer
    GLAD_API_CALL PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;
    GLAD_API_CALL PFNGLINVALIDATETEXIMAGEPROC glad_debug_glInvalidateTexImage;

/// <summary>
///   invalidate the entirety a texture image
///   <para>
///     glInvalidateTexSubImage invalidates all of a texture image. texture and level indicated
///     which texture image is being invalidated. After this command, data in the texture image has
///     undefined values. level must be greater than or equal to zero and be less than the base 2
///     logarithm of the maximum texture width, height, or depth. For textures of targets
///     GL_TEXTURE_RECTANGLE , GL_TEXTURE_BUFFER , GL_TEXTURE_2D_MULTISAMPLE , or
///     GL_TEXTURE_2D_MULTISAMPLE_ARRAY , level must be zero.
///   </para>
/// </summary>
/// <param name='texture'>The name of a texture object to invalidate.</param>
/// <param name='level'>The level of detail of the texture object to invalidate.</param>
#define glInvalidateTexImage glad_debug_glInvalidateTexImage
    GLAD_API_CALL PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;
    GLAD_API_CALL PFNGLINVALIDATETEXSUBIMAGEPROC glad_debug_glInvalidateTexSubImage;

/// <summary>
///   invalidate a region of a texture image
///   <para>
///     glInvalidateTexSubImage invalidates all or part of a texture image. texture and level
///     indicated which texture image is being invalidated. After this command, data in that
///     subregion have undefined values. xoffset , yoffset , zoffset , width , height , and depth
///     are interpreted as they are in glTexSubImage3D. For texture targets that don't have certain
///     dimensions, this command treats those dimensions as having a size of 1. For example, to
///     invalidate a portion of a two- dimensional texture, the application would use zoffset equal
///     to zero and depth equal to one. Cube map textures are treated as an array of six slices in
///     the z-dimension, where a value of zoffset is interpreted as specifying face
///     GL_TEXTURE_CUBE_MAP_POSITIVE_X + zoffset. level must be greater than or equal to zero and be
///     less than the base 2 logarithm of the maximum texture width, height, or depth. xoffset ,
///     yoffset and zoffset must be greater than or equal to zero and be less than the width, height
///     or depth of the image, respectively. Furthermore, xoffset + width , yoffset + height , and
///     zoffset + depth must be less than or equal to the width, height or depth of the image,
///     respectively. For textures of targets GL_TEXTURE_RECTANGLE , GL_TEXTURE_BUFFER ,
///     GL_TEXTURE_2D_MULTISAMPLE , or GL_TEXTURE_2D_MULTISAMPLE_ARRAY , level must be zero.
///   </para>
/// </summary>
/// <param name='texture'>The name of a texture object a subregion of which to invalidate.</param>
/// <param name='level'>The level of detail of the texture object within which the region
/// resides.</param> <param name='xoffset'>The X offset of the region to be invalidated.</param>
/// <param name='yoffset'>The Y offset of the region to be invalidated.</param>
/// <param name='zoffset'>The Z offset of the region to be invalidated.</param>
/// <param name='width'>The width of the region to be invalidated.</param>
/// <param name='height'>The height of the region to be invalidated.</param>
/// <param name='depth'>The depth of the region to be invalidated.</param>
#define glInvalidateTexSubImage glad_debug_glInvalidateTexSubImage
    GLAD_API_CALL PFNGLISASYNCMARKERSGIXPROC glad_glIsAsyncMarkerSGIX;
    GLAD_API_CALL PFNGLISASYNCMARKERSGIXPROC glad_debug_glIsAsyncMarkerSGIX;
#define glIsAsyncMarkerSGIX glad_debug_glIsAsyncMarkerSGIX
    GLAD_API_CALL PFNGLISBUFFERPROC glad_glIsBuffer;
    GLAD_API_CALL PFNGLISBUFFERPROC glad_debug_glIsBuffer;

/// <summary>
///   determine if a name corresponds to a buffer object
///   <para>
///     glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object. If buffer is
///     zero, or is a non-zero value that is not currently the name of a buffer object, or if an
///     error occurs, glIsBuffer returns GL_FALSE. A name returned by glGenBuffers , but not yet
///     associated with a buffer object by calling glBindBuffer , is not the name of a buffer
///     object.
///   </para>
/// </summary>
/// <param name='buffer'>Specifies a value that may be the name of a buffer object.</param>
#define glIsBuffer glad_debug_glIsBuffer
    GLAD_API_CALL PFNGLISBUFFERARBPROC glad_glIsBufferARB;
    GLAD_API_CALL PFNGLISBUFFERARBPROC glad_debug_glIsBufferARB;
#define glIsBufferARB glad_debug_glIsBufferARB
    GLAD_API_CALL PFNGLISBUFFERRESIDENTNVPROC glad_glIsBufferResidentNV;
    GLAD_API_CALL PFNGLISBUFFERRESIDENTNVPROC glad_debug_glIsBufferResidentNV;
#define glIsBufferResidentNV glad_debug_glIsBufferResidentNV
    GLAD_API_CALL PFNGLISCOMMANDLISTNVPROC glad_glIsCommandListNV;
    GLAD_API_CALL PFNGLISCOMMANDLISTNVPROC glad_debug_glIsCommandListNV;
#define glIsCommandListNV glad_debug_glIsCommandListNV
    GLAD_API_CALL PFNGLISENABLEDPROC glad_glIsEnabled;
    GLAD_API_CALL PFNGLISENABLEDPROC glad_debug_glIsEnabled;

/// <summary>
///   test whether a capability is enabled
///   <para>
///     glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise.
///     Boolean states that are indexed may be tested with glIsEnabledi. For glIsEnabledi , index
///     specifies the index of the capability to test. index must be between zero and the count of
///     indexed capabilities for cap. Initially all capabilities except GL_DITHER are disabled;
///     GL_DITHER is initially enabled. The following capabilities are accepted for cap :
///   </para>
/// </summary>
/// <param name='cap'>Specifies a symbolic constant indicating a GL capability.</param>
/// <param name='index'>Specifies the index of the capability.</param>
#define glIsEnabled glad_debug_glIsEnabled
    GLAD_API_CALL PFNGLISENABLEDINDEXEDEXTPROC glad_glIsEnabledIndexedEXT;
    GLAD_API_CALL PFNGLISENABLEDINDEXEDEXTPROC glad_debug_glIsEnabledIndexedEXT;
#define glIsEnabledIndexedEXT glad_debug_glIsEnabledIndexedEXT
    GLAD_API_CALL PFNGLISENABLEDIPROC glad_glIsEnabledi;
    GLAD_API_CALL PFNGLISENABLEDIPROC glad_debug_glIsEnabledi;
#define glIsEnabledi glad_debug_glIsEnabledi
    GLAD_API_CALL PFNGLISFENCEAPPLEPROC glad_glIsFenceAPPLE;
    GLAD_API_CALL PFNGLISFENCEAPPLEPROC glad_debug_glIsFenceAPPLE;
#define glIsFenceAPPLE glad_debug_glIsFenceAPPLE
    GLAD_API_CALL PFNGLISFENCENVPROC glad_glIsFenceNV;
    GLAD_API_CALL PFNGLISFENCENVPROC glad_debug_glIsFenceNV;
#define glIsFenceNV glad_debug_glIsFenceNV
    GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
    GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_debug_glIsFramebuffer;

/// <summary>
///   determine if a name corresponds to a framebuffer object
///   <para>
///     glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer
///     object. If framebuffer is zero, or if framebuffer is not the name of a framebuffer object,
///     or if an error occurs, glIsFramebuffer returns GL_FALSE. If framebuffer is a name returned
///     by glGenFramebuffers , by that has not yet been bound through a call to glBindFramebuffer ,
///     then the name is not a framebuffer object and glIsFramebuffer returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='framebuffer'>Specifies a value that may be the name of a framebuffer
/// object.</param>
#define glIsFramebuffer glad_debug_glIsFramebuffer
    GLAD_API_CALL PFNGLISFRAMEBUFFEREXTPROC glad_glIsFramebufferEXT;
    GLAD_API_CALL PFNGLISFRAMEBUFFEREXTPROC glad_debug_glIsFramebufferEXT;
#define glIsFramebufferEXT glad_debug_glIsFramebufferEXT
    GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTARBPROC glad_glIsImageHandleResidentARB;
    GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTARBPROC glad_debug_glIsImageHandleResidentARB;
#define glIsImageHandleResidentARB glad_debug_glIsImageHandleResidentARB
    GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTNVPROC glad_glIsImageHandleResidentNV;
    GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTNVPROC glad_debug_glIsImageHandleResidentNV;
#define glIsImageHandleResidentNV glad_debug_glIsImageHandleResidentNV
    GLAD_API_CALL PFNGLISMEMORYOBJECTEXTPROC glad_glIsMemoryObjectEXT;
    GLAD_API_CALL PFNGLISMEMORYOBJECTEXTPROC glad_debug_glIsMemoryObjectEXT;
#define glIsMemoryObjectEXT glad_debug_glIsMemoryObjectEXT
    GLAD_API_CALL PFNGLISNAMEAMDPROC glad_glIsNameAMD;
    GLAD_API_CALL PFNGLISNAMEAMDPROC glad_debug_glIsNameAMD;
#define glIsNameAMD glad_debug_glIsNameAMD
    GLAD_API_CALL PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_glIsNamedBufferResidentNV;
    GLAD_API_CALL PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_debug_glIsNamedBufferResidentNV;
#define glIsNamedBufferResidentNV glad_debug_glIsNamedBufferResidentNV
    GLAD_API_CALL PFNGLISNAMEDSTRINGARBPROC glad_glIsNamedStringARB;
    GLAD_API_CALL PFNGLISNAMEDSTRINGARBPROC glad_debug_glIsNamedStringARB;
#define glIsNamedStringARB glad_debug_glIsNamedStringARB
    GLAD_API_CALL PFNGLISOBJECTBUFFERATIPROC glad_glIsObjectBufferATI;
    GLAD_API_CALL PFNGLISOBJECTBUFFERATIPROC glad_debug_glIsObjectBufferATI;
#define glIsObjectBufferATI glad_debug_glIsObjectBufferATI
    GLAD_API_CALL PFNGLISOCCLUSIONQUERYNVPROC glad_glIsOcclusionQueryNV;
    GLAD_API_CALL PFNGLISOCCLUSIONQUERYNVPROC glad_debug_glIsOcclusionQueryNV;
#define glIsOcclusionQueryNV glad_debug_glIsOcclusionQueryNV
    GLAD_API_CALL PFNGLISPATHNVPROC glad_glIsPathNV;
    GLAD_API_CALL PFNGLISPATHNVPROC glad_debug_glIsPathNV;
#define glIsPathNV glad_debug_glIsPathNV
    GLAD_API_CALL PFNGLISPOINTINFILLPATHNVPROC glad_glIsPointInFillPathNV;
    GLAD_API_CALL PFNGLISPOINTINFILLPATHNVPROC glad_debug_glIsPointInFillPathNV;
#define glIsPointInFillPathNV glad_debug_glIsPointInFillPathNV
    GLAD_API_CALL PFNGLISPOINTINSTROKEPATHNVPROC glad_glIsPointInStrokePathNV;
    GLAD_API_CALL PFNGLISPOINTINSTROKEPATHNVPROC glad_debug_glIsPointInStrokePathNV;
#define glIsPointInStrokePathNV glad_debug_glIsPointInStrokePathNV
    GLAD_API_CALL PFNGLISPROGRAMPROC glad_glIsProgram;
    GLAD_API_CALL PFNGLISPROGRAMPROC glad_debug_glIsProgram;

/// <summary>
///   Determines if a name corresponds to a program object
///   <para>
///     glIsProgram returns GL_TRUE if program is the name of a program object previously created
///     with glCreateProgram and not yet deleted with glDeleteProgram. If program is zero or a
///     non-zero value that is not the name of a program object, or if an error occurs, glIsProgram
///     returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='program'>Specifies a potential program object.</param>
#define glIsProgram glad_debug_glIsProgram
    GLAD_API_CALL PFNGLISPROGRAMARBPROC glad_glIsProgramARB;
    GLAD_API_CALL PFNGLISPROGRAMARBPROC glad_debug_glIsProgramARB;
#define glIsProgramARB glad_debug_glIsProgramARB
    GLAD_API_CALL PFNGLISPROGRAMNVPROC glad_glIsProgramNV;
    GLAD_API_CALL PFNGLISPROGRAMNVPROC glad_debug_glIsProgramNV;
#define glIsProgramNV glad_debug_glIsProgramNV
    GLAD_API_CALL PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;
    GLAD_API_CALL PFNGLISPROGRAMPIPELINEPROC glad_debug_glIsProgramPipeline;

/// <summary>
///   determine if a name corresponds to a program pipeline object
///   <para>
///     glIsProgramPipeline returns GL_TRUE if pipeline is currently the name of a program pipeline
///     object. If pipeline is zero, or if pipeline is not the name of a program pipeline object, or
///     if an error occurs, glIsProgramPipeline returns GL_FALSE. If pipeline is a name returned by
///     glGenProgramPipelines , but that has not yet been bound through a call to
///     glBindProgramPipeline , then the name is not a program pipeline object and
///     glIsProgramPipeline returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies a value that may be the name of a program pipeline
/// object.</param>
#define glIsProgramPipeline glad_debug_glIsProgramPipeline
    GLAD_API_CALL PFNGLISQUERYPROC glad_glIsQuery;
    GLAD_API_CALL PFNGLISQUERYPROC glad_debug_glIsQuery;

/// <summary>
///   determine if a name corresponds to a query object
///   <para>
///     glIsQuery returns GL_TRUE if id is currently the name of a query object. If id is zero, or
///     is a non-zero value that is not currently the name of a query object, or if an error occurs,
///     glIsQuery returns GL_FALSE. A name returned by glGenQueries , but not yet associated with a
///     query object by calling glBeginQuery , is not the name of a query object.
///   </para>
/// </summary>
/// <param name='id'>Specifies a value that may be the name of a query object.</param>
#define glIsQuery glad_debug_glIsQuery
    GLAD_API_CALL PFNGLISQUERYARBPROC glad_glIsQueryARB;
    GLAD_API_CALL PFNGLISQUERYARBPROC glad_debug_glIsQueryARB;
#define glIsQueryARB glad_debug_glIsQueryARB
    GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
    GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_debug_glIsRenderbuffer;

/// <summary>
///   determine if a name corresponds to a renderbuffer object
///   <para>
///     glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer
///     object. If renderbuffer is zero, or if renderbuffer is not the name of a renderbuffer
///     object, or if an error occurs, glIsRenderbuffer returns GL_FALSE. If renderbuffer is a name
///     returned by glGenRenderbuffers , by that has not yet been bound through a call to
///     glBindRenderbuffer or glFramebufferRenderbuffer , then the name is not a renderbuffer object
///     and glIsRenderbuffer returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='renderbuffer'>Specifies a value that may be the name of a renderbuffer
/// object.</param>
#define glIsRenderbuffer glad_debug_glIsRenderbuffer
    GLAD_API_CALL PFNGLISRENDERBUFFEREXTPROC glad_glIsRenderbufferEXT;
    GLAD_API_CALL PFNGLISRENDERBUFFEREXTPROC glad_debug_glIsRenderbufferEXT;
#define glIsRenderbufferEXT glad_debug_glIsRenderbufferEXT
    GLAD_API_CALL PFNGLISSAMPLERPROC glad_glIsSampler;
    GLAD_API_CALL PFNGLISSAMPLERPROC glad_debug_glIsSampler;

/// <summary>
///   determine if a name corresponds to a sampler object
///   <para>
///     glIsSampler returns GL_TRUE if id is currently the name of a sampler object. If id is zero,
///     or is a non-zero value that is not currently the name of a sampler object, or if an error
///     occurs, glIsSampler returns GL_FALSE. A name returned by glGenSamplers , is the name of a
///     sampler object.
///   </para>
/// </summary>
/// <param name='id'>Specifies a value that may be the name of a sampler object.</param>
#define glIsSampler glad_debug_glIsSampler
    GLAD_API_CALL PFNGLISSEMAPHOREEXTPROC glad_glIsSemaphoreEXT;
    GLAD_API_CALL PFNGLISSEMAPHOREEXTPROC glad_debug_glIsSemaphoreEXT;
#define glIsSemaphoreEXT glad_debug_glIsSemaphoreEXT
    GLAD_API_CALL PFNGLISSHADERPROC glad_glIsShader;
    GLAD_API_CALL PFNGLISSHADERPROC glad_debug_glIsShader;

/// <summary>
///   Determines if a name corresponds to a shader object
///   <para>
///     glIsShader returns GL_TRUE if shader is the name of a shader object previously created with
///     glCreateShader and not yet deleted with glDeleteShader. If shader is zero or a non-zero
///     value that is not the name of a shader object, or if an error occurs, glIsShader returns
///     GL_FALSE.
///   </para>
/// </summary>
/// <param name='shader'>Specifies a potential shader object.</param>
#define glIsShader glad_debug_glIsShader
    GLAD_API_CALL PFNGLISSTATENVPROC glad_glIsStateNV;
    GLAD_API_CALL PFNGLISSTATENVPROC glad_debug_glIsStateNV;
#define glIsStateNV glad_debug_glIsStateNV
    GLAD_API_CALL PFNGLISSYNCPROC glad_glIsSync;
    GLAD_API_CALL PFNGLISSYNCPROC glad_debug_glIsSync;

/// <summary>
///   determine if a name corresponds to a sync object
///   <para>
///     glIsSync returns GL_TRUE if sync is currently the name of a sync object. If sync is not the
///     name of a sync object, or if an error occurs, glIsSync returns GL_FALSE. Note that zero is
///     not the name of a sync object.
///   </para>
/// </summary>
/// <param name='sync'>Specifies a value that may be the name of a sync object.</param>
#define glIsSync glad_debug_glIsSync
    GLAD_API_CALL PFNGLISTEXTUREPROC glad_glIsTexture;
    GLAD_API_CALL PFNGLISTEXTUREPROC glad_debug_glIsTexture;

/// <summary>
///   determine if a name corresponds to a texture
///   <para>
///     glIsTexture returns GL_TRUE if texture is currently the name of a texture. If texture is
///     zero, or is a non-zero value that is not currently the name of a texture, or if an error
///     occurs, glIsTexture returns GL_FALSE. A name returned by glGenTextures , but not yet
///     associated with a texture by calling glBindTexture , is not the name of a texture.
///   </para>
/// </summary>
/// <param name='texture'>Specifies a value that may be the name of a texture.</param>
#define glIsTexture glad_debug_glIsTexture
    GLAD_API_CALL PFNGLISTEXTUREEXTPROC glad_glIsTextureEXT;
    GLAD_API_CALL PFNGLISTEXTUREEXTPROC glad_debug_glIsTextureEXT;
#define glIsTextureEXT glad_debug_glIsTextureEXT
    GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_glIsTextureHandleResidentARB;
    GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_debug_glIsTextureHandleResidentARB;
#define glIsTextureHandleResidentARB glad_debug_glIsTextureHandleResidentARB
    GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_glIsTextureHandleResidentNV;
    GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_debug_glIsTextureHandleResidentNV;
#define glIsTextureHandleResidentNV glad_debug_glIsTextureHandleResidentNV
    GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
    GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_debug_glIsTransformFeedback;

/// <summary>
///   determine if a name corresponds to a transform feedback object
///   <para>
///     glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback
///     object. If id is zero, or if id is not the name of a transform feedback object, or if an
///     error occurs, glIsTransformFeedback returns GL_FALSE. If id is a name returned by
///     glGenTransformFeedbacks , but that has not yet been bound through a call to
///     glBindTransformFeedback , then the name is not a transform feedback object and
///     glIsTransformFeedback returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='id'>Specifies a value that may be the name of a transform feedback object.</param>
#define glIsTransformFeedback glad_debug_glIsTransformFeedback
    GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKNVPROC glad_glIsTransformFeedbackNV;
    GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKNVPROC glad_debug_glIsTransformFeedbackNV;
#define glIsTransformFeedbackNV glad_debug_glIsTransformFeedbackNV
    GLAD_API_CALL PFNGLISVARIANTENABLEDEXTPROC glad_glIsVariantEnabledEXT;
    GLAD_API_CALL PFNGLISVARIANTENABLEDEXTPROC glad_debug_glIsVariantEnabledEXT;
#define glIsVariantEnabledEXT glad_debug_glIsVariantEnabledEXT
    GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
    GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_debug_glIsVertexArray;

/// <summary>
///   determine if a name corresponds to a vertex array object
///   <para>
///     glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array object. If
///     array is zero, or if array is not the name of a vertex array object, or if an error occurs,
///     glIsVertexArray returns GL_FALSE. If array is a name returned by glGenVertexArrays , by that
///     has not yet been bound through a call to glBindVertexArray , then the name is not a vertex
///     array object and glIsVertexArray returns GL_FALSE.
///   </para>
/// </summary>
/// <param name='array'>Specifies a value that may be the name of a vertex array object.</param>
#define glIsVertexArray glad_debug_glIsVertexArray
    GLAD_API_CALL PFNGLISVERTEXARRAYAPPLEPROC glad_glIsVertexArrayAPPLE;
    GLAD_API_CALL PFNGLISVERTEXARRAYAPPLEPROC glad_debug_glIsVertexArrayAPPLE;
#define glIsVertexArrayAPPLE glad_debug_glIsVertexArrayAPPLE
    GLAD_API_CALL PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_glIsVertexAttribEnabledAPPLE;
    GLAD_API_CALL PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_debug_glIsVertexAttribEnabledAPPLE;
#define glIsVertexAttribEnabledAPPLE glad_debug_glIsVertexAttribEnabledAPPLE
    GLAD_API_CALL PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_glLGPUCopyImageSubDataNVX;
    GLAD_API_CALL PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_debug_glLGPUCopyImageSubDataNVX;
#define glLGPUCopyImageSubDataNVX glad_debug_glLGPUCopyImageSubDataNVX
    GLAD_API_CALL PFNGLLGPUINTERLOCKNVXPROC glad_glLGPUInterlockNVX;
    GLAD_API_CALL PFNGLLGPUINTERLOCKNVXPROC glad_debug_glLGPUInterlockNVX;
#define glLGPUInterlockNVX glad_debug_glLGPUInterlockNVX
    GLAD_API_CALL PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_glLGPUNamedBufferSubDataNVX;
    GLAD_API_CALL PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_debug_glLGPUNamedBufferSubDataNVX;
#define glLGPUNamedBufferSubDataNVX glad_debug_glLGPUNamedBufferSubDataNVX
    GLAD_API_CALL PFNGLLABELOBJECTEXTPROC glad_glLabelObjectEXT;
    GLAD_API_CALL PFNGLLABELOBJECTEXTPROC glad_debug_glLabelObjectEXT;
#define glLabelObjectEXT glad_debug_glLabelObjectEXT
    GLAD_API_CALL PFNGLLIGHTENVISGIXPROC glad_glLightEnviSGIX;
    GLAD_API_CALL PFNGLLIGHTENVISGIXPROC glad_debug_glLightEnviSGIX;
#define glLightEnviSGIX glad_debug_glLightEnviSGIX
    GLAD_API_CALL PFNGLLIGHTMODELXOESPROC glad_glLightModelxOES;
    GLAD_API_CALL PFNGLLIGHTMODELXOESPROC glad_debug_glLightModelxOES;
#define glLightModelxOES glad_debug_glLightModelxOES
    GLAD_API_CALL PFNGLLIGHTMODELXVOESPROC glad_glLightModelxvOES;
    GLAD_API_CALL PFNGLLIGHTMODELXVOESPROC glad_debug_glLightModelxvOES;
#define glLightModelxvOES glad_debug_glLightModelxvOES
    GLAD_API_CALL PFNGLLIGHTXOESPROC glad_glLightxOES;
    GLAD_API_CALL PFNGLLIGHTXOESPROC glad_debug_glLightxOES;
#define glLightxOES glad_debug_glLightxOES
    GLAD_API_CALL PFNGLLIGHTXVOESPROC glad_glLightxvOES;
    GLAD_API_CALL PFNGLLIGHTXVOESPROC glad_debug_glLightxvOES;
#define glLightxvOES glad_debug_glLightxvOES
    GLAD_API_CALL PFNGLLINEWIDTHPROC glad_glLineWidth;
    GLAD_API_CALL PFNGLLINEWIDTHPROC glad_debug_glLineWidth;

/// <summary>
///   specify the width of rasterized lines
///   <para>
///     glLineWidth specifies the rasterized width of both aliased and antialiased lines. Using a
///     line width other than 1 has different effects, depending on whether line antialiasing is
///     enabled. To enable and disable line antialiasing, call glEnable and glDisable with argument
///     GL_LINE_SMOOTH. Line antialiasing is initially disabled. If line antialiasing is disabled,
///     the actual width is determined by rounding the supplied width to the nearest integer. (If
///     the rounding results in the value 0, it is as if the line width were 1.) If Δ x >= Δ y , i
///     pixels are filled in each column that is rasterized, where i is the rounded value of width.
///     Otherwise, i pixels are filled in each row that is rasterized. If antialiasing is enabled,
///     line rasterization produces a fragment for each pixel square that intersects the region
///     lying within the rectangle having width equal to the current line width, length equal to the
///     actual length of the line, and centered on the mathematical line segment. The coverage value
///     for each fragment is the window coordinate area of the intersection of the rectangular
///     region with the corresponding pixel square. This value is saved and used in the final
///     rasterization step. Not all widths can be supported when line antialiasing is enabled. If an
///     unsupported width is requested, the nearest supported width is used. Only width 1 is
///     guaranteed to be supported; others depend on the implementation. Likewise, there is a range
///     for aliased line widths as well. To query the range of supported widths and the size
///     difference between supported widths within the range, call glGet with arguments
///     GL_ALIASED_LINE_WIDTH_RANGE , GL_SMOOTH_LINE_WIDTH_RANGE , and
///     GL_SMOOTH_LINE_WIDTH_GRANULARITY.
///   </para>
/// </summary>
/// <param name='width'>Specifies the width of rasterized lines. The initial value is 1.</param>
#define glLineWidth glad_debug_glLineWidth
    GLAD_API_CALL PFNGLLINEWIDTHXOESPROC glad_glLineWidthxOES;
    GLAD_API_CALL PFNGLLINEWIDTHXOESPROC glad_debug_glLineWidthxOES;
#define glLineWidthxOES glad_debug_glLineWidthxOES
    GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_glLinkProgram;
    GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_debug_glLinkProgram;

/// <summary>
///   Links a program object
///   <para>
///     glLinkProgram links the program object specified by program. If any shader objects of type
///     GL_VERTEX_SHADER are attached to program , they will be used to create an executable that
///     will run on the programmable vertex processor. If any shader objects of type
///     GL_GEOMETRY_SHADER are attached to program , they will be used to create an executable that
///     will run on the programmable geometry processor. If any shader objects of type
///     GL_FRAGMENT_SHADER are attached to program , they will be used to create an executable that
///     will run on the programmable fragment processor. The status of the link operation will be
///     stored as part of the program object's state. This value will be set to GL_TRUE if the
///     program object was linked without errors and is ready for use, and GL_FALSE otherwise. It
///     can be queried by calling glGetProgram with arguments program and GL_LINK_STATUS. As a
///     result of a successful link operation, all active user-defined uniform variables belonging
///     to program will be initialized to 0, and each of the program object's active uniform
///     variables will be assigned a location that can be queried by calling glGetUniformLocation.
///     Also, any active user-defined attribute variables that have not been bound to a generic
///     vertex attribute index will be bound to one at this time. Linking of a program object can
///     fail for a number of reasons as specified in the OpenGL Shading Language Specification. The
///     following lists some of the conditions that will cause a link error. The number of active
///     attribute variables supported by the implementation has been exceeded. The storage limit for
///     uniform variables has been exceeded. The number of active uniform variables supported by the
///     implementation has been exceeded. The main function is missing for the vertex, geometry or
///     fragment shader. A varying variable actually used in the fragment shader is not declared in
///     the same way (or is not declared at all) in the vertex shader, or geometry shader shader if
///     present. A reference to a function or variable name is unresolved. A shared global is
///     declared with two different types or two different initial values. One or more of the
///     attached shader objects has not been successfully compiled. Binding a generic attribute
///     matrix caused some rows of the matrix to fall outside the allowed maximum of
///     GL_MAX_VERTEX_ATTRIBS. Not enough contiguous vertex attribute slots could be found to bind
///     attribute matrices. The program object contains objects to form a fragment shader but does
///     not contain objects to form a vertex shader. The program object contains objects to form a
///     geometry shader but does not contain objects to form a vertex shader. The program object
///     contains objects to form a geometry shader and the input primitive type, output primitive
///     type, or maximum output vertex count is not specified in any compiled geometry shader
///     object. The program object contains objects to form a geometry shader and the input
///     primitive type, output primitive type, or maximum output vertex count is specified
///     differently in multiple geometry shader objects. The number of active outputs in the
///     fragment shader is greater than the value of GL_MAX_DRAW_BUFFERS. The program has an active
///     output assigned to a location greater than or equal to the value of
///     GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and has an active output assigned an index greater than or
///     equal to one. More than one varying out variable is bound to the same number and index. The
///     explicit binding assigments do not leave enough space for the linker to automatically assign
///     a location for a varying out array, which requires multiple contiguous locations. The count
///     specified by glTransformFeedbackVaryings is non-zero, but the program object has no vertex
///     or geometry shader. Any variable name specified to glTransformFeedbackVaryings in the
///     varyings array is not declared as an output in the vertex shader (or the geometry shader, if
///     active). Any two entries in the varyings array given glTransformFeedbackVaryings specify the
///     same varying variable. The total number of components to capture in any transform feedback
///     varying variable is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
///     and the buffer mode is GL_SEPARATE_ATTRIBS. When a program object has been successfully
///     linked, the program object can be made part of current state by calling glUseProgram.
///     Whether or not the link operation was successful, the program object's information log will
///     be overwritten. The information log can be retrieved by calling glGetProgramInfoLog.
///     glLinkProgram will also install the generated executables as part of the current rendering
///     state if the link operation was successful and the specified program object is already
///     currently in use as a result of a previous call to glUseProgram. If the program object
///     currently in use is relinked unsuccessfully, its link status will be set to GL_FALSE , but
///     the executables and associated state will remain part of the current state until a
///     subsequent call to glUseProgram removes it from use. After it is removed from use, it cannot
///     be made part of current state until it has been successfully relinked. If program contains
///     shader objects of type GL_VERTEX_SHADER , and optionally of type GL_GEOMETRY_SHADER , but
///     does not contain shader objects of type GL_FRAGMENT_SHADER , the vertex shader executable
///     will be installed on the programmable vertex processor, the geometry shader executable, if
///     present, will be installed on the programmable geometry processor, but no executable will be
///     installed on the fragment processor. The results of rasterizing primitives with such a
///     program will be undefined. The program object's information log is updated and the program
///     is generated at the time of the link operation. After the link operation, applications are
///     free to modify attached shader objects, compile attached shader objects, detach shader
///     objects, delete shader objects, and attach additional shader objects. None of these
///     operations affects the information log or the program that is part of the program object.
///   </para>
/// </summary>
/// <param name='program'>Specifies the handle of the program object to be linked.</param>
#define glLinkProgram glad_debug_glLinkProgram
    GLAD_API_CALL PFNGLLINKPROGRAMARBPROC glad_glLinkProgramARB;
    GLAD_API_CALL PFNGLLINKPROGRAMARBPROC glad_debug_glLinkProgramARB;
#define glLinkProgramARB glad_debug_glLinkProgramARB
    GLAD_API_CALL PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glad_glListDrawCommandsStatesClientNV;
    GLAD_API_CALL PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC
        glad_debug_glListDrawCommandsStatesClientNV;
#define glListDrawCommandsStatesClientNV glad_debug_glListDrawCommandsStatesClientNV
    GLAD_API_CALL PFNGLLISTPARAMETERFSGIXPROC glad_glListParameterfSGIX;
    GLAD_API_CALL PFNGLLISTPARAMETERFSGIXPROC glad_debug_glListParameterfSGIX;
#define glListParameterfSGIX glad_debug_glListParameterfSGIX
    GLAD_API_CALL PFNGLLISTPARAMETERFVSGIXPROC glad_glListParameterfvSGIX;
    GLAD_API_CALL PFNGLLISTPARAMETERFVSGIXPROC glad_debug_glListParameterfvSGIX;
#define glListParameterfvSGIX glad_debug_glListParameterfvSGIX
    GLAD_API_CALL PFNGLLISTPARAMETERISGIXPROC glad_glListParameteriSGIX;
    GLAD_API_CALL PFNGLLISTPARAMETERISGIXPROC glad_debug_glListParameteriSGIX;
#define glListParameteriSGIX glad_debug_glListParameteriSGIX
    GLAD_API_CALL PFNGLLISTPARAMETERIVSGIXPROC glad_glListParameterivSGIX;
    GLAD_API_CALL PFNGLLISTPARAMETERIVSGIXPROC glad_debug_glListParameterivSGIX;
#define glListParameterivSGIX glad_debug_glListParameterivSGIX
    GLAD_API_CALL PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC glad_glLoadIdentityDeformationMapSGIX;
    GLAD_API_CALL PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC
        glad_debug_glLoadIdentityDeformationMapSGIX;
#define glLoadIdentityDeformationMapSGIX glad_debug_glLoadIdentityDeformationMapSGIX
    GLAD_API_CALL PFNGLLOADMATRIXXOESPROC glad_glLoadMatrixxOES;
    GLAD_API_CALL PFNGLLOADMATRIXXOESPROC glad_debug_glLoadMatrixxOES;
#define glLoadMatrixxOES glad_debug_glLoadMatrixxOES
    GLAD_API_CALL PFNGLLOADPROGRAMNVPROC glad_glLoadProgramNV;
    GLAD_API_CALL PFNGLLOADPROGRAMNVPROC glad_debug_glLoadProgramNV;
#define glLoadProgramNV glad_debug_glLoadProgramNV
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_glLoadTransposeMatrixdARB;
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_debug_glLoadTransposeMatrixdARB;
#define glLoadTransposeMatrixdARB glad_debug_glLoadTransposeMatrixdARB
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_glLoadTransposeMatrixfARB;
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_debug_glLoadTransposeMatrixfARB;
#define glLoadTransposeMatrixfARB glad_debug_glLoadTransposeMatrixfARB
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXXOESPROC glad_glLoadTransposeMatrixxOES;
    GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXXOESPROC glad_debug_glLoadTransposeMatrixxOES;
#define glLoadTransposeMatrixxOES glad_debug_glLoadTransposeMatrixxOES
    GLAD_API_CALL PFNGLLOCKARRAYSEXTPROC glad_glLockArraysEXT;
    GLAD_API_CALL PFNGLLOCKARRAYSEXTPROC glad_debug_glLockArraysEXT;
#define glLockArraysEXT glad_debug_glLockArraysEXT
    GLAD_API_CALL PFNGLLOGICOPPROC glad_glLogicOp;
    GLAD_API_CALL PFNGLLOGICOPPROC glad_debug_glLogicOp;

/// <summary>
///   specify a logical pixel operation for rendering
///   <para>
///     glLogicOp specifies a logical operation that, when enabled, is applied between the incoming
///     RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable
///     or disable the logical operation, call glEnable and glDisable using the symbolic constant
///     GL_COLOR_LOGIC_OP. The initial value is disabled. opcode is a symbolic constant chosen from
///     the list above. In the explanation of the logical operations, s represents the incoming
///     color and d represents the color in the frame buffer. Standard C-language operators are
///     used. As these bitwise operators suggest, the logical operation is applied independently to
///     each bit pair of the source and destination colors.
///   </para>
/// </summary>
/// <param name='opcode'>Specifies a symbolic constant that selects a logical operation. The
/// following symbols are accepted:</param>
#define glLogicOp glad_debug_glLogicOp
    GLAD_API_CALL PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_glMakeBufferNonResidentNV;
    GLAD_API_CALL PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_debug_glMakeBufferNonResidentNV;
#define glMakeBufferNonResidentNV glad_debug_glMakeBufferNonResidentNV
    GLAD_API_CALL PFNGLMAKEBUFFERRESIDENTNVPROC glad_glMakeBufferResidentNV;
    GLAD_API_CALL PFNGLMAKEBUFFERRESIDENTNVPROC glad_debug_glMakeBufferResidentNV;
#define glMakeBufferResidentNV glad_debug_glMakeBufferResidentNV
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_glMakeImageHandleNonResidentARB;
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_debug_glMakeImageHandleNonResidentARB;
#define glMakeImageHandleNonResidentARB glad_debug_glMakeImageHandleNonResidentARB
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_glMakeImageHandleNonResidentNV;
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_debug_glMakeImageHandleNonResidentNV;
#define glMakeImageHandleNonResidentNV glad_debug_glMakeImageHandleNonResidentNV
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_glMakeImageHandleResidentARB;
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_debug_glMakeImageHandleResidentARB;
#define glMakeImageHandleResidentARB glad_debug_glMakeImageHandleResidentARB
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_glMakeImageHandleResidentNV;
    GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_debug_glMakeImageHandleResidentNV;
#define glMakeImageHandleResidentNV glad_debug_glMakeImageHandleResidentNV
    GLAD_API_CALL PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_glMakeNamedBufferNonResidentNV;
    GLAD_API_CALL PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_debug_glMakeNamedBufferNonResidentNV;
#define glMakeNamedBufferNonResidentNV glad_debug_glMakeNamedBufferNonResidentNV
    GLAD_API_CALL PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_glMakeNamedBufferResidentNV;
    GLAD_API_CALL PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_debug_glMakeNamedBufferResidentNV;
#define glMakeNamedBufferResidentNV glad_debug_glMakeNamedBufferResidentNV
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glad_glMakeTextureHandleNonResidentARB;
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC
        glad_debug_glMakeTextureHandleNonResidentARB;
#define glMakeTextureHandleNonResidentARB glad_debug_glMakeTextureHandleNonResidentARB
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glad_glMakeTextureHandleNonResidentNV;
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC
        glad_debug_glMakeTextureHandleNonResidentNV;
#define glMakeTextureHandleNonResidentNV glad_debug_glMakeTextureHandleNonResidentNV
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_glMakeTextureHandleResidentARB;
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_debug_glMakeTextureHandleResidentARB;
#define glMakeTextureHandleResidentARB glad_debug_glMakeTextureHandleResidentARB
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_glMakeTextureHandleResidentNV;
    GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_debug_glMakeTextureHandleResidentNV;
#define glMakeTextureHandleResidentNV glad_debug_glMakeTextureHandleResidentNV
    GLAD_API_CALL PFNGLMAP1XOESPROC glad_glMap1xOES;
    GLAD_API_CALL PFNGLMAP1XOESPROC glad_debug_glMap1xOES;
#define glMap1xOES glad_debug_glMap1xOES
    GLAD_API_CALL PFNGLMAP2XOESPROC glad_glMap2xOES;
    GLAD_API_CALL PFNGLMAP2XOESPROC glad_debug_glMap2xOES;
#define glMap2xOES glad_debug_glMap2xOES
    GLAD_API_CALL PFNGLMAPBUFFERPROC glad_glMapBuffer;
    GLAD_API_CALL PFNGLMAPBUFFERPROC glad_debug_glMapBuffer;

/// <summary>
///   map all of a buffer object's data store into the client's address space
///   <para>
///     glMapBuffer and glMapNamedBuffer map the entire data store of a specified buffer object into
///     the client's address space. The data can then be directly read and/or written relative to
///     the returned pointer, depending on the specified access policy. A pointer to the beginning
///     of the mapped range is returned once all pending operations on that buffer object have
///     completed, and may be used to modify and/or query the corresponding range of the data store
///     according to the value of access : GL_READ_ONLY indicates that the returned pointer may be
///     used to read buffer object data. GL_WRITE_ONLY indicates that the returned pointer may be
///     used to modify buffer object data. GL_READ_WRITE indicates that the returned pointer may be
///     used to read and to modify buffer object data. If an error is generated, a NULL pointer is
///     returned. If no error occurs, the returned pointer will reflect an allocation aligned to the
///     value of GL_MIN_MAP_BUFFER_ALIGNMENT basic machine units. The returned pointer values may
///     not be passed as parameter values to GL commands. For example, they may not be used to
///     specify array pointers, or to specify or query pixel or texture image data; such actions
///     produce undefined results, although implementations may not check for such behavior for
///     performance reasons. No GL error is generated if the returned pointer is accessed in a way
///     inconsistent with access (e.g. used to read from a mapping made with access GL_WRITE_ONLY or
///     write to a mapping made with access GL_READ_ONLY ), but the result is undefined and system
///     errors (possibly including program termination) may occur. Mappings to the data stores of
///     buffer objects may have nonstandard performance characteristics. For example, such mappings
///     may be marked as uncacheable regions of memory, and in such cases reading from them may be
///     very slow. To ensure optimal performance, the client should use the mapping in a fashion
///     consistent with GL_BUFFER_USAGE (see glGet*BufferParameter and usage of glBufferData ) for
///     the buffer object and of access. Using a mapping in a fashion inconsistent with these values
///     is liable to be multiple orders of magnitude slower than using normal memory.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='access'>Specifies the access policy for</param>
#define glMapBuffer glad_debug_glMapBuffer
    GLAD_API_CALL PFNGLMAPBUFFERARBPROC glad_glMapBufferARB;
    GLAD_API_CALL PFNGLMAPBUFFERARBPROC glad_debug_glMapBufferARB;
#define glMapBufferARB glad_debug_glMapBufferARB
    GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
    GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_debug_glMapBufferRange;

/// <summary>
///   map all or part of a buffer object's data store into the client's address space
///   <para>
///     glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified
///     buffer object into the client's address space. offset and length indicate the range of data
///     in the buffer object that is to be mapped, in terms of basic machine units. access is a
///     bitfield containing flags which describe the requested mapping. These flags are described
///     below. A pointer to the beginning of the mapped range is returned once all pending
///     operations on the buffer object have completed, and may be used to modify and/or query the
///     corresponding range of the data store according to the following flag bits set in access :
///     GL_MAP_READ_BIT indicates that the returned pointer may be used to read buffer object data.
///     No GL error is generated if the pointer is used to query a mapping which excludes this flag,
///     but the result is undefined and system errors (possibly including program termination) may
///     occur. GL_MAP_WRITE_BIT indicates that the returned pointer may be used to modify buffer
///     object data. No GL error is generated if the pointer is used to modify a mapping which
///     excludes this flag, but the result is undefined and system errors (possibly including
///     program termination) may occur. GL_MAP_PERSISTENT_BIT indicates that the mapping is to be
///     made in a persistent fassion and that the client intends to hold and use the returned
///     pointer during subsequent GL operation. It is not an error to call drawing commands (render)
///     while buffers are mapped using this flag. It is an error to specify this flag if the
///     buffer's data store was not allocated through a call to the glBufferStorage command in which
///     the GL_MAP_PERSISTENT_BIT was also set. GL_MAP_COHERENT_BIT indicates that a persistent
///     mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a
///     buffer's data store by either the client or server will eventually become visible to the
///     other without further intervention from the application. In the absence of this bit,
///     persistent mappings are not coherent and modified ranges of the buffer store must be
///     explicitly communicated to the GL, either by unmapping the buffer, or through a call to
///     glFlushMappedBufferRange or glMemoryBarrier. The following optional flag bits in access may
///     be used to modify the mapping: GL_MAP_INVALIDATE_RANGE_BIT indicates that the previous
///     contents of the specified range may be discarded. Data within this range are undefined with
///     the exception of subsequently written data. No GL error is generated if subsequent GL
///     operations access unwritten data, but the result is undefined and system errors (possibly
///     including program termination) may occur. This flag may not be used in combination with
///     GL_MAP_READ_BIT. GL_MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
///     entire buffer may be discarded. Data within the entire buffer are undefined with the
///     exception of subsequently written data. No GL error is generated if subsequent GL operations
///     access unwritten data, but the result is undefined and system errors (possibly including
///     program termination) may occur. This flag may not be used in combination with
///     GL_MAP_READ_BIT. GL_MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges of
///     the mapping may be modified. When this flag is set, modifications to each subrange must be
///     explicitly flushed by calling glFlushMappedBufferRange. No GL error is set if a subrange of
///     the mapping is modified and not flushed, but data within the corresponding subrange of the
///     buffer are undefined. This flag may only be used in conjunction with GL_MAP_WRITE_BIT. When
///     this option is selected, flushing is strictly limited to regions that are explicitly
///     indicated with calls to glFlushMappedBufferRange prior to unmap; if this option is not
///     selected glUnmapBuffer will automatically flush the entire mapped range when called.
///     GL_MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to synchronize pending
///     operations on the buffer prior to returning from glMapBufferRange or glMapNamedBufferRange.
///     No GL error is generated if pending operations which source or modify the buffer overlap the
///     mapped region, but the result of such previous and any subsequent operations is undefined.
///     If an error occurs, a NULL pointer is returned. If no error occurs, the returned pointer
///     will reflect an allocation aligned to the value of GL_MIN_MAP_BUFFER_ALIGNMENT basic machine
///     units. Subtracting offset from this returned pointer will always produce a multiple of the
///     value of GL_MIN_MAP_BUFFER_ALIGNMENT. The returned pointer values may not be passed as
///     parameter values to GL commands. For example, they may not be used to specify array
///     pointers, or to specify or query pixel or texture image data; such actions produce undefined
///     results, although implementations may not check for such behavior for performance reasons.
///     Mappings to the data stores of buffer objects may have nonstandard performance
///     characteristics. For example, such mappings may be marked as uncacheable regions of memory,
///     and in such cases reading from them may be very slow. To ensure optimal performance, the
///     client should use the mapping in a fashion consistent with the values of GL_BUFFER_USAGE
///     (see glGet*BufferParameter and usage of glBufferData ) for the buffer object and of access.
///     Using a mapping in a fashion inconsistent with these values is liable to be multiple orders
///     of magnitude slower than using normal memory.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
/// <param name='offset'>Specifies the starting offset within the buffer of the range to be
/// mapped.</param> <param name='length'>Specifies the length of the range to be mapped.</param>
/// <param name='access'>Specifies a combination of access flags indicating the desired access to
/// the mapped range.</param>
#define glMapBufferRange glad_debug_glMapBufferRange
    GLAD_API_CALL PFNGLMAPCONTROLPOINTSNVPROC glad_glMapControlPointsNV;
    GLAD_API_CALL PFNGLMAPCONTROLPOINTSNVPROC glad_debug_glMapControlPointsNV;
#define glMapControlPointsNV glad_debug_glMapControlPointsNV
    GLAD_API_CALL PFNGLMAPGRID1XOESPROC glad_glMapGrid1xOES;
    GLAD_API_CALL PFNGLMAPGRID1XOESPROC glad_debug_glMapGrid1xOES;
#define glMapGrid1xOES glad_debug_glMapGrid1xOES
    GLAD_API_CALL PFNGLMAPGRID2XOESPROC glad_glMapGrid2xOES;
    GLAD_API_CALL PFNGLMAPGRID2XOESPROC glad_debug_glMapGrid2xOES;
#define glMapGrid2xOES glad_debug_glMapGrid2xOES
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERPROC glad_debug_glMapNamedBuffer;
#define glMapNamedBuffer glad_debug_glMapNamedBuffer
    GLAD_API_CALL PFNGLMAPNAMEDBUFFEREXTPROC glad_glMapNamedBufferEXT;
    GLAD_API_CALL PFNGLMAPNAMEDBUFFEREXTPROC glad_debug_glMapNamedBufferEXT;
#define glMapNamedBufferEXT glad_debug_glMapNamedBufferEXT
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEPROC glad_debug_glMapNamedBufferRange;
#define glMapNamedBufferRange glad_debug_glMapNamedBufferRange
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_glMapNamedBufferRangeEXT;
    GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_debug_glMapNamedBufferRangeEXT;
#define glMapNamedBufferRangeEXT glad_debug_glMapNamedBufferRangeEXT
    GLAD_API_CALL PFNGLMAPOBJECTBUFFERATIPROC glad_glMapObjectBufferATI;
    GLAD_API_CALL PFNGLMAPOBJECTBUFFERATIPROC glad_debug_glMapObjectBufferATI;
#define glMapObjectBufferATI glad_debug_glMapObjectBufferATI
    GLAD_API_CALL PFNGLMAPPARAMETERFVNVPROC glad_glMapParameterfvNV;
    GLAD_API_CALL PFNGLMAPPARAMETERFVNVPROC glad_debug_glMapParameterfvNV;
#define glMapParameterfvNV glad_debug_glMapParameterfvNV
    GLAD_API_CALL PFNGLMAPPARAMETERIVNVPROC glad_glMapParameterivNV;
    GLAD_API_CALL PFNGLMAPPARAMETERIVNVPROC glad_debug_glMapParameterivNV;
#define glMapParameterivNV glad_debug_glMapParameterivNV
    GLAD_API_CALL PFNGLMAPTEXTURE2DINTELPROC glad_glMapTexture2DINTEL;
    GLAD_API_CALL PFNGLMAPTEXTURE2DINTELPROC glad_debug_glMapTexture2DINTEL;
#define glMapTexture2DINTEL glad_debug_glMapTexture2DINTEL
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_glMapVertexAttrib1dAPPLE;
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_debug_glMapVertexAttrib1dAPPLE;
#define glMapVertexAttrib1dAPPLE glad_debug_glMapVertexAttrib1dAPPLE
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_glMapVertexAttrib1fAPPLE;
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_debug_glMapVertexAttrib1fAPPLE;
#define glMapVertexAttrib1fAPPLE glad_debug_glMapVertexAttrib1fAPPLE
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_glMapVertexAttrib2dAPPLE;
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_debug_glMapVertexAttrib2dAPPLE;
#define glMapVertexAttrib2dAPPLE glad_debug_glMapVertexAttrib2dAPPLE
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_glMapVertexAttrib2fAPPLE;
    GLAD_API_CALL PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_debug_glMapVertexAttrib2fAPPLE;
#define glMapVertexAttrib2fAPPLE glad_debug_glMapVertexAttrib2fAPPLE
    GLAD_API_CALL PFNGLMATERIALXOESPROC glad_glMaterialxOES;
    GLAD_API_CALL PFNGLMATERIALXOESPROC glad_debug_glMaterialxOES;
#define glMaterialxOES glad_debug_glMaterialxOES
    GLAD_API_CALL PFNGLMATERIALXVOESPROC glad_glMaterialxvOES;
    GLAD_API_CALL PFNGLMATERIALXVOESPROC glad_debug_glMaterialxvOES;
#define glMaterialxvOES glad_debug_glMaterialxvOES
    GLAD_API_CALL PFNGLMATRIXFRUSTUMEXTPROC glad_glMatrixFrustumEXT;
    GLAD_API_CALL PFNGLMATRIXFRUSTUMEXTPROC glad_debug_glMatrixFrustumEXT;
#define glMatrixFrustumEXT glad_debug_glMatrixFrustumEXT
    GLAD_API_CALL PFNGLMATRIXINDEXPOINTERARBPROC glad_glMatrixIndexPointerARB;
    GLAD_API_CALL PFNGLMATRIXINDEXPOINTERARBPROC glad_debug_glMatrixIndexPointerARB;
#define glMatrixIndexPointerARB glad_debug_glMatrixIndexPointerARB
    GLAD_API_CALL PFNGLMATRIXINDEXUBVARBPROC glad_glMatrixIndexubvARB;
    GLAD_API_CALL PFNGLMATRIXINDEXUBVARBPROC glad_debug_glMatrixIndexubvARB;
#define glMatrixIndexubvARB glad_debug_glMatrixIndexubvARB
    GLAD_API_CALL PFNGLMATRIXINDEXUIVARBPROC glad_glMatrixIndexuivARB;
    GLAD_API_CALL PFNGLMATRIXINDEXUIVARBPROC glad_debug_glMatrixIndexuivARB;
#define glMatrixIndexuivARB glad_debug_glMatrixIndexuivARB
    GLAD_API_CALL PFNGLMATRIXINDEXUSVARBPROC glad_glMatrixIndexusvARB;
    GLAD_API_CALL PFNGLMATRIXINDEXUSVARBPROC glad_debug_glMatrixIndexusvARB;
#define glMatrixIndexusvARB glad_debug_glMatrixIndexusvARB
    GLAD_API_CALL PFNGLMATRIXLOAD3X2FNVPROC glad_glMatrixLoad3x2fNV;
    GLAD_API_CALL PFNGLMATRIXLOAD3X2FNVPROC glad_debug_glMatrixLoad3x2fNV;
#define glMatrixLoad3x2fNV glad_debug_glMatrixLoad3x2fNV
    GLAD_API_CALL PFNGLMATRIXLOAD3X3FNVPROC glad_glMatrixLoad3x3fNV;
    GLAD_API_CALL PFNGLMATRIXLOAD3X3FNVPROC glad_debug_glMatrixLoad3x3fNV;
#define glMatrixLoad3x3fNV glad_debug_glMatrixLoad3x3fNV
    GLAD_API_CALL PFNGLMATRIXLOADIDENTITYEXTPROC glad_glMatrixLoadIdentityEXT;
    GLAD_API_CALL PFNGLMATRIXLOADIDENTITYEXTPROC glad_debug_glMatrixLoadIdentityEXT;
#define glMatrixLoadIdentityEXT glad_debug_glMatrixLoadIdentityEXT
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_glMatrixLoadTranspose3x3fNV;
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_debug_glMatrixLoadTranspose3x3fNV;
#define glMatrixLoadTranspose3x3fNV glad_debug_glMatrixLoadTranspose3x3fNV
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_glMatrixLoadTransposedEXT;
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_debug_glMatrixLoadTransposedEXT;
#define glMatrixLoadTransposedEXT glad_debug_glMatrixLoadTransposedEXT
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_glMatrixLoadTransposefEXT;
    GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_debug_glMatrixLoadTransposefEXT;
#define glMatrixLoadTransposefEXT glad_debug_glMatrixLoadTransposefEXT
    GLAD_API_CALL PFNGLMATRIXLOADDEXTPROC glad_glMatrixLoaddEXT;
    GLAD_API_CALL PFNGLMATRIXLOADDEXTPROC glad_debug_glMatrixLoaddEXT;
#define glMatrixLoaddEXT glad_debug_glMatrixLoaddEXT
    GLAD_API_CALL PFNGLMATRIXLOADFEXTPROC glad_glMatrixLoadfEXT;
    GLAD_API_CALL PFNGLMATRIXLOADFEXTPROC glad_debug_glMatrixLoadfEXT;
#define glMatrixLoadfEXT glad_debug_glMatrixLoadfEXT
    GLAD_API_CALL PFNGLMATRIXMULT3X2FNVPROC glad_glMatrixMult3x2fNV;
    GLAD_API_CALL PFNGLMATRIXMULT3X2FNVPROC glad_debug_glMatrixMult3x2fNV;
#define glMatrixMult3x2fNV glad_debug_glMatrixMult3x2fNV
    GLAD_API_CALL PFNGLMATRIXMULT3X3FNVPROC glad_glMatrixMult3x3fNV;
    GLAD_API_CALL PFNGLMATRIXMULT3X3FNVPROC glad_debug_glMatrixMult3x3fNV;
#define glMatrixMult3x3fNV glad_debug_glMatrixMult3x3fNV
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_glMatrixMultTranspose3x3fNV;
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_debug_glMatrixMultTranspose3x3fNV;
#define glMatrixMultTranspose3x3fNV glad_debug_glMatrixMultTranspose3x3fNV
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_glMatrixMultTransposedEXT;
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_debug_glMatrixMultTransposedEXT;
#define glMatrixMultTransposedEXT glad_debug_glMatrixMultTransposedEXT
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_glMatrixMultTransposefEXT;
    GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_debug_glMatrixMultTransposefEXT;
#define glMatrixMultTransposefEXT glad_debug_glMatrixMultTransposefEXT
    GLAD_API_CALL PFNGLMATRIXMULTDEXTPROC glad_glMatrixMultdEXT;
    GLAD_API_CALL PFNGLMATRIXMULTDEXTPROC glad_debug_glMatrixMultdEXT;
#define glMatrixMultdEXT glad_debug_glMatrixMultdEXT
    GLAD_API_CALL PFNGLMATRIXMULTFEXTPROC glad_glMatrixMultfEXT;
    GLAD_API_CALL PFNGLMATRIXMULTFEXTPROC glad_debug_glMatrixMultfEXT;
#define glMatrixMultfEXT glad_debug_glMatrixMultfEXT
    GLAD_API_CALL PFNGLMATRIXORTHOEXTPROC glad_glMatrixOrthoEXT;
    GLAD_API_CALL PFNGLMATRIXORTHOEXTPROC glad_debug_glMatrixOrthoEXT;
#define glMatrixOrthoEXT glad_debug_glMatrixOrthoEXT
    GLAD_API_CALL PFNGLMATRIXPOPEXTPROC glad_glMatrixPopEXT;
    GLAD_API_CALL PFNGLMATRIXPOPEXTPROC glad_debug_glMatrixPopEXT;
#define glMatrixPopEXT glad_debug_glMatrixPopEXT
    GLAD_API_CALL PFNGLMATRIXPUSHEXTPROC glad_glMatrixPushEXT;
    GLAD_API_CALL PFNGLMATRIXPUSHEXTPROC glad_debug_glMatrixPushEXT;
#define glMatrixPushEXT glad_debug_glMatrixPushEXT
    GLAD_API_CALL PFNGLMATRIXROTATEDEXTPROC glad_glMatrixRotatedEXT;
    GLAD_API_CALL PFNGLMATRIXROTATEDEXTPROC glad_debug_glMatrixRotatedEXT;
#define glMatrixRotatedEXT glad_debug_glMatrixRotatedEXT
    GLAD_API_CALL PFNGLMATRIXROTATEFEXTPROC glad_glMatrixRotatefEXT;
    GLAD_API_CALL PFNGLMATRIXROTATEFEXTPROC glad_debug_glMatrixRotatefEXT;
#define glMatrixRotatefEXT glad_debug_glMatrixRotatefEXT
    GLAD_API_CALL PFNGLMATRIXSCALEDEXTPROC glad_glMatrixScaledEXT;
    GLAD_API_CALL PFNGLMATRIXSCALEDEXTPROC glad_debug_glMatrixScaledEXT;
#define glMatrixScaledEXT glad_debug_glMatrixScaledEXT
    GLAD_API_CALL PFNGLMATRIXSCALEFEXTPROC glad_glMatrixScalefEXT;
    GLAD_API_CALL PFNGLMATRIXSCALEFEXTPROC glad_debug_glMatrixScalefEXT;
#define glMatrixScalefEXT glad_debug_glMatrixScalefEXT
    GLAD_API_CALL PFNGLMATRIXTRANSLATEDEXTPROC glad_glMatrixTranslatedEXT;
    GLAD_API_CALL PFNGLMATRIXTRANSLATEDEXTPROC glad_debug_glMatrixTranslatedEXT;
#define glMatrixTranslatedEXT glad_debug_glMatrixTranslatedEXT
    GLAD_API_CALL PFNGLMATRIXTRANSLATEFEXTPROC glad_glMatrixTranslatefEXT;
    GLAD_API_CALL PFNGLMATRIXTRANSLATEFEXTPROC glad_debug_glMatrixTranslatefEXT;
#define glMatrixTranslatefEXT glad_debug_glMatrixTranslatefEXT
    GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_glMaxShaderCompilerThreadsARB;
    GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_debug_glMaxShaderCompilerThreadsARB;
#define glMaxShaderCompilerThreadsARB glad_debug_glMaxShaderCompilerThreadsARB
    GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_glMaxShaderCompilerThreadsKHR;
    GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_debug_glMaxShaderCompilerThreadsKHR;
#define glMaxShaderCompilerThreadsKHR glad_debug_glMaxShaderCompilerThreadsKHR
    GLAD_API_CALL PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;
    GLAD_API_CALL PFNGLMEMORYBARRIERPROC glad_debug_glMemoryBarrier;

/// <summary>
///   defines a barrier ordering memory transactions
///   <para>
///     glMemoryBarrier defines a barrier ordering the memory transactions issued prior to the
///     command relative to those issued after the barrier. For the purposes of this ordering,
///     memory transactions performed by shaders are considered to be issued by the rendering
///     command that triggered the execution of the shader. barriers is a bitfield indicating the
///     set of operations that are synchronized with shader stores; the bits used in barriers are as
///     follows: If set, vertex data sourced from buffer objects after the barrier will reflect data
///     written by shaders prior to the barrier. The set of buffer objects affected by this bit is
///     derived from the buffer object bindings used for generic vertex attributes derived from the
///     GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings. If set, vertex array indices sourced from buffer
///     objects after the barrier will reflect data written by shaders prior to the barrier. The
///     buffer objects affected by this bit are derived from the GL_ELEMENT_ARRAY_BUFFER binding.
///     Shader uniforms sourced from buffer objects after the barrier will reflect data written by
///     shaders prior to the barrier. Texture fetches from shaders, including fetches from buffer
///     object memory via buffer textures, after the barrier will reflect data written by shaders
///     prior to the barrier. Memory accesses using shader image load, store, and atomic built-in
///     functions issued after the barrier will reflect data written by shaders prior to the
///     barrier. Additionally, image stores and atomics issued after the barrier will not execute
///     until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated
///     prior to the barrier complete. Command data sourced from buffer objects by Draw*Indirect
///     commands after the barrier will reflect data written by shaders prior to the barrier. The
///     buffer objects affected by this bit are derived from the GL_DRAW_INDIRECT_BUFFER binding.
///     Reads and writes of buffer objects via the GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER
///     bindings (via glReadPixels , glTexSubImage , etc.) after the barrier will reflect data
///     written by shaders prior to the barrier. Additionally, buffer object writes issued after the
///     barrier will wait on the completion of all shader writes initiated prior to the barrier.
///     Writes to a texture via glTex(Sub)Image* , glCopyTex(Sub)Image* , glCompressedTex(Sub)Image*
///     , and reads via glGetTexImage after the barrier will reflect data written by shaders prior
///     to the barrier. Additionally, texture writes from these commands issued after the barrier
///     will not execute until all shader writes initiated prior to the barrier complete. Reads or
///     writes via glBufferSubData , glCopyBufferSubData , or glGetBufferSubData , or to buffer
///     object memory mapped by glMapBuffer or glMapBufferRange after the barrier will reflect data
///     written by shaders prior to the barrier. Additionally, writes via these commands issued
///     after the barrier will wait on the completion of any shader writes to the same memory
///     initiated prior to the barrier. Reads and writes via framebuffer object attachments after
///     the barrier will reflect data written by shaders prior to the barrier. Additionally,
///     framebuffer writes issued after the barrier will wait on the completion of all shader writes
///     issued prior to the barrier. Writes via transform feedback bindings after the barrier will
///     reflect data written by shaders prior to the barrier. Additionally, transform feedback
///     writes issued after the barrier will wait on the completion of all shader writes issued
///     prior to the barrier. Accesses to atomic counters after the barrier will reflect writes
///     prior to the barrier. Accesses to shader storage blocks after the barrier will reflect
///     writes prior to the barrier. Writes of buffer objects via the GL_QUERY_BUFFER binding after
///     the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer
///     object writes issued after the barrier will wait on the completion of all shader writes
///     initiated prior to the barrier. If barriers is GL_ALL_BARRIER_BITS , shader memory accesses
///     will be synchronized relative to all the operations described above. Implementations may
///     cache buffer object and texture image memory that could be written by shaders in multiple
///     caches; for example, there may be separate caches for texture, vertex fetching, and one or
///     more caches for shader memory accesses. Implementations are not required to keep these
///     caches coherent with shader memory writes. Stores issued by one invocation may not be
///     immediately observable by other pipeline stages or other shader invocations because the
///     value stored may remain in a cache local to the processor executing the store, or because
///     data overwritten by the store is still in a cache elsewhere in the system. When
///     glMemoryBarrier is called, the GL flushes and/or invalidates any caches relevant to the
///     operations specified by the barriers parameter to ensure consistent ordering of operations
///     across the barrier. To allow for independent shader invocations to communicate by reads and
///     writes to a common memory address, image variables in the OpenGL Shading Language may be
///     declared as "coherent". Buffer object or texture image memory accessed through such
///     variables may be cached only if caches are automatically updated due to stores issued by any
///     other shader invocation. If the same address is accessed using both coherent and
///     non-coherent variables, the accesses using variables declared as coherent will observe the
///     results stored using coherent variables in other invocations. Using variables declared as
///     "coherent" guarantees only that the results of stores will be immediately visible to shader
///     invocations using similarly-declared variables; calling glMemoryBarrier is required to
///     ensure that the stores are visible to other operations. The following guidelines may be
///     helpful in choosing when to use coherent memory accesses and when to use barriers. Data that
///     are read-only or constant may be accessed without using coherent variables or calling
///     MemoryBarrier (). Updates to the read-only data via API calls such as glBufferSubData will
///     invalidate shader caches implicitly as required. Data that are shared between shader
///     invocations at a fine granularity (e.g., written by one invocation, consumed by another
///     invocation) should use coherent variables to read and write the shared data. Data written by
///     one shader invocation and consumed by other shader invocations launched as a result of its
///     execution ("dependent invocations") should use coherent variables in the producing shader
///     invocation and call memoryBarrier () after the last write. The consuming shader invocation
///     should also use coherent variables. Data written to image variables in one rendering pass
///     and read by the shader in a later pass need not use coherent variables or memoryBarrier().
///     Calling glMemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in barriers between
///     passes is necessary. Data written by the shader in one rendering pass and read by another
///     mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent
///     variables or memoryBarrier (). Calling glMemoryBarrier with the appropriate bits set in
///     barriers between passes is necessary.
///   </para>
/// </summary>
/// <param name='barriers'>Specifies the barriers to insert.</param>
#define glMemoryBarrier glad_debug_glMemoryBarrier
    GLAD_API_CALL PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;
    GLAD_API_CALL PFNGLMEMORYBARRIERBYREGIONPROC glad_debug_glMemoryBarrierByRegion;
#define glMemoryBarrierByRegion glad_debug_glMemoryBarrierByRegion
    GLAD_API_CALL PFNGLMEMORYBARRIEREXTPROC glad_glMemoryBarrierEXT;
    GLAD_API_CALL PFNGLMEMORYBARRIEREXTPROC glad_debug_glMemoryBarrierEXT;
#define glMemoryBarrierEXT glad_debug_glMemoryBarrierEXT
    GLAD_API_CALL PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_glMemoryObjectParameterivEXT;
    GLAD_API_CALL PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_debug_glMemoryObjectParameterivEXT;
#define glMemoryObjectParameterivEXT glad_debug_glMemoryObjectParameterivEXT
    GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
    GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_debug_glMinSampleShading;

/// <summary>
///   specifies minimum rate at which sample shading takes place
///   <para>
///     glMinSampleShading specifies the rate at which samples are shaded within a covered pixel.
///     Sample-rate shading is enabled by calling glEnable with the parameter GL_SAMPLE_SHADING. If
///     GL_MULTISAMPLE or GL_SAMPLE_SHADING is disabled, sample shading has no effect. Otherwise, an
///     implementation must provide at least as many unique color values for each covered fragment
///     as specified by value times samples where samples is the value of GL_SAMPLES for the current
///     framebuffer. At least 1 sample for each covered fragment is generated. A value of 1.0
///     indicates that each sample in the framebuffer should be indpendently shaded. A value of 0.0
///     effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0
///     allows the GL to shade only a subset of the total samples within each covered fragment.
///     Which samples are shaded and the algorithm used to select that subset of the fragment's
///     samples is implementation dependent.
///   </para>
/// </summary>
/// <param name='value'>Specifies the rate at which samples are shaded within each covered
/// pixel.</param>
#define glMinSampleShading glad_debug_glMinSampleShading
    GLAD_API_CALL PFNGLMINSAMPLESHADINGARBPROC glad_glMinSampleShadingARB;
    GLAD_API_CALL PFNGLMINSAMPLESHADINGARBPROC glad_debug_glMinSampleShadingARB;
#define glMinSampleShadingARB glad_debug_glMinSampleShadingARB
    GLAD_API_CALL PFNGLMINMAXEXTPROC glad_glMinmaxEXT;
    GLAD_API_CALL PFNGLMINMAXEXTPROC glad_debug_glMinmaxEXT;
#define glMinmaxEXT glad_debug_glMinmaxEXT
    GLAD_API_CALL PFNGLMULTMATRIXXOESPROC glad_glMultMatrixxOES;
    GLAD_API_CALL PFNGLMULTMATRIXXOESPROC glad_debug_glMultMatrixxOES;
#define glMultMatrixxOES glad_debug_glMultMatrixxOES
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_glMultTransposeMatrixdARB;
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_debug_glMultTransposeMatrixdARB;
#define glMultTransposeMatrixdARB glad_debug_glMultTransposeMatrixdARB
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_glMultTransposeMatrixfARB;
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_debug_glMultTransposeMatrixfARB;
#define glMultTransposeMatrixfARB glad_debug_glMultTransposeMatrixfARB
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXXOESPROC glad_glMultTransposeMatrixxOES;
    GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXXOESPROC glad_debug_glMultTransposeMatrixxOES;
#define glMultTransposeMatrixxOES glad_debug_glMultTransposeMatrixxOES
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_debug_glMultiDrawArrays;

/// <summary>
///   render multiple sets of primitives from array data
///   <para>
///     glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine
///     calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture
///     coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals,
///     and colors and use them to construct a sequence of primitives with a single call to
///     glMultiDrawArrays. glMultiDrawArrays behaves identically to glDrawArrays except that
///     drawcount separate ranges of elements are specified instead. When glMultiDrawArrays is
///     called, it uses count sequential elements from each enabled array to construct a sequence of
///     geometric primitives, beginning with element first. mode specifies what kind of primitives
///     are constructed, and how the array elements construct those primitives. Vertex attributes
///     that are modified by glMultiDrawArrays have an unspecified value after glMultiDrawArrays
///     returns. Attributes that aren't modified remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='first'>Points to an array of starting indices in the enabled arrays.</param>
/// <param name='count'>Points to an array of the number of indices to be rendered.</param>
/// <param name='drawcount'>Specifies the size of the first and count</param>
#define glMultiDrawArrays glad_debug_glMultiDrawArrays
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSEXTPROC glad_glMultiDrawArraysEXT;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSEXTPROC glad_debug_glMultiDrawArraysEXT;
#define glMultiDrawArraysEXT glad_debug_glMultiDrawArraysEXT
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_debug_glMultiDrawArraysIndirect;

/// <summary>
///   render multiple sets of primitives from array data, taking parameters from memory
///   <para>
///     glMultiDrawArraysIndirect specifies multiple geometric primitives with very few subroutine
///     calls. glMultiDrawArraysIndirect behaves similarly to a multitude of calls to
///     glDrawArraysInstancedBaseInstance , execept that the parameters to each call to
///     glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by
///     indirect , separated by the stride, in basic machine units, specified by stride. If stride
///     is zero, then the array is assumed to be tightly packed in memory. The parameters addressed
///     by indirect are packed into an array of structures, each element of which takes the form (in
///     C): A single call to glMultiDrawArraysIndirect is equivalent, assuming no errors are
///     generated to: If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a
///     call to glMultiDrawArraysIndirect , indirect is interpreted as an offset, in basic machine
///     units, into that buffer and the parameter data is read from the buffer rather than from
///     client memory. In contrast to glDrawArraysInstancedBaseInstance , the first member of the
///     parameter structure is unsigned, and out-of-range indices do not generate an error. Vertex
///     attributes that are modified by glMultiDrawArraysIndirect have an unspecified value after
///     glMultiDrawArraysIndirect returns. Attributes that aren't modified remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='indirect'>Specifies the address of an array of structures containing the draw
/// parameters.</param> <param name='drawcount'>Specifies the the number of elements in the array of
/// draw parameter structures.</param> <param name='stride'>Specifies the distance in basic machine
/// units between elements of the draw parameter array.</param>
#define glMultiDrawArraysIndirect glad_debug_glMultiDrawArraysIndirect
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_glMultiDrawArraysIndirectAMD;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_debug_glMultiDrawArraysIndirectAMD;
#define glMultiDrawArraysIndirectAMD glad_debug_glMultiDrawArraysIndirectAMD
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC
        glad_glMultiDrawArraysIndirectBindlessCountNV;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC
        glad_debug_glMultiDrawArraysIndirectBindlessCountNV;
#define glMultiDrawArraysIndirectBindlessCountNV glad_debug_glMultiDrawArraysIndirectBindlessCountNV
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC
        glad_glMultiDrawArraysIndirectBindlessNV;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC
        glad_debug_glMultiDrawArraysIndirectBindlessNV;
#define glMultiDrawArraysIndirectBindlessNV glad_debug_glMultiDrawArraysIndirectBindlessNV
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_debug_glMultiDrawArraysIndirectCount;
#define glMultiDrawArraysIndirectCount glad_debug_glMultiDrawArraysIndirectCount
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glad_glMultiDrawArraysIndirectCountARB;
    GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC
        glad_debug_glMultiDrawArraysIndirectCountARB;
#define glMultiDrawArraysIndirectCountARB glad_debug_glMultiDrawArraysIndirectCountARB
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_glMultiDrawElementArrayAPPLE;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_debug_glMultiDrawElementArrayAPPLE;
#define glMultiDrawElementArrayAPPLE glad_debug_glMultiDrawElementArrayAPPLE
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_debug_glMultiDrawElements;

/// <summary>
///   render multiple sets of primitives by specifying indices of array data elements
///   <para>
///     glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine
///     calls. Instead of calling a GL function to pass each individual vertex, normal, texture
///     coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals,
///     and so on, and use them to construct a sequence of primitives with a single call to
///     glMultiDrawElements. glMultiDrawElements is identical in operation to glDrawElements except
///     that drawcount separate lists of elements are specified. Vertex attributes that are modified
///     by glMultiDrawElements have an unspecified value after glMultiDrawElements returns.
///     Attributes that aren't modified maintain their previous values.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Points to an array of the elements counts.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='drawcount'>Specifies the size of the</param>
#define glMultiDrawElements glad_debug_glMultiDrawElements
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_debug_glMultiDrawElementsBaseVertex;

/// <summary>
///   render multiple sets of primitives by specifying indices of array data elements and an index
///   to apply to each index <para>
///     glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex , except that
///     drawcount separate lists of elements are specifried instead. It has the same effect as:
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='count'>Points to an array of the elements counts.</param>
/// <param name='type'>Specifies the type of the values in</param>
/// <param name='indices'>Specifies a pointer to the location where the indices are stored.</param>
/// <param name='drawcount'>Specifies the size of the</param>
/// <param name='basevertex'>Specifies a pointer to the location where the base vertices are
/// stored.</param>
#define glMultiDrawElementsBaseVertex glad_debug_glMultiDrawElementsBaseVertex
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSEXTPROC glad_glMultiDrawElementsEXT;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSEXTPROC glad_debug_glMultiDrawElementsEXT;
#define glMultiDrawElementsEXT glad_debug_glMultiDrawElementsEXT
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_debug_glMultiDrawElementsIndirect;

/// <summary>
///   render indexed primitives from array data, taking parameters from memory
///   <para>
///     glMultiDrawElementsIndirect specifies multiple indexed geometric primitives with very few
///     subroutine calls. glMultiDrawElementsIndirect behaves similarly to a multitude of calls to
///     glDrawElementsInstancedBaseVertexBaseInstance , execpt that the parameters to
///     glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the
///     address given by indirect , separated by the stride, in basic machine units, specified by
///     stride. If stride is zero, then the array is assumed to be tightly packed in memory. The
///     parameters addressed by indirect are packed into a structure that takes the form (in C): A
///     single call to glMultiDrawElementsIndirect is equivalent, assuming no errors are generated
///     to: If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a call to
///     glDrawElementsIndirect , indirect is interpreted as an offset, in basic machine units, into
///     that buffer and the parameter data is read from the buffer rather than from client memory.
///     Note that indices stored in client memory are not supported. If no buffer is bound to the
///     GL_ELEMENT_ARRAY_BUFFER binding, an error will be generated. The results of the operation
///     are undefined if the reservedMustBeZero member of the parameter structure is non-zero.
///     However, no error is generated in this case. Vertex attributes that are modified by
///     glDrawElementsIndirect have an unspecified value after glDrawElementsIndirect returns.
///     Attributes that aren't modified remain well defined.
///   </para>
/// </summary>
/// <param name='mode'>Specifies what kind of primitives to render. Symbolic constants</param>
/// <param name='type'>Specifies the type of data in the buffer bound to the</param>
/// <param name='indirect'>Specifies the address of a structure containing an array of draw
/// parameters.</param> <param name='drawcount'>Specifies the number of elements in the array
/// addressed by</param> <param name='stride'>Specifies the distance in basic machine units between
/// elements of the draw parameter array.</param>
#define glMultiDrawElementsIndirect glad_debug_glMultiDrawElementsIndirect
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_glMultiDrawElementsIndirectAMD;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_debug_glMultiDrawElementsIndirectAMD;
#define glMultiDrawElementsIndirectAMD glad_debug_glMultiDrawElementsIndirectAMD
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC
        glad_glMultiDrawElementsIndirectBindlessCountNV;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC
        glad_debug_glMultiDrawElementsIndirectBindlessCountNV;
#define glMultiDrawElementsIndirectBindlessCountNV \
    glad_debug_glMultiDrawElementsIndirectBindlessCountNV
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC
        glad_glMultiDrawElementsIndirectBindlessNV;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC
        glad_debug_glMultiDrawElementsIndirectBindlessNV;
#define glMultiDrawElementsIndirectBindlessNV glad_debug_glMultiDrawElementsIndirectBindlessNV
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC
        glad_debug_glMultiDrawElementsIndirectCount;
#define glMultiDrawElementsIndirectCount glad_debug_glMultiDrawElementsIndirectCount
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC
        glad_glMultiDrawElementsIndirectCountARB;
    GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC
        glad_debug_glMultiDrawElementsIndirectCountARB;
#define glMultiDrawElementsIndirectCountARB glad_debug_glMultiDrawElementsIndirectCountARB
    GLAD_API_CALL PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC
        glad_glMultiDrawMeshTasksIndirectCountNV;
    GLAD_API_CALL PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC
        glad_debug_glMultiDrawMeshTasksIndirectCountNV;
#define glMultiDrawMeshTasksIndirectCountNV glad_debug_glMultiDrawMeshTasksIndirectCountNV
    GLAD_API_CALL PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC glad_glMultiDrawMeshTasksIndirectNV;
    GLAD_API_CALL PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC glad_debug_glMultiDrawMeshTasksIndirectNV;
#define glMultiDrawMeshTasksIndirectNV glad_debug_glMultiDrawMeshTasksIndirectNV
    GLAD_API_CALL PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC glad_glMultiDrawRangeElementArrayAPPLE;
    GLAD_API_CALL PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC
        glad_debug_glMultiDrawRangeElementArrayAPPLE;
#define glMultiDrawRangeElementArrayAPPLE glad_debug_glMultiDrawRangeElementArrayAPPLE
    GLAD_API_CALL PFNGLMULTIMODEDRAWARRAYSIBMPROC glad_glMultiModeDrawArraysIBM;
    GLAD_API_CALL PFNGLMULTIMODEDRAWARRAYSIBMPROC glad_debug_glMultiModeDrawArraysIBM;
#define glMultiModeDrawArraysIBM glad_debug_glMultiModeDrawArraysIBM
    GLAD_API_CALL PFNGLMULTIMODEDRAWELEMENTSIBMPROC glad_glMultiModeDrawElementsIBM;
    GLAD_API_CALL PFNGLMULTIMODEDRAWELEMENTSIBMPROC glad_debug_glMultiModeDrawElementsIBM;
#define glMultiModeDrawElementsIBM glad_debug_glMultiModeDrawElementsIBM
    GLAD_API_CALL PFNGLMULTITEXBUFFEREXTPROC glad_glMultiTexBufferEXT;
    GLAD_API_CALL PFNGLMULTITEXBUFFEREXTPROC glad_debug_glMultiTexBufferEXT;
#define glMultiTexBufferEXT glad_debug_glMultiTexBufferEXT
    GLAD_API_CALL PFNGLMULTITEXCOORD1BOESPROC glad_glMultiTexCoord1bOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD1BOESPROC glad_debug_glMultiTexCoord1bOES;
#define glMultiTexCoord1bOES glad_debug_glMultiTexCoord1bOES
    GLAD_API_CALL PFNGLMULTITEXCOORD1BVOESPROC glad_glMultiTexCoord1bvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD1BVOESPROC glad_debug_glMultiTexCoord1bvOES;
#define glMultiTexCoord1bvOES glad_debug_glMultiTexCoord1bvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD1DARBPROC glad_glMultiTexCoord1dARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1DARBPROC glad_debug_glMultiTexCoord1dARB;
#define glMultiTexCoord1dARB glad_debug_glMultiTexCoord1dARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1DVARBPROC glad_glMultiTexCoord1dvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1DVARBPROC glad_debug_glMultiTexCoord1dvARB;
#define glMultiTexCoord1dvARB glad_debug_glMultiTexCoord1dvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1FARBPROC glad_glMultiTexCoord1fARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1FARBPROC glad_debug_glMultiTexCoord1fARB;
#define glMultiTexCoord1fARB glad_debug_glMultiTexCoord1fARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1FVARBPROC glad_glMultiTexCoord1fvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1FVARBPROC glad_debug_glMultiTexCoord1fvARB;
#define glMultiTexCoord1fvARB glad_debug_glMultiTexCoord1fvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1HNVPROC glad_glMultiTexCoord1hNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD1HNVPROC glad_debug_glMultiTexCoord1hNV;
#define glMultiTexCoord1hNV glad_debug_glMultiTexCoord1hNV
    GLAD_API_CALL PFNGLMULTITEXCOORD1HVNVPROC glad_glMultiTexCoord1hvNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD1HVNVPROC glad_debug_glMultiTexCoord1hvNV;
#define glMultiTexCoord1hvNV glad_debug_glMultiTexCoord1hvNV
    GLAD_API_CALL PFNGLMULTITEXCOORD1IARBPROC glad_glMultiTexCoord1iARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1IARBPROC glad_debug_glMultiTexCoord1iARB;
#define glMultiTexCoord1iARB glad_debug_glMultiTexCoord1iARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1IVARBPROC glad_glMultiTexCoord1ivARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1IVARBPROC glad_debug_glMultiTexCoord1ivARB;
#define glMultiTexCoord1ivARB glad_debug_glMultiTexCoord1ivARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1SARBPROC glad_glMultiTexCoord1sARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1SARBPROC glad_debug_glMultiTexCoord1sARB;
#define glMultiTexCoord1sARB glad_debug_glMultiTexCoord1sARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1SVARBPROC glad_glMultiTexCoord1svARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD1SVARBPROC glad_debug_glMultiTexCoord1svARB;
#define glMultiTexCoord1svARB glad_debug_glMultiTexCoord1svARB
    GLAD_API_CALL PFNGLMULTITEXCOORD1XOESPROC glad_glMultiTexCoord1xOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD1XOESPROC glad_debug_glMultiTexCoord1xOES;
#define glMultiTexCoord1xOES glad_debug_glMultiTexCoord1xOES
    GLAD_API_CALL PFNGLMULTITEXCOORD1XVOESPROC glad_glMultiTexCoord1xvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD1XVOESPROC glad_debug_glMultiTexCoord1xvOES;
#define glMultiTexCoord1xvOES glad_debug_glMultiTexCoord1xvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD2BOESPROC glad_glMultiTexCoord2bOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD2BOESPROC glad_debug_glMultiTexCoord2bOES;
#define glMultiTexCoord2bOES glad_debug_glMultiTexCoord2bOES
    GLAD_API_CALL PFNGLMULTITEXCOORD2BVOESPROC glad_glMultiTexCoord2bvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD2BVOESPROC glad_debug_glMultiTexCoord2bvOES;
#define glMultiTexCoord2bvOES glad_debug_glMultiTexCoord2bvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD2DARBPROC glad_glMultiTexCoord2dARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2DARBPROC glad_debug_glMultiTexCoord2dARB;
#define glMultiTexCoord2dARB glad_debug_glMultiTexCoord2dARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2DVARBPROC glad_glMultiTexCoord2dvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2DVARBPROC glad_debug_glMultiTexCoord2dvARB;
#define glMultiTexCoord2dvARB glad_debug_glMultiTexCoord2dvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2FARBPROC glad_glMultiTexCoord2fARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2FARBPROC glad_debug_glMultiTexCoord2fARB;
#define glMultiTexCoord2fARB glad_debug_glMultiTexCoord2fARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2FVARBPROC glad_glMultiTexCoord2fvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2FVARBPROC glad_debug_glMultiTexCoord2fvARB;
#define glMultiTexCoord2fvARB glad_debug_glMultiTexCoord2fvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2HNVPROC glad_glMultiTexCoord2hNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD2HNVPROC glad_debug_glMultiTexCoord2hNV;
#define glMultiTexCoord2hNV glad_debug_glMultiTexCoord2hNV
    GLAD_API_CALL PFNGLMULTITEXCOORD2HVNVPROC glad_glMultiTexCoord2hvNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD2HVNVPROC glad_debug_glMultiTexCoord2hvNV;
#define glMultiTexCoord2hvNV glad_debug_glMultiTexCoord2hvNV
    GLAD_API_CALL PFNGLMULTITEXCOORD2IARBPROC glad_glMultiTexCoord2iARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2IARBPROC glad_debug_glMultiTexCoord2iARB;
#define glMultiTexCoord2iARB glad_debug_glMultiTexCoord2iARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2IVARBPROC glad_glMultiTexCoord2ivARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2IVARBPROC glad_debug_glMultiTexCoord2ivARB;
#define glMultiTexCoord2ivARB glad_debug_glMultiTexCoord2ivARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2SARBPROC glad_glMultiTexCoord2sARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2SARBPROC glad_debug_glMultiTexCoord2sARB;
#define glMultiTexCoord2sARB glad_debug_glMultiTexCoord2sARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2SVARBPROC glad_glMultiTexCoord2svARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD2SVARBPROC glad_debug_glMultiTexCoord2svARB;
#define glMultiTexCoord2svARB glad_debug_glMultiTexCoord2svARB
    GLAD_API_CALL PFNGLMULTITEXCOORD2XOESPROC glad_glMultiTexCoord2xOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD2XOESPROC glad_debug_glMultiTexCoord2xOES;
#define glMultiTexCoord2xOES glad_debug_glMultiTexCoord2xOES
    GLAD_API_CALL PFNGLMULTITEXCOORD2XVOESPROC glad_glMultiTexCoord2xvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD2XVOESPROC glad_debug_glMultiTexCoord2xvOES;
#define glMultiTexCoord2xvOES glad_debug_glMultiTexCoord2xvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD3BOESPROC glad_glMultiTexCoord3bOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD3BOESPROC glad_debug_glMultiTexCoord3bOES;
#define glMultiTexCoord3bOES glad_debug_glMultiTexCoord3bOES
    GLAD_API_CALL PFNGLMULTITEXCOORD3BVOESPROC glad_glMultiTexCoord3bvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD3BVOESPROC glad_debug_glMultiTexCoord3bvOES;
#define glMultiTexCoord3bvOES glad_debug_glMultiTexCoord3bvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD3DARBPROC glad_glMultiTexCoord3dARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3DARBPROC glad_debug_glMultiTexCoord3dARB;
#define glMultiTexCoord3dARB glad_debug_glMultiTexCoord3dARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3DVARBPROC glad_glMultiTexCoord3dvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3DVARBPROC glad_debug_glMultiTexCoord3dvARB;
#define glMultiTexCoord3dvARB glad_debug_glMultiTexCoord3dvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3FARBPROC glad_glMultiTexCoord3fARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3FARBPROC glad_debug_glMultiTexCoord3fARB;
#define glMultiTexCoord3fARB glad_debug_glMultiTexCoord3fARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3FVARBPROC glad_glMultiTexCoord3fvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3FVARBPROC glad_debug_glMultiTexCoord3fvARB;
#define glMultiTexCoord3fvARB glad_debug_glMultiTexCoord3fvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3HNVPROC glad_glMultiTexCoord3hNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD3HNVPROC glad_debug_glMultiTexCoord3hNV;
#define glMultiTexCoord3hNV glad_debug_glMultiTexCoord3hNV
    GLAD_API_CALL PFNGLMULTITEXCOORD3HVNVPROC glad_glMultiTexCoord3hvNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD3HVNVPROC glad_debug_glMultiTexCoord3hvNV;
#define glMultiTexCoord3hvNV glad_debug_glMultiTexCoord3hvNV
    GLAD_API_CALL PFNGLMULTITEXCOORD3IARBPROC glad_glMultiTexCoord3iARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3IARBPROC glad_debug_glMultiTexCoord3iARB;
#define glMultiTexCoord3iARB glad_debug_glMultiTexCoord3iARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3IVARBPROC glad_glMultiTexCoord3ivARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3IVARBPROC glad_debug_glMultiTexCoord3ivARB;
#define glMultiTexCoord3ivARB glad_debug_glMultiTexCoord3ivARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3SARBPROC glad_glMultiTexCoord3sARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3SARBPROC glad_debug_glMultiTexCoord3sARB;
#define glMultiTexCoord3sARB glad_debug_glMultiTexCoord3sARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3SVARBPROC glad_glMultiTexCoord3svARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD3SVARBPROC glad_debug_glMultiTexCoord3svARB;
#define glMultiTexCoord3svARB glad_debug_glMultiTexCoord3svARB
    GLAD_API_CALL PFNGLMULTITEXCOORD3XOESPROC glad_glMultiTexCoord3xOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD3XOESPROC glad_debug_glMultiTexCoord3xOES;
#define glMultiTexCoord3xOES glad_debug_glMultiTexCoord3xOES
    GLAD_API_CALL PFNGLMULTITEXCOORD3XVOESPROC glad_glMultiTexCoord3xvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD3XVOESPROC glad_debug_glMultiTexCoord3xvOES;
#define glMultiTexCoord3xvOES glad_debug_glMultiTexCoord3xvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD4BOESPROC glad_glMultiTexCoord4bOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD4BOESPROC glad_debug_glMultiTexCoord4bOES;
#define glMultiTexCoord4bOES glad_debug_glMultiTexCoord4bOES
    GLAD_API_CALL PFNGLMULTITEXCOORD4BVOESPROC glad_glMultiTexCoord4bvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD4BVOESPROC glad_debug_glMultiTexCoord4bvOES;
#define glMultiTexCoord4bvOES glad_debug_glMultiTexCoord4bvOES
    GLAD_API_CALL PFNGLMULTITEXCOORD4DARBPROC glad_glMultiTexCoord4dARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4DARBPROC glad_debug_glMultiTexCoord4dARB;
#define glMultiTexCoord4dARB glad_debug_glMultiTexCoord4dARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4DVARBPROC glad_glMultiTexCoord4dvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4DVARBPROC glad_debug_glMultiTexCoord4dvARB;
#define glMultiTexCoord4dvARB glad_debug_glMultiTexCoord4dvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4FARBPROC glad_glMultiTexCoord4fARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4FARBPROC glad_debug_glMultiTexCoord4fARB;
#define glMultiTexCoord4fARB glad_debug_glMultiTexCoord4fARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4FVARBPROC glad_glMultiTexCoord4fvARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4FVARBPROC glad_debug_glMultiTexCoord4fvARB;
#define glMultiTexCoord4fvARB glad_debug_glMultiTexCoord4fvARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4HNVPROC glad_glMultiTexCoord4hNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD4HNVPROC glad_debug_glMultiTexCoord4hNV;
#define glMultiTexCoord4hNV glad_debug_glMultiTexCoord4hNV
    GLAD_API_CALL PFNGLMULTITEXCOORD4HVNVPROC glad_glMultiTexCoord4hvNV;
    GLAD_API_CALL PFNGLMULTITEXCOORD4HVNVPROC glad_debug_glMultiTexCoord4hvNV;
#define glMultiTexCoord4hvNV glad_debug_glMultiTexCoord4hvNV
    GLAD_API_CALL PFNGLMULTITEXCOORD4IARBPROC glad_glMultiTexCoord4iARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4IARBPROC glad_debug_glMultiTexCoord4iARB;
#define glMultiTexCoord4iARB glad_debug_glMultiTexCoord4iARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4IVARBPROC glad_glMultiTexCoord4ivARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4IVARBPROC glad_debug_glMultiTexCoord4ivARB;
#define glMultiTexCoord4ivARB glad_debug_glMultiTexCoord4ivARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4SARBPROC glad_glMultiTexCoord4sARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4SARBPROC glad_debug_glMultiTexCoord4sARB;
#define glMultiTexCoord4sARB glad_debug_glMultiTexCoord4sARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4SVARBPROC glad_glMultiTexCoord4svARB;
    GLAD_API_CALL PFNGLMULTITEXCOORD4SVARBPROC glad_debug_glMultiTexCoord4svARB;
#define glMultiTexCoord4svARB glad_debug_glMultiTexCoord4svARB
    GLAD_API_CALL PFNGLMULTITEXCOORD4XOESPROC glad_glMultiTexCoord4xOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD4XOESPROC glad_debug_glMultiTexCoord4xOES;
#define glMultiTexCoord4xOES glad_debug_glMultiTexCoord4xOES
    GLAD_API_CALL PFNGLMULTITEXCOORD4XVOESPROC glad_glMultiTexCoord4xvOES;
    GLAD_API_CALL PFNGLMULTITEXCOORD4XVOESPROC glad_debug_glMultiTexCoord4xvOES;
#define glMultiTexCoord4xvOES glad_debug_glMultiTexCoord4xvOES
    GLAD_API_CALL PFNGLMULTITEXCOORDPOINTEREXTPROC glad_glMultiTexCoordPointerEXT;
    GLAD_API_CALL PFNGLMULTITEXCOORDPOINTEREXTPROC glad_debug_glMultiTexCoordPointerEXT;
#define glMultiTexCoordPointerEXT glad_debug_glMultiTexCoordPointerEXT
    GLAD_API_CALL PFNGLMULTITEXENVFEXTPROC glad_glMultiTexEnvfEXT;
    GLAD_API_CALL PFNGLMULTITEXENVFEXTPROC glad_debug_glMultiTexEnvfEXT;
#define glMultiTexEnvfEXT glad_debug_glMultiTexEnvfEXT
    GLAD_API_CALL PFNGLMULTITEXENVFVEXTPROC glad_glMultiTexEnvfvEXT;
    GLAD_API_CALL PFNGLMULTITEXENVFVEXTPROC glad_debug_glMultiTexEnvfvEXT;
#define glMultiTexEnvfvEXT glad_debug_glMultiTexEnvfvEXT
    GLAD_API_CALL PFNGLMULTITEXENVIEXTPROC glad_glMultiTexEnviEXT;
    GLAD_API_CALL PFNGLMULTITEXENVIEXTPROC glad_debug_glMultiTexEnviEXT;
#define glMultiTexEnviEXT glad_debug_glMultiTexEnviEXT
    GLAD_API_CALL PFNGLMULTITEXENVIVEXTPROC glad_glMultiTexEnvivEXT;
    GLAD_API_CALL PFNGLMULTITEXENVIVEXTPROC glad_debug_glMultiTexEnvivEXT;
#define glMultiTexEnvivEXT glad_debug_glMultiTexEnvivEXT
    GLAD_API_CALL PFNGLMULTITEXGENDEXTPROC glad_glMultiTexGendEXT;
    GLAD_API_CALL PFNGLMULTITEXGENDEXTPROC glad_debug_glMultiTexGendEXT;
#define glMultiTexGendEXT glad_debug_glMultiTexGendEXT
    GLAD_API_CALL PFNGLMULTITEXGENDVEXTPROC glad_glMultiTexGendvEXT;
    GLAD_API_CALL PFNGLMULTITEXGENDVEXTPROC glad_debug_glMultiTexGendvEXT;
#define glMultiTexGendvEXT glad_debug_glMultiTexGendvEXT
    GLAD_API_CALL PFNGLMULTITEXGENFEXTPROC glad_glMultiTexGenfEXT;
    GLAD_API_CALL PFNGLMULTITEXGENFEXTPROC glad_debug_glMultiTexGenfEXT;
#define glMultiTexGenfEXT glad_debug_glMultiTexGenfEXT
    GLAD_API_CALL PFNGLMULTITEXGENFVEXTPROC glad_glMultiTexGenfvEXT;
    GLAD_API_CALL PFNGLMULTITEXGENFVEXTPROC glad_debug_glMultiTexGenfvEXT;
#define glMultiTexGenfvEXT glad_debug_glMultiTexGenfvEXT
    GLAD_API_CALL PFNGLMULTITEXGENIEXTPROC glad_glMultiTexGeniEXT;
    GLAD_API_CALL PFNGLMULTITEXGENIEXTPROC glad_debug_glMultiTexGeniEXT;
#define glMultiTexGeniEXT glad_debug_glMultiTexGeniEXT
    GLAD_API_CALL PFNGLMULTITEXGENIVEXTPROC glad_glMultiTexGenivEXT;
    GLAD_API_CALL PFNGLMULTITEXGENIVEXTPROC glad_debug_glMultiTexGenivEXT;
#define glMultiTexGenivEXT glad_debug_glMultiTexGenivEXT
    GLAD_API_CALL PFNGLMULTITEXIMAGE1DEXTPROC glad_glMultiTexImage1DEXT;
    GLAD_API_CALL PFNGLMULTITEXIMAGE1DEXTPROC glad_debug_glMultiTexImage1DEXT;
#define glMultiTexImage1DEXT glad_debug_glMultiTexImage1DEXT
    GLAD_API_CALL PFNGLMULTITEXIMAGE2DEXTPROC glad_glMultiTexImage2DEXT;
    GLAD_API_CALL PFNGLMULTITEXIMAGE2DEXTPROC glad_debug_glMultiTexImage2DEXT;
#define glMultiTexImage2DEXT glad_debug_glMultiTexImage2DEXT
    GLAD_API_CALL PFNGLMULTITEXIMAGE3DEXTPROC glad_glMultiTexImage3DEXT;
    GLAD_API_CALL PFNGLMULTITEXIMAGE3DEXTPROC glad_debug_glMultiTexImage3DEXT;
#define glMultiTexImage3DEXT glad_debug_glMultiTexImage3DEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIIVEXTPROC glad_glMultiTexParameterIivEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIIVEXTPROC glad_debug_glMultiTexParameterIivEXT;
#define glMultiTexParameterIivEXT glad_debug_glMultiTexParameterIivEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_glMultiTexParameterIuivEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_debug_glMultiTexParameterIuivEXT;
#define glMultiTexParameterIuivEXT glad_debug_glMultiTexParameterIuivEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERFEXTPROC glad_glMultiTexParameterfEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERFEXTPROC glad_debug_glMultiTexParameterfEXT;
#define glMultiTexParameterfEXT glad_debug_glMultiTexParameterfEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERFVEXTPROC glad_glMultiTexParameterfvEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERFVEXTPROC glad_debug_glMultiTexParameterfvEXT;
#define glMultiTexParameterfvEXT glad_debug_glMultiTexParameterfvEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIEXTPROC glad_glMultiTexParameteriEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIEXTPROC glad_debug_glMultiTexParameteriEXT;
#define glMultiTexParameteriEXT glad_debug_glMultiTexParameteriEXT
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIVEXTPROC glad_glMultiTexParameterivEXT;
    GLAD_API_CALL PFNGLMULTITEXPARAMETERIVEXTPROC glad_debug_glMultiTexParameterivEXT;
#define glMultiTexParameterivEXT glad_debug_glMultiTexParameterivEXT
    GLAD_API_CALL PFNGLMULTITEXRENDERBUFFEREXTPROC glad_glMultiTexRenderbufferEXT;
    GLAD_API_CALL PFNGLMULTITEXRENDERBUFFEREXTPROC glad_debug_glMultiTexRenderbufferEXT;
#define glMultiTexRenderbufferEXT glad_debug_glMultiTexRenderbufferEXT
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_glMultiTexSubImage1DEXT;
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_debug_glMultiTexSubImage1DEXT;
#define glMultiTexSubImage1DEXT glad_debug_glMultiTexSubImage1DEXT
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_glMultiTexSubImage2DEXT;
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_debug_glMultiTexSubImage2DEXT;
#define glMultiTexSubImage2DEXT glad_debug_glMultiTexSubImage2DEXT
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_glMultiTexSubImage3DEXT;
    GLAD_API_CALL PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_debug_glMultiTexSubImage3DEXT;
#define glMultiTexSubImage3DEXT glad_debug_glMultiTexSubImage3DEXT
    GLAD_API_CALL PFNGLMULTICASTBARRIERNVPROC glad_glMulticastBarrierNV;
    GLAD_API_CALL PFNGLMULTICASTBARRIERNVPROC glad_debug_glMulticastBarrierNV;
#define glMulticastBarrierNV glad_debug_glMulticastBarrierNV
    GLAD_API_CALL PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_glMulticastBlitFramebufferNV;
    GLAD_API_CALL PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_debug_glMulticastBlitFramebufferNV;
#define glMulticastBlitFramebufferNV glad_debug_glMulticastBlitFramebufferNV
    GLAD_API_CALL PFNGLMULTICASTBUFFERSUBDATANVPROC glad_glMulticastBufferSubDataNV;
    GLAD_API_CALL PFNGLMULTICASTBUFFERSUBDATANVPROC glad_debug_glMulticastBufferSubDataNV;
#define glMulticastBufferSubDataNV glad_debug_glMulticastBufferSubDataNV
    GLAD_API_CALL PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_glMulticastCopyBufferSubDataNV;
    GLAD_API_CALL PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_debug_glMulticastCopyBufferSubDataNV;
#define glMulticastCopyBufferSubDataNV glad_debug_glMulticastCopyBufferSubDataNV
    GLAD_API_CALL PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_glMulticastCopyImageSubDataNV;
    GLAD_API_CALL PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_debug_glMulticastCopyImageSubDataNV;
#define glMulticastCopyImageSubDataNV glad_debug_glMulticastCopyImageSubDataNV
    GLAD_API_CALL PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC
        glad_glMulticastFramebufferSampleLocationsfvNV;
    GLAD_API_CALL PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC
        glad_debug_glMulticastFramebufferSampleLocationsfvNV;
#define glMulticastFramebufferSampleLocationsfvNV \
    glad_debug_glMulticastFramebufferSampleLocationsfvNV
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_glMulticastGetQueryObjecti64vNV;
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_debug_glMulticastGetQueryObjecti64vNV;
#define glMulticastGetQueryObjecti64vNV glad_debug_glMulticastGetQueryObjecti64vNV
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_glMulticastGetQueryObjectivNV;
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_debug_glMulticastGetQueryObjectivNV;
#define glMulticastGetQueryObjectivNV glad_debug_glMulticastGetQueryObjectivNV
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC glad_glMulticastGetQueryObjectui64vNV;
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC
        glad_debug_glMulticastGetQueryObjectui64vNV;
#define glMulticastGetQueryObjectui64vNV glad_debug_glMulticastGetQueryObjectui64vNV
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_glMulticastGetQueryObjectuivNV;
    GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_debug_glMulticastGetQueryObjectuivNV;
#define glMulticastGetQueryObjectuivNV glad_debug_glMulticastGetQueryObjectuivNV
    GLAD_API_CALL PFNGLMULTICASTSCISSORARRAYVNVXPROC glad_glMulticastScissorArrayvNVX;
    GLAD_API_CALL PFNGLMULTICASTSCISSORARRAYVNVXPROC glad_debug_glMulticastScissorArrayvNVX;
#define glMulticastScissorArrayvNVX glad_debug_glMulticastScissorArrayvNVX
    GLAD_API_CALL PFNGLMULTICASTVIEWPORTARRAYVNVXPROC glad_glMulticastViewportArrayvNVX;
    GLAD_API_CALL PFNGLMULTICASTVIEWPORTARRAYVNVXPROC glad_debug_glMulticastViewportArrayvNVX;
#define glMulticastViewportArrayvNVX glad_debug_glMulticastViewportArrayvNVX
    GLAD_API_CALL PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC
        glad_glMulticastViewportPositionWScaleNVX;
    GLAD_API_CALL PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC
        glad_debug_glMulticastViewportPositionWScaleNVX;
#define glMulticastViewportPositionWScaleNVX glad_debug_glMulticastViewportPositionWScaleNVX
    GLAD_API_CALL PFNGLMULTICASTWAITSYNCNVPROC glad_glMulticastWaitSyncNV;
    GLAD_API_CALL PFNGLMULTICASTWAITSYNCNVPROC glad_debug_glMulticastWaitSyncNV;
#define glMulticastWaitSyncNV glad_debug_glMulticastWaitSyncNV
    GLAD_API_CALL PFNGLNAMEDBUFFERATTACHMEMORYNVPROC glad_glNamedBufferAttachMemoryNV;
    GLAD_API_CALL PFNGLNAMEDBUFFERATTACHMEMORYNVPROC glad_debug_glNamedBufferAttachMemoryNV;
#define glNamedBufferAttachMemoryNV glad_debug_glNamedBufferAttachMemoryNV
    GLAD_API_CALL PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;
    GLAD_API_CALL PFNGLNAMEDBUFFERDATAPROC glad_debug_glNamedBufferData;
#define glNamedBufferData glad_debug_glNamedBufferData
    GLAD_API_CALL PFNGLNAMEDBUFFERDATAEXTPROC glad_glNamedBufferDataEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERDATAEXTPROC glad_debug_glNamedBufferDataEXT;
#define glNamedBufferDataEXT glad_debug_glNamedBufferDataEXT
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_glNamedBufferPageCommitmentARB;
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_debug_glNamedBufferPageCommitmentARB;
#define glNamedBufferPageCommitmentARB glad_debug_glNamedBufferPageCommitmentARB
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_glNamedBufferPageCommitmentEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_debug_glNamedBufferPageCommitmentEXT;
#define glNamedBufferPageCommitmentEXT glad_debug_glNamedBufferPageCommitmentEXT
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC glad_glNamedBufferPageCommitmentMemNV;
    GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC
        glad_debug_glNamedBufferPageCommitmentMemNV;
#define glNamedBufferPageCommitmentMemNV glad_debug_glNamedBufferPageCommitmentMemNV
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEPROC glad_debug_glNamedBufferStorage;
#define glNamedBufferStorage glad_debug_glNamedBufferStorage
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_glNamedBufferStorageEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_debug_glNamedBufferStorageEXT;
#define glNamedBufferStorageEXT glad_debug_glNamedBufferStorageEXT
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_glNamedBufferStorageExternalEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_debug_glNamedBufferStorageExternalEXT;
#define glNamedBufferStorageExternalEXT glad_debug_glNamedBufferStorageExternalEXT
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_glNamedBufferStorageMemEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_debug_glNamedBufferStorageMemEXT;
#define glNamedBufferStorageMemEXT glad_debug_glNamedBufferStorageMemEXT
    GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;
    GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAPROC glad_debug_glNamedBufferSubData;
#define glNamedBufferSubData glad_debug_glNamedBufferSubData
    GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_glNamedBufferSubDataEXT;
    GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_debug_glNamedBufferSubDataEXT;
#define glNamedBufferSubDataEXT glad_debug_glNamedBufferSubDataEXT
    GLAD_API_CALL PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_glNamedCopyBufferSubDataEXT;
    GLAD_API_CALL PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_debug_glNamedCopyBufferSubDataEXT;
#define glNamedCopyBufferSubDataEXT glad_debug_glNamedCopyBufferSubDataEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_debug_glNamedFramebufferDrawBuffer;
#define glNamedFramebufferDrawBuffer glad_debug_glNamedFramebufferDrawBuffer
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_debug_glNamedFramebufferDrawBuffers;
#define glNamedFramebufferDrawBuffers glad_debug_glNamedFramebufferDrawBuffers
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_debug_glNamedFramebufferParameteri;
#define glNamedFramebufferParameteri glad_debug_glNamedFramebufferParameteri
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_glNamedFramebufferParameteriEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_debug_glNamedFramebufferParameteriEXT;
#define glNamedFramebufferParameteriEXT glad_debug_glNamedFramebufferParameteriEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_debug_glNamedFramebufferReadBuffer;
#define glNamedFramebufferReadBuffer glad_debug_glNamedFramebufferReadBuffer
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_debug_glNamedFramebufferRenderbuffer;
#define glNamedFramebufferRenderbuffer glad_debug_glNamedFramebufferRenderbuffer
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glad_glNamedFramebufferRenderbufferEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC
        glad_debug_glNamedFramebufferRenderbufferEXT;
#define glNamedFramebufferRenderbufferEXT glad_debug_glNamedFramebufferRenderbufferEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC
        glad_glNamedFramebufferSampleLocationsfvARB;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC
        glad_debug_glNamedFramebufferSampleLocationsfvARB;
#define glNamedFramebufferSampleLocationsfvARB glad_debug_glNamedFramebufferSampleLocationsfvARB
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC
        glad_glNamedFramebufferSampleLocationsfvNV;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC
        glad_debug_glNamedFramebufferSampleLocationsfvNV;
#define glNamedFramebufferSampleLocationsfvNV glad_debug_glNamedFramebufferSampleLocationsfvNV
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC
        glad_glNamedFramebufferSamplePositionsfvAMD;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC
        glad_debug_glNamedFramebufferSamplePositionsfvAMD;
#define glNamedFramebufferSamplePositionsfvAMD glad_debug_glNamedFramebufferSamplePositionsfvAMD
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_debug_glNamedFramebufferTexture;
#define glNamedFramebufferTexture glad_debug_glNamedFramebufferTexture
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_glNamedFramebufferTexture1DEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_debug_glNamedFramebufferTexture1DEXT;
#define glNamedFramebufferTexture1DEXT glad_debug_glNamedFramebufferTexture1DEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_glNamedFramebufferTexture2DEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_debug_glNamedFramebufferTexture2DEXT;
#define glNamedFramebufferTexture2DEXT glad_debug_glNamedFramebufferTexture2DEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_glNamedFramebufferTexture3DEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_debug_glNamedFramebufferTexture3DEXT;
#define glNamedFramebufferTexture3DEXT glad_debug_glNamedFramebufferTexture3DEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_glNamedFramebufferTextureEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_debug_glNamedFramebufferTextureEXT;
#define glNamedFramebufferTextureEXT glad_debug_glNamedFramebufferTextureEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glad_glNamedFramebufferTextureFaceEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC
        glad_debug_glNamedFramebufferTextureFaceEXT;
#define glNamedFramebufferTextureFaceEXT glad_debug_glNamedFramebufferTextureFaceEXT
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_debug_glNamedFramebufferTextureLayer;
#define glNamedFramebufferTextureLayer glad_debug_glNamedFramebufferTextureLayer
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glad_glNamedFramebufferTextureLayerEXT;
    GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC
        glad_debug_glNamedFramebufferTextureLayerEXT;
#define glNamedFramebufferTextureLayerEXT glad_debug_glNamedFramebufferTextureLayerEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glad_glNamedProgramLocalParameter4dEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC
        glad_debug_glNamedProgramLocalParameter4dEXT;
#define glNamedProgramLocalParameter4dEXT glad_debug_glNamedProgramLocalParameter4dEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glad_glNamedProgramLocalParameter4dvEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC
        glad_debug_glNamedProgramLocalParameter4dvEXT;
#define glNamedProgramLocalParameter4dvEXT glad_debug_glNamedProgramLocalParameter4dvEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glad_glNamedProgramLocalParameter4fEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC
        glad_debug_glNamedProgramLocalParameter4fEXT;
#define glNamedProgramLocalParameter4fEXT glad_debug_glNamedProgramLocalParameter4fEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glad_glNamedProgramLocalParameter4fvEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC
        glad_debug_glNamedProgramLocalParameter4fvEXT;
#define glNamedProgramLocalParameter4fvEXT glad_debug_glNamedProgramLocalParameter4fvEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glad_glNamedProgramLocalParameterI4iEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC
        glad_debug_glNamedProgramLocalParameterI4iEXT;
#define glNamedProgramLocalParameterI4iEXT glad_debug_glNamedProgramLocalParameterI4iEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC
        glad_glNamedProgramLocalParameterI4ivEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC
        glad_debug_glNamedProgramLocalParameterI4ivEXT;
#define glNamedProgramLocalParameterI4ivEXT glad_debug_glNamedProgramLocalParameterI4ivEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC
        glad_glNamedProgramLocalParameterI4uiEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC
        glad_debug_glNamedProgramLocalParameterI4uiEXT;
#define glNamedProgramLocalParameterI4uiEXT glad_debug_glNamedProgramLocalParameterI4uiEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC
        glad_glNamedProgramLocalParameterI4uivEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC
        glad_debug_glNamedProgramLocalParameterI4uivEXT;
#define glNamedProgramLocalParameterI4uivEXT glad_debug_glNamedProgramLocalParameterI4uivEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC
        glad_glNamedProgramLocalParameters4fvEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC
        glad_debug_glNamedProgramLocalParameters4fvEXT;
#define glNamedProgramLocalParameters4fvEXT glad_debug_glNamedProgramLocalParameters4fvEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC
        glad_glNamedProgramLocalParametersI4ivEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC
        glad_debug_glNamedProgramLocalParametersI4ivEXT;
#define glNamedProgramLocalParametersI4ivEXT glad_debug_glNamedProgramLocalParametersI4ivEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC
        glad_glNamedProgramLocalParametersI4uivEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC
        glad_debug_glNamedProgramLocalParametersI4uivEXT;
#define glNamedProgramLocalParametersI4uivEXT glad_debug_glNamedProgramLocalParametersI4uivEXT
    GLAD_API_CALL PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_glNamedProgramStringEXT;
    GLAD_API_CALL PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_debug_glNamedProgramStringEXT;
#define glNamedProgramStringEXT glad_debug_glNamedProgramStringEXT
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_debug_glNamedRenderbufferStorage;
#define glNamedRenderbufferStorage glad_debug_glNamedRenderbufferStorage
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_glNamedRenderbufferStorageEXT;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_debug_glNamedRenderbufferStorageEXT;
#define glNamedRenderbufferStorageEXT glad_debug_glNamedRenderbufferStorageEXT
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC
        glad_glNamedRenderbufferStorageMultisample;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC
        glad_debug_glNamedRenderbufferStorageMultisample;
#define glNamedRenderbufferStorageMultisample glad_debug_glNamedRenderbufferStorageMultisample
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC
        glad_glNamedRenderbufferStorageMultisampleAdvancedAMD;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC
        glad_debug_glNamedRenderbufferStorageMultisampleAdvancedAMD;
#define glNamedRenderbufferStorageMultisampleAdvancedAMD \
    glad_debug_glNamedRenderbufferStorageMultisampleAdvancedAMD
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC
        glad_glNamedRenderbufferStorageMultisampleCoverageEXT;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC
        glad_debug_glNamedRenderbufferStorageMultisampleCoverageEXT;
#define glNamedRenderbufferStorageMultisampleCoverageEXT \
    glad_debug_glNamedRenderbufferStorageMultisampleCoverageEXT
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC
        glad_glNamedRenderbufferStorageMultisampleEXT;
    GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC
        glad_debug_glNamedRenderbufferStorageMultisampleEXT;
#define glNamedRenderbufferStorageMultisampleEXT glad_debug_glNamedRenderbufferStorageMultisampleEXT
    GLAD_API_CALL PFNGLNAMEDSTRINGARBPROC glad_glNamedStringARB;
    GLAD_API_CALL PFNGLNAMEDSTRINGARBPROC glad_debug_glNamedStringARB;
#define glNamedStringARB glad_debug_glNamedStringARB
    GLAD_API_CALL PFNGLNEWOBJECTBUFFERATIPROC glad_glNewObjectBufferATI;
    GLAD_API_CALL PFNGLNEWOBJECTBUFFERATIPROC glad_debug_glNewObjectBufferATI;
#define glNewObjectBufferATI glad_debug_glNewObjectBufferATI
    GLAD_API_CALL PFNGLNORMAL3FVERTEX3FSUNPROC glad_glNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLNORMAL3FVERTEX3FSUNPROC glad_debug_glNormal3fVertex3fSUN;
#define glNormal3fVertex3fSUN glad_debug_glNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLNORMAL3FVERTEX3FVSUNPROC glad_glNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLNORMAL3FVERTEX3FVSUNPROC glad_debug_glNormal3fVertex3fvSUN;
#define glNormal3fVertex3fvSUN glad_debug_glNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLNORMAL3HNVPROC glad_glNormal3hNV;
    GLAD_API_CALL PFNGLNORMAL3HNVPROC glad_debug_glNormal3hNV;
#define glNormal3hNV glad_debug_glNormal3hNV
    GLAD_API_CALL PFNGLNORMAL3HVNVPROC glad_glNormal3hvNV;
    GLAD_API_CALL PFNGLNORMAL3HVNVPROC glad_debug_glNormal3hvNV;
#define glNormal3hvNV glad_debug_glNormal3hvNV
    GLAD_API_CALL PFNGLNORMAL3XOESPROC glad_glNormal3xOES;
    GLAD_API_CALL PFNGLNORMAL3XOESPROC glad_debug_glNormal3xOES;
#define glNormal3xOES glad_debug_glNormal3xOES
    GLAD_API_CALL PFNGLNORMAL3XVOESPROC glad_glNormal3xvOES;
    GLAD_API_CALL PFNGLNORMAL3XVOESPROC glad_debug_glNormal3xvOES;
#define glNormal3xvOES glad_debug_glNormal3xvOES
    GLAD_API_CALL PFNGLNORMALFORMATNVPROC glad_glNormalFormatNV;
    GLAD_API_CALL PFNGLNORMALFORMATNVPROC glad_debug_glNormalFormatNV;
#define glNormalFormatNV glad_debug_glNormalFormatNV
    GLAD_API_CALL PFNGLNORMALPOINTEREXTPROC glad_glNormalPointerEXT;
    GLAD_API_CALL PFNGLNORMALPOINTEREXTPROC glad_debug_glNormalPointerEXT;
#define glNormalPointerEXT glad_debug_glNormalPointerEXT
    GLAD_API_CALL PFNGLNORMALPOINTERLISTIBMPROC glad_glNormalPointerListIBM;
    GLAD_API_CALL PFNGLNORMALPOINTERLISTIBMPROC glad_debug_glNormalPointerListIBM;
#define glNormalPointerListIBM glad_debug_glNormalPointerListIBM
    GLAD_API_CALL PFNGLNORMALPOINTERVINTELPROC glad_glNormalPointervINTEL;
    GLAD_API_CALL PFNGLNORMALPOINTERVINTELPROC glad_debug_glNormalPointervINTEL;
#define glNormalPointervINTEL glad_debug_glNormalPointervINTEL
    GLAD_API_CALL PFNGLNORMALSTREAM3BATIPROC glad_glNormalStream3bATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3BATIPROC glad_debug_glNormalStream3bATI;
#define glNormalStream3bATI glad_debug_glNormalStream3bATI
    GLAD_API_CALL PFNGLNORMALSTREAM3BVATIPROC glad_glNormalStream3bvATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3BVATIPROC glad_debug_glNormalStream3bvATI;
#define glNormalStream3bvATI glad_debug_glNormalStream3bvATI
    GLAD_API_CALL PFNGLNORMALSTREAM3DATIPROC glad_glNormalStream3dATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3DATIPROC glad_debug_glNormalStream3dATI;
#define glNormalStream3dATI glad_debug_glNormalStream3dATI
    GLAD_API_CALL PFNGLNORMALSTREAM3DVATIPROC glad_glNormalStream3dvATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3DVATIPROC glad_debug_glNormalStream3dvATI;
#define glNormalStream3dvATI glad_debug_glNormalStream3dvATI
    GLAD_API_CALL PFNGLNORMALSTREAM3FATIPROC glad_glNormalStream3fATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3FATIPROC glad_debug_glNormalStream3fATI;
#define glNormalStream3fATI glad_debug_glNormalStream3fATI
    GLAD_API_CALL PFNGLNORMALSTREAM3FVATIPROC glad_glNormalStream3fvATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3FVATIPROC glad_debug_glNormalStream3fvATI;
#define glNormalStream3fvATI glad_debug_glNormalStream3fvATI
    GLAD_API_CALL PFNGLNORMALSTREAM3IATIPROC glad_glNormalStream3iATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3IATIPROC glad_debug_glNormalStream3iATI;
#define glNormalStream3iATI glad_debug_glNormalStream3iATI
    GLAD_API_CALL PFNGLNORMALSTREAM3IVATIPROC glad_glNormalStream3ivATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3IVATIPROC glad_debug_glNormalStream3ivATI;
#define glNormalStream3ivATI glad_debug_glNormalStream3ivATI
    GLAD_API_CALL PFNGLNORMALSTREAM3SATIPROC glad_glNormalStream3sATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3SATIPROC glad_debug_glNormalStream3sATI;
#define glNormalStream3sATI glad_debug_glNormalStream3sATI
    GLAD_API_CALL PFNGLNORMALSTREAM3SVATIPROC glad_glNormalStream3svATI;
    GLAD_API_CALL PFNGLNORMALSTREAM3SVATIPROC glad_debug_glNormalStream3svATI;
#define glNormalStream3svATI glad_debug_glNormalStream3svATI
    GLAD_API_CALL PFNGLOBJECTLABELPROC glad_glObjectLabel;
    GLAD_API_CALL PFNGLOBJECTLABELPROC glad_debug_glObjectLabel;

/// <summary>
///   label a named object identified within a namespace
///   <para>
///     glObjectLabel labels the object identified by name within the namespace given by identifier.
///     identifier must be one of GL_BUFFER , GL_SHADER , GL_PROGRAM , GL_VERTEX_ARRAY , GL_QUERY ,
///     GL_PROGRAM_PIPELINE , GL_TRANSFORM_FEEDBACK , GL_SAMPLER , GL_TEXTURE , GL_RENDERBUFFER ,
///     GL_FRAMEBUFFER , to indicate the namespace containing the names of buffers, shaders,
///     programs, vertex array objects, query objects, program pipelines, transform feedback
///     objects, samplers, textures, renderbuffers and frame buffers, respectively. label is the
///     address of a string that will be used to label an object. length contains the number of
///     characters in label. If length is negative, it is implied that label contains a
///     null-terminated string. If label is NULL, any debug label is effectively removed from the
///     object.
///   </para>
/// </summary>
/// <param name='identifier'>The namespace from which the name of the object is allocated.</param>
/// <param name='name'>The name of the object to label.</param>
/// <param name='length'>The length of the label to be used for the object.</param>
/// <param name='label'>The address of a string containing the label to assign to the
/// object.</param>
#define glObjectLabel glad_debug_glObjectLabel
    GLAD_API_CALL PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;
    GLAD_API_CALL PFNGLOBJECTPTRLABELPROC glad_debug_glObjectPtrLabel;

/// <summary>
///   label a a sync object identified by a pointer
///   <para>
///     glObjectPtrLabel labels the sync object identified by ptr. label is the address of a string
///     that will be used to label the object. length contains the number of characters in label. If
///     length is negative, it is implied that label contains a null-terminated string. If label is
///     NULL, any debug label is effectively removed from the object.
///   </para>
/// </summary>
/// <param name='ptr'>A pointer identifying a sync object.</param>
/// <param name='length'>The length of the label to be used for the object.</param>
/// <param name='label'>The address of a string containing the label to assign to the
/// object.</param>
#define glObjectPtrLabel glad_debug_glObjectPtrLabel
    GLAD_API_CALL PFNGLOBJECTPURGEABLEAPPLEPROC glad_glObjectPurgeableAPPLE;
    GLAD_API_CALL PFNGLOBJECTPURGEABLEAPPLEPROC glad_debug_glObjectPurgeableAPPLE;
#define glObjectPurgeableAPPLE glad_debug_glObjectPurgeableAPPLE
    GLAD_API_CALL PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_glObjectUnpurgeableAPPLE;
    GLAD_API_CALL PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_debug_glObjectUnpurgeableAPPLE;
#define glObjectUnpurgeableAPPLE glad_debug_glObjectUnpurgeableAPPLE
    GLAD_API_CALL PFNGLORTHOFOESPROC glad_glOrthofOES;
    GLAD_API_CALL PFNGLORTHOFOESPROC glad_debug_glOrthofOES;
#define glOrthofOES glad_debug_glOrthofOES
    GLAD_API_CALL PFNGLORTHOXOESPROC glad_glOrthoxOES;
    GLAD_API_CALL PFNGLORTHOXOESPROC glad_debug_glOrthoxOES;
#define glOrthoxOES glad_debug_glOrthoxOES
    GLAD_API_CALL PFNGLPNTRIANGLESFATIPROC glad_glPNTrianglesfATI;
    GLAD_API_CALL PFNGLPNTRIANGLESFATIPROC glad_debug_glPNTrianglesfATI;
#define glPNTrianglesfATI glad_debug_glPNTrianglesfATI
    GLAD_API_CALL PFNGLPNTRIANGLESIATIPROC glad_glPNTrianglesiATI;
    GLAD_API_CALL PFNGLPNTRIANGLESIATIPROC glad_debug_glPNTrianglesiATI;
#define glPNTrianglesiATI glad_debug_glPNTrianglesiATI
    GLAD_API_CALL PFNGLPASSTEXCOORDATIPROC glad_glPassTexCoordATI;
    GLAD_API_CALL PFNGLPASSTEXCOORDATIPROC glad_debug_glPassTexCoordATI;
#define glPassTexCoordATI glad_debug_glPassTexCoordATI
    GLAD_API_CALL PFNGLPASSTHROUGHXOESPROC glad_glPassThroughxOES;
    GLAD_API_CALL PFNGLPASSTHROUGHXOESPROC glad_debug_glPassThroughxOES;
#define glPassThroughxOES glad_debug_glPassThroughxOES
    GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
    GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_debug_glPatchParameterfv;
#define glPatchParameterfv glad_debug_glPatchParameterfv
    GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
    GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_debug_glPatchParameteri;
#define glPatchParameteri glad_debug_glPatchParameteri
    GLAD_API_CALL PFNGLPATHCOMMANDSNVPROC glad_glPathCommandsNV;
    GLAD_API_CALL PFNGLPATHCOMMANDSNVPROC glad_debug_glPathCommandsNV;
#define glPathCommandsNV glad_debug_glPathCommandsNV
    GLAD_API_CALL PFNGLPATHCOORDSNVPROC glad_glPathCoordsNV;
    GLAD_API_CALL PFNGLPATHCOORDSNVPROC glad_debug_glPathCoordsNV;
#define glPathCoordsNV glad_debug_glPathCoordsNV
    GLAD_API_CALL PFNGLPATHCOVERDEPTHFUNCNVPROC glad_glPathCoverDepthFuncNV;
    GLAD_API_CALL PFNGLPATHCOVERDEPTHFUNCNVPROC glad_debug_glPathCoverDepthFuncNV;
#define glPathCoverDepthFuncNV glad_debug_glPathCoverDepthFuncNV
    GLAD_API_CALL PFNGLPATHDASHARRAYNVPROC glad_glPathDashArrayNV;
    GLAD_API_CALL PFNGLPATHDASHARRAYNVPROC glad_debug_glPathDashArrayNV;
#define glPathDashArrayNV glad_debug_glPathDashArrayNV
    GLAD_API_CALL PFNGLPATHGLYPHINDEXARRAYNVPROC glad_glPathGlyphIndexArrayNV;
    GLAD_API_CALL PFNGLPATHGLYPHINDEXARRAYNVPROC glad_debug_glPathGlyphIndexArrayNV;
#define glPathGlyphIndexArrayNV glad_debug_glPathGlyphIndexArrayNV
    GLAD_API_CALL PFNGLPATHGLYPHINDEXRANGENVPROC glad_glPathGlyphIndexRangeNV;
    GLAD_API_CALL PFNGLPATHGLYPHINDEXRANGENVPROC glad_debug_glPathGlyphIndexRangeNV;
#define glPathGlyphIndexRangeNV glad_debug_glPathGlyphIndexRangeNV
    GLAD_API_CALL PFNGLPATHGLYPHRANGENVPROC glad_glPathGlyphRangeNV;
    GLAD_API_CALL PFNGLPATHGLYPHRANGENVPROC glad_debug_glPathGlyphRangeNV;
#define glPathGlyphRangeNV glad_debug_glPathGlyphRangeNV
    GLAD_API_CALL PFNGLPATHGLYPHSNVPROC glad_glPathGlyphsNV;
    GLAD_API_CALL PFNGLPATHGLYPHSNVPROC glad_debug_glPathGlyphsNV;
#define glPathGlyphsNV glad_debug_glPathGlyphsNV
    GLAD_API_CALL PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_glPathMemoryGlyphIndexArrayNV;
    GLAD_API_CALL PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_debug_glPathMemoryGlyphIndexArrayNV;
#define glPathMemoryGlyphIndexArrayNV glad_debug_glPathMemoryGlyphIndexArrayNV
    GLAD_API_CALL PFNGLPATHPARAMETERFNVPROC glad_glPathParameterfNV;
    GLAD_API_CALL PFNGLPATHPARAMETERFNVPROC glad_debug_glPathParameterfNV;
#define glPathParameterfNV glad_debug_glPathParameterfNV
    GLAD_API_CALL PFNGLPATHPARAMETERFVNVPROC glad_glPathParameterfvNV;
    GLAD_API_CALL PFNGLPATHPARAMETERFVNVPROC glad_debug_glPathParameterfvNV;
#define glPathParameterfvNV glad_debug_glPathParameterfvNV
    GLAD_API_CALL PFNGLPATHPARAMETERINVPROC glad_glPathParameteriNV;
    GLAD_API_CALL PFNGLPATHPARAMETERINVPROC glad_debug_glPathParameteriNV;
#define glPathParameteriNV glad_debug_glPathParameteriNV
    GLAD_API_CALL PFNGLPATHPARAMETERIVNVPROC glad_glPathParameterivNV;
    GLAD_API_CALL PFNGLPATHPARAMETERIVNVPROC glad_debug_glPathParameterivNV;
#define glPathParameterivNV glad_debug_glPathParameterivNV
    GLAD_API_CALL PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_glPathStencilDepthOffsetNV;
    GLAD_API_CALL PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_debug_glPathStencilDepthOffsetNV;
#define glPathStencilDepthOffsetNV glad_debug_glPathStencilDepthOffsetNV
    GLAD_API_CALL PFNGLPATHSTENCILFUNCNVPROC glad_glPathStencilFuncNV;
    GLAD_API_CALL PFNGLPATHSTENCILFUNCNVPROC glad_debug_glPathStencilFuncNV;
#define glPathStencilFuncNV glad_debug_glPathStencilFuncNV
    GLAD_API_CALL PFNGLPATHSTRINGNVPROC glad_glPathStringNV;
    GLAD_API_CALL PFNGLPATHSTRINGNVPROC glad_debug_glPathStringNV;
#define glPathStringNV glad_debug_glPathStringNV
    GLAD_API_CALL PFNGLPATHSUBCOMMANDSNVPROC glad_glPathSubCommandsNV;
    GLAD_API_CALL PFNGLPATHSUBCOMMANDSNVPROC glad_debug_glPathSubCommandsNV;
#define glPathSubCommandsNV glad_debug_glPathSubCommandsNV
    GLAD_API_CALL PFNGLPATHSUBCOORDSNVPROC glad_glPathSubCoordsNV;
    GLAD_API_CALL PFNGLPATHSUBCOORDSNVPROC glad_debug_glPathSubCoordsNV;
#define glPathSubCoordsNV glad_debug_glPathSubCoordsNV
    GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
    GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_debug_glPauseTransformFeedback;

/// <summary>
///   pause transform feedback operations
///   <para>
///     glPauseTransformFeedback pauses transform feedback operations on the currently active
///     transform feedback object. When transform feedback operations are paused, transform feedback
///     is still considered active and changing most transform feedback state related to the object
///     results in an error. However, a new transform feedback object may be bound while transform
///     feedback is paused.
///   </para>
/// </summary>
#define glPauseTransformFeedback glad_debug_glPauseTransformFeedback
    GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_glPauseTransformFeedbackNV;
    GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_debug_glPauseTransformFeedbackNV;
#define glPauseTransformFeedbackNV glad_debug_glPauseTransformFeedbackNV
    GLAD_API_CALL PFNGLPIXELDATARANGENVPROC glad_glPixelDataRangeNV;
    GLAD_API_CALL PFNGLPIXELDATARANGENVPROC glad_debug_glPixelDataRangeNV;
#define glPixelDataRangeNV glad_debug_glPixelDataRangeNV
    GLAD_API_CALL PFNGLPIXELMAPXPROC glad_glPixelMapx;
    GLAD_API_CALL PFNGLPIXELMAPXPROC glad_debug_glPixelMapx;
#define glPixelMapx glad_debug_glPixelMapx
    GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_glPixelStoref;
    GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_debug_glPixelStoref;
#define glPixelStoref glad_debug_glPixelStoref
    GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_glPixelStorei;
    GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_debug_glPixelStorei;
#define glPixelStorei glad_debug_glPixelStorei
    GLAD_API_CALL PFNGLPIXELSTOREXPROC glad_glPixelStorex;
    GLAD_API_CALL PFNGLPIXELSTOREXPROC glad_debug_glPixelStorex;
#define glPixelStorex glad_debug_glPixelStorex
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERFSGISPROC glad_glPixelTexGenParameterfSGIS;
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERFSGISPROC glad_debug_glPixelTexGenParameterfSGIS;
#define glPixelTexGenParameterfSGIS glad_debug_glPixelTexGenParameterfSGIS
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERFVSGISPROC glad_glPixelTexGenParameterfvSGIS;
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERFVSGISPROC glad_debug_glPixelTexGenParameterfvSGIS;
#define glPixelTexGenParameterfvSGIS glad_debug_glPixelTexGenParameterfvSGIS
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERISGISPROC glad_glPixelTexGenParameteriSGIS;
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERISGISPROC glad_debug_glPixelTexGenParameteriSGIS;
#define glPixelTexGenParameteriSGIS glad_debug_glPixelTexGenParameteriSGIS
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERIVSGISPROC glad_glPixelTexGenParameterivSGIS;
    GLAD_API_CALL PFNGLPIXELTEXGENPARAMETERIVSGISPROC glad_debug_glPixelTexGenParameterivSGIS;
#define glPixelTexGenParameterivSGIS glad_debug_glPixelTexGenParameterivSGIS
    GLAD_API_CALL PFNGLPIXELTEXGENSGIXPROC glad_glPixelTexGenSGIX;
    GLAD_API_CALL PFNGLPIXELTEXGENSGIXPROC glad_debug_glPixelTexGenSGIX;
#define glPixelTexGenSGIX glad_debug_glPixelTexGenSGIX
    GLAD_API_CALL PFNGLPIXELTRANSFERXOESPROC glad_glPixelTransferxOES;
    GLAD_API_CALL PFNGLPIXELTRANSFERXOESPROC glad_debug_glPixelTransferxOES;
#define glPixelTransferxOES glad_debug_glPixelTransferxOES
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_glPixelTransformParameterfEXT;
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_debug_glPixelTransformParameterfEXT;
#define glPixelTransformParameterfEXT glad_debug_glPixelTransformParameterfEXT
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_glPixelTransformParameterfvEXT;
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_debug_glPixelTransformParameterfvEXT;
#define glPixelTransformParameterfvEXT glad_debug_glPixelTransformParameterfvEXT
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_glPixelTransformParameteriEXT;
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_debug_glPixelTransformParameteriEXT;
#define glPixelTransformParameteriEXT glad_debug_glPixelTransformParameteriEXT
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_glPixelTransformParameterivEXT;
    GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_debug_glPixelTransformParameterivEXT;
#define glPixelTransformParameterivEXT glad_debug_glPixelTransformParameterivEXT
    GLAD_API_CALL PFNGLPIXELZOOMXOESPROC glad_glPixelZoomxOES;
    GLAD_API_CALL PFNGLPIXELZOOMXOESPROC glad_debug_glPixelZoomxOES;
#define glPixelZoomxOES glad_debug_glPixelZoomxOES
    GLAD_API_CALL PFNGLPOINTALONGPATHNVPROC glad_glPointAlongPathNV;
    GLAD_API_CALL PFNGLPOINTALONGPATHNVPROC glad_debug_glPointAlongPathNV;
#define glPointAlongPathNV glad_debug_glPointAlongPathNV
    GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
    GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_debug_glPointParameterf;
#define glPointParameterf glad_debug_glPointParameterf
    GLAD_API_CALL PFNGLPOINTPARAMETERFARBPROC glad_glPointParameterfARB;
    GLAD_API_CALL PFNGLPOINTPARAMETERFARBPROC glad_debug_glPointParameterfARB;
#define glPointParameterfARB glad_debug_glPointParameterfARB
    GLAD_API_CALL PFNGLPOINTPARAMETERFEXTPROC glad_glPointParameterfEXT;
    GLAD_API_CALL PFNGLPOINTPARAMETERFEXTPROC glad_debug_glPointParameterfEXT;
#define glPointParameterfEXT glad_debug_glPointParameterfEXT
    GLAD_API_CALL PFNGLPOINTPARAMETERFSGISPROC glad_glPointParameterfSGIS;
    GLAD_API_CALL PFNGLPOINTPARAMETERFSGISPROC glad_debug_glPointParameterfSGIS;
#define glPointParameterfSGIS glad_debug_glPointParameterfSGIS
    GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
    GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_debug_glPointParameterfv;
#define glPointParameterfv glad_debug_glPointParameterfv
    GLAD_API_CALL PFNGLPOINTPARAMETERFVARBPROC glad_glPointParameterfvARB;
    GLAD_API_CALL PFNGLPOINTPARAMETERFVARBPROC glad_debug_glPointParameterfvARB;
#define glPointParameterfvARB glad_debug_glPointParameterfvARB
    GLAD_API_CALL PFNGLPOINTPARAMETERFVEXTPROC glad_glPointParameterfvEXT;
    GLAD_API_CALL PFNGLPOINTPARAMETERFVEXTPROC glad_debug_glPointParameterfvEXT;
#define glPointParameterfvEXT glad_debug_glPointParameterfvEXT
    GLAD_API_CALL PFNGLPOINTPARAMETERFVSGISPROC glad_glPointParameterfvSGIS;
    GLAD_API_CALL PFNGLPOINTPARAMETERFVSGISPROC glad_debug_glPointParameterfvSGIS;
#define glPointParameterfvSGIS glad_debug_glPointParameterfvSGIS
    GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
    GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_debug_glPointParameteri;
#define glPointParameteri glad_debug_glPointParameteri
    GLAD_API_CALL PFNGLPOINTPARAMETERINVPROC glad_glPointParameteriNV;
    GLAD_API_CALL PFNGLPOINTPARAMETERINVPROC glad_debug_glPointParameteriNV;
#define glPointParameteriNV glad_debug_glPointParameteriNV
    GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
    GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_debug_glPointParameteriv;
#define glPointParameteriv glad_debug_glPointParameteriv
    GLAD_API_CALL PFNGLPOINTPARAMETERIVNVPROC glad_glPointParameterivNV;
    GLAD_API_CALL PFNGLPOINTPARAMETERIVNVPROC glad_debug_glPointParameterivNV;
#define glPointParameterivNV glad_debug_glPointParameterivNV
    GLAD_API_CALL PFNGLPOINTPARAMETERXVOESPROC glad_glPointParameterxvOES;
    GLAD_API_CALL PFNGLPOINTPARAMETERXVOESPROC glad_debug_glPointParameterxvOES;
#define glPointParameterxvOES glad_debug_glPointParameterxvOES
    GLAD_API_CALL PFNGLPOINTSIZEPROC glad_glPointSize;
    GLAD_API_CALL PFNGLPOINTSIZEPROC glad_debug_glPointSize;

/// <summary>
///   specify the diameter of rasterized points
///   <para>
///     glPointSize specifies the rasterized diameter of points. If point size mode is disabled (see
///     glEnable with parameter GL_PROGRAM_POINT_SIZE ), this value will be used to rasterize
///     points. Otherwise, the value written to the shading language built-in variable gl_PointSize
///     will be used.
///   </para>
/// </summary>
/// <param name='size'>Specifies the diameter of rasterized points. The initial value is 1.</param>
#define glPointSize glad_debug_glPointSize
    GLAD_API_CALL PFNGLPOINTSIZEXOESPROC glad_glPointSizexOES;
    GLAD_API_CALL PFNGLPOINTSIZEXOESPROC glad_debug_glPointSizexOES;
#define glPointSizexOES glad_debug_glPointSizexOES
    GLAD_API_CALL PFNGLPOLLASYNCSGIXPROC glad_glPollAsyncSGIX;
    GLAD_API_CALL PFNGLPOLLASYNCSGIXPROC glad_debug_glPollAsyncSGIX;
#define glPollAsyncSGIX glad_debug_glPollAsyncSGIX
    GLAD_API_CALL PFNGLPOLLINSTRUMENTSSGIXPROC glad_glPollInstrumentsSGIX;
    GLAD_API_CALL PFNGLPOLLINSTRUMENTSSGIXPROC glad_debug_glPollInstrumentsSGIX;
#define glPollInstrumentsSGIX glad_debug_glPollInstrumentsSGIX
    GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_glPolygonMode;
    GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_debug_glPolygonMode;

/// <summary>
///   select a polygon rasterization mode
///   <para>
///     glPolygonMode controls the interpretation of polygons for rasterization. face describes
///     which polygons mode applies to: both front and back-facing polygons ( GL_FRONT_AND_BACK ).
///     The polygon mode affects only the final rasterization of polygons. In particular, a
///     polygon's vertices are lit and the polygon is clipped and possibly culled before these modes
///     are applied. Three modes are defined and can be specified in mode : Polygon vertices that
///     are marked as the start of a boundary edge are drawn as points. Point attributes such as
///     GL_POINT_SIZE and GL_POINT_SMOOTH control the rasterization of the points. Polygon
///     rasterization attributes other than GL_POLYGON_MODE have no effect. Boundary edges of the
///     polygon are drawn as line segments. Line attributes such as GL_LINE_WIDTH and GL_LINE_SMOOTH
///     control the rasterization of the lines. Polygon rasterization attributes other than
///     GL_POLYGON_MODE have no effect. The interior of the polygon is filled. Polygon attributes
///     such as GL_POLYGON_SMOOTH control the rasterization of the polygon.
///   </para>
/// </summary>
/// <param name='face'>Specifies the polygons that</param>
/// <param name='mode'>Specifies how polygons will be rasterized. Accepted values are</param>
#define glPolygonMode glad_debug_glPolygonMode
    GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
    GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_debug_glPolygonOffset;

/// <summary>
///   set the scale and units used to calculate depth values
///   <para>
///     When GL_POLYGON_OFFSET_FILL , GL_POLYGON_OFFSET_LINE , or GL_POLYGON_OFFSET_POINT is
///     enabled, each fragment's depth value will be offset after it is interpolated from the depth
///     values of the appropriate vertices. The value of the offset is factor × DZ + r × units ,
///     where DZ is a measurement of the change in depth relative to the screen area of the polygon,
///     and r is the smallest value that is guaranteed to produce a resolvable offset for a given
///     implementation. The offset is added before the depth test is performed and before the value
///     is written into the depth buffer. glPolygonOffset is useful for rendering hidden-line
///     images, for applying decals to surfaces, and for rendering solids with highlighted edges.
///   </para>
/// </summary>
/// <param name='factor'>Specifies a scale factor that is used to create a variable depth offset for
/// each polygon. The initial value is 0.</param> <param name='units'>Is multiplied by an
/// implementation-specific value to create a constant depth offset. The initial value is 0.</param>
#define glPolygonOffset glad_debug_glPolygonOffset
    GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
    GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPPROC glad_debug_glPolygonOffsetClamp;
#define glPolygonOffsetClamp glad_debug_glPolygonOffsetClamp
    GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_glPolygonOffsetClampEXT;
    GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_debug_glPolygonOffsetClampEXT;
#define glPolygonOffsetClampEXT glad_debug_glPolygonOffsetClampEXT
    GLAD_API_CALL PFNGLPOLYGONOFFSETEXTPROC glad_glPolygonOffsetEXT;
    GLAD_API_CALL PFNGLPOLYGONOFFSETEXTPROC glad_debug_glPolygonOffsetEXT;
#define glPolygonOffsetEXT glad_debug_glPolygonOffsetEXT
    GLAD_API_CALL PFNGLPOLYGONOFFSETXOESPROC glad_glPolygonOffsetxOES;
    GLAD_API_CALL PFNGLPOLYGONOFFSETXOESPROC glad_debug_glPolygonOffsetxOES;
#define glPolygonOffsetxOES glad_debug_glPolygonOffsetxOES
    GLAD_API_CALL PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;
    GLAD_API_CALL PFNGLPOPDEBUGGROUPPROC glad_debug_glPopDebugGroup;

/// <summary>
///   pop the active debug group
///   <para>
///     glPopDebugGroup pops the active debug group. After popping a debug group, the GL will also
///     generate a debug output message describing its cause based on the message string, the source
///     source , and an ID id submitted to the corresponding glPushDebugGroup command.
///     GL_DEBUG_TYPE_PUSH_GROUP and GL_DEBUG_TYPE_POP_GROUP share a single namespace for message
///     id. severity has the value GL_DEBUG_SEVERITY_NOTIFICATION. The type has the value
///     GL_DEBUG_TYPE_POP_GROUP. Popping a debug group restores the debug output volume control of
///     the parent debug group.
///   </para>
/// </summary>
#define glPopDebugGroup glad_debug_glPopDebugGroup
    GLAD_API_CALL PFNGLPOPGROUPMARKEREXTPROC glad_glPopGroupMarkerEXT;
    GLAD_API_CALL PFNGLPOPGROUPMARKEREXTPROC glad_debug_glPopGroupMarkerEXT;
#define glPopGroupMarkerEXT glad_debug_glPopGroupMarkerEXT
    GLAD_API_CALL PFNGLPRESENTFRAMEDUALFILLNVPROC glad_glPresentFrameDualFillNV;
    GLAD_API_CALL PFNGLPRESENTFRAMEDUALFILLNVPROC glad_debug_glPresentFrameDualFillNV;
#define glPresentFrameDualFillNV glad_debug_glPresentFrameDualFillNV
    GLAD_API_CALL PFNGLPRESENTFRAMEKEYEDNVPROC glad_glPresentFrameKeyedNV;
    GLAD_API_CALL PFNGLPRESENTFRAMEKEYEDNVPROC glad_debug_glPresentFrameKeyedNV;
#define glPresentFrameKeyedNV glad_debug_glPresentFrameKeyedNV
    GLAD_API_CALL PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_glPrimitiveBoundingBoxARB;
    GLAD_API_CALL PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_debug_glPrimitiveBoundingBoxARB;
#define glPrimitiveBoundingBoxARB glad_debug_glPrimitiveBoundingBoxARB
    GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
    GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_debug_glPrimitiveRestartIndex;

/// <summary>
///   specify the primitive restart index
///   <para>
///     glPrimitiveRestartIndex specifies a vertex array element that is treated specially when
///     primitive restarting is enabled. This is known as the primitive restart index. When one of
///     the Draw* commands transfers a set of generic attribute array elements to the GL, if the
///     index within the vertex arrays corresponding to that set is equal to the primitive restart
///     index, then the GL does not process those elements as a vertex. Instead, it is as if the
///     drawing command ended with the immediately preceding transfer, and another drawing command
///     is immediately started with the same parameters, but only transferring the immediately
///     following element through the end of the originally specified elements. When either
///     glDrawElementsBaseVertex , glDrawElementsInstancedBaseVertex or
///     glMultiDrawElementsBaseVertex is used, the primitive restart comparison occurs before the
///     basevertex offset is added to the array index.
///   </para>
/// </summary>
/// <param name='index'>Specifies the value to be interpreted as the primitive restart
/// index.</param>
#define glPrimitiveRestartIndex glad_debug_glPrimitiveRestartIndex
    GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXNVPROC glad_glPrimitiveRestartIndexNV;
    GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXNVPROC glad_debug_glPrimitiveRestartIndexNV;
#define glPrimitiveRestartIndexNV glad_debug_glPrimitiveRestartIndexNV
    GLAD_API_CALL PFNGLPRIMITIVERESTARTNVPROC glad_glPrimitiveRestartNV;
    GLAD_API_CALL PFNGLPRIMITIVERESTARTNVPROC glad_debug_glPrimitiveRestartNV;
#define glPrimitiveRestartNV glad_debug_glPrimitiveRestartNV
    GLAD_API_CALL PFNGLPRIORITIZETEXTURESEXTPROC glad_glPrioritizeTexturesEXT;
    GLAD_API_CALL PFNGLPRIORITIZETEXTURESEXTPROC glad_debug_glPrioritizeTexturesEXT;
#define glPrioritizeTexturesEXT glad_debug_glPrioritizeTexturesEXT
    GLAD_API_CALL PFNGLPRIORITIZETEXTURESXOESPROC glad_glPrioritizeTexturesxOES;
    GLAD_API_CALL PFNGLPRIORITIZETEXTURESXOESPROC glad_debug_glPrioritizeTexturesxOES;
#define glPrioritizeTexturesxOES glad_debug_glPrioritizeTexturesxOES
    GLAD_API_CALL PFNGLPROGRAMBINARYPROC glad_glProgramBinary;
    GLAD_API_CALL PFNGLPROGRAMBINARYPROC glad_debug_glProgramBinary;

/// <summary>
///   load a program object with a program binary
///   <para>
///     glProgramBinary loads a program object with a program binary previously returned from
///     glGetProgramBinary. binaryFormat and binary must be those returned by a previous call to
///     glGetProgramBinary , and length must be the length returned by glGetProgramBinary , or by
///     glGetProgram when called with pname set to GL_PROGRAM_BINARY_LENGTH. If these conditions are
///     not met, loading the program binary will fail and program 's GL_LINK_STATUS will be set to
///     GL_FALSE. A program object's program binary is replaced by calls to glLinkProgram or
///     glProgramBinary. When linking success or failure is concerned, glProgramBinary can be
///     considered to perform an implicit linking operation. glLinkProgram and glProgramBinary both
///     set the program object's GL_LINK_STATUS to GL_TRUE or GL_FALSE. A successful call to
///     glProgramBinary will reset all uniform variables to their initial values. The initial value
///     is either the value of the variable's initializer as specified in the original shader
///     source, or zero if no initializer was present. Additionally, all vertex shader input and
///     fragment shader output assignments that were in effect when the program was linked before
///     saving are restored with glProgramBinary is called.
///   </para>
/// </summary>
/// <param name='program'>Specifies the name of a program object into which to load a program
/// binary.</param> <param name='binaryFormat'>Specifies the format of the binary data in
/// binary.</param> <param name='binary'>Specifies the address an array containing the binary to be
/// loaded into</param> <param name='length'>Specifies the number of bytes contained in</param>
#define glProgramBinary glad_debug_glProgramBinary
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_glProgramBufferParametersIivNV;
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_debug_glProgramBufferParametersIivNV;
#define glProgramBufferParametersIivNV glad_debug_glProgramBufferParametersIivNV
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_glProgramBufferParametersIuivNV;
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_debug_glProgramBufferParametersIuivNV;
#define glProgramBufferParametersIuivNV glad_debug_glProgramBufferParametersIuivNV
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_glProgramBufferParametersfvNV;
    GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_debug_glProgramBufferParametersfvNV;
#define glProgramBufferParametersfvNV glad_debug_glProgramBufferParametersfvNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DARBPROC glad_glProgramEnvParameter4dARB;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DARBPROC glad_debug_glProgramEnvParameter4dARB;
#define glProgramEnvParameter4dARB glad_debug_glProgramEnvParameter4dARB
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_glProgramEnvParameter4dvARB;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_debug_glProgramEnvParameter4dvARB;
#define glProgramEnvParameter4dvARB glad_debug_glProgramEnvParameter4dvARB
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FARBPROC glad_glProgramEnvParameter4fARB;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FARBPROC glad_debug_glProgramEnvParameter4fARB;
#define glProgramEnvParameter4fARB glad_debug_glProgramEnvParameter4fARB
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_glProgramEnvParameter4fvARB;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_debug_glProgramEnvParameter4fvARB;
#define glProgramEnvParameter4fvARB glad_debug_glProgramEnvParameter4fvARB
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4INVPROC glad_glProgramEnvParameterI4iNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4INVPROC glad_debug_glProgramEnvParameterI4iNV;
#define glProgramEnvParameterI4iNV glad_debug_glProgramEnvParameterI4iNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_glProgramEnvParameterI4ivNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_debug_glProgramEnvParameterI4ivNV;
#define glProgramEnvParameterI4ivNV glad_debug_glProgramEnvParameterI4ivNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_glProgramEnvParameterI4uiNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_debug_glProgramEnvParameterI4uiNV;
#define glProgramEnvParameterI4uiNV glad_debug_glProgramEnvParameterI4uiNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_glProgramEnvParameterI4uivNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_debug_glProgramEnvParameterI4uivNV;
#define glProgramEnvParameterI4uivNV glad_debug_glProgramEnvParameterI4uivNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_glProgramEnvParameters4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_debug_glProgramEnvParameters4fvEXT;
#define glProgramEnvParameters4fvEXT glad_debug_glProgramEnvParameters4fvEXT
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_glProgramEnvParametersI4ivNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_debug_glProgramEnvParametersI4ivNV;
#define glProgramEnvParametersI4ivNV glad_debug_glProgramEnvParametersI4ivNV
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_glProgramEnvParametersI4uivNV;
    GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_debug_glProgramEnvParametersI4uivNV;
#define glProgramEnvParametersI4uivNV glad_debug_glProgramEnvParametersI4uivNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_glProgramLocalParameter4dARB;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_debug_glProgramLocalParameter4dARB;
#define glProgramLocalParameter4dARB glad_debug_glProgramLocalParameter4dARB
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_glProgramLocalParameter4dvARB;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_debug_glProgramLocalParameter4dvARB;
#define glProgramLocalParameter4dvARB glad_debug_glProgramLocalParameter4dvARB
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_glProgramLocalParameter4fARB;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_debug_glProgramLocalParameter4fARB;
#define glProgramLocalParameter4fARB glad_debug_glProgramLocalParameter4fARB
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_glProgramLocalParameter4fvARB;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_debug_glProgramLocalParameter4fvARB;
#define glProgramLocalParameter4fvARB glad_debug_glProgramLocalParameter4fvARB
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_glProgramLocalParameterI4iNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_debug_glProgramLocalParameterI4iNV;
#define glProgramLocalParameterI4iNV glad_debug_glProgramLocalParameterI4iNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_glProgramLocalParameterI4ivNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_debug_glProgramLocalParameterI4ivNV;
#define glProgramLocalParameterI4ivNV glad_debug_glProgramLocalParameterI4ivNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_glProgramLocalParameterI4uiNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_debug_glProgramLocalParameterI4uiNV;
#define glProgramLocalParameterI4uiNV glad_debug_glProgramLocalParameterI4uiNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_glProgramLocalParameterI4uivNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_debug_glProgramLocalParameterI4uivNV;
#define glProgramLocalParameterI4uivNV glad_debug_glProgramLocalParameterI4uivNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glProgramLocalParameters4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_debug_glProgramLocalParameters4fvEXT;
#define glProgramLocalParameters4fvEXT glad_debug_glProgramLocalParameters4fvEXT
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_glProgramLocalParametersI4ivNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_debug_glProgramLocalParametersI4ivNV;
#define glProgramLocalParametersI4ivNV glad_debug_glProgramLocalParametersI4ivNV
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_glProgramLocalParametersI4uivNV;
    GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_debug_glProgramLocalParametersI4uivNV;
#define glProgramLocalParametersI4uivNV glad_debug_glProgramLocalParametersI4uivNV
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_glProgramNamedParameter4dNV;
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_debug_glProgramNamedParameter4dNV;
#define glProgramNamedParameter4dNV glad_debug_glProgramNamedParameter4dNV
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_glProgramNamedParameter4dvNV;
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_debug_glProgramNamedParameter4dvNV;
#define glProgramNamedParameter4dvNV glad_debug_glProgramNamedParameter4dvNV
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_glProgramNamedParameter4fNV;
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_debug_glProgramNamedParameter4fNV;
#define glProgramNamedParameter4fNV glad_debug_glProgramNamedParameter4fNV
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_glProgramNamedParameter4fvNV;
    GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_debug_glProgramNamedParameter4fvNV;
#define glProgramNamedParameter4fvNV glad_debug_glProgramNamedParameter4fvNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4DNVPROC glad_glProgramParameter4dNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4DNVPROC glad_debug_glProgramParameter4dNV;
#define glProgramParameter4dNV glad_debug_glProgramParameter4dNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4DVNVPROC glad_glProgramParameter4dvNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4DVNVPROC glad_debug_glProgramParameter4dvNV;
#define glProgramParameter4dvNV glad_debug_glProgramParameter4dvNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4FNVPROC glad_glProgramParameter4fNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4FNVPROC glad_debug_glProgramParameter4fNV;
#define glProgramParameter4fNV glad_debug_glProgramParameter4fNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4FVNVPROC glad_glProgramParameter4fvNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETER4FVNVPROC glad_debug_glProgramParameter4fvNV;
#define glProgramParameter4fvNV glad_debug_glProgramParameter4fvNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIPROC glad_debug_glProgramParameteri;
#define glProgramParameteri glad_debug_glProgramParameteri
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIARBPROC glad_glProgramParameteriARB;
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIARBPROC glad_debug_glProgramParameteriARB;
#define glProgramParameteriARB glad_debug_glProgramParameteriARB
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIEXTPROC glad_glProgramParameteriEXT;
    GLAD_API_CALL PFNGLPROGRAMPARAMETERIEXTPROC glad_debug_glProgramParameteriEXT;
#define glProgramParameteriEXT glad_debug_glProgramParameteriEXT
    GLAD_API_CALL PFNGLPROGRAMPARAMETERS4DVNVPROC glad_glProgramParameters4dvNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETERS4DVNVPROC glad_debug_glProgramParameters4dvNV;
#define glProgramParameters4dvNV glad_debug_glProgramParameters4dvNV
    GLAD_API_CALL PFNGLPROGRAMPARAMETERS4FVNVPROC glad_glProgramParameters4fvNV;
    GLAD_API_CALL PFNGLPROGRAMPARAMETERS4FVNVPROC glad_debug_glProgramParameters4fvNV;
#define glProgramParameters4fvNV glad_debug_glProgramParameters4fvNV
    GLAD_API_CALL PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_glProgramPathFragmentInputGenNV;
    GLAD_API_CALL PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_debug_glProgramPathFragmentInputGenNV;
#define glProgramPathFragmentInputGenNV glad_debug_glProgramPathFragmentInputGenNV
    GLAD_API_CALL PFNGLPROGRAMSTRINGARBPROC glad_glProgramStringARB;
    GLAD_API_CALL PFNGLPROGRAMSTRINGARBPROC glad_debug_glProgramStringARB;
#define glProgramStringARB glad_debug_glProgramStringARB
    GLAD_API_CALL PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC glad_glProgramSubroutineParametersuivNV;
    GLAD_API_CALL PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC
        glad_debug_glProgramSubroutineParametersuivNV;
#define glProgramSubroutineParametersuivNV glad_debug_glProgramSubroutineParametersuivNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DPROC glad_debug_glProgramUniform1d;
#define glProgramUniform1d glad_debug_glProgramUniform1d
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DEXTPROC glad_glProgramUniform1dEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DEXTPROC glad_debug_glProgramUniform1dEXT;
#define glProgramUniform1dEXT glad_debug_glProgramUniform1dEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVPROC glad_debug_glProgramUniform1dv;
#define glProgramUniform1dv glad_debug_glProgramUniform1dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVEXTPROC glad_glProgramUniform1dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVEXTPROC glad_debug_glProgramUniform1dvEXT;
#define glProgramUniform1dvEXT glad_debug_glProgramUniform1dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FPROC glad_debug_glProgramUniform1f;
#define glProgramUniform1f glad_debug_glProgramUniform1f
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FEXTPROC glad_glProgramUniform1fEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FEXTPROC glad_debug_glProgramUniform1fEXT;
#define glProgramUniform1fEXT glad_debug_glProgramUniform1fEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVPROC glad_debug_glProgramUniform1fv;
#define glProgramUniform1fv glad_debug_glProgramUniform1fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVEXTPROC glad_glProgramUniform1fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVEXTPROC glad_debug_glProgramUniform1fvEXT;
#define glProgramUniform1fvEXT glad_debug_glProgramUniform1fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IPROC glad_debug_glProgramUniform1i;
#define glProgramUniform1i glad_debug_glProgramUniform1i
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64ARBPROC glad_glProgramUniform1i64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64ARBPROC glad_debug_glProgramUniform1i64ARB;
#define glProgramUniform1i64ARB glad_debug_glProgramUniform1i64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64NVPROC glad_glProgramUniform1i64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64NVPROC glad_debug_glProgramUniform1i64NV;
#define glProgramUniform1i64NV glad_debug_glProgramUniform1i64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VARBPROC glad_glProgramUniform1i64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VARBPROC glad_debug_glProgramUniform1i64vARB;
#define glProgramUniform1i64vARB glad_debug_glProgramUniform1i64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VNVPROC glad_glProgramUniform1i64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VNVPROC glad_debug_glProgramUniform1i64vNV;
#define glProgramUniform1i64vNV glad_debug_glProgramUniform1i64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IEXTPROC glad_glProgramUniform1iEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IEXTPROC glad_debug_glProgramUniform1iEXT;
#define glProgramUniform1iEXT glad_debug_glProgramUniform1iEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVPROC glad_debug_glProgramUniform1iv;
#define glProgramUniform1iv glad_debug_glProgramUniform1iv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVEXTPROC glad_glProgramUniform1ivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVEXTPROC glad_debug_glProgramUniform1ivEXT;
#define glProgramUniform1ivEXT glad_debug_glProgramUniform1ivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIPROC glad_debug_glProgramUniform1ui;
#define glProgramUniform1ui glad_debug_glProgramUniform1ui
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_glProgramUniform1ui64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_debug_glProgramUniform1ui64ARB;
#define glProgramUniform1ui64ARB glad_debug_glProgramUniform1ui64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64NVPROC glad_glProgramUniform1ui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64NVPROC glad_debug_glProgramUniform1ui64NV;
#define glProgramUniform1ui64NV glad_debug_glProgramUniform1ui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_glProgramUniform1ui64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_debug_glProgramUniform1ui64vARB;
#define glProgramUniform1ui64vARB glad_debug_glProgramUniform1ui64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_glProgramUniform1ui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_debug_glProgramUniform1ui64vNV;
#define glProgramUniform1ui64vNV glad_debug_glProgramUniform1ui64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIEXTPROC glad_glProgramUniform1uiEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIEXTPROC glad_debug_glProgramUniform1uiEXT;
#define glProgramUniform1uiEXT glad_debug_glProgramUniform1uiEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVPROC glad_debug_glProgramUniform1uiv;
#define glProgramUniform1uiv glad_debug_glProgramUniform1uiv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_glProgramUniform1uivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_debug_glProgramUniform1uivEXT;
#define glProgramUniform1uivEXT glad_debug_glProgramUniform1uivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DPROC glad_debug_glProgramUniform2d;
#define glProgramUniform2d glad_debug_glProgramUniform2d
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DEXTPROC glad_glProgramUniform2dEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DEXTPROC glad_debug_glProgramUniform2dEXT;
#define glProgramUniform2dEXT glad_debug_glProgramUniform2dEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVPROC glad_debug_glProgramUniform2dv;
#define glProgramUniform2dv glad_debug_glProgramUniform2dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVEXTPROC glad_glProgramUniform2dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVEXTPROC glad_debug_glProgramUniform2dvEXT;
#define glProgramUniform2dvEXT glad_debug_glProgramUniform2dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FPROC glad_debug_glProgramUniform2f;
#define glProgramUniform2f glad_debug_glProgramUniform2f
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FEXTPROC glad_glProgramUniform2fEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FEXTPROC glad_debug_glProgramUniform2fEXT;
#define glProgramUniform2fEXT glad_debug_glProgramUniform2fEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVPROC glad_debug_glProgramUniform2fv;
#define glProgramUniform2fv glad_debug_glProgramUniform2fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVEXTPROC glad_glProgramUniform2fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVEXTPROC glad_debug_glProgramUniform2fvEXT;
#define glProgramUniform2fvEXT glad_debug_glProgramUniform2fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IPROC glad_debug_glProgramUniform2i;
#define glProgramUniform2i glad_debug_glProgramUniform2i
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64ARBPROC glad_glProgramUniform2i64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64ARBPROC glad_debug_glProgramUniform2i64ARB;
#define glProgramUniform2i64ARB glad_debug_glProgramUniform2i64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64NVPROC glad_glProgramUniform2i64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64NVPROC glad_debug_glProgramUniform2i64NV;
#define glProgramUniform2i64NV glad_debug_glProgramUniform2i64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VARBPROC glad_glProgramUniform2i64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VARBPROC glad_debug_glProgramUniform2i64vARB;
#define glProgramUniform2i64vARB glad_debug_glProgramUniform2i64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VNVPROC glad_glProgramUniform2i64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VNVPROC glad_debug_glProgramUniform2i64vNV;
#define glProgramUniform2i64vNV glad_debug_glProgramUniform2i64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IEXTPROC glad_glProgramUniform2iEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IEXTPROC glad_debug_glProgramUniform2iEXT;
#define glProgramUniform2iEXT glad_debug_glProgramUniform2iEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVPROC glad_debug_glProgramUniform2iv;
#define glProgramUniform2iv glad_debug_glProgramUniform2iv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVEXTPROC glad_glProgramUniform2ivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVEXTPROC glad_debug_glProgramUniform2ivEXT;
#define glProgramUniform2ivEXT glad_debug_glProgramUniform2ivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIPROC glad_debug_glProgramUniform2ui;
#define glProgramUniform2ui glad_debug_glProgramUniform2ui
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_glProgramUniform2ui64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_debug_glProgramUniform2ui64ARB;
#define glProgramUniform2ui64ARB glad_debug_glProgramUniform2ui64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64NVPROC glad_glProgramUniform2ui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64NVPROC glad_debug_glProgramUniform2ui64NV;
#define glProgramUniform2ui64NV glad_debug_glProgramUniform2ui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_glProgramUniform2ui64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_debug_glProgramUniform2ui64vARB;
#define glProgramUniform2ui64vARB glad_debug_glProgramUniform2ui64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_glProgramUniform2ui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_debug_glProgramUniform2ui64vNV;
#define glProgramUniform2ui64vNV glad_debug_glProgramUniform2ui64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIEXTPROC glad_glProgramUniform2uiEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIEXTPROC glad_debug_glProgramUniform2uiEXT;
#define glProgramUniform2uiEXT glad_debug_glProgramUniform2uiEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVPROC glad_debug_glProgramUniform2uiv;
#define glProgramUniform2uiv glad_debug_glProgramUniform2uiv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_glProgramUniform2uivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_debug_glProgramUniform2uivEXT;
#define glProgramUniform2uivEXT glad_debug_glProgramUniform2uivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DPROC glad_debug_glProgramUniform3d;
#define glProgramUniform3d glad_debug_glProgramUniform3d
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DEXTPROC glad_glProgramUniform3dEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DEXTPROC glad_debug_glProgramUniform3dEXT;
#define glProgramUniform3dEXT glad_debug_glProgramUniform3dEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVPROC glad_debug_glProgramUniform3dv;
#define glProgramUniform3dv glad_debug_glProgramUniform3dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVEXTPROC glad_glProgramUniform3dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVEXTPROC glad_debug_glProgramUniform3dvEXT;
#define glProgramUniform3dvEXT glad_debug_glProgramUniform3dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FPROC glad_debug_glProgramUniform3f;
#define glProgramUniform3f glad_debug_glProgramUniform3f
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FEXTPROC glad_glProgramUniform3fEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FEXTPROC glad_debug_glProgramUniform3fEXT;
#define glProgramUniform3fEXT glad_debug_glProgramUniform3fEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVPROC glad_debug_glProgramUniform3fv;
#define glProgramUniform3fv glad_debug_glProgramUniform3fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVEXTPROC glad_glProgramUniform3fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVEXTPROC glad_debug_glProgramUniform3fvEXT;
#define glProgramUniform3fvEXT glad_debug_glProgramUniform3fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IPROC glad_debug_glProgramUniform3i;
#define glProgramUniform3i glad_debug_glProgramUniform3i
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64ARBPROC glad_glProgramUniform3i64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64ARBPROC glad_debug_glProgramUniform3i64ARB;
#define glProgramUniform3i64ARB glad_debug_glProgramUniform3i64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64NVPROC glad_glProgramUniform3i64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64NVPROC glad_debug_glProgramUniform3i64NV;
#define glProgramUniform3i64NV glad_debug_glProgramUniform3i64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VARBPROC glad_glProgramUniform3i64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VARBPROC glad_debug_glProgramUniform3i64vARB;
#define glProgramUniform3i64vARB glad_debug_glProgramUniform3i64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VNVPROC glad_glProgramUniform3i64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VNVPROC glad_debug_glProgramUniform3i64vNV;
#define glProgramUniform3i64vNV glad_debug_glProgramUniform3i64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IEXTPROC glad_glProgramUniform3iEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IEXTPROC glad_debug_glProgramUniform3iEXT;
#define glProgramUniform3iEXT glad_debug_glProgramUniform3iEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVPROC glad_debug_glProgramUniform3iv;
#define glProgramUniform3iv glad_debug_glProgramUniform3iv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVEXTPROC glad_glProgramUniform3ivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVEXTPROC glad_debug_glProgramUniform3ivEXT;
#define glProgramUniform3ivEXT glad_debug_glProgramUniform3ivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIPROC glad_debug_glProgramUniform3ui;
#define glProgramUniform3ui glad_debug_glProgramUniform3ui
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_glProgramUniform3ui64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_debug_glProgramUniform3ui64ARB;
#define glProgramUniform3ui64ARB glad_debug_glProgramUniform3ui64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64NVPROC glad_glProgramUniform3ui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64NVPROC glad_debug_glProgramUniform3ui64NV;
#define glProgramUniform3ui64NV glad_debug_glProgramUniform3ui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_glProgramUniform3ui64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_debug_glProgramUniform3ui64vARB;
#define glProgramUniform3ui64vARB glad_debug_glProgramUniform3ui64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_glProgramUniform3ui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_debug_glProgramUniform3ui64vNV;
#define glProgramUniform3ui64vNV glad_debug_glProgramUniform3ui64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIEXTPROC glad_glProgramUniform3uiEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIEXTPROC glad_debug_glProgramUniform3uiEXT;
#define glProgramUniform3uiEXT glad_debug_glProgramUniform3uiEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVPROC glad_debug_glProgramUniform3uiv;
#define glProgramUniform3uiv glad_debug_glProgramUniform3uiv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_glProgramUniform3uivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_debug_glProgramUniform3uivEXT;
#define glProgramUniform3uivEXT glad_debug_glProgramUniform3uivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DPROC glad_debug_glProgramUniform4d;
#define glProgramUniform4d glad_debug_glProgramUniform4d
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DEXTPROC glad_glProgramUniform4dEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DEXTPROC glad_debug_glProgramUniform4dEXT;
#define glProgramUniform4dEXT glad_debug_glProgramUniform4dEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVPROC glad_debug_glProgramUniform4dv;
#define glProgramUniform4dv glad_debug_glProgramUniform4dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVEXTPROC glad_glProgramUniform4dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVEXTPROC glad_debug_glProgramUniform4dvEXT;
#define glProgramUniform4dvEXT glad_debug_glProgramUniform4dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FPROC glad_debug_glProgramUniform4f;
#define glProgramUniform4f glad_debug_glProgramUniform4f
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FEXTPROC glad_glProgramUniform4fEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FEXTPROC glad_debug_glProgramUniform4fEXT;
#define glProgramUniform4fEXT glad_debug_glProgramUniform4fEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVPROC glad_debug_glProgramUniform4fv;
#define glProgramUniform4fv glad_debug_glProgramUniform4fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVEXTPROC glad_glProgramUniform4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVEXTPROC glad_debug_glProgramUniform4fvEXT;
#define glProgramUniform4fvEXT glad_debug_glProgramUniform4fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IPROC glad_debug_glProgramUniform4i;
#define glProgramUniform4i glad_debug_glProgramUniform4i
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64ARBPROC glad_glProgramUniform4i64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64ARBPROC glad_debug_glProgramUniform4i64ARB;
#define glProgramUniform4i64ARB glad_debug_glProgramUniform4i64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64NVPROC glad_glProgramUniform4i64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64NVPROC glad_debug_glProgramUniform4i64NV;
#define glProgramUniform4i64NV glad_debug_glProgramUniform4i64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VARBPROC glad_glProgramUniform4i64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VARBPROC glad_debug_glProgramUniform4i64vARB;
#define glProgramUniform4i64vARB glad_debug_glProgramUniform4i64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VNVPROC glad_glProgramUniform4i64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VNVPROC glad_debug_glProgramUniform4i64vNV;
#define glProgramUniform4i64vNV glad_debug_glProgramUniform4i64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IEXTPROC glad_glProgramUniform4iEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IEXTPROC glad_debug_glProgramUniform4iEXT;
#define glProgramUniform4iEXT glad_debug_glProgramUniform4iEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVPROC glad_debug_glProgramUniform4iv;
#define glProgramUniform4iv glad_debug_glProgramUniform4iv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVEXTPROC glad_glProgramUniform4ivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVEXTPROC glad_debug_glProgramUniform4ivEXT;
#define glProgramUniform4ivEXT glad_debug_glProgramUniform4ivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIPROC glad_debug_glProgramUniform4ui;
#define glProgramUniform4ui glad_debug_glProgramUniform4ui
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_glProgramUniform4ui64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_debug_glProgramUniform4ui64ARB;
#define glProgramUniform4ui64ARB glad_debug_glProgramUniform4ui64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64NVPROC glad_glProgramUniform4ui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64NVPROC glad_debug_glProgramUniform4ui64NV;
#define glProgramUniform4ui64NV glad_debug_glProgramUniform4ui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_glProgramUniform4ui64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_debug_glProgramUniform4ui64vARB;
#define glProgramUniform4ui64vARB glad_debug_glProgramUniform4ui64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_glProgramUniform4ui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_debug_glProgramUniform4ui64vNV;
#define glProgramUniform4ui64vNV glad_debug_glProgramUniform4ui64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIEXTPROC glad_glProgramUniform4uiEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIEXTPROC glad_debug_glProgramUniform4uiEXT;
#define glProgramUniform4uiEXT glad_debug_glProgramUniform4uiEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVPROC glad_debug_glProgramUniform4uiv;
#define glProgramUniform4uiv glad_debug_glProgramUniform4uiv
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_glProgramUniform4uivEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_debug_glProgramUniform4uivEXT;
#define glProgramUniform4uivEXT glad_debug_glProgramUniform4uivEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_glProgramUniformHandleui64ARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_debug_glProgramUniformHandleui64ARB;
#define glProgramUniformHandleui64ARB glad_debug_glProgramUniformHandleui64ARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_glProgramUniformHandleui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_debug_glProgramUniformHandleui64NV;
#define glProgramUniformHandleui64NV glad_debug_glProgramUniformHandleui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_glProgramUniformHandleui64vARB;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_debug_glProgramUniformHandleui64vARB;
#define glProgramUniformHandleui64vARB glad_debug_glProgramUniformHandleui64vARB
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_glProgramUniformHandleui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_debug_glProgramUniformHandleui64vNV;
#define glProgramUniformHandleui64vNV glad_debug_glProgramUniformHandleui64vNV
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_debug_glProgramUniformMatrix2dv;
#define glProgramUniformMatrix2dv glad_debug_glProgramUniformMatrix2dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_glProgramUniformMatrix2dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_debug_glProgramUniformMatrix2dvEXT;
#define glProgramUniformMatrix2dvEXT glad_debug_glProgramUniformMatrix2dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_debug_glProgramUniformMatrix2fv;
#define glProgramUniformMatrix2fv glad_debug_glProgramUniformMatrix2fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_glProgramUniformMatrix2fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_debug_glProgramUniformMatrix2fvEXT;
#define glProgramUniformMatrix2fvEXT glad_debug_glProgramUniformMatrix2fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_debug_glProgramUniformMatrix2x3dv;
#define glProgramUniformMatrix2x3dv glad_debug_glProgramUniformMatrix2x3dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_glProgramUniformMatrix2x3dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_debug_glProgramUniformMatrix2x3dvEXT;
#define glProgramUniformMatrix2x3dvEXT glad_debug_glProgramUniformMatrix2x3dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_debug_glProgramUniformMatrix2x3fv;
#define glProgramUniformMatrix2x3fv glad_debug_glProgramUniformMatrix2x3fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_glProgramUniformMatrix2x3fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_debug_glProgramUniformMatrix2x3fvEXT;
#define glProgramUniformMatrix2x3fvEXT glad_debug_glProgramUniformMatrix2x3fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_debug_glProgramUniformMatrix2x4dv;
#define glProgramUniformMatrix2x4dv glad_debug_glProgramUniformMatrix2x4dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_glProgramUniformMatrix2x4dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_debug_glProgramUniformMatrix2x4dvEXT;
#define glProgramUniformMatrix2x4dvEXT glad_debug_glProgramUniformMatrix2x4dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_debug_glProgramUniformMatrix2x4fv;
#define glProgramUniformMatrix2x4fv glad_debug_glProgramUniformMatrix2x4fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_glProgramUniformMatrix2x4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_debug_glProgramUniformMatrix2x4fvEXT;
#define glProgramUniformMatrix2x4fvEXT glad_debug_glProgramUniformMatrix2x4fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_debug_glProgramUniformMatrix3dv;
#define glProgramUniformMatrix3dv glad_debug_glProgramUniformMatrix3dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_glProgramUniformMatrix3dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_debug_glProgramUniformMatrix3dvEXT;
#define glProgramUniformMatrix3dvEXT glad_debug_glProgramUniformMatrix3dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_debug_glProgramUniformMatrix3fv;
#define glProgramUniformMatrix3fv glad_debug_glProgramUniformMatrix3fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_glProgramUniformMatrix3fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_debug_glProgramUniformMatrix3fvEXT;
#define glProgramUniformMatrix3fvEXT glad_debug_glProgramUniformMatrix3fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_debug_glProgramUniformMatrix3x2dv;
#define glProgramUniformMatrix3x2dv glad_debug_glProgramUniformMatrix3x2dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_glProgramUniformMatrix3x2dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_debug_glProgramUniformMatrix3x2dvEXT;
#define glProgramUniformMatrix3x2dvEXT glad_debug_glProgramUniformMatrix3x2dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_debug_glProgramUniformMatrix3x2fv;
#define glProgramUniformMatrix3x2fv glad_debug_glProgramUniformMatrix3x2fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_glProgramUniformMatrix3x2fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_debug_glProgramUniformMatrix3x2fvEXT;
#define glProgramUniformMatrix3x2fvEXT glad_debug_glProgramUniformMatrix3x2fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_debug_glProgramUniformMatrix3x4dv;
#define glProgramUniformMatrix3x4dv glad_debug_glProgramUniformMatrix3x4dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_glProgramUniformMatrix3x4dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_debug_glProgramUniformMatrix3x4dvEXT;
#define glProgramUniformMatrix3x4dvEXT glad_debug_glProgramUniformMatrix3x4dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_debug_glProgramUniformMatrix3x4fv;
#define glProgramUniformMatrix3x4fv glad_debug_glProgramUniformMatrix3x4fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_glProgramUniformMatrix3x4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_debug_glProgramUniformMatrix3x4fvEXT;
#define glProgramUniformMatrix3x4fvEXT glad_debug_glProgramUniformMatrix3x4fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_debug_glProgramUniformMatrix4dv;
#define glProgramUniformMatrix4dv glad_debug_glProgramUniformMatrix4dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_glProgramUniformMatrix4dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_debug_glProgramUniformMatrix4dvEXT;
#define glProgramUniformMatrix4dvEXT glad_debug_glProgramUniformMatrix4dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_debug_glProgramUniformMatrix4fv;
#define glProgramUniformMatrix4fv glad_debug_glProgramUniformMatrix4fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_glProgramUniformMatrix4fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_debug_glProgramUniformMatrix4fvEXT;
#define glProgramUniformMatrix4fvEXT glad_debug_glProgramUniformMatrix4fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_debug_glProgramUniformMatrix4x2dv;
#define glProgramUniformMatrix4x2dv glad_debug_glProgramUniformMatrix4x2dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_glProgramUniformMatrix4x2dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_debug_glProgramUniformMatrix4x2dvEXT;
#define glProgramUniformMatrix4x2dvEXT glad_debug_glProgramUniformMatrix4x2dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_debug_glProgramUniformMatrix4x2fv;
#define glProgramUniformMatrix4x2fv glad_debug_glProgramUniformMatrix4x2fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_glProgramUniformMatrix4x2fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_debug_glProgramUniformMatrix4x2fvEXT;
#define glProgramUniformMatrix4x2fvEXT glad_debug_glProgramUniformMatrix4x2fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_debug_glProgramUniformMatrix4x3dv;
#define glProgramUniformMatrix4x3dv glad_debug_glProgramUniformMatrix4x3dv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_glProgramUniformMatrix4x3dvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_debug_glProgramUniformMatrix4x3dvEXT;
#define glProgramUniformMatrix4x3dvEXT glad_debug_glProgramUniformMatrix4x3dvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_debug_glProgramUniformMatrix4x3fv;
#define glProgramUniformMatrix4x3fv glad_debug_glProgramUniformMatrix4x3fv
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_glProgramUniformMatrix4x3fvEXT;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_debug_glProgramUniformMatrix4x3fvEXT;
#define glProgramUniformMatrix4x3fvEXT glad_debug_glProgramUniformMatrix4x3fvEXT
    GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64NVPROC glad_glProgramUniformui64NV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64NVPROC glad_debug_glProgramUniformui64NV;
#define glProgramUniformui64NV glad_debug_glProgramUniformui64NV
    GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64VNVPROC glad_glProgramUniformui64vNV;
    GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64VNVPROC glad_debug_glProgramUniformui64vNV;
#define glProgramUniformui64vNV glad_debug_glProgramUniformui64vNV
    GLAD_API_CALL PFNGLPROGRAMVERTEXLIMITNVPROC glad_glProgramVertexLimitNV;
    GLAD_API_CALL PFNGLPROGRAMVERTEXLIMITNVPROC glad_debug_glProgramVertexLimitNV;
#define glProgramVertexLimitNV glad_debug_glProgramVertexLimitNV
    GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
    GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_debug_glProvokingVertex;

/// <summary>
///   specifiy the vertex to be used as the source of data for flat shaded varyings
///   <para>
///     Flatshading a vertex shader varying output means to assign all vetices of the primitive the
///     same value for that output. The vertex from which these values is derived is known as the
///     provoking vertex and glProvokingVertex specifies which vertex is to be used as the source of
///     data for flat shaded varyings. provokeMode must be either GL_FIRST_VERTEX_CONVENTION or
///     GL_LAST_VERTEX_CONVENTION , and controls the selection of the vertex whose values are
///     assigned to flatshaded varying outputs. The interpretation of these values for the supported
///     primitive types is: i + 1, if i < n 1, if i = n If a vertex or geometry shader is active,
///     user-defined varying outputs may be flatshaded by using the flat qualifier when declaring
///     the output.
///   </para>
/// </summary>
/// <param name='provokeMode'>Specifies the vertex to be used as the source of data for flat shaded
/// varyings.</param>
#define glProvokingVertex glad_debug_glProvokingVertex
    GLAD_API_CALL PFNGLPROVOKINGVERTEXEXTPROC glad_glProvokingVertexEXT;
    GLAD_API_CALL PFNGLPROVOKINGVERTEXEXTPROC glad_debug_glProvokingVertexEXT;
#define glProvokingVertexEXT glad_debug_glProvokingVertexEXT
    GLAD_API_CALL PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_glPushClientAttribDefaultEXT;
    GLAD_API_CALL PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_debug_glPushClientAttribDefaultEXT;
#define glPushClientAttribDefaultEXT glad_debug_glPushClientAttribDefaultEXT
    GLAD_API_CALL PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;
    GLAD_API_CALL PFNGLPUSHDEBUGGROUPPROC glad_debug_glPushDebugGroup;

/// <summary>
///   push a named debug group into the command stream
///   <para>
///     glPushDebugGroup pushes a debug group described by the string message into the command
///     stream. The value of id specifies the ID of messages generated. The parameter length
///     contains the number of characters in message. If length is negative, it is implied that
///     message contains a null terminated string. The message has the specified source and id , the
///     type GL_DEBUG_TYPE_PUSH_GROUP , and severity GL_DEBUG_SEVERITY_NOTIFICATION. The GL will put
///     a new debug group on top of the debug group stack which inherits the control of the volume
///     of debug output of the debug group previously residing on the top of the debug group stack.
///     Because debug groups are strictly hierarchical, any additional control of the debug output
///     volume will only apply within the active debug group and the debug groups pushed on top of
///     the active debug group.
///   </para>
/// </summary>
/// <param name='source'>The source of the debug message.</param>
/// <param name='id'>The identifier of the message.</param>
/// <param name='length'>The length of the message to be sent to the debug output stream.</param>
/// <param name='message'>The a string containing the message to be sent to the debug output
/// stream.</param>
#define glPushDebugGroup glad_debug_glPushDebugGroup
    GLAD_API_CALL PFNGLPUSHGROUPMARKEREXTPROC glad_glPushGroupMarkerEXT;
    GLAD_API_CALL PFNGLPUSHGROUPMARKEREXTPROC glad_debug_glPushGroupMarkerEXT;
#define glPushGroupMarkerEXT glad_debug_glPushGroupMarkerEXT
    GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
    GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_debug_glQueryCounter;

/// <summary>
///   record the GL time into a query object after all previous commands have reached the GL server
///   but have not yet necessarily executed. <para>
///     glQueryCounter causes the GL to record the current time into the query object named id.
///     target must be GL_TIMESTAMP. The time is recorded after all previous commands on the GL
///     client and server state and the framebuffer have been fully realized. When the time is
///     recorded, the query result for that object is marked available. glQueryCounter timer queries
///     can be used within a glBeginQuery / glEndQuery block where the target is GL_TIME_ELAPSED and
///     it does not affect the result of that query object.
///   </para>
/// </summary>
/// <param name='id'>Specify the name of a query object into which to record the GL time.</param>
/// <param name='target'>Specify the counter to query.</param>
#define glQueryCounter glad_debug_glQueryCounter
    GLAD_API_CALL PFNGLQUERYMATRIXXOESPROC glad_glQueryMatrixxOES;
    GLAD_API_CALL PFNGLQUERYMATRIXXOESPROC glad_debug_glQueryMatrixxOES;
#define glQueryMatrixxOES glad_debug_glQueryMatrixxOES
    GLAD_API_CALL PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_glQueryObjectParameteruiAMD;
    GLAD_API_CALL PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_debug_glQueryObjectParameteruiAMD;
#define glQueryObjectParameteruiAMD glad_debug_glQueryObjectParameteruiAMD
    GLAD_API_CALL PFNGLQUERYRESOURCENVPROC glad_glQueryResourceNV;
    GLAD_API_CALL PFNGLQUERYRESOURCENVPROC glad_debug_glQueryResourceNV;
#define glQueryResourceNV glad_debug_glQueryResourceNV
    GLAD_API_CALL PFNGLQUERYRESOURCETAGNVPROC glad_glQueryResourceTagNV;
    GLAD_API_CALL PFNGLQUERYRESOURCETAGNVPROC glad_debug_glQueryResourceTagNV;
#define glQueryResourceTagNV glad_debug_glQueryResourceTagNV
    GLAD_API_CALL PFNGLRASTERPOS2XOESPROC glad_glRasterPos2xOES;
    GLAD_API_CALL PFNGLRASTERPOS2XOESPROC glad_debug_glRasterPos2xOES;
#define glRasterPos2xOES glad_debug_glRasterPos2xOES
    GLAD_API_CALL PFNGLRASTERPOS2XVOESPROC glad_glRasterPos2xvOES;
    GLAD_API_CALL PFNGLRASTERPOS2XVOESPROC glad_debug_glRasterPos2xvOES;
#define glRasterPos2xvOES glad_debug_glRasterPos2xvOES
    GLAD_API_CALL PFNGLRASTERPOS3XOESPROC glad_glRasterPos3xOES;
    GLAD_API_CALL PFNGLRASTERPOS3XOESPROC glad_debug_glRasterPos3xOES;
#define glRasterPos3xOES glad_debug_glRasterPos3xOES
    GLAD_API_CALL PFNGLRASTERPOS3XVOESPROC glad_glRasterPos3xvOES;
    GLAD_API_CALL PFNGLRASTERPOS3XVOESPROC glad_debug_glRasterPos3xvOES;
#define glRasterPos3xvOES glad_debug_glRasterPos3xvOES
    GLAD_API_CALL PFNGLRASTERPOS4XOESPROC glad_glRasterPos4xOES;
    GLAD_API_CALL PFNGLRASTERPOS4XOESPROC glad_debug_glRasterPos4xOES;
#define glRasterPos4xOES glad_debug_glRasterPos4xOES
    GLAD_API_CALL PFNGLRASTERPOS4XVOESPROC glad_glRasterPos4xvOES;
    GLAD_API_CALL PFNGLRASTERPOS4XVOESPROC glad_debug_glRasterPos4xvOES;
#define glRasterPos4xvOES glad_debug_glRasterPos4xvOES
    GLAD_API_CALL PFNGLRASTERSAMPLESEXTPROC glad_glRasterSamplesEXT;
    GLAD_API_CALL PFNGLRASTERSAMPLESEXTPROC glad_debug_glRasterSamplesEXT;
#define glRasterSamplesEXT glad_debug_glRasterSamplesEXT
    GLAD_API_CALL PFNGLREADBUFFERPROC glad_glReadBuffer;
    GLAD_API_CALL PFNGLREADBUFFERPROC glad_debug_glReadBuffer;

/// <summary>
///   select a color buffer source for pixels
///   <para>
///     glReadBuffer specifies a color buffer as the source for subsequent glReadPixels ,
///     glCopyTexImage1D , glCopyTexImage2D , glCopyTexSubImage1D , glCopyTexSubImage2D , and
///     glCopyTexSubImage3D commands. mode accepts one of twelve or more predefined values. In a
///     fully configured system, GL_FRONT , GL_LEFT , and GL_FRONT_LEFT all name the front left
///     buffer, GL_FRONT_RIGHT and GL_RIGHT name the front right buffer, and GL_BACK_LEFT and
///     GL_BACK name the back left buffer. Further more, the constants GL_COLOR_ATTACHMENT i may be
///     used to indicate the i th color attachment where i ranges from zero to the value of
///     GL_MAX_COLOR_ATTACHMENTS minus one. Nonstereo double-buffered configurations have only a
///     front left and a back left buffer. Single-buffered configurations have a front left and a
///     front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to
///     specify a nonexistent buffer to glReadBuffer. mode is initially GL_FRONT in single-buffered
///     configurations and GL_BACK in double-buffered configurations. For glReadBuffer , the target
///     framebuffer object is that bound to GL_READ_FRAMEBUFFER. For glNamedFramebufferReadBuffer ,
///     framebuffer must either be zero or the name of the target framebuffer object. If framebuffer
///     is zero, then the default read framebuffer is affected.
///   </para>
/// </summary>
/// <param name='framebuffer'>Specifies the name of the framebuffer object for</param>
/// <param name='mode'>Specifies a color buffer. Accepted values are</param>
#define glReadBuffer glad_debug_glReadBuffer
    GLAD_API_CALL PFNGLREADINSTRUMENTSSGIXPROC glad_glReadInstrumentsSGIX;
    GLAD_API_CALL PFNGLREADINSTRUMENTSSGIXPROC glad_debug_glReadInstrumentsSGIX;
#define glReadInstrumentsSGIX glad_debug_glReadInstrumentsSGIX
    GLAD_API_CALL PFNGLREADPIXELSPROC glad_glReadPixels;
    GLAD_API_CALL PFNGLREADPIXELSPROC glad_debug_glReadPixels;

/// <summary>
///   read a block of pixels from the frame buffer
///   <para>
///     glReadPixels and glReadnPixels return pixel data from the frame buffer, starting with the
///     pixel whose lower left corner is at location ( x , y ), into client memory starting at
///     location data. Several parameters control the processing of the pixel data before it is
///     placed into client memory. These parameters are set with glPixelStore. This reference page
///     describes the effects on glReadPixels and glReadnPixels of most, but not all of the
///     parameters specified by these three commands. If a non-zero named buffer object is bound to
///     the GL_PIXEL_PACK_BUFFER target (see glBindBuffer ) while a block of pixels is requested,
///     data is treated as a byte offset into the buffer object's data store rather than a pointer
///     to client memory. glReadPixels and glReadnPixels return values from each pixel with lower
///     left corner at x + i y + j for 0 <= i < width and 0 <= j < height. This pixel is said to be
///     the i th pixel in the j th row. Pixels are returned in row order from the lowest to the
///     highest row, left to right in each row. format specifies the format for the returned pixel
///     values; accepted values are: Stencil values are read from the stencil buffer. Depth values
///     are read from the depth buffer. Each component is converted to floating point such that the
///     minimum depth value maps to 0 and the maximum value maps to 1. Each component is clamped to
///     the range 0 1. Values are taken from both the depth and stencil buffers. The type parameter
///     must be GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV. Color values are taken
///     from the color buffer. Finally, the indices or components are converted to the proper
///     format, as specified by type. If format is GL_STENCIL_INDEX and type is not GL_FLOAT , each
///     index is masked with the mask value given in the following table. If type is GL_FLOAT , then
///     each integer index is converted to single-precision floating-point format. If format is
///     GL_RED , GL_GREEN , GL_BLUE , GL_RGB , GL_BGR , GL_RGBA , or GL_BGRA and type is not
///     GL_FLOAT , each component is multiplied by the multiplier shown in the following table. If
///     type is GL_FLOAT , then each component is passed as is (or converted to the client's
///     single-precision floating-point format if it is different from the one used by the GL).
///     Return values are placed in memory as follows. If format is GL_STENCIL_INDEX ,
///     GL_DEPTH_COMPONENT , GL_RED , GL_GREEN , or GL_BLUE , a single value is returned and the
///     data for the i th pixel in the j th row is placed in location j ⁢ width + i. GL_RGB and
///     GL_BGR return three values, GL_RGBA and GL_BGRA return four values for each pixel, with all
///     values corresponding to a single pixel occupying contiguous space in data. Storage
///     parameters set by glPixelStore , such as GL_PACK_LSB_FIRST and GL_PACK_SWAP_BYTES , affect
///     the way that data is written into memory. See glPixelStore for a description. glReadnPixels
///     function will only handle the call if bufSize is at least of the size required to store the
///     requested data. Otherwise, it will generate a GL_INVALID_OPERATION error.
///   </para>
/// </summary>
/// <param name='x'>Specify the window coordinates of the first pixel that is read from the frame
/// buffer. This location is the lower left corner of a rectangular block of pixels.</param> <param
/// name='y'>Specify the dimensions of the pixel rectangle.</param> <param name='width'>Specifies
/// the format of the pixel data. The following symbolic values are accepted:</param> <param
/// name='height'>Specifies the data type of the pixel data. Must be one of</param> <param
/// name='format'>Specifies the size of the buffer</param> <param name='type'>Returns the pixel
/// data.</param>
#define glReadPixels glad_debug_glReadPixels
    GLAD_API_CALL PFNGLREADNPIXELSPROC glad_glReadnPixels;
    GLAD_API_CALL PFNGLREADNPIXELSPROC glad_debug_glReadnPixels;
#define glReadnPixels glad_debug_glReadnPixels
    GLAD_API_CALL PFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB;
    GLAD_API_CALL PFNGLREADNPIXELSARBPROC glad_debug_glReadnPixelsARB;
#define glReadnPixelsARB glad_debug_glReadnPixelsARB
    GLAD_API_CALL PFNGLRECTXOESPROC glad_glRectxOES;
    GLAD_API_CALL PFNGLRECTXOESPROC glad_debug_glRectxOES;
#define glRectxOES glad_debug_glRectxOES
    GLAD_API_CALL PFNGLRECTXVOESPROC glad_glRectxvOES;
    GLAD_API_CALL PFNGLRECTXVOESPROC glad_debug_glRectxvOES;
#define glRectxvOES glad_debug_glRectxvOES
    GLAD_API_CALL PFNGLREFERENCEPLANESGIXPROC glad_glReferencePlaneSGIX;
    GLAD_API_CALL PFNGLREFERENCEPLANESGIXPROC glad_debug_glReferencePlaneSGIX;
#define glReferencePlaneSGIX glad_debug_glReferencePlaneSGIX
    GLAD_API_CALL PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_glReleaseKeyedMutexWin32EXT;
    GLAD_API_CALL PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_debug_glReleaseKeyedMutexWin32EXT;
#define glReleaseKeyedMutexWin32EXT glad_debug_glReleaseKeyedMutexWin32EXT
    GLAD_API_CALL PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;
    GLAD_API_CALL PFNGLRELEASESHADERCOMPILERPROC glad_debug_glReleaseShaderCompiler;

/// <summary>
///   release resources consumed by the implementation's shader compiler
///   <para>
///     glReleaseShaderCompiler provides a hint to the implementation that it may free internal
///     resources associated with its shader compiler. glCompileShader may subsequently be called
///     and the implementation may at that time reallocate resources previously freed by the call to
///     glReleaseShaderCompiler.
///   </para>
/// </summary>
#define glReleaseShaderCompiler glad_debug_glReleaseShaderCompiler
    GLAD_API_CALL PFNGLRENDERGPUMASKNVPROC glad_glRenderGpuMaskNV;
    GLAD_API_CALL PFNGLRENDERGPUMASKNVPROC glad_debug_glRenderGpuMaskNV;
#define glRenderGpuMaskNV glad_debug_glRenderGpuMaskNV
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_debug_glRenderbufferStorage;

/// <summary>
///   establish data storage, format and dimensions of a renderbuffer object's image
///   <para>
///     glRenderbufferStorage is equivalent to calling glRenderbufferStorageMultisample with the
///     samples set to zero, and glNamedRenderbufferStorage is equivalent to calling
///     glNamedRenderbufferStorageMultisample with the samples set to zero. For
///     glRenderbufferStorage , the target of the operation, specified by target must be
///     GL_RENDERBUFFER. For glNamedRenderbufferStorage , renderbuffer must be a name of an existing
///     renderbuffer object. internalformat specifies the internal format to be used for the
///     renderbuffer object's storage and must be a color-renderable, depth-renderable, or
///     stencil-renderable format. width and height are the dimensions, in pixels, of the
///     renderbuffer. Both width and height must be less than or equal to the value of
///     GL_MAX_RENDERBUFFER_SIZE. Upon success, glRenderbufferStorage and glNamedRenderbufferStorage
///     delete any existing data store for the renderbuffer image and the contents of the data store
///     after calling glRenderbufferStorage are undefined.
///   </para>
/// </summary>
/// <param name='target'>Specifies a binding target of the allocation for</param>
/// <param name='renderbuffer'>Specifies the name of the renderbuffer object for</param>
/// <param name='internalformat'>Specifies the internal format to use for the renderbuffer object's
/// image.</param> <param name='width'>Specifies the width of the renderbuffer, in pixels.</param>
/// <param name='height'>Specifies the height of the renderbuffer, in pixels.</param>
#define glRenderbufferStorage glad_debug_glRenderbufferStorage
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEEXTPROC glad_glRenderbufferStorageEXT;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEEXTPROC glad_debug_glRenderbufferStorageEXT;
#define glRenderbufferStorageEXT glad_debug_glRenderbufferStorageEXT
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC
        glad_debug_glRenderbufferStorageMultisample;

/// <summary>
///   establish data storage, format, dimensions and sample count of a renderbuffer object's image
///   <para>
///     glRenderbufferStorageMultisample and glNamedRenderbufferStorageMultisample establish the
///     data storage, format, dimensions and number of samples of a renderbuffer object's image. For
///     glRenderbufferStorageMultisample , the target of the operation, specified by target must be
///     GL_RENDERBUFFER. For glNamedRenderbufferStorageMultisample , renderbuffer must be an ID of
///     an existing renderbuffer object. internalformat specifies the internal format to be used for
///     the renderbuffer object's storage and must be a color-renderable, depth-renderable, or
///     stencil-renderable format. width and height are the dimensions, in pixels, of the
///     renderbuffer. Both width and height must be less than or equal to the value of
///     GL_MAX_RENDERBUFFER_SIZE. samples specifies the number of samples to be used for the
///     renderbuffer object's image, and must be less than or equal to the value of GL_MAX_SAMPLES.
///     If internalformat is a signed or unsigned integer format then samples must be less than or
///     equal to the value of GL_MAX_INTEGER_SAMPLES. Upon success, glRenderbufferStorageMultisample
///     and glNamedRenderbufferStorageMultisample delete any existing data store for the
///     renderbuffer image and the contents of the data store after calling either of the functions
///     are undefined.
///   </para>
/// </summary>
/// <param name='target'>Specifies a binding target of the allocation for</param>
/// <param name='renderbuffer'>Specifies the name of the renderbuffer object for</param>
/// <param name='samples'>Specifies the number of samples to be used for the renderbuffer object's
/// storage.</param> <param name='internalformat'>Specifies the internal format to use for the
/// renderbuffer object's image.</param> <param name='width'>Specifies the width of the
/// renderbuffer, in pixels.</param> <param name='height'>Specifies the height of the renderbuffer,
/// in pixels.</param>
#define glRenderbufferStorageMultisample glad_debug_glRenderbufferStorageMultisample
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC
        glad_glRenderbufferStorageMultisampleAdvancedAMD;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC
        glad_debug_glRenderbufferStorageMultisampleAdvancedAMD;
#define glRenderbufferStorageMultisampleAdvancedAMD \
    glad_debug_glRenderbufferStorageMultisampleAdvancedAMD
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC
        glad_glRenderbufferStorageMultisampleCoverageNV;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC
        glad_debug_glRenderbufferStorageMultisampleCoverageNV;
#define glRenderbufferStorageMultisampleCoverageNV \
    glad_debug_glRenderbufferStorageMultisampleCoverageNV
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC
        glad_glRenderbufferStorageMultisampleEXT;
    GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC
        glad_debug_glRenderbufferStorageMultisampleEXT;
#define glRenderbufferStorageMultisampleEXT glad_debug_glRenderbufferStorageMultisampleEXT
    GLAD_API_CALL PFNGLREPLACEMENTCODEPOINTERSUNPROC glad_glReplacementCodePointerSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEPOINTERSUNPROC glad_debug_glReplacementCodePointerSUN;
#define glReplacementCodePointerSUN glad_debug_glReplacementCodePointerSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUBSUNPROC glad_glReplacementCodeubSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUBSUNPROC glad_debug_glReplacementCodeubSUN;
#define glReplacementCodeubSUN glad_debug_glReplacementCodeubSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUBVSUNPROC glad_glReplacementCodeubvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUBVSUNPROC glad_debug_glReplacementCodeubvSUN;
#define glReplacementCodeubvSUN glad_debug_glReplacementCodeubvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC
        glad_glReplacementCodeuiColor3fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiColor3fVertex3fSUN;
#define glReplacementCodeuiColor3fVertex3fSUN glad_debug_glReplacementCodeuiColor3fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiColor3fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiColor3fVertex3fvSUN;
#define glReplacementCodeuiColor3fVertex3fvSUN glad_debug_glReplacementCodeuiColor3fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN \
    glad_debug_glReplacementCodeuiColor4fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN \
    glad_debug_glReplacementCodeuiColor4fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC
        glad_glReplacementCodeuiColor4ubVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiColor4ubVertex3fSUN;
#define glReplacementCodeuiColor4ubVertex3fSUN glad_debug_glReplacementCodeuiColor4ubVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC
        glad_glReplacementCodeuiColor4ubVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiColor4ubVertex3fvSUN;
#define glReplacementCodeuiColor4ubVertex3fvSUN glad_debug_glReplacementCodeuiColor4ubVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC
        glad_glReplacementCodeuiNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiNormal3fVertex3fSUN;
#define glReplacementCodeuiNormal3fVertex3fSUN glad_debug_glReplacementCodeuiNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiNormal3fVertex3fvSUN;
#define glReplacementCodeuiNormal3fVertex3fvSUN glad_debug_glReplacementCodeuiNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUISUNPROC glad_glReplacementCodeuiSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUISUNPROC glad_debug_glReplacementCodeuiSUN;
#define glReplacementCodeuiSUN glad_debug_glReplacementCodeuiSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN \
    glad_debug_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN \
    glad_debug_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC
        glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN \
    glad_debug_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN \
    glad_debug_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC
        glad_glReplacementCodeuiTexCoord2fVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fVertex3fSUN;
#define glReplacementCodeuiTexCoord2fVertex3fSUN glad_debug_glReplacementCodeuiTexCoord2fVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC
        glad_glReplacementCodeuiTexCoord2fVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC
        glad_debug_glReplacementCodeuiTexCoord2fVertex3fvSUN;
#define glReplacementCodeuiTexCoord2fVertex3fvSUN \
    glad_debug_glReplacementCodeuiTexCoord2fVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC glad_glReplacementCodeuiVertex3fSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC glad_debug_glReplacementCodeuiVertex3fSUN;
#define glReplacementCodeuiVertex3fSUN glad_debug_glReplacementCodeuiVertex3fSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC glad_glReplacementCodeuiVertex3fvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC glad_debug_glReplacementCodeuiVertex3fvSUN;
#define glReplacementCodeuiVertex3fvSUN glad_debug_glReplacementCodeuiVertex3fvSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVSUNPROC glad_glReplacementCodeuivSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUIVSUNPROC glad_debug_glReplacementCodeuivSUN;
#define glReplacementCodeuivSUN glad_debug_glReplacementCodeuivSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUSSUNPROC glad_glReplacementCodeusSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUSSUNPROC glad_debug_glReplacementCodeusSUN;
#define glReplacementCodeusSUN glad_debug_glReplacementCodeusSUN
    GLAD_API_CALL PFNGLREPLACEMENTCODEUSVSUNPROC glad_glReplacementCodeusvSUN;
    GLAD_API_CALL PFNGLREPLACEMENTCODEUSVSUNPROC glad_debug_glReplacementCodeusvSUN;
#define glReplacementCodeusvSUN glad_debug_glReplacementCodeusvSUN
    GLAD_API_CALL PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_glRequestResidentProgramsNV;
    GLAD_API_CALL PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_debug_glRequestResidentProgramsNV;
#define glRequestResidentProgramsNV glad_debug_glRequestResidentProgramsNV
    GLAD_API_CALL PFNGLRESETHISTOGRAMEXTPROC glad_glResetHistogramEXT;
    GLAD_API_CALL PFNGLRESETHISTOGRAMEXTPROC glad_debug_glResetHistogramEXT;
#define glResetHistogramEXT glad_debug_glResetHistogramEXT
    GLAD_API_CALL PFNGLRESETMEMORYOBJECTPARAMETERNVPROC glad_glResetMemoryObjectParameterNV;
    GLAD_API_CALL PFNGLRESETMEMORYOBJECTPARAMETERNVPROC glad_debug_glResetMemoryObjectParameterNV;
#define glResetMemoryObjectParameterNV glad_debug_glResetMemoryObjectParameterNV
    GLAD_API_CALL PFNGLRESETMINMAXEXTPROC glad_glResetMinmaxEXT;
    GLAD_API_CALL PFNGLRESETMINMAXEXTPROC glad_debug_glResetMinmaxEXT;
#define glResetMinmaxEXT glad_debug_glResetMinmaxEXT
    GLAD_API_CALL PFNGLRESIZEBUFFERSMESAPROC glad_glResizeBuffersMESA;
    GLAD_API_CALL PFNGLRESIZEBUFFERSMESAPROC glad_debug_glResizeBuffersMESA;
#define glResizeBuffersMESA glad_debug_glResizeBuffersMESA
    GLAD_API_CALL PFNGLRESOLVEDEPTHVALUESNVPROC glad_glResolveDepthValuesNV;
    GLAD_API_CALL PFNGLRESOLVEDEPTHVALUESNVPROC glad_debug_glResolveDepthValuesNV;
#define glResolveDepthValuesNV glad_debug_glResolveDepthValuesNV
    GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
    GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_debug_glResumeTransformFeedback;

/// <summary>
///   resume transform feedback operations
///   <para>
///     glResumeTransformFeedback resumes transform feedback operations on the currently active
///     transform feedback object. When transform feedback operations are paused, transform feedback
///     is still considered active and changing most transform feedback state related to the object
///     results in an error. However, a new transform feedback object may be bound while transform
///     feedback is paused.
///   </para>
/// </summary>
#define glResumeTransformFeedback glad_debug_glResumeTransformFeedback
    GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_glResumeTransformFeedbackNV;
    GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_debug_glResumeTransformFeedbackNV;
#define glResumeTransformFeedbackNV glad_debug_glResumeTransformFeedbackNV
    GLAD_API_CALL PFNGLROTATEXOESPROC glad_glRotatexOES;
    GLAD_API_CALL PFNGLROTATEXOESPROC glad_debug_glRotatexOES;
#define glRotatexOES glad_debug_glRotatexOES
    GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
    GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_debug_glSampleCoverage;

/// <summary>
///   specify multisample coverage parameters
///   <para>
///     Multisampling samples a pixel multiple times at various implementation-dependent subpixel
///     locations to generate antialiasing effects. Multisampling transparently antialiases points,
///     lines, polygons, and images if it is enabled. value is used in constructing a temporary mask
///     used in determining which samples will be used in resolving the final fragment color. This
///     mask is bitwise-anded with the coverage mask generated from the multisampling computation.
///     If the invert flag is set, the temporary mask is inverted (all bits flipped) and then the
///     bitwise-and is computed. If an implementation does not have any multisample buffers
///     available, or multisampling is disabled, rasterization occurs with only a single sample
///     computing a pixel's final RGB color. Provided an implementation supports multisample
///     buffers, and multisampling is enabled, then a pixel's final color is generated by combining
///     several samples per pixel. Each sample contains color, depth, and stencil information,
///     allowing those operations to be performed on each sample.
///   </para>
/// </summary>
/// <param name='value'>Specify a single floating-point sample coverage value. The value is clamped
/// to the range</param> <param name='invert'>Specify a single boolean value representing if the
/// coverage masks should be inverted.</param>
#define glSampleCoverage glad_debug_glSampleCoverage
    GLAD_API_CALL PFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB;
    GLAD_API_CALL PFNGLSAMPLECOVERAGEARBPROC glad_debug_glSampleCoverageARB;
#define glSampleCoverageARB glad_debug_glSampleCoverageARB
    GLAD_API_CALL PFNGLSAMPLEMAPATIPROC glad_glSampleMapATI;
    GLAD_API_CALL PFNGLSAMPLEMAPATIPROC glad_debug_glSampleMapATI;
#define glSampleMapATI glad_debug_glSampleMapATI
    GLAD_API_CALL PFNGLSAMPLEMASKEXTPROC glad_glSampleMaskEXT;
    GLAD_API_CALL PFNGLSAMPLEMASKEXTPROC glad_debug_glSampleMaskEXT;
#define glSampleMaskEXT glad_debug_glSampleMaskEXT
    GLAD_API_CALL PFNGLSAMPLEMASKINDEXEDNVPROC glad_glSampleMaskIndexedNV;
    GLAD_API_CALL PFNGLSAMPLEMASKINDEXEDNVPROC glad_debug_glSampleMaskIndexedNV;
#define glSampleMaskIndexedNV glad_debug_glSampleMaskIndexedNV
    GLAD_API_CALL PFNGLSAMPLEMASKSGISPROC glad_glSampleMaskSGIS;
    GLAD_API_CALL PFNGLSAMPLEMASKSGISPROC glad_debug_glSampleMaskSGIS;
#define glSampleMaskSGIS glad_debug_glSampleMaskSGIS
    GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
    GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_debug_glSampleMaski;

/// <summary>
///   set the value of a sub-word of the sample mask
///   <para>
///     glSampleMaski sets one 32-bit sub-word of the multi-word sample mask, GL_SAMPLE_MASK_VALUE.
///     maskIndex specifies which 32-bit sub-word of the sample mask to update, and mask specifies
///     the new value to use for that sub-word. maskIndex must be less than the value of
///     GL_MAX_SAMPLE_MASK_WORDS. Bit B of mask word M corresponds to sample 32 x M + B.
///   </para>
/// </summary>
/// <param name='maskNumber'>Specifies which 32-bit sub-word of the sample mask to update.</param>
/// <param name='mask'>Specifies the new value of the mask sub-word.</param>
#define glSampleMaski glad_debug_glSampleMaski
    GLAD_API_CALL PFNGLSAMPLEPATTERNEXTPROC glad_glSamplePatternEXT;
    GLAD_API_CALL PFNGLSAMPLEPATTERNEXTPROC glad_debug_glSamplePatternEXT;
#define glSamplePatternEXT glad_debug_glSamplePatternEXT
    GLAD_API_CALL PFNGLSAMPLEPATTERNSGISPROC glad_glSamplePatternSGIS;
    GLAD_API_CALL PFNGLSAMPLEPATTERNSGISPROC glad_debug_glSamplePatternSGIS;
#define glSamplePatternSGIS glad_debug_glSamplePatternSGIS
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_debug_glSamplerParameterIiv;
#define glSamplerParameterIiv glad_debug_glSamplerParameterIiv
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_debug_glSamplerParameterIuiv;
#define glSamplerParameterIuiv glad_debug_glSamplerParameterIuiv
    GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_debug_glSamplerParameterf;
#define glSamplerParameterf glad_debug_glSamplerParameterf
    GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_debug_glSamplerParameterfv;
#define glSamplerParameterfv glad_debug_glSamplerParameterfv
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_debug_glSamplerParameteri;
#define glSamplerParameteri glad_debug_glSamplerParameteri
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
    GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_debug_glSamplerParameteriv;
#define glSamplerParameteriv glad_debug_glSamplerParameteriv
    GLAD_API_CALL PFNGLSCALEXOESPROC glad_glScalexOES;
    GLAD_API_CALL PFNGLSCALEXOESPROC glad_debug_glScalexOES;
#define glScalexOES glad_debug_glScalexOES
    GLAD_API_CALL PFNGLSCISSORPROC glad_glScissor;
    GLAD_API_CALL PFNGLSCISSORPROC glad_debug_glScissor;

/// <summary>
///   define the scissor box
///   <para>
///     glScissor defines a rectangle, called the scissor box, in window coordinates. The first two
///     arguments, x and y , specify the lower left corner of the box. width and height specify the
///     width and height of the box. To enable and disable the scissor test, call glEnable and
///     glDisable with argument GL_SCISSOR_TEST. The test is initially disabled. While the test is
///     enabled, only pixels that lie within the scissor box can be modified by drawing commands.
///     Window coordinates have integer values at the shared corners of frame buffer pixels.
///     glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and
///     glScissor(0,0,0,0) doesn't allow modification of any pixels in the window. When the scissor
///     test is disabled, it is as though the scissor box includes the entire window.
///   </para>
/// </summary>
/// <param name='x'>Specify the lower left corner of the scissor box. Initially (0, 0).</param>
/// <param name='y'>Specify the width and height of the scissor box. When a GL context is first
/// attached to a window,</param>
#define glScissor glad_debug_glScissor
    GLAD_API_CALL PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;
    GLAD_API_CALL PFNGLSCISSORARRAYVPROC glad_debug_glScissorArrayv;
#define glScissorArrayv glad_debug_glScissorArrayv
    GLAD_API_CALL PFNGLSCISSOREXCLUSIVEARRAYVNVPROC glad_glScissorExclusiveArrayvNV;
    GLAD_API_CALL PFNGLSCISSOREXCLUSIVEARRAYVNVPROC glad_debug_glScissorExclusiveArrayvNV;
#define glScissorExclusiveArrayvNV glad_debug_glScissorExclusiveArrayvNV
    GLAD_API_CALL PFNGLSCISSOREXCLUSIVENVPROC glad_glScissorExclusiveNV;
    GLAD_API_CALL PFNGLSCISSOREXCLUSIVENVPROC glad_debug_glScissorExclusiveNV;
#define glScissorExclusiveNV glad_debug_glScissorExclusiveNV
    GLAD_API_CALL PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;
    GLAD_API_CALL PFNGLSCISSORINDEXEDPROC glad_debug_glScissorIndexed;

/// <summary>
///   define the scissor box for a specific viewport
///   <para>
///     glScissorIndexed defines the scissor box for a specified viewport. index specifies the index
///     of scissor box to modify. index must be less than the value of GL_MAX_VIEWPORTS. For
///     glScissorIndexed , left , bottom , width and height specify the left, bottom, width and
///     height of the scissor box, in pixels, respectively. For glScissorIndexedv , v specifies the
///     address of an array containing integers specifying the lower left corner of the scissor box,
///     and the width and height of the scissor box, in that order. To enable and disable the
///     scissor test, call glEnable and glDisable with argument GL_SCISSOR_TEST. The test is
///     initially disabled for all viewports. While the test is enabled, only pixels that lie within
///     the scissor box can be modified by drawing commands. Window coordinates have integer values
///     at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only
///     the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any
///     pixels in the window. When the scissor test is disabled, it is as though the scissor box
///     includes the entire window.
///   </para>
/// </summary>
/// <param name='index'>Specifies the index of the viewport whose scissor box to modify.</param>
/// <param name='left'>Specify the coordinate of the bottom left corner of the scissor box, in
/// pixels.</param> <param name='bottom'>Specify ths dimensions of the scissor box, in
/// pixels.</param> <param name='width'>For</param>
#define glScissorIndexed glad_debug_glScissorIndexed
    GLAD_API_CALL PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;
    GLAD_API_CALL PFNGLSCISSORINDEXEDVPROC glad_debug_glScissorIndexedv;
#define glScissorIndexedv glad_debug_glScissorIndexedv
    GLAD_API_CALL PFNGLSECONDARYCOLOR3BEXTPROC glad_glSecondaryColor3bEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3BEXTPROC glad_debug_glSecondaryColor3bEXT;
#define glSecondaryColor3bEXT glad_debug_glSecondaryColor3bEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3BVEXTPROC glad_glSecondaryColor3bvEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3BVEXTPROC glad_debug_glSecondaryColor3bvEXT;
#define glSecondaryColor3bvEXT glad_debug_glSecondaryColor3bvEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3DEXTPROC glad_glSecondaryColor3dEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3DEXTPROC glad_debug_glSecondaryColor3dEXT;
#define glSecondaryColor3dEXT glad_debug_glSecondaryColor3dEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3DVEXTPROC glad_glSecondaryColor3dvEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3DVEXTPROC glad_debug_glSecondaryColor3dvEXT;
#define glSecondaryColor3dvEXT glad_debug_glSecondaryColor3dvEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3FEXTPROC glad_glSecondaryColor3fEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3FEXTPROC glad_debug_glSecondaryColor3fEXT;
#define glSecondaryColor3fEXT glad_debug_glSecondaryColor3fEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3FVEXTPROC glad_glSecondaryColor3fvEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3FVEXTPROC glad_debug_glSecondaryColor3fvEXT;
#define glSecondaryColor3fvEXT glad_debug_glSecondaryColor3fvEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3HNVPROC glad_glSecondaryColor3hNV;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3HNVPROC glad_debug_glSecondaryColor3hNV;
#define glSecondaryColor3hNV glad_debug_glSecondaryColor3hNV
    GLAD_API_CALL PFNGLSECONDARYCOLOR3HVNVPROC glad_glSecondaryColor3hvNV;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3HVNVPROC glad_debug_glSecondaryColor3hvNV;
#define glSecondaryColor3hvNV glad_debug_glSecondaryColor3hvNV
    GLAD_API_CALL PFNGLSECONDARYCOLOR3IEXTPROC glad_glSecondaryColor3iEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3IEXTPROC glad_debug_glSecondaryColor3iEXT;
#define glSecondaryColor3iEXT glad_debug_glSecondaryColor3iEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3IVEXTPROC glad_glSecondaryColor3ivEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3IVEXTPROC glad_debug_glSecondaryColor3ivEXT;
#define glSecondaryColor3ivEXT glad_debug_glSecondaryColor3ivEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3SEXTPROC glad_glSecondaryColor3sEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3SEXTPROC glad_debug_glSecondaryColor3sEXT;
#define glSecondaryColor3sEXT glad_debug_glSecondaryColor3sEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3SVEXTPROC glad_glSecondaryColor3svEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3SVEXTPROC glad_debug_glSecondaryColor3svEXT;
#define glSecondaryColor3svEXT glad_debug_glSecondaryColor3svEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UBEXTPROC glad_glSecondaryColor3ubEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UBEXTPROC glad_debug_glSecondaryColor3ubEXT;
#define glSecondaryColor3ubEXT glad_debug_glSecondaryColor3ubEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UBVEXTPROC glad_glSecondaryColor3ubvEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UBVEXTPROC glad_debug_glSecondaryColor3ubvEXT;
#define glSecondaryColor3ubvEXT glad_debug_glSecondaryColor3ubvEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UIEXTPROC glad_glSecondaryColor3uiEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UIEXTPROC glad_debug_glSecondaryColor3uiEXT;
#define glSecondaryColor3uiEXT glad_debug_glSecondaryColor3uiEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UIVEXTPROC glad_glSecondaryColor3uivEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3UIVEXTPROC glad_debug_glSecondaryColor3uivEXT;
#define glSecondaryColor3uivEXT glad_debug_glSecondaryColor3uivEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3USEXTPROC glad_glSecondaryColor3usEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3USEXTPROC glad_debug_glSecondaryColor3usEXT;
#define glSecondaryColor3usEXT glad_debug_glSecondaryColor3usEXT
    GLAD_API_CALL PFNGLSECONDARYCOLOR3USVEXTPROC glad_glSecondaryColor3usvEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLOR3USVEXTPROC glad_debug_glSecondaryColor3usvEXT;
#define glSecondaryColor3usvEXT glad_debug_glSecondaryColor3usvEXT
    GLAD_API_CALL PFNGLSECONDARYCOLORFORMATNVPROC glad_glSecondaryColorFormatNV;
    GLAD_API_CALL PFNGLSECONDARYCOLORFORMATNVPROC glad_debug_glSecondaryColorFormatNV;
#define glSecondaryColorFormatNV glad_debug_glSecondaryColorFormatNV
    GLAD_API_CALL PFNGLSECONDARYCOLORPOINTEREXTPROC glad_glSecondaryColorPointerEXT;
    GLAD_API_CALL PFNGLSECONDARYCOLORPOINTEREXTPROC glad_debug_glSecondaryColorPointerEXT;
#define glSecondaryColorPointerEXT glad_debug_glSecondaryColorPointerEXT
    GLAD_API_CALL PFNGLSECONDARYCOLORPOINTERLISTIBMPROC glad_glSecondaryColorPointerListIBM;
    GLAD_API_CALL PFNGLSECONDARYCOLORPOINTERLISTIBMPROC glad_debug_glSecondaryColorPointerListIBM;
#define glSecondaryColorPointerListIBM glad_debug_glSecondaryColorPointerListIBM
    GLAD_API_CALL PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_glSelectPerfMonitorCountersAMD;
    GLAD_API_CALL PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_debug_glSelectPerfMonitorCountersAMD;
#define glSelectPerfMonitorCountersAMD glad_debug_glSelectPerfMonitorCountersAMD
    GLAD_API_CALL PFNGLSEMAPHOREPARAMETERIVNVPROC glad_glSemaphoreParameterivNV;
    GLAD_API_CALL PFNGLSEMAPHOREPARAMETERIVNVPROC glad_debug_glSemaphoreParameterivNV;
#define glSemaphoreParameterivNV glad_debug_glSemaphoreParameterivNV
    GLAD_API_CALL PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_glSemaphoreParameterui64vEXT;
    GLAD_API_CALL PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_debug_glSemaphoreParameterui64vEXT;
#define glSemaphoreParameterui64vEXT glad_debug_glSemaphoreParameterui64vEXT
    GLAD_API_CALL PFNGLSEPARABLEFILTER2DEXTPROC glad_glSeparableFilter2DEXT;
    GLAD_API_CALL PFNGLSEPARABLEFILTER2DEXTPROC glad_debug_glSeparableFilter2DEXT;
#define glSeparableFilter2DEXT glad_debug_glSeparableFilter2DEXT
    GLAD_API_CALL PFNGLSETFENCEAPPLEPROC glad_glSetFenceAPPLE;
    GLAD_API_CALL PFNGLSETFENCEAPPLEPROC glad_debug_glSetFenceAPPLE;
#define glSetFenceAPPLE glad_debug_glSetFenceAPPLE
    GLAD_API_CALL PFNGLSETFENCENVPROC glad_glSetFenceNV;
    GLAD_API_CALL PFNGLSETFENCENVPROC glad_debug_glSetFenceNV;
#define glSetFenceNV glad_debug_glSetFenceNV
    GLAD_API_CALL PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_glSetFragmentShaderConstantATI;
    GLAD_API_CALL PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_debug_glSetFragmentShaderConstantATI;
#define glSetFragmentShaderConstantATI glad_debug_glSetFragmentShaderConstantATI
    GLAD_API_CALL PFNGLSETINVARIANTEXTPROC glad_glSetInvariantEXT;
    GLAD_API_CALL PFNGLSETINVARIANTEXTPROC glad_debug_glSetInvariantEXT;
#define glSetInvariantEXT glad_debug_glSetInvariantEXT
    GLAD_API_CALL PFNGLSETLOCALCONSTANTEXTPROC glad_glSetLocalConstantEXT;
    GLAD_API_CALL PFNGLSETLOCALCONSTANTEXTPROC glad_debug_glSetLocalConstantEXT;
#define glSetLocalConstantEXT glad_debug_glSetLocalConstantEXT
    GLAD_API_CALL PFNGLSETMULTISAMPLEFVAMDPROC glad_glSetMultisamplefvAMD;
    GLAD_API_CALL PFNGLSETMULTISAMPLEFVAMDPROC glad_debug_glSetMultisamplefvAMD;
#define glSetMultisamplefvAMD glad_debug_glSetMultisamplefvAMD
    GLAD_API_CALL PFNGLSHADERBINARYPROC glad_glShaderBinary;
    GLAD_API_CALL PFNGLSHADERBINARYPROC glad_debug_glShaderBinary;

/// <summary>
///   load pre-compiled shader binaries
///   <para>
///     glShaderBinary loads pre-compiled shader binary code into the count shader objects whose
///     handles are given in shaders. binary points to length bytes of binary shader code stored in
///     client memory. binaryFormat specifies the format of the pre-compiled code. The binary image
///     contained in binary will be decoded according to the extension specification defining the
///     specified binaryFormat token. OpenGL does not define any specific binary formats, but it
///     does provide a mechanism to obtain token vaues for such formats provided by such extensions.
///     Depending on the types of the shader objects in shaders , glShaderBinary will individually
///     load binary vertex or fragment shaders, or load an executable binary that contains an
///     optimized pair of vertex and fragment shaders stored in the same binary.
///   </para>
/// </summary>
/// <param name='count'>Specifies the number of shader object handles contained in</param>
/// <param name='shaders'>Specifies the address of an array of shader handles into which to load
/// pre-compiled shader binaries.</param> <param name='binaryFormat'>Specifies the format of the
/// shader binaries contained in</param> <param name='binary'>Specifies the address of an array of
/// bytes containing pre-compiled binary shader code.</param> <param name='length'>Specifies the
/// length of the array whose address is given in</param>
#define glShaderBinary glad_debug_glShaderBinary
    GLAD_API_CALL PFNGLSHADEROP1EXTPROC glad_glShaderOp1EXT;
    GLAD_API_CALL PFNGLSHADEROP1EXTPROC glad_debug_glShaderOp1EXT;
#define glShaderOp1EXT glad_debug_glShaderOp1EXT
    GLAD_API_CALL PFNGLSHADEROP2EXTPROC glad_glShaderOp2EXT;
    GLAD_API_CALL PFNGLSHADEROP2EXTPROC glad_debug_glShaderOp2EXT;
#define glShaderOp2EXT glad_debug_glShaderOp2EXT
    GLAD_API_CALL PFNGLSHADEROP3EXTPROC glad_glShaderOp3EXT;
    GLAD_API_CALL PFNGLSHADEROP3EXTPROC glad_debug_glShaderOp3EXT;
#define glShaderOp3EXT glad_debug_glShaderOp3EXT
    GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_glShaderSource;
    GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_debug_glShaderSource;

/// <summary>
///   Replaces the source code in a shader object
///   <para>
///     glShaderSource sets the source code in shader to the source code in the array of strings
///     specified by string. Any source code previously stored in the shader object is completely
///     replaced. The number of strings in the array is specified by count. If length is NULL , each
///     string is assumed to be null terminated. If length is a value other than NULL , it points to
///     an array containing a string length for each of the corresponding elements of string. Each
///     element in the length array may contain the length of the corresponding string (the null
///     character is not counted as part of the string length) or a value less than 0 to indicate
///     that the string is null terminated. The source code strings are not scanned or parsed at
///     this time; they are simply copied into the specified shader object.
///   </para>
/// </summary>
/// <param name='shader'>Specifies the handle of the shader object whose source code is to be
/// replaced.</param> <param name='count'>Specifies the number of elements in the</param> <param
/// name='string'>Specifies an array of pointers to strings containing the source code to be loaded
/// into the shader.</param> <param name='length'>Specifies an array of string lengths.</param>
#define glShaderSource glad_debug_glShaderSource
    GLAD_API_CALL PFNGLSHADERSOURCEARBPROC glad_glShaderSourceARB;
    GLAD_API_CALL PFNGLSHADERSOURCEARBPROC glad_debug_glShaderSourceARB;
#define glShaderSourceARB glad_debug_glShaderSourceARB
    GLAD_API_CALL PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;
    GLAD_API_CALL PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_debug_glShaderStorageBlockBinding;

/// <summary>
///   change an active shader storage block binding
///   <para>
///     glShaderStorageBlockBinding , changes the active shader storage block with an assigned index
///     of storageBlockIndex in program object program. storageBlockIndex must be an active shader
///     storage block index in program. storageBlockBinding must be less than the value of
///     GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS. If successful, glShaderStorageBinding specifies that
///     program will use the data store of the buffer object bound to the binding point
///     storageBlockBinding to read and write the values of the buffer variables in the shader
///     storage block identified by storageBlockIndex.
///   </para>
/// </summary>
/// <param name='program'>The name of the program containing the block whose binding to
/// change.</param> <param name='storageBlockIndex'>The index storage block within the
/// program.</param> <param name='storageBlockBinding'>The index storage block binding to associate
/// with the specified storage block.</param>
#define glShaderStorageBlockBinding glad_debug_glShaderStorageBlockBinding
    GLAD_API_CALL PFNGLSHADINGRATEIMAGEBARRIERNVPROC glad_glShadingRateImageBarrierNV;
    GLAD_API_CALL PFNGLSHADINGRATEIMAGEBARRIERNVPROC glad_debug_glShadingRateImageBarrierNV;
#define glShadingRateImageBarrierNV glad_debug_glShadingRateImageBarrierNV
    GLAD_API_CALL PFNGLSHADINGRATEIMAGEPALETTENVPROC glad_glShadingRateImagePaletteNV;
    GLAD_API_CALL PFNGLSHADINGRATEIMAGEPALETTENVPROC glad_debug_glShadingRateImagePaletteNV;
#define glShadingRateImagePaletteNV glad_debug_glShadingRateImagePaletteNV
    GLAD_API_CALL PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC glad_glShadingRateSampleOrderCustomNV;
    GLAD_API_CALL PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC
        glad_debug_glShadingRateSampleOrderCustomNV;
#define glShadingRateSampleOrderCustomNV glad_debug_glShadingRateSampleOrderCustomNV
    GLAD_API_CALL PFNGLSHADINGRATESAMPLEORDERNVPROC glad_glShadingRateSampleOrderNV;
    GLAD_API_CALL PFNGLSHADINGRATESAMPLEORDERNVPROC glad_debug_glShadingRateSampleOrderNV;
#define glShadingRateSampleOrderNV glad_debug_glShadingRateSampleOrderNV
    GLAD_API_CALL PFNGLSHARPENTEXFUNCSGISPROC glad_glSharpenTexFuncSGIS;
    GLAD_API_CALL PFNGLSHARPENTEXFUNCSGISPROC glad_debug_glSharpenTexFuncSGIS;
#define glSharpenTexFuncSGIS glad_debug_glSharpenTexFuncSGIS
    GLAD_API_CALL PFNGLSIGNALSEMAPHOREEXTPROC glad_glSignalSemaphoreEXT;
    GLAD_API_CALL PFNGLSIGNALSEMAPHOREEXTPROC glad_debug_glSignalSemaphoreEXT;
#define glSignalSemaphoreEXT glad_debug_glSignalSemaphoreEXT
    GLAD_API_CALL PFNGLSIGNALSEMAPHOREUI64NVXPROC glad_glSignalSemaphoreui64NVX;
    GLAD_API_CALL PFNGLSIGNALSEMAPHOREUI64NVXPROC glad_debug_glSignalSemaphoreui64NVX;
#define glSignalSemaphoreui64NVX glad_debug_glSignalSemaphoreui64NVX
    GLAD_API_CALL PFNGLSIGNALVKFENCENVPROC glad_glSignalVkFenceNV;
    GLAD_API_CALL PFNGLSIGNALVKFENCENVPROC glad_debug_glSignalVkFenceNV;
#define glSignalVkFenceNV glad_debug_glSignalVkFenceNV
    GLAD_API_CALL PFNGLSIGNALVKSEMAPHORENVPROC glad_glSignalVkSemaphoreNV;
    GLAD_API_CALL PFNGLSIGNALVKSEMAPHORENVPROC glad_debug_glSignalVkSemaphoreNV;
#define glSignalVkSemaphoreNV glad_debug_glSignalVkSemaphoreNV
    GLAD_API_CALL PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;
    GLAD_API_CALL PFNGLSPECIALIZESHADERPROC glad_debug_glSpecializeShader;
#define glSpecializeShader glad_debug_glSpecializeShader
    GLAD_API_CALL PFNGLSPECIALIZESHADERARBPROC glad_glSpecializeShaderARB;
    GLAD_API_CALL PFNGLSPECIALIZESHADERARBPROC glad_debug_glSpecializeShaderARB;
#define glSpecializeShaderARB glad_debug_glSpecializeShaderARB
    GLAD_API_CALL PFNGLSPRITEPARAMETERFSGIXPROC glad_glSpriteParameterfSGIX;
    GLAD_API_CALL PFNGLSPRITEPARAMETERFSGIXPROC glad_debug_glSpriteParameterfSGIX;
#define glSpriteParameterfSGIX glad_debug_glSpriteParameterfSGIX
    GLAD_API_CALL PFNGLSPRITEPARAMETERFVSGIXPROC glad_glSpriteParameterfvSGIX;
    GLAD_API_CALL PFNGLSPRITEPARAMETERFVSGIXPROC glad_debug_glSpriteParameterfvSGIX;
#define glSpriteParameterfvSGIX glad_debug_glSpriteParameterfvSGIX
    GLAD_API_CALL PFNGLSPRITEPARAMETERISGIXPROC glad_glSpriteParameteriSGIX;
    GLAD_API_CALL PFNGLSPRITEPARAMETERISGIXPROC glad_debug_glSpriteParameteriSGIX;
#define glSpriteParameteriSGIX glad_debug_glSpriteParameteriSGIX
    GLAD_API_CALL PFNGLSPRITEPARAMETERIVSGIXPROC glad_glSpriteParameterivSGIX;
    GLAD_API_CALL PFNGLSPRITEPARAMETERIVSGIXPROC glad_debug_glSpriteParameterivSGIX;
#define glSpriteParameterivSGIX glad_debug_glSpriteParameterivSGIX
    GLAD_API_CALL PFNGLSTARTINSTRUMENTSSGIXPROC glad_glStartInstrumentsSGIX;
    GLAD_API_CALL PFNGLSTARTINSTRUMENTSSGIXPROC glad_debug_glStartInstrumentsSGIX;
#define glStartInstrumentsSGIX glad_debug_glStartInstrumentsSGIX
    GLAD_API_CALL PFNGLSTATECAPTURENVPROC glad_glStateCaptureNV;
    GLAD_API_CALL PFNGLSTATECAPTURENVPROC glad_debug_glStateCaptureNV;
#define glStateCaptureNV glad_debug_glStateCaptureNV
    GLAD_API_CALL PFNGLSTENCILCLEARTAGEXTPROC glad_glStencilClearTagEXT;
    GLAD_API_CALL PFNGLSTENCILCLEARTAGEXTPROC glad_debug_glStencilClearTagEXT;
#define glStencilClearTagEXT glad_debug_glStencilClearTagEXT
    GLAD_API_CALL PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_glStencilFillPathInstancedNV;
    GLAD_API_CALL PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_debug_glStencilFillPathInstancedNV;
#define glStencilFillPathInstancedNV glad_debug_glStencilFillPathInstancedNV
    GLAD_API_CALL PFNGLSTENCILFILLPATHNVPROC glad_glStencilFillPathNV;
    GLAD_API_CALL PFNGLSTENCILFILLPATHNVPROC glad_debug_glStencilFillPathNV;
#define glStencilFillPathNV glad_debug_glStencilFillPathNV
    GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_glStencilFunc;
    GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_debug_glStencilFunc;

/// <summary>
///   set front and back function and reference value for stencil testing
///   <para>
///     Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil
///     planes are first drawn into using GL drawing primitives, then geometry and images are
///     rendered using the stencil planes to mask out portions of the screen. Stenciling is
///     typically used in multipass rendering algorithms to achieve special effects, such as decals,
///     outlining, and constructive solid geometry rendering. The stencil test conditionally
///     eliminates a pixel based on the outcome of a comparison between the reference value and the
///     value in the stencil buffer. To enable and disable the test, call glEnable and glDisable
///     with argument GL_STENCIL_TEST. To specify actions based on the outcome of the stencil test,
///     call glStencilOp or glStencilOpSeparate. There can be two separate sets of func , ref , and
///     mask parameters; one affects back-facing polygons, and the other affects front-facing
///     polygons as well as other non-polygon primitives. glStencilFunc sets both front and back
///     stencil state to the same values. Use glStencilFuncSeparate to set front and back stencil
///     state to different values. func is a symbolic constant that determines the stencil
///     comparison function. It accepts one of eight values, shown in the following list. ref is an
///     integer reference value that is used in the stencil comparison. It is clamped to the range 0
///     2 n - 1 , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed
///     with both the reference value and the stored stencil value, with the ANDed values
///     participating in the comparison. If stencil represents the value stored in the corresponding
///     stencil buffer location, the following list shows the effect of each comparison function
///     that can be specified by func. Only if the comparison succeeds is the pixel passed through
///     to the next stage in the rasterization process (see glStencilOp ). All tests treat stencil
///     values as unsigned integers in the range 0 2 n - 1 , where n is the number of bitplanes in
///     the stencil buffer. The following values are accepted by func : Always fails. Passes if (
///     ref & mask ) < ( stencil & mask ). Passes if ( ref & mask ) <= ( stencil & mask ). Passes if
///     ( ref & mask ) > ( stencil & mask ). Passes if ( ref & mask ) >= ( stencil & mask ). Passes
///     if ( ref & mask ) = ( stencil & mask ). Passes if ( ref & mask ) != ( stencil & mask ).
///     Always passes.
///   </para>
/// </summary>
/// <param name='func'>Specifies the test function. Eight symbolic constants are valid:</param>
/// <param name='ref'>Specifies the reference value for the stencil test.</param>
/// <param name='mask'>Specifies a mask that is ANDed with both the reference value and the stored
/// stencil value when the test is done. The initial value is all 1's.</param>
#define glStencilFunc glad_debug_glStencilFunc
    GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
    GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_debug_glStencilFuncSeparate;

/// <summary>
///   set front and/or back function and reference value for stencil testing
///   <para>
///     Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You
///     draw into the stencil planes using GL drawing primitives, then render geometry and images,
///     using the stencil planes to mask out portions of the screen. Stenciling is typically used in
///     multipass rendering algorithms to achieve special effects, such as decals, outlining, and
///     constructive solid geometry rendering. The stencil test conditionally eliminates a pixel
///     based on the outcome of a comparison between the reference value and the value in the
///     stencil buffer. To enable and disable the test, call glEnable and glDisable with argument
///     GL_STENCIL_TEST. To specify actions based on the outcome of the stencil test, call
///     glStencilOp or glStencilOpSeparate. There can be two separate sets of func , ref , and mask
///     parameters; one affects back-facing polygons, and the other affects front-facing polygons as
///     well as other non-polygon primitives. glStencilFunc sets both front and back stencil state
///     to the same values, as if glStencilFuncSeparate were called with face set to
///     GL_FRONT_AND_BACK. func is a symbolic constant that determines the stencil comparison
///     function. It accepts one of eight values, shown in the following list. ref is an integer
///     reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1
///     , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed with both
///     the reference value and the stored stencil value, with the ANDed values participating in the
///     comparison. If stencil represents the value stored in the corresponding stencil buffer
///     location, the following list shows the effect of each comparison function that can be
///     specified by func. Only if the comparison succeeds is the pixel passed through to the next
///     stage in the rasterization process (see glStencilOp ). All tests treat stencil values as
///     unsigned integers in the range 0 2 n - 1 , where n is the number of bitplanes in the stencil
///     buffer. The following values are accepted by func : Always fails. Passes if ( ref & mask ) <
///     ( stencil & mask ). Passes if ( ref & mask ) <= ( stencil & mask ). Passes if ( ref & mask )
///     > ( stencil & mask ). Passes if ( ref & mask ) >= ( stencil & mask ). Passes if ( ref & mask
///     ) = ( stencil & mask ). Passes if ( ref & mask ) != ( stencil & mask ). Always passes.
///   </para>
/// </summary>
/// <param name='face'>Specifies whether front and/or back stencil state is updated. Three symbolic
/// constants are valid:</param> <param name='func'>Specifies the test function. Eight symbolic
/// constants are valid:</param> <param name='ref'>Specifies the reference value for the stencil
/// test.</param> <param name='mask'>Specifies a mask that is ANDed with both the reference value
/// and the stored stencil value when the test is done. The initial value is all 1's.</param>
#define glStencilFuncSeparate glad_debug_glStencilFuncSeparate
    GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEATIPROC glad_glStencilFuncSeparateATI;
    GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEATIPROC glad_debug_glStencilFuncSeparateATI;
#define glStencilFuncSeparateATI glad_debug_glStencilFuncSeparateATI
    GLAD_API_CALL PFNGLSTENCILMASKPROC glad_glStencilMask;
    GLAD_API_CALL PFNGLSTENCILMASKPROC glad_debug_glStencilMask;

/// <summary>
///   control the front and back writing of individual bits in the stencil planes
///   <para>
///     glStencilMask controls the writing of individual bits in the stencil planes. The least
///     significant n bits of mask , where n is the number of bits in the stencil buffer, specify a
///     mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the
///     stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all
///     bits are enabled for writing. There can be two separate mask writemasks; one affects
///     back-facing polygons, and the other affects front-facing polygons as well as other
///     non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the
///     same values. Use glStencilMaskSeparate to set front and back stencil writemasks to different
///     values.
///   </para>
/// </summary>
/// <param name='mask'>Specifies a bit mask to enable and disable writing of individual bits in the
/// stencil planes. Initially, the mask is all 1's.</param>
#define glStencilMask glad_debug_glStencilMask
    GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
    GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_debug_glStencilMaskSeparate;

/// <summary>
///   control the front and/or back writing of individual bits in the stencil planes
///   <para>
///     glStencilMaskSeparate controls the writing of individual bits in the stencil planes. The
///     least significant n bits of mask , where n is the number of bits in the stencil buffer,
///     specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding
///     bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected.
///     Initially, all bits are enabled for writing. There can be two separate mask writemasks; one
///     affects back-facing polygons, and the other affects front-facing polygons as well as other
///     non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the
///     same values, as if glStencilMaskSeparate were called with face set to GL_FRONT_AND_BACK.
///   </para>
/// </summary>
/// <param name='face'>Specifies whether the front and/or back stencil writemask is updated. Three
/// symbolic constants are valid:</param> <param name='mask'>Specifies a bit mask to enable and
/// disable writing of individual bits in the stencil planes. Initially, the mask is all
/// 1's.</param>
#define glStencilMaskSeparate glad_debug_glStencilMaskSeparate
    GLAD_API_CALL PFNGLSTENCILOPPROC glad_glStencilOp;
    GLAD_API_CALL PFNGLSTENCILOPPROC glad_debug_glStencilOp;

/// <summary>
///   set front and back stencil test actions
///   <para>
///     Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You
///     draw into the stencil planes using GL drawing primitives, then render geometry and images,
///     using the stencil planes to mask out portions of the screen. Stenciling is typically used in
///     multipass rendering algorithms to achieve special effects, such as decals, outlining, and
///     constructive solid geometry rendering. The stencil test conditionally eliminates a pixel
///     based on the outcome of a comparison between the value in the stencil buffer and a reference
///     value. To enable and disable the test, call glEnable and glDisable with argument
///     GL_STENCIL_TEST ; to control it, call glStencilFunc or glStencilFuncSeparate. There can be
///     two separate sets of sfail , dpfail , and dppass parameters; one affects back-facing
///     polygons, and the other affects front-facing polygons as well as other non-polygon
///     primitives. glStencilOp sets both front and back stencil state to the same values. Use
///     glStencilOpSeparate to set front and back stencil state to different values. glStencilOp
///     takes three arguments that indicate what happens to the stored stencil value while
///     stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or
///     depth buffers, and sfail specifies what happens to the stencil buffer contents. The
///     following eight actions are possible. Keeps the current value. Sets the stencil buffer value
///     to 0. Sets the stencil buffer value to ref , as specified by glStencilFunc. Increments the
///     current stencil buffer value. Clamps to the maximum representable unsigned value. Increments
///     the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the
///     maximum representable unsigned value. Decrements the current stencil buffer value. Clamps to
///     0. Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum
///     representable unsigned value when decrementing a stencil buffer value of zero. Bitwise
///     inverts the current stencil buffer value. Stencil buffer values are treated as unsigned
///     integers. When incremented and decremented, values are clamped to 0 and 2 n - 1 , where n is
///     the value returned by querying GL_STENCIL_BITS. The other two arguments to glStencilOp
///     specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed
///     ( dppass ) or fail ( dpfail ) (see glDepthFunc ). The actions are specified using the same
///     eight symbolic constants as sfail. Note that dpfail is ignored when there is no depth
///     buffer, or when the depth buffer is not enabled. In these cases, sfail and dppass specify
///     stencil action when the stencil test fails and passes, respectively.
///   </para>
/// </summary>
/// <param name='sfail'>Specifies the action to take when the stencil test fails. Eight symbolic
/// constants are accepted:</param> <param name='dpfail'>Specifies the stencil action when the
/// stencil test passes, but the depth test fails.</param> <param name='dppass'>Specifies the
/// stencil action when both the stencil test and the depth test pass, or when the stencil test
/// passes and either there is no depth buffer or depth testing is not enabled.</param>
#define glStencilOp glad_debug_glStencilOp
    GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
    GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_debug_glStencilOpSeparate;

/// <summary>
///   set front and/or back stencil test actions
///   <para>
///     Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You
///     draw into the stencil planes using GL drawing primitives, then render geometry and images,
///     using the stencil planes to mask out portions of the screen. Stenciling is typically used in
///     multipass rendering algorithms to achieve special effects, such as decals, outlining, and
///     constructive solid geometry rendering. The stencil test conditionally eliminates a pixel
///     based on the outcome of a comparison between the value in the stencil buffer and a reference
///     value. To enable and disable the test, call glEnable and glDisable with argument
///     GL_STENCIL_TEST ; to control it, call glStencilFunc or glStencilFuncSeparate. There can be
///     two separate sets of sfail , dpfail , and dppass parameters; one affects back-facing
///     polygons, and the other affects front-facing polygons as well as other non-polygon
///     primitives. glStencilOp sets both front and back stencil state to the same values, as if
///     glStencilOpSeparate were called with face set to GL_FRONT_AND_BACK. glStencilOpSeparate
///     takes three arguments that indicate what happens to the stored stencil value while
///     stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or
///     depth buffers, and sfail specifies what happens to the stencil buffer contents. The
///     following eight actions are possible. Keeps the current value. Sets the stencil buffer value
///     to 0. Sets the stencil buffer value to ref , as specified by glStencilFunc. Increments the
///     current stencil buffer value. Clamps to the maximum representable unsigned value. Increments
///     the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the
///     maximum representable unsigned value. Decrements the current stencil buffer value. Clamps to
///     0. Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum
///     representable unsigned value when decrementing a stencil buffer value of zero. Bitwise
///     inverts the current stencil buffer value. Stencil buffer values are treated as unsigned
///     integers. When incremented and decremented, values are clamped to 0 and 2 n - 1 , where n is
///     the value returned by querying GL_STENCIL_BITS. The other two arguments to
///     glStencilOpSeparate specify stencil buffer actions that depend on whether subsequent depth
///     buffer tests succeed ( dppass ) or fail ( dpfail ) (see glDepthFunc ). The actions are
///     specified using the same eight symbolic constants as sfail. Note that dpfail is ignored when
///     there is no depth buffer, or when the depth buffer is not enabled. In these cases, sfail and
///     dppass specify stencil action when the stencil test fails and passes, respectively.
///   </para>
/// </summary>
/// <param name='face'>Specifies whether front and/or back stencil state is updated. Three symbolic
/// constants are valid:</param> <param name='sfail'>Specifies the action to take when the stencil
/// test fails. Eight symbolic constants are accepted:</param> <param name='dpfail'>Specifies the
/// stencil action when the stencil test passes, but the depth test fails.</param> <param
/// name='dppass'>Specifies the stencil action when both the stencil test and the depth test pass,
/// or when the stencil test passes and either there is no depth buffer or depth testing is not
/// enabled.</param>
#define glStencilOpSeparate glad_debug_glStencilOpSeparate
    GLAD_API_CALL PFNGLSTENCILOPSEPARATEATIPROC glad_glStencilOpSeparateATI;
    GLAD_API_CALL PFNGLSTENCILOPSEPARATEATIPROC glad_debug_glStencilOpSeparateATI;
#define glStencilOpSeparateATI glad_debug_glStencilOpSeparateATI
    GLAD_API_CALL PFNGLSTENCILOPVALUEAMDPROC glad_glStencilOpValueAMD;
    GLAD_API_CALL PFNGLSTENCILOPVALUEAMDPROC glad_debug_glStencilOpValueAMD;
#define glStencilOpValueAMD glad_debug_glStencilOpValueAMD
    GLAD_API_CALL PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_glStencilStrokePathInstancedNV;
    GLAD_API_CALL PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_debug_glStencilStrokePathInstancedNV;
#define glStencilStrokePathInstancedNV glad_debug_glStencilStrokePathInstancedNV
    GLAD_API_CALL PFNGLSTENCILSTROKEPATHNVPROC glad_glStencilStrokePathNV;
    GLAD_API_CALL PFNGLSTENCILSTROKEPATHNVPROC glad_debug_glStencilStrokePathNV;
#define glStencilStrokePathNV glad_debug_glStencilStrokePathNV
    GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC
        glad_glStencilThenCoverFillPathInstancedNV;
    GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC
        glad_debug_glStencilThenCoverFillPathInstancedNV;
#define glStencilThenCoverFillPathInstancedNV glad_debug_glStencilThenCoverFillPathInstancedNV
    GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_glStencilThenCoverFillPathNV;
    GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_debug_glStencilThenCoverFillPathNV;
#define glStencilThenCoverFillPathNV glad_debug_glStencilThenCoverFillPathNV
    GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC
        glad_glStencilThenCoverStrokePathInstancedNV;
    GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC
        glad_debug_glStencilThenCoverStrokePathInstancedNV;
#define glStencilThenCoverStrokePathInstancedNV glad_debug_glStencilThenCoverStrokePathInstancedNV
    GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_glStencilThenCoverStrokePathNV;
    GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_debug_glStencilThenCoverStrokePathNV;
#define glStencilThenCoverStrokePathNV glad_debug_glStencilThenCoverStrokePathNV
    GLAD_API_CALL PFNGLSTOPINSTRUMENTSSGIXPROC glad_glStopInstrumentsSGIX;
    GLAD_API_CALL PFNGLSTOPINSTRUMENTSSGIXPROC glad_debug_glStopInstrumentsSGIX;
#define glStopInstrumentsSGIX glad_debug_glStopInstrumentsSGIX
    GLAD_API_CALL PFNGLSTRINGMARKERGREMEDYPROC glad_glStringMarkerGREMEDY;
    GLAD_API_CALL PFNGLSTRINGMARKERGREMEDYPROC glad_debug_glStringMarkerGREMEDY;
#define glStringMarkerGREMEDY glad_debug_glStringMarkerGREMEDY
    GLAD_API_CALL PFNGLSUBPIXELPRECISIONBIASNVPROC glad_glSubpixelPrecisionBiasNV;
    GLAD_API_CALL PFNGLSUBPIXELPRECISIONBIASNVPROC glad_debug_glSubpixelPrecisionBiasNV;
#define glSubpixelPrecisionBiasNV glad_debug_glSubpixelPrecisionBiasNV
    GLAD_API_CALL PFNGLSWIZZLEEXTPROC glad_glSwizzleEXT;
    GLAD_API_CALL PFNGLSWIZZLEEXTPROC glad_debug_glSwizzleEXT;
#define glSwizzleEXT glad_debug_glSwizzleEXT
    GLAD_API_CALL PFNGLSYNCTEXTUREINTELPROC glad_glSyncTextureINTEL;
    GLAD_API_CALL PFNGLSYNCTEXTUREINTELPROC glad_debug_glSyncTextureINTEL;
#define glSyncTextureINTEL glad_debug_glSyncTextureINTEL
    GLAD_API_CALL PFNGLTAGSAMPLEBUFFERSGIXPROC glad_glTagSampleBufferSGIX;
    GLAD_API_CALL PFNGLTAGSAMPLEBUFFERSGIXPROC glad_debug_glTagSampleBufferSGIX;
#define glTagSampleBufferSGIX glad_debug_glTagSampleBufferSGIX
    GLAD_API_CALL PFNGLTANGENT3BEXTPROC glad_glTangent3bEXT;
    GLAD_API_CALL PFNGLTANGENT3BEXTPROC glad_debug_glTangent3bEXT;
#define glTangent3bEXT glad_debug_glTangent3bEXT
    GLAD_API_CALL PFNGLTANGENT3BVEXTPROC glad_glTangent3bvEXT;
    GLAD_API_CALL PFNGLTANGENT3BVEXTPROC glad_debug_glTangent3bvEXT;
#define glTangent3bvEXT glad_debug_glTangent3bvEXT
    GLAD_API_CALL PFNGLTANGENT3DEXTPROC glad_glTangent3dEXT;
    GLAD_API_CALL PFNGLTANGENT3DEXTPROC glad_debug_glTangent3dEXT;
#define glTangent3dEXT glad_debug_glTangent3dEXT
    GLAD_API_CALL PFNGLTANGENT3DVEXTPROC glad_glTangent3dvEXT;
    GLAD_API_CALL PFNGLTANGENT3DVEXTPROC glad_debug_glTangent3dvEXT;
#define glTangent3dvEXT glad_debug_glTangent3dvEXT
    GLAD_API_CALL PFNGLTANGENT3FEXTPROC glad_glTangent3fEXT;
    GLAD_API_CALL PFNGLTANGENT3FEXTPROC glad_debug_glTangent3fEXT;
#define glTangent3fEXT glad_debug_glTangent3fEXT
    GLAD_API_CALL PFNGLTANGENT3FVEXTPROC glad_glTangent3fvEXT;
    GLAD_API_CALL PFNGLTANGENT3FVEXTPROC glad_debug_glTangent3fvEXT;
#define glTangent3fvEXT glad_debug_glTangent3fvEXT
    GLAD_API_CALL PFNGLTANGENT3IEXTPROC glad_glTangent3iEXT;
    GLAD_API_CALL PFNGLTANGENT3IEXTPROC glad_debug_glTangent3iEXT;
#define glTangent3iEXT glad_debug_glTangent3iEXT
    GLAD_API_CALL PFNGLTANGENT3IVEXTPROC glad_glTangent3ivEXT;
    GLAD_API_CALL PFNGLTANGENT3IVEXTPROC glad_debug_glTangent3ivEXT;
#define glTangent3ivEXT glad_debug_glTangent3ivEXT
    GLAD_API_CALL PFNGLTANGENT3SEXTPROC glad_glTangent3sEXT;
    GLAD_API_CALL PFNGLTANGENT3SEXTPROC glad_debug_glTangent3sEXT;
#define glTangent3sEXT glad_debug_glTangent3sEXT
    GLAD_API_CALL PFNGLTANGENT3SVEXTPROC glad_glTangent3svEXT;
    GLAD_API_CALL PFNGLTANGENT3SVEXTPROC glad_debug_glTangent3svEXT;
#define glTangent3svEXT glad_debug_glTangent3svEXT
    GLAD_API_CALL PFNGLTANGENTPOINTEREXTPROC glad_glTangentPointerEXT;
    GLAD_API_CALL PFNGLTANGENTPOINTEREXTPROC glad_debug_glTangentPointerEXT;
#define glTangentPointerEXT glad_debug_glTangentPointerEXT
    GLAD_API_CALL PFNGLTBUFFERMASK3DFXPROC glad_glTbufferMask3DFX;
    GLAD_API_CALL PFNGLTBUFFERMASK3DFXPROC glad_debug_glTbufferMask3DFX;
#define glTbufferMask3DFX glad_debug_glTbufferMask3DFX
    GLAD_API_CALL PFNGLTESSELLATIONFACTORAMDPROC glad_glTessellationFactorAMD;
    GLAD_API_CALL PFNGLTESSELLATIONFACTORAMDPROC glad_debug_glTessellationFactorAMD;
#define glTessellationFactorAMD glad_debug_glTessellationFactorAMD
    GLAD_API_CALL PFNGLTESSELLATIONMODEAMDPROC glad_glTessellationModeAMD;
    GLAD_API_CALL PFNGLTESSELLATIONMODEAMDPROC glad_debug_glTessellationModeAMD;
#define glTessellationModeAMD glad_debug_glTessellationModeAMD
    GLAD_API_CALL PFNGLTESTFENCEAPPLEPROC glad_glTestFenceAPPLE;
    GLAD_API_CALL PFNGLTESTFENCEAPPLEPROC glad_debug_glTestFenceAPPLE;
#define glTestFenceAPPLE glad_debug_glTestFenceAPPLE
    GLAD_API_CALL PFNGLTESTFENCENVPROC glad_glTestFenceNV;
    GLAD_API_CALL PFNGLTESTFENCENVPROC glad_debug_glTestFenceNV;
#define glTestFenceNV glad_debug_glTestFenceNV
    GLAD_API_CALL PFNGLTESTOBJECTAPPLEPROC glad_glTestObjectAPPLE;
    GLAD_API_CALL PFNGLTESTOBJECTAPPLEPROC glad_debug_glTestObjectAPPLE;
#define glTestObjectAPPLE glad_debug_glTestObjectAPPLE
    GLAD_API_CALL PFNGLTEXATTACHMEMORYNVPROC glad_glTexAttachMemoryNV;
    GLAD_API_CALL PFNGLTEXATTACHMEMORYNVPROC glad_debug_glTexAttachMemoryNV;
#define glTexAttachMemoryNV glad_debug_glTexAttachMemoryNV
    GLAD_API_CALL PFNGLTEXBUFFERPROC glad_glTexBuffer;
    GLAD_API_CALL PFNGLTEXBUFFERPROC glad_debug_glTexBuffer;

/// <summary>
///   attach a buffer object's data store to a buffer texture object
///   <para>
///     glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a
///     specified texture object, and specify the storage format for the texture image found found
///     in the buffer object. The texture object must be a buffer texture. If buffer is zero, any
///     buffer object attached to the buffer texture is detached and no new buffer object is
///     attached. If buffer is non-zero, it must be the name of an existing buffer object.
///     internalformat specifies the storage format, and must be one of the following sized internal
///     formats: When a buffer object is attached to a buffer texture, the buffer object's data
///     store is taken as the texture's texel array. The number of texels in the buffer texture's
///     texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type)
///     } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units
///     (the value of GL_BUFFER_SIZE for buffer ), and $components$ and $base\_type$ are the element
///     count and base data type for elements, as specified in the table above. The number of texels
///     in the texel array is then clamped to the value of the implementation-dependent limit
///     GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer texture is accessed in a shader, the results of a
///     texel fetch are undefined if the specified texel coordinate is negative, or greater than or
///     equal to the clamped number of texels in the texel array.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='internalFormat'>Specifies the internal format of the data in the store belonging
/// to</param> <param name='buffer'>Specifies the name of the buffer object whose storage to attach
/// to the active buffer texture.</param>
#define glTexBuffer glad_debug_glTexBuffer
    GLAD_API_CALL PFNGLTEXBUFFERARBPROC glad_glTexBufferARB;
    GLAD_API_CALL PFNGLTEXBUFFERARBPROC glad_debug_glTexBufferARB;
#define glTexBufferARB glad_debug_glTexBufferARB
    GLAD_API_CALL PFNGLTEXBUFFEREXTPROC glad_glTexBufferEXT;
    GLAD_API_CALL PFNGLTEXBUFFEREXTPROC glad_debug_glTexBufferEXT;
#define glTexBufferEXT glad_debug_glTexBufferEXT
    GLAD_API_CALL PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;
    GLAD_API_CALL PFNGLTEXBUFFERRANGEPROC glad_debug_glTexBufferRange;

/// <summary>
///   attach a range of a buffer object's data store to a buffer texture object
///   <para>
///     glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified
///     buffer object to a specified texture object, and specify the storage format for the texture
///     image found found in the buffer object. The texture object must be a buffer texture. If
///     buffer is zero, any buffer object attached to the buffer texture is detached and no new
///     buffer object is attached. If buffer is non-zero, it must be the name of an existing buffer
///     object. The start and size of the range are specified by offset and size respectively, both
///     measured in basic machine units. offset must be greater than or equal to zero, size must be
///     greater than zero, and the sum of offset and size must not exceed the value of
///     GL_BUFFER_SIZE for buffer. Furthermore, offset must be an integer multiple of the value of
///     GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT. internalformat specifies the storage format, and must be
///     one of the following sized internal formats: When a range of a buffer object is attached to
///     a buffer texture, the specified range of the buffer object's data store is taken as the
///     texture's texel array. The number of texels in the buffer texture's texel array is given by
///     $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$
///     where $components$ and $base\_type$ are the element count and base data type for elements,
///     as specified in the table above. The number of texels in the texel array is then clamped to
///     the value of the implementation-dependent limit GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer
///     texture is accessed in a shader, the results of a texel fetch are undefined if the specified
///     texel coordinate is negative, or greater than or equal to the clamped number of texels in
///     the texel array.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='internalFormat'>Specifies the internal format of the data in the store belonging
/// to</param> <param name='buffer'>Specifies the name of the buffer object whose storage to attach
/// to the active buffer texture.</param> <param name='offset'>Specifies the offset of the start of
/// the range of the buffer's data store to attach.</param> <param name='size'>Specifies the size of
/// the range of the buffer's data store to attach.</param>
#define glTexBufferRange glad_debug_glTexBufferRange
    GLAD_API_CALL PFNGLTEXBUMPPARAMETERFVATIPROC glad_glTexBumpParameterfvATI;
    GLAD_API_CALL PFNGLTEXBUMPPARAMETERFVATIPROC glad_debug_glTexBumpParameterfvATI;
#define glTexBumpParameterfvATI glad_debug_glTexBumpParameterfvATI
    GLAD_API_CALL PFNGLTEXBUMPPARAMETERIVATIPROC glad_glTexBumpParameterivATI;
    GLAD_API_CALL PFNGLTEXBUMPPARAMETERIVATIPROC glad_debug_glTexBumpParameterivATI;
#define glTexBumpParameterivATI glad_debug_glTexBumpParameterivATI
    GLAD_API_CALL PFNGLTEXCOORD1BOESPROC glad_glTexCoord1bOES;
    GLAD_API_CALL PFNGLTEXCOORD1BOESPROC glad_debug_glTexCoord1bOES;
#define glTexCoord1bOES glad_debug_glTexCoord1bOES
    GLAD_API_CALL PFNGLTEXCOORD1BVOESPROC glad_glTexCoord1bvOES;
    GLAD_API_CALL PFNGLTEXCOORD1BVOESPROC glad_debug_glTexCoord1bvOES;
#define glTexCoord1bvOES glad_debug_glTexCoord1bvOES
    GLAD_API_CALL PFNGLTEXCOORD1HNVPROC glad_glTexCoord1hNV;
    GLAD_API_CALL PFNGLTEXCOORD1HNVPROC glad_debug_glTexCoord1hNV;
#define glTexCoord1hNV glad_debug_glTexCoord1hNV
    GLAD_API_CALL PFNGLTEXCOORD1HVNVPROC glad_glTexCoord1hvNV;
    GLAD_API_CALL PFNGLTEXCOORD1HVNVPROC glad_debug_glTexCoord1hvNV;
#define glTexCoord1hvNV glad_debug_glTexCoord1hvNV
    GLAD_API_CALL PFNGLTEXCOORD1XOESPROC glad_glTexCoord1xOES;
    GLAD_API_CALL PFNGLTEXCOORD1XOESPROC glad_debug_glTexCoord1xOES;
#define glTexCoord1xOES glad_debug_glTexCoord1xOES
    GLAD_API_CALL PFNGLTEXCOORD1XVOESPROC glad_glTexCoord1xvOES;
    GLAD_API_CALL PFNGLTEXCOORD1XVOESPROC glad_debug_glTexCoord1xvOES;
#define glTexCoord1xvOES glad_debug_glTexCoord1xvOES
    GLAD_API_CALL PFNGLTEXCOORD2BOESPROC glad_glTexCoord2bOES;
    GLAD_API_CALL PFNGLTEXCOORD2BOESPROC glad_debug_glTexCoord2bOES;
#define glTexCoord2bOES glad_debug_glTexCoord2bOES
    GLAD_API_CALL PFNGLTEXCOORD2BVOESPROC glad_glTexCoord2bvOES;
    GLAD_API_CALL PFNGLTEXCOORD2BVOESPROC glad_debug_glTexCoord2bvOES;
#define glTexCoord2bvOES glad_debug_glTexCoord2bvOES
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC glad_glTexCoord2fColor3fVertex3fSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC glad_debug_glTexCoord2fColor3fVertex3fSUN;
#define glTexCoord2fColor3fVertex3fSUN glad_debug_glTexCoord2fColor3fVertex3fSUN
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC glad_glTexCoord2fColor3fVertex3fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC glad_debug_glTexCoord2fColor3fVertex3fvSUN;
#define glTexCoord2fColor3fVertex3fvSUN glad_debug_glTexCoord2fColor3fVertex3fvSUN
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_glTexCoord2fColor4fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC
        glad_debug_glTexCoord2fColor4fNormal3fVertex3fSUN;
#define glTexCoord2fColor4fNormal3fVertex3fSUN glad_debug_glTexCoord2fColor4fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_glTexCoord2fColor4fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC
        glad_debug_glTexCoord2fColor4fNormal3fVertex3fvSUN;
#define glTexCoord2fColor4fNormal3fVertex3fvSUN glad_debug_glTexCoord2fColor4fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC glad_glTexCoord2fColor4ubVertex3fSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC glad_debug_glTexCoord2fColor4ubVertex3fSUN;
#define glTexCoord2fColor4ubVertex3fSUN glad_debug_glTexCoord2fColor4ubVertex3fSUN
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC glad_glTexCoord2fColor4ubVertex3fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC
        glad_debug_glTexCoord2fColor4ubVertex3fvSUN;
#define glTexCoord2fColor4ubVertex3fvSUN glad_debug_glTexCoord2fColor4ubVertex3fvSUN
    GLAD_API_CALL PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_glTexCoord2fNormal3fVertex3fSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_debug_glTexCoord2fNormal3fVertex3fSUN;
#define glTexCoord2fNormal3fVertex3fSUN glad_debug_glTexCoord2fNormal3fVertex3fSUN
    GLAD_API_CALL PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC glad_glTexCoord2fNormal3fVertex3fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC
        glad_debug_glTexCoord2fNormal3fVertex3fvSUN;
#define glTexCoord2fNormal3fVertex3fvSUN glad_debug_glTexCoord2fNormal3fVertex3fvSUN
    GLAD_API_CALL PFNGLTEXCOORD2FVERTEX3FSUNPROC glad_glTexCoord2fVertex3fSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FVERTEX3FSUNPROC glad_debug_glTexCoord2fVertex3fSUN;
#define glTexCoord2fVertex3fSUN glad_debug_glTexCoord2fVertex3fSUN
    GLAD_API_CALL PFNGLTEXCOORD2FVERTEX3FVSUNPROC glad_glTexCoord2fVertex3fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD2FVERTEX3FVSUNPROC glad_debug_glTexCoord2fVertex3fvSUN;
#define glTexCoord2fVertex3fvSUN glad_debug_glTexCoord2fVertex3fvSUN
    GLAD_API_CALL PFNGLTEXCOORD2HNVPROC glad_glTexCoord2hNV;
    GLAD_API_CALL PFNGLTEXCOORD2HNVPROC glad_debug_glTexCoord2hNV;
#define glTexCoord2hNV glad_debug_glTexCoord2hNV
    GLAD_API_CALL PFNGLTEXCOORD2HVNVPROC glad_glTexCoord2hvNV;
    GLAD_API_CALL PFNGLTEXCOORD2HVNVPROC glad_debug_glTexCoord2hvNV;
#define glTexCoord2hvNV glad_debug_glTexCoord2hvNV
    GLAD_API_CALL PFNGLTEXCOORD2XOESPROC glad_glTexCoord2xOES;
    GLAD_API_CALL PFNGLTEXCOORD2XOESPROC glad_debug_glTexCoord2xOES;
#define glTexCoord2xOES glad_debug_glTexCoord2xOES
    GLAD_API_CALL PFNGLTEXCOORD2XVOESPROC glad_glTexCoord2xvOES;
    GLAD_API_CALL PFNGLTEXCOORD2XVOESPROC glad_debug_glTexCoord2xvOES;
#define glTexCoord2xvOES glad_debug_glTexCoord2xvOES
    GLAD_API_CALL PFNGLTEXCOORD3BOESPROC glad_glTexCoord3bOES;
    GLAD_API_CALL PFNGLTEXCOORD3BOESPROC glad_debug_glTexCoord3bOES;
#define glTexCoord3bOES glad_debug_glTexCoord3bOES
    GLAD_API_CALL PFNGLTEXCOORD3BVOESPROC glad_glTexCoord3bvOES;
    GLAD_API_CALL PFNGLTEXCOORD3BVOESPROC glad_debug_glTexCoord3bvOES;
#define glTexCoord3bvOES glad_debug_glTexCoord3bvOES
    GLAD_API_CALL PFNGLTEXCOORD3HNVPROC glad_glTexCoord3hNV;
    GLAD_API_CALL PFNGLTEXCOORD3HNVPROC glad_debug_glTexCoord3hNV;
#define glTexCoord3hNV glad_debug_glTexCoord3hNV
    GLAD_API_CALL PFNGLTEXCOORD3HVNVPROC glad_glTexCoord3hvNV;
    GLAD_API_CALL PFNGLTEXCOORD3HVNVPROC glad_debug_glTexCoord3hvNV;
#define glTexCoord3hvNV glad_debug_glTexCoord3hvNV
    GLAD_API_CALL PFNGLTEXCOORD3XOESPROC glad_glTexCoord3xOES;
    GLAD_API_CALL PFNGLTEXCOORD3XOESPROC glad_debug_glTexCoord3xOES;
#define glTexCoord3xOES glad_debug_glTexCoord3xOES
    GLAD_API_CALL PFNGLTEXCOORD3XVOESPROC glad_glTexCoord3xvOES;
    GLAD_API_CALL PFNGLTEXCOORD3XVOESPROC glad_debug_glTexCoord3xvOES;
#define glTexCoord3xvOES glad_debug_glTexCoord3xvOES
    GLAD_API_CALL PFNGLTEXCOORD4BOESPROC glad_glTexCoord4bOES;
    GLAD_API_CALL PFNGLTEXCOORD4BOESPROC glad_debug_glTexCoord4bOES;
#define glTexCoord4bOES glad_debug_glTexCoord4bOES
    GLAD_API_CALL PFNGLTEXCOORD4BVOESPROC glad_glTexCoord4bvOES;
    GLAD_API_CALL PFNGLTEXCOORD4BVOESPROC glad_debug_glTexCoord4bvOES;
#define glTexCoord4bvOES glad_debug_glTexCoord4bvOES
    GLAD_API_CALL PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC
        glad_glTexCoord4fColor4fNormal3fVertex4fSUN;
    GLAD_API_CALL PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC
        glad_debug_glTexCoord4fColor4fNormal3fVertex4fSUN;
#define glTexCoord4fColor4fNormal3fVertex4fSUN glad_debug_glTexCoord4fColor4fNormal3fVertex4fSUN
    GLAD_API_CALL PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC
        glad_glTexCoord4fColor4fNormal3fVertex4fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC
        glad_debug_glTexCoord4fColor4fNormal3fVertex4fvSUN;
#define glTexCoord4fColor4fNormal3fVertex4fvSUN glad_debug_glTexCoord4fColor4fNormal3fVertex4fvSUN
    GLAD_API_CALL PFNGLTEXCOORD4FVERTEX4FSUNPROC glad_glTexCoord4fVertex4fSUN;
    GLAD_API_CALL PFNGLTEXCOORD4FVERTEX4FSUNPROC glad_debug_glTexCoord4fVertex4fSUN;
#define glTexCoord4fVertex4fSUN glad_debug_glTexCoord4fVertex4fSUN
    GLAD_API_CALL PFNGLTEXCOORD4FVERTEX4FVSUNPROC glad_glTexCoord4fVertex4fvSUN;
    GLAD_API_CALL PFNGLTEXCOORD4FVERTEX4FVSUNPROC glad_debug_glTexCoord4fVertex4fvSUN;
#define glTexCoord4fVertex4fvSUN glad_debug_glTexCoord4fVertex4fvSUN
    GLAD_API_CALL PFNGLTEXCOORD4HNVPROC glad_glTexCoord4hNV;
    GLAD_API_CALL PFNGLTEXCOORD4HNVPROC glad_debug_glTexCoord4hNV;
#define glTexCoord4hNV glad_debug_glTexCoord4hNV
    GLAD_API_CALL PFNGLTEXCOORD4HVNVPROC glad_glTexCoord4hvNV;
    GLAD_API_CALL PFNGLTEXCOORD4HVNVPROC glad_debug_glTexCoord4hvNV;
#define glTexCoord4hvNV glad_debug_glTexCoord4hvNV
    GLAD_API_CALL PFNGLTEXCOORD4XOESPROC glad_glTexCoord4xOES;
    GLAD_API_CALL PFNGLTEXCOORD4XOESPROC glad_debug_glTexCoord4xOES;
#define glTexCoord4xOES glad_debug_glTexCoord4xOES
    GLAD_API_CALL PFNGLTEXCOORD4XVOESPROC glad_glTexCoord4xvOES;
    GLAD_API_CALL PFNGLTEXCOORD4XVOESPROC glad_debug_glTexCoord4xvOES;
#define glTexCoord4xvOES glad_debug_glTexCoord4xvOES
    GLAD_API_CALL PFNGLTEXCOORDFORMATNVPROC glad_glTexCoordFormatNV;
    GLAD_API_CALL PFNGLTEXCOORDFORMATNVPROC glad_debug_glTexCoordFormatNV;
#define glTexCoordFormatNV glad_debug_glTexCoordFormatNV
    GLAD_API_CALL PFNGLTEXCOORDPOINTEREXTPROC glad_glTexCoordPointerEXT;
    GLAD_API_CALL PFNGLTEXCOORDPOINTEREXTPROC glad_debug_glTexCoordPointerEXT;
#define glTexCoordPointerEXT glad_debug_glTexCoordPointerEXT
    GLAD_API_CALL PFNGLTEXCOORDPOINTERLISTIBMPROC glad_glTexCoordPointerListIBM;
    GLAD_API_CALL PFNGLTEXCOORDPOINTERLISTIBMPROC glad_debug_glTexCoordPointerListIBM;
#define glTexCoordPointerListIBM glad_debug_glTexCoordPointerListIBM
    GLAD_API_CALL PFNGLTEXCOORDPOINTERVINTELPROC glad_glTexCoordPointervINTEL;
    GLAD_API_CALL PFNGLTEXCOORDPOINTERVINTELPROC glad_debug_glTexCoordPointervINTEL;
#define glTexCoordPointervINTEL glad_debug_glTexCoordPointervINTEL
    GLAD_API_CALL PFNGLTEXENVXOESPROC glad_glTexEnvxOES;
    GLAD_API_CALL PFNGLTEXENVXOESPROC glad_debug_glTexEnvxOES;
#define glTexEnvxOES glad_debug_glTexEnvxOES
    GLAD_API_CALL PFNGLTEXENVXVOESPROC glad_glTexEnvxvOES;
    GLAD_API_CALL PFNGLTEXENVXVOESPROC glad_debug_glTexEnvxvOES;
#define glTexEnvxvOES glad_debug_glTexEnvxvOES
    GLAD_API_CALL PFNGLTEXFILTERFUNCSGISPROC glad_glTexFilterFuncSGIS;
    GLAD_API_CALL PFNGLTEXFILTERFUNCSGISPROC glad_debug_glTexFilterFuncSGIS;
#define glTexFilterFuncSGIS glad_debug_glTexFilterFuncSGIS
    GLAD_API_CALL PFNGLTEXGENXOESPROC glad_glTexGenxOES;
    GLAD_API_CALL PFNGLTEXGENXOESPROC glad_debug_glTexGenxOES;
#define glTexGenxOES glad_debug_glTexGenxOES
    GLAD_API_CALL PFNGLTEXGENXVOESPROC glad_glTexGenxvOES;
    GLAD_API_CALL PFNGLTEXGENXVOESPROC glad_debug_glTexGenxvOES;
#define glTexGenxvOES glad_debug_glTexGenxvOES
    GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
    GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_debug_glTexImage1D;

/// <summary>
///   specify a one-dimensional texture image
///   <para>
///     Texturing maps a portion of a specified texture image onto each graphical primitive for
///     which texturing is enabled. To enable and disable one-dimensional texturing, call glEnable
///     and glDisable with argument GL_TEXTURE_1D. Texture images are defined with glTexImage1D. The
///     arguments describe the parameters of the texture image, such as width, width of the border,
///     level-of-detail number (see glTexParameter ), and the internal resolution and format used to
///     store the image. The last three arguments describe how the image is represented in memory.
///     If target is GL_PROXY_TEXTURE_1D , no data is read from data , but all of the texture image
///     state is recalculated, checked for consistency, and checked against the implementation's
///     capabilities. If the implementation cannot handle a texture of the requested texture size,
///     it sets all of the image state to 0, but does not generate an error (see glGetError ). To
///     query for an entire mipmap array, use an image array level greater than or equal to 1. If
///     target is GL_TEXTURE_1D , data is read from data as a sequence of signed or unsigned bytes,
///     shorts, or longs, or single-precision floating-point values, depending on type. These values
///     are grouped into sets of one, two, three, or four values, depending on format , to form
///     elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by
///     GL_UNPACK_LSB_FIRST (see glPixelStore ). If a non-zero named buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified, data
///     is treated as a byte offset into the buffer object's data store. The first element
///     corresponds to the left end of the texture array. Subsequent elements progress left-to-right
///     through the remaining texels in the texture array. The final element corresponds to the
///     right end of the texture array. format determines the composition of each element in data.
///     It can assume one of these symbolic values: Each element is a single red component. The GL
///     converts it to floating point and assembles it into an RGBA element by attaching 0 for green
///     and blue, and 1 for alpha. Each component is clamped to the range [0,1]. Each element is a
///     single red/green double The GL converts it to floating point and assembles it into an RGBA
///     element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range
///     [0,1]. Each element is an RGB triple. The GL converts it to floating point and assembles it
///     into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
///     Each element contains all four components. Each component clamped to the range [0,1]. Each
///     element is a single depth value. The GL converts it to floating point and clamps to the
///     range [0,1]. If an application wants to store the texture at a certain resolution or in a
///     certain format, it can request the resolution and format with internalFormat. The GL will
///     choose an internal representation that closely approximates that requested by internalFormat
///     , but it may not match exactly. (The representations specified by GL_RED , GL_RG , GL_RGB
///     and GL_RGBA must match exactly.) internalFormat may be one of the base internal formats
///     shown in Table 1, below internalFormat may also be one of the sized internal formats shown
///     in Table 2, below Finally, internalFormat may also be one of the generic or compressed
///     compressed texture formats shown in Table 3 below If the internalFormat parameter is one of
///     the generic compressed formats, GL_COMPRESSED_RED , GL_COMPRESSED_RG , GL_COMPRESSED_RGB ,
///     or GL_COMPRESSED_RGBA , the GL will replace the internal format with the symbolic constant
///     for a specific internal format and compress the texture before storage. If no corresponding
///     internal format is available, or the GL can not compress that image for any reason, the
///     internal format is instead replaced with a corresponding base internal format. If the
///     internalFormat parameter is GL_SRGB , GL_SRGB8 , GL_SRGB_ALPHA or GL_SRGB8_ALPHA8 , the
///     texture is treated as if the red, green, or blue components are encoded in the sRGB color
///     space. Any alpha component is left unchanged. The conversion from the sRGB encoded component
///     c s to a linear component c l is: c l = { c s 12.92 if c s ≤ 0.04045 ( c s + 0.055 1.055
///     ) 2.4 if c s > 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the
///     GL_PROXY_TEXTURE_1D target to try out a resolution and format. The implementation will
///     update and recompute its best match for the requested storage resolution and format. To then
///     query this state, call glGetTexLevelParameter. If the texture cannot be accommodated,
///     texture state is set to 0. A one-component texture image uses only the red component of the
///     RGBA color from data. A two-component image uses the R and A values. A three-component image
///     uses the R, G, and B values. A four-component image uses all of the RGBA components.
///     Image-based shadowing can be enabled by comparing texture r coordinates to depth texture
///     values to generate a boolean result. See glTexParameter for details on texture comparison.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalFormat'>Specifies the number of color components in the
/// texture. Must be one of base internal formats given in Table 1, one of the sized internal
/// formats given in Table 2, or one of the compressed internal formats given in Table 3,
/// below.</param> <param name='width'>Specifies the width of the texture image. All implementations
/// support texture images that are at least 1024 texels wide. The height of the 1D texture image
/// is 1.</param> <param name='border'>This value must be 0.</param> <param name='format'>Specifies
/// the format of the pixel data. The following symbolic values are accepted:</param> <param
/// name='type'>Specifies the data type of the pixel data. The following symbolic values are
/// accepted:</param> <param name='data'>Specifies a pointer to the image data in memory.</param>
#define glTexImage1D glad_debug_glTexImage1D
    GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
    GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_debug_glTexImage2D;

/// <summary>
///   specify a two-dimensional texture image
///   <para>
///     Texturing allows elements of an image array to be read by shaders. To define texture images,
///     call glTexImage2D. The arguments describe the parameters of the texture image, such as
///     height, width, width of the border, level-of-detail number (see glTexParameter ), and number
///     of color components provided. The last three arguments describe how the image is represented
///     in memory. If target is GL_PROXY_TEXTURE_2D , GL_PROXY_TEXTURE_1D_ARRAY ,
///     GL_PROXY_TEXTURE_CUBE_MAP , or GL_PROXY_TEXTURE_RECTANGLE , no data is read from data , but
///     all of the texture image state is recalculated, checked for consistency, and checked against
///     the implementation's capabilities. If the implementation cannot handle a texture of the
///     requested texture size, it sets all of the image state to 0, but does not generate an error
///     (see glGetError ). To query for an entire mipmap array, use an image array level greater
///     than or equal to 1. If target is GL_TEXTURE_2D , GL_TEXTURE_RECTANGLE or one of the
///     GL_TEXTURE_CUBE_MAP targets, data is read from data as a sequence of signed or unsigned
///     bytes, shorts, or longs, or single-precision floating-point values, depending on type. These
///     values are grouped into sets of one, two, three, or four values, depending on format , to
///     form elements. Each data byte is treated as eight 1-bit elements, with bit ordering
///     determined by GL_UNPACK_LSB_FIRST (see glPixelStore ). If target is GL_TEXTURE_1D_ARRAY ,
///     data is interpreted as an array of one-dimensional images. If a non-zero named buffer object
///     is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is
///     specified, data is treated as a byte offset into the buffer object's data store. The first
///     element corresponds to the lower left corner of the texture image. Subsequent elements
///     progress left-to-right through the remaining texels in the lowest row of the texture image,
///     and then in successively higher rows of the texture image. The final element corresponds to
///     the upper right corner of the texture image. format determines the composition of each
///     element in data. It can assume one of these symbolic values: Each element is a single red
///     component. The GL converts it to floating point and assembles it into an RGBA element by
///     attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range
///     [0,1]. Each element is a red/green double. The GL converts it to floating point and
///     assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component
///     is clamped to the range [0,1]. Each element is an RGB triple. The GL converts it to floating
///     point and assembles it into an RGBA element by attaching 1 for alpha. Each component is
///     clamped to the range [0,1]. Each element contains all four components. Each component is
///     clamped to the range [0,1]. Each element is a single depth value. The GL converts it to
///     floating point and clamps to the range [0,1]. Each element is a pair of depth and stencil
///     values. The depth component of the pair is interpreted as in GL_DEPTH_COMPONENT. The stencil
///     component is interpreted based on specified the depth + stencil internal format. If an
///     application wants to store the texture at a certain resolution or in a certain format, it
///     can request the resolution and format with internalFormat. The GL will choose an internal
///     representation that closely approximates that requested by internalFormat , but it may not
///     match exactly. (The representations specified by GL_RED , GL_RG , GL_RGB , and GL_RGBA must
///     match exactly.) internalFormat may be one of the base internal formats shown in Table 1,
///     below internalFormat may also be one of the sized internal formats shown in Table 2, below
///     Finally, internalFormat may also be one of the generic or compressed compressed texture
///     formats shown in Table 3 below If the internalFormat parameter is one of the generic
///     compressed formats, GL_COMPRESSED_RED , GL_COMPRESSED_RG , GL_COMPRESSED_RGB , or
///     GL_COMPRESSED_RGBA , the GL will replace the internal format with the symbolic constant for
///     a specific internal format and compress the texture before storage. If no corresponding
///     internal format is available, or the GL can not compress that image for any reason, the
///     internal format is instead replaced with a corresponding base internal format. If the
///     internalFormat parameter is GL_SRGB , GL_SRGB8 , GL_SRGB_ALPHA , or GL_SRGB8_ALPHA8 , the
///     texture is treated as if the red, green, or blue components are encoded in the sRGB color
///     space. Any alpha component is left unchanged. The conversion from the sRGB encoded component
///     c s to a linear component c l is: c l = { c s 12.92 if c s ≤ 0.04045 ( c s + 0.055 1.055
///     ) 2.4 if c s > 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the
///     GL_PROXY_TEXTURE_2D , GL_PROXY_TEXTURE_1D_ARRAY , GL_PROXY_TEXTURE_RECTANGLE , or
///     GL_PROXY_TEXTURE_CUBE_MAP target to try out a resolution and format. The implementation will
///     update and recompute its best match for the requested storage resolution and format. To then
///     query this state, call glGetTexLevelParameter. If the texture cannot be accommodated,
///     texture state is set to 0. A one-component texture image uses only the red component of the
///     RGBA color extracted from data. A two-component image uses the R and G values. A
///     three-component image uses the R, G, and B values. A four-component image uses all of the
///     RGBA components. Image-based shadowing can be enabled by comparing texture r coordinates to
///     depth texture values to generate a boolean result. See glTexParameter for details on texture
///     comparison.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalFormat'>Specifies the number of color components in the
/// texture. Must be one of base internal formats given in Table 1, one of the sized internal
/// formats given in Table 2, or one of the compressed internal formats given in Table 3,
/// below.</param> <param name='width'>Specifies the width of the texture image. All implementations
/// support texture images that are at least 1024 texels wide.</param> <param
/// name='height'>Specifies the height of the texture image, or the number of layers in a texture
/// array, in the case of the</param> <param name='border'>This value must be 0.</param> <param
/// name='format'>Specifies the format of the pixel data. The following symbolic values are
/// accepted:</param> <param name='type'>Specifies the data type of the pixel data. The following
/// symbolic values are accepted:</param> <param name='data'>Specifies a pointer to the image data
/// in memory.</param>
#define glTexImage2D glad_debug_glTexImage2D
    GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
    GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_debug_glTexImage2DMultisample;

/// <summary>
///   establish the data storage, format, dimensions, and number of samples of a multisample
///   texture's image <para>
///     glTexImage2DMultisample establishes the data storage, format, dimensions and number of
///     samples of a multisample texture's image. target must be GL_TEXTURE_2D_MULTISAMPLE or
///     GL_PROXY_TEXTURE_2D_MULTISAMPLE. width and height are the dimensions in texels of the
///     texture, and must be in the range zero to the value of GL_MAX_TEXTURE_SIZE minus one.
///     samples specifies the number of samples in the image and must be in the range zero to the
///     value of GL_MAX_SAMPLES minus one. internalformat must be a color-renderable,
///     depth-renderable, or stencil-renderable format. If fixedsamplelocations is GL_TRUE , the
///     image will use identical sample locations and the same number of samples for all texels in
///     the image, and the sample locations will not depend on the internal format or size of the
///     image. When a multisample texture is accessed in a shader, the access takes one vector of
///     integers describing which texel to fetch and an integer corresponding to the sample numbers
///     describing which sample within the texel to fetch. No standard sampling instructions are
///     allowed on the multisample texture targets.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target of the operation.</param>
/// <param name='samples'>The number of samples in the multisample texture's image.</param>
/// <param name='internalformat'>The internal format to be used to store the multisample texture's
/// image.</param> <param name='width'>The width of the multisample texture's image, in
/// texels.</param> <param name='height'>The height of the multisample texture's image, in
/// texels.</param> <param name='fixedsamplelocations'>Specifies whether the image will use
/// identical sample locations and the same number of samples for all texels in the image, and the
/// sample locations will not depend on the internal format or size of the image.</param>
#define glTexImage2DMultisample glad_debug_glTexImage2DMultisample
    GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTexImage2DMultisampleCoverageNV;
    GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC
        glad_debug_glTexImage2DMultisampleCoverageNV;
#define glTexImage2DMultisampleCoverageNV glad_debug_glTexImage2DMultisampleCoverageNV
    GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
    GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_debug_glTexImage3D;

/// <summary>
///   specify a three-dimensional texture image
///   <para>
///     Texturing maps a portion of a specified texture image onto each graphical primitive for
///     which texturing is enabled. To enable and disable three-dimensional texturing, call glEnable
///     and glDisable with argument GL_TEXTURE_3D. To define texture images, call glTexImage3D. The
///     arguments describe the parameters of the texture image, such as height, width, depth, width
///     of the border, level-of-detail number (see glTexParameter ), and number of color components
///     provided. The last three arguments describe how the image is represented in memory. If
///     target is GL_PROXY_TEXTURE_3D , no data is read from data , but all of the texture image
///     state is recalculated, checked for consistency, and checked against the implementation's
///     capabilities. If the implementation cannot handle a texture of the requested texture size,
///     it sets all of the image state to 0, but does not generate an error (see glGetError ). To
///     query for an entire mipmap array, use an image array level greater than or equal to 1. If
///     target is GL_TEXTURE_3D , data is read from data as a sequence of signed or unsigned bytes,
///     shorts, or longs, or single-precision floating-point values, depending on type. These values
///     are grouped into sets of one, two, three, or four values, depending on format , to form
///     elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by
///     GL_UNPACK_LSB_FIRST (see glPixelStore ). If a non-zero named buffer object is bound to the
///     GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is specified, data
///     is treated as a byte offset into the buffer object's data store. The first element
///     corresponds to the lower left corner of the texture image. Subsequent elements progress
///     left-to-right through the remaining texels in the lowest row of the texture image, and then
///     in successively higher rows of the texture image. The final element corresponds to the upper
///     right corner of the texture image. format determines the composition of each element in
///     data. It can assume one of these symbolic values: Each element is a single red component.
///     The GL converts it to floating point and assembles it into an RGBA element by attaching 0
///     for green and blue, and 1 for alpha. Each component is clamped to the range [0,1]. Each
///     element is a red and green pair. The GL converts each to floating point and assembles it
///     into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to
///     the range [0,1]. Each element is an RGB triple. The GL converts it to floating point and
///     assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the
///     range [0,1]. Each element contains all four components. Each component is clamped to the
///     range [0,1]. If an application wants to store the texture at a certain resolution or in a
///     certain format, it can request the resolution and format with internalFormat. The GL will
///     choose an internal representation that closely approximates that requested by internalFormat
///     , but it may not match exactly. (The representations specified by GL_RED , GL_RG , GL_RGB ,
///     and GL_RGBA must match exactly.) internalFormat may be one of the base internal formats
///     shown in Table 1, below internalFormat may also be one of the sized internal formats shown
///     in Table 2, below Finally, internalFormat may also be one of the generic or compressed
///     compressed texture formats shown in Table 3 below If the internalFormat parameter is one of
///     the generic compressed formats, GL_COMPRESSED_RED , GL_COMPRESSED_RG , GL_COMPRESSED_RGB ,
///     or GL_COMPRESSED_RGBA , the GL will replace the internal format with the symbolic constant
///     for a specific internal format and compress the texture before storage. If no corresponding
///     internal format is available, or the GL can not compress that image for any reason, the
///     internal format is instead replaced with a corresponding base internal format. If the
///     internalFormat parameter is GL_SRGB , GL_SRGB8 , GL_SRGB_ALPHA , or GL_SRGB8_ALPHA8 , the
///     texture is treated as if the red, green, blue, or luminance components are encoded in the
///     sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB
///     encoded component c s to a linear component c l is: c l = { c s 12.92 if c s ≤ 0.04045 ( c s
///     + 0.055 1.055 ) 2.4 if c s > 0.04045 Assume c s is the sRGB component in the range [0,1].
///     Use the GL_PROXY_TEXTURE_3D target to try out a resolution and format. The implementation
///     will update and recompute its best match for the requested storage resolution and format. To
///     then query this state, call glGetTexLevelParameter. If the texture cannot be accommodated,
///     texture state is set to 0. A one-component texture image uses only the red component of the
///     RGBA color extracted from data. A two-component image uses the R and A values. A
///     three-component image uses the R, G, and B values. A four-component image uses all of the
///     RGBA components.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target texture. Must be one of</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='internalFormat'>Specifies the number of color components in the
/// texture. Must be one of base internal formats given in Table 1, one of the sized internal
/// formats given in Table 2, or one of the compressed internal formats given in Table 3,
/// below.</param> <param name='width'>Specifies the width of the texture image. All implementations
/// support 3D texture images that are at least 16 texels wide.</param> <param
/// name='height'>Specifies the height of the texture image. All implementations support 3D texture
/// images that are at least 256 texels high.</param> <param name='depth'>Specifies the depth of the
/// texture image, or the number of layers in a texture array. All implementations support 3D
/// texture images that are at least 256 texels deep, and texture arrays that are at least 256
/// layers deep.</param> <param name='border'>This value must be 0.</param> <param
/// name='format'>Specifies the format of the pixel data. The following symbolic values are
/// accepted:</param> <param name='type'>Specifies the data type of the pixel data. The following
/// symbolic values are accepted:</param> <param name='data'>Specifies a pointer to the image data
/// in memory.</param>
#define glTexImage3D glad_debug_glTexImage3D
    GLAD_API_CALL PFNGLTEXIMAGE3DEXTPROC glad_glTexImage3DEXT;
    GLAD_API_CALL PFNGLTEXIMAGE3DEXTPROC glad_debug_glTexImage3DEXT;
#define glTexImage3DEXT glad_debug_glTexImage3DEXT
    GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
    GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_debug_glTexImage3DMultisample;

/// <summary>
///   establish the data storage, format, dimensions, and number of samples of a multisample
///   texture's image <para>
///     glTexImage3DMultisample establishes the data storage, format, dimensions and number of
///     samples of a multisample texture's image. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or
///     GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. width and height are the dimensions in texels of the
///     texture, and must be in the range zero to the value of GL_MAX_TEXTURE_SIZE minus one. depth
///     is the number of array slices in the array texture's image. samples specifies the number of
///     samples in the image and must be in the range zero to the value of GL_MAX_SAMPLES minus one.
///     internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
///     If fixedsamplelocations is GL_TRUE , the image will use identical sample locations and the
///     same number of samples for all texels in the image, and the sample locations will not depend
///     on the internal format or size of the image. When a multisample texture is accessed in a
///     shader, the access takes one vector of integers describing which texel to fetch and an
///     integer corresponding to the sample numbers describing which sample within the texel to
///     fetch. No standard sampling instructions are allowed on the multisample texture targets.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target of the operation.</param>
/// <param name='samples'>The number of samples in the multisample texture's image.</param>
/// <param name='internalformat'>The internal format to be used to store the multisample texture's
/// image.</param> <param name='width'>The width of the multisample texture's image, in
/// texels.</param> <param name='height'>The height of the multisample texture's image, in
/// texels.</param> <param name='fixedsamplelocations'>Specifies whether the image will use
/// identical sample locations and the same number of samples for all texels in the image, and the
/// sample locations will not depend on the internal format or size of the image.</param>
#define glTexImage3DMultisample glad_debug_glTexImage3DMultisample
    GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTexImage3DMultisampleCoverageNV;
    GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC
        glad_debug_glTexImage3DMultisampleCoverageNV;
#define glTexImage3DMultisampleCoverageNV glad_debug_glTexImage3DMultisampleCoverageNV
    GLAD_API_CALL PFNGLTEXIMAGE4DSGISPROC glad_glTexImage4DSGIS;
    GLAD_API_CALL PFNGLTEXIMAGE4DSGISPROC glad_debug_glTexImage4DSGIS;
#define glTexImage4DSGIS glad_debug_glTexImage4DSGIS
    GLAD_API_CALL PFNGLTEXPAGECOMMITMENTARBPROC glad_glTexPageCommitmentARB;
    GLAD_API_CALL PFNGLTEXPAGECOMMITMENTARBPROC glad_debug_glTexPageCommitmentARB;
#define glTexPageCommitmentARB glad_debug_glTexPageCommitmentARB
    GLAD_API_CALL PFNGLTEXPAGECOMMITMENTMEMNVPROC glad_glTexPageCommitmentMemNV;
    GLAD_API_CALL PFNGLTEXPAGECOMMITMENTMEMNVPROC glad_debug_glTexPageCommitmentMemNV;
#define glTexPageCommitmentMemNV glad_debug_glTexPageCommitmentMemNV
    GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
    GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_debug_glTexParameterIiv;
#define glTexParameterIiv glad_debug_glTexParameterIiv
    GLAD_API_CALL PFNGLTEXPARAMETERIIVEXTPROC glad_glTexParameterIivEXT;
    GLAD_API_CALL PFNGLTEXPARAMETERIIVEXTPROC glad_debug_glTexParameterIivEXT;
#define glTexParameterIivEXT glad_debug_glTexParameterIivEXT
    GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
    GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_debug_glTexParameterIuiv;
#define glTexParameterIuiv glad_debug_glTexParameterIuiv
    GLAD_API_CALL PFNGLTEXPARAMETERIUIVEXTPROC glad_glTexParameterIuivEXT;
    GLAD_API_CALL PFNGLTEXPARAMETERIUIVEXTPROC glad_debug_glTexParameterIuivEXT;
#define glTexParameterIuivEXT glad_debug_glTexParameterIuivEXT
    GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
    GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_debug_glTexParameterf;
#define glTexParameterf glad_debug_glTexParameterf
    GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
    GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_debug_glTexParameterfv;
#define glTexParameterfv glad_debug_glTexParameterfv
    GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
    GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_debug_glTexParameteri;
#define glTexParameteri glad_debug_glTexParameteri
    GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
    GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_debug_glTexParameteriv;
#define glTexParameteriv glad_debug_glTexParameteriv
    GLAD_API_CALL PFNGLTEXPARAMETERXOESPROC glad_glTexParameterxOES;
    GLAD_API_CALL PFNGLTEXPARAMETERXOESPROC glad_debug_glTexParameterxOES;
#define glTexParameterxOES glad_debug_glTexParameterxOES
    GLAD_API_CALL PFNGLTEXPARAMETERXVOESPROC glad_glTexParameterxvOES;
    GLAD_API_CALL PFNGLTEXPARAMETERXVOESPROC glad_debug_glTexParameterxvOES;
#define glTexParameterxvOES glad_debug_glTexParameterxvOES
    GLAD_API_CALL PFNGLTEXRENDERBUFFERNVPROC glad_glTexRenderbufferNV;
    GLAD_API_CALL PFNGLTEXRENDERBUFFERNVPROC glad_debug_glTexRenderbufferNV;
#define glTexRenderbufferNV glad_debug_glTexRenderbufferNV
    GLAD_API_CALL PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;
    GLAD_API_CALL PFNGLTEXSTORAGE1DPROC glad_debug_glTexStorage1D;

/// <summary>
///   simultaneously specify storage for all levels of a one-dimensional texture
///   <para>
///     glTexStorage1D and glTextureStorage1D specify the storage requirements for all levels of a
///     one-dimensional texture simultaneously. Once a texture is specified with this command, the
///     format and dimensions of all levels become immutable unless it is a proxy texture. The
///     contents of the image may still be modified, however, its storage requirements may not
///     change. Such a texture is referred to as an immutable-format texture. Calling glTexStorage1D
///     is equivalent, assuming no errors are generated, to executing the following pseudo-code:
///     Calling glTextureStorage1D is equivalent to the above pseudo-code, where target is the
///     effective target of texture and it is as if texture were bound to target for the purposes of
///     glTexImage1D. Since no texture data is actually provided, the values used in the pseudo-code
///     for format and type are irrelevant and may be considered to be any values that are legal for
///     the chosen internalformat enumerant. internalformat must be one of the sized internal
///     formats given in Table 1 below, one of the sized depth-component formats
///     GL_DEPTH_COMPONENT32F , GL_DEPTH_COMPONENT24 , or GL_DEPTH_COMPONENT16 , one of the combined
///     depth-stencil formats, GL_DEPTH32F_STENCIL8 , or GL_DEPTH24_STENCIL8 , or the stencil-only
///     format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
///     GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling
///     glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT. No further changes to the
///     dimensions or format of the texture object may be made. Using any command that might alter
///     the dimensions or format of the texture object (such as glTexImage1D or another call to
///     glTexStorage1D ) will result in the generation of a GL_INVALID_OPERATION error, even if it
///     would not, in fact, alter the dimensions or format of the object.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='levels'>Specify the number of texture levels.</param>
/// <param name='internalformat'>Specifies the sized internal format to be used to store texture
/// image data.</param> <param name='width'>Specifies the width of the texture, in texels.</param>
#define glTexStorage1D glad_debug_glTexStorage1D
    GLAD_API_CALL PFNGLTEXSTORAGE1DEXTPROC glad_glTexStorage1DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGE1DEXTPROC glad_debug_glTexStorage1DEXT;
#define glTexStorage1DEXT glad_debug_glTexStorage1DEXT
    GLAD_API_CALL PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;
    GLAD_API_CALL PFNGLTEXSTORAGE2DPROC glad_debug_glTexStorage2D;

/// <summary>
///   simultaneously specify storage for all levels of a two-dimensional or one-dimensional array
///   texture <para>
///     glTexStorage2D and glTextureStorage2D specify the storage requirements for all levels of a
///     two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is
///     specified with this command, the format and dimensions of all levels become immutable unless
///     it is a proxy texture. The contents of the image may still be modified, however, its storage
///     requirements may not change. Such a texture is referred to as an immutable-format texture.
///     The behavior of glTexStorage2D depends on the target parameter. When target is GL_TEXTURE_2D
///     , GL_PROXY_TEXTURE_2D , GL_TEXTURE_RECTANGLE , GL_PROXY_TEXTURE_RECTANGLE or
///     GL_PROXY_TEXTURE_CUBE_MAP , calling glTexStorage2D is equivalent, assuming no errors are
///     generated, to executing the following pseudo-code: When target is GL_TEXTURE_CUBE_MAP ,
///     glTexStorage2D is equivalent to: When target is GL_TEXTURE_1D or GL_TEXTURE_1D_ARRAY ,
///     glTexStorage2D is equivalent to: Calling glTextureStorage2D is equivalent to the above
///     pseudo-code, where target is the effective target of texture and it is as if texture were
///     bound to target for the purposes of glTexImage2D. Since no texture data is actually
///     provided, the values used in the pseudo-code for format and type are irrelevant and may be
///     considered to be any values that are legal for the chosen internalformat enumerant.
///     internalformat must be one of the sized internal formats given in Table 1 below, one of the
///     sized depth-component formats GL_DEPTH_COMPONENT32F , GL_DEPTH_COMPONENT24 , or
///     GL_DEPTH_COMPONENT16 , one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8 , or
///     GL_DEPTH24_STENCIL8 , or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value
///     of GL_TEXTURE_IMMUTABLE_FORMAT becomes GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may
///     be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT. No
///     further changes to the dimensions or format of the texture object may be made. Using any
///     command that might alter the dimensions or format of the texture object (such as
///     glTexImage2D or another call to glTexStorage2D ) will result in the generation of a
///     GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions or format of
///     the object.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='levels'>Specify the number of texture levels.</param>
/// <param name='internalformat'>Specifies the sized internal format to be used to store texture
/// image data.</param> <param name='width'>Specifies the width of the texture, in texels.</param>
/// <param name='height'>Specifies the height of the texture, in texels.</param>
#define glTexStorage2D glad_debug_glTexStorage2D
    GLAD_API_CALL PFNGLTEXSTORAGE2DEXTPROC glad_glTexStorage2DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGE2DEXTPROC glad_debug_glTexStorage2DEXT;
#define glTexStorage2DEXT glad_debug_glTexStorage2DEXT
    GLAD_API_CALL PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;
    GLAD_API_CALL PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_debug_glTexStorage2DMultisample;

/// <summary>
///   specify storage for a two-dimensional multisample texture
///   <para>
///     glTexStorage2DMultisample and glTextureStorage2DMultisample specify the storage requirements
///     for a two-dimensional multisample texture. Once a texture is specified with this command,
///     its format and dimensions become immutable unless it is a proxy texture. The contents of the
///     image may still be modified, however, its storage requirements may not change. Such a
///     texture is referred to as an immutable-format texture. samples specifies the number of
///     samples to be used for the texture and must be greater than zero and less than or equal to
///     the value of GL_MAX_SAMPLES. internalformat must be a color-renderable, depth-renderable, or
///     stencil-renderable format. width and height specify the width and height, respectively, of
///     the texture. If fixedsamplelocations is GL_TRUE , the image will use identical sample
///     locations and the same number of samples for all texels in the image, and the sample
///     locations will not depend on the internal format or size of the image.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='samples'>Specify the number of samples in the texture.</param>
/// <param name='internalformat'>Specifies the sized internal format to be used to store texture
/// image data.</param> <param name='width'>Specifies the width of the texture, in texels.</param>
/// <param name='height'>Specifies the height of the texture, in texels.</param>
/// <param name='fixedsamplelocations'>Specifies whether the image will use identical sample
/// locations and the same number of samples for all texels in the image, and the sample locations
/// will not depend on the internal format or size of the image.</param>
#define glTexStorage2DMultisample glad_debug_glTexStorage2DMultisample
    GLAD_API_CALL PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;
    GLAD_API_CALL PFNGLTEXSTORAGE3DPROC glad_debug_glTexStorage3D;

/// <summary>
///   simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or
///   cube-map array texture <para>
///     glTexStorage3D and glTextureStorage3D specify specify the storage requirements for all
///     levels of a three-dimensional, two-dimensional array or cube-map array texture
///     simultaneously. Once a texture is specified with this command, the format and dimensions of
///     all levels become immutable unless it is a proxy texture. The contents of the image may
///     still be modified, however, its storage requirements may not change. Such a texture is
///     referred to as an immutable-format texture. The behavior of glTexStorage3D depends on the
///     target parameter. When target is GL_TEXTURE_3D , or GL_PROXY_TEXTURE_3D , calling
///     glTexStorage3D is equivalent, assuming no errors are generated, to executing the following
///     pseudo-code: When target is GL_TEXTURE_2D_ARRAY , GL_PROXY_TEXTURE_2D_ARRAY ,
///     GL_TEXTURE_CUBE_MAP_ARRAY , or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY , glTexStorage3D is
///     equivalent to: Calling glTextureStorage3D is equivalent to the above pseudo-code, where
///     target is the effective target of texture and it is as if texture were bound to target for
///     the purposes of glTexImage3D. Since no texture data is actually provided, the values used in
///     the pseudo-code for format and type are irrelevant and may be considered to be any values
///     that are legal for the chosen internalformat enumerant. internalformat must be one of the
///     sized internal formats given in Table 1 below, one of the sized depth-component formats
///     GL_DEPTH_COMPONENT32F , GL_DEPTH_COMPONENT24 , or GL_DEPTH_COMPONENT16 , one of the combined
///     depth-stencil formats, GL_DEPTH32F_STENCIL8 , or GL_DEPTH24_STENCIL8 , or the stencil-only
///     format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
///     GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling
///     glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT. No further changes to the
///     dimensions or format of the texture object may be made. Using any command that might alter
///     the dimensions or format of the texture object (such as glTexImage3D or another call to
///     glTexStorage3D ) will result in the generation of a GL_INVALID_OPERATION error, even if it
///     would not, in fact, alter the dimensions or format of the object.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='levels'>Specify the number of texture levels.</param>
/// <param name='internalformat'>Specifies the sized internal format to be used to store texture
/// image data.</param> <param name='width'>Specifies the width of the texture, in texels.</param>
/// <param name='height'>Specifies the height of the texture, in texels.</param>
/// <param name='depth'>Specifies the depth of the texture, in texels.</param>
#define glTexStorage3D glad_debug_glTexStorage3D
    GLAD_API_CALL PFNGLTEXSTORAGE3DEXTPROC glad_glTexStorage3DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGE3DEXTPROC glad_debug_glTexStorage3DEXT;
#define glTexStorage3DEXT glad_debug_glTexStorage3DEXT
    GLAD_API_CALL PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;
    GLAD_API_CALL PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_debug_glTexStorage3DMultisample;

/// <summary>
///   specify storage for a two-dimensional multisample array texture
///   <para>
///     glTexStorage3DMultisample and glTextureStorage3DMultisample specify the storage requirements
///     for a two-dimensional multisample array texture. Once a texture is specified with this
///     command, its format and dimensions become immutable unless it is a proxy texture. The
///     contents of the image may still be modified, however, its storage requirements may not
///     change. Such a texture is referred to as an immutable-format texture. samples specifies the
///     number of samples to be used for the texture and must be greater than zero and less than or
///     equal to the value of GL_MAX_SAMPLES. internalformat must be a color-renderable,
///     depth-renderable, or stencil-renderable format. width and height specify the width and
///     height, respectively, of the texture and depth specifies the depth (or the number of layers)
///     of the texture. If fixedsamplelocations is GL_TRUE , the image will use identical sample
///     locations and the same number of samples for all texels in the image, and the sample
///     locations will not depend on the internal format or size of the image.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture object is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='samples'>Specify the number of samples in the texture.</param>
/// <param name='internalformat'>Specifies the sized internal format to be used to store texture
/// image data.</param> <param name='width'>Specifies the width of the texture, in texels.</param>
/// <param name='height'>Specifies the height of the texture, in texels.</param>
/// <param name='depth'>Specifies the depth of the texture, in layers.</param>
/// <param name='fixedsamplelocations'>Specifies whether the image will use identical sample
/// locations and the same number of samples for all texels in the image, and the sample locations
/// will not depend on the internal format or size of the image.</param>
#define glTexStorage3DMultisample glad_debug_glTexStorage3DMultisample
    GLAD_API_CALL PFNGLTEXSTORAGEMEM1DEXTPROC glad_glTexStorageMem1DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGEMEM1DEXTPROC glad_debug_glTexStorageMem1DEXT;
#define glTexStorageMem1DEXT glad_debug_glTexStorageMem1DEXT
    GLAD_API_CALL PFNGLTEXSTORAGEMEM2DEXTPROC glad_glTexStorageMem2DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGEMEM2DEXTPROC glad_debug_glTexStorageMem2DEXT;
#define glTexStorageMem2DEXT glad_debug_glTexStorageMem2DEXT
    GLAD_API_CALL PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTexStorageMem2DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_debug_glTexStorageMem2DMultisampleEXT;
#define glTexStorageMem2DMultisampleEXT glad_debug_glTexStorageMem2DMultisampleEXT
    GLAD_API_CALL PFNGLTEXSTORAGEMEM3DEXTPROC glad_glTexStorageMem3DEXT;
    GLAD_API_CALL PFNGLTEXSTORAGEMEM3DEXTPROC glad_debug_glTexStorageMem3DEXT;
#define glTexStorageMem3DEXT glad_debug_glTexStorageMem3DEXT
    GLAD_API_CALL PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTexStorageMem3DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_debug_glTexStorageMem3DMultisampleEXT;
#define glTexStorageMem3DMultisampleEXT glad_debug_glTexStorageMem3DMultisampleEXT
    GLAD_API_CALL PFNGLTEXSTORAGESPARSEAMDPROC glad_glTexStorageSparseAMD;
    GLAD_API_CALL PFNGLTEXSTORAGESPARSEAMDPROC glad_debug_glTexStorageSparseAMD;
#define glTexStorageSparseAMD glad_debug_glTexStorageSparseAMD
    GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
    GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_debug_glTexSubImage1D;

/// <summary>
///   specify a one-dimensional texture subimage
///   <para>
///     Texturing maps a portion of a specified texture image onto each graphical primitive for
///     which texturing is enabled. To enable or disable one-dimensional texturing, call glEnable
///     and glDisable with argument GL_TEXTURE_1D. glTexSubImage1D and glTextureSubImage1D redefine
///     a contiguous subregion of an existing one-dimensional texture image. The texels referenced
///     by pixels replace the portion of the existing texture array with x indices xoffset and
///     xoffset + width - 1 , inclusive. This region may not include any texels outside the range of
///     the texture array as it was originally specified. It is not an error to specify a subtexture
///     with width of 0, but such a specification has no effect. If a non-zero named buffer object
///     is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is
///     specified, pixels is treated as a byte offset into the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='width'>Specifies the width of the texture subimage.</param>
/// <param name='format'>Specifies the format of the pixel data. The following symbolic values are
/// accepted:</param> <param name='type'>Specifies the data type of the pixel data. The following
/// symbolic values are accepted:</param> <param name='pixels'>Specifies a pointer to the image data
/// in memory.</param>
#define glTexSubImage1D glad_debug_glTexSubImage1D
    GLAD_API_CALL PFNGLTEXSUBIMAGE1DEXTPROC glad_glTexSubImage1DEXT;
    GLAD_API_CALL PFNGLTEXSUBIMAGE1DEXTPROC glad_debug_glTexSubImage1DEXT;
#define glTexSubImage1DEXT glad_debug_glTexSubImage1DEXT
    GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
    GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_debug_glTexSubImage2D;

/// <summary>
///   specify a two-dimensional texture subimage
///   <para>
///     Texturing maps a portion of a specified texture image onto each graphical primitive for
///     which texturing is enabled. glTexSubImage2D and glTextureSubImage2D redefine a contiguous
///     subregion of an existing two-dimensional or one-dimensional array texture image. The texels
///     referenced by pixels replace the portion of the existing texture array with x indices
///     xoffset and xoffset + width - 1 , inclusive, and y indices yoffset and yoffset + height - 1
///     , inclusive. This region may not include any texels outside the range of the texture array
///     as it was originally specified. It is not an error to specify a subtexture with zero width
///     or height, but such a specification has no effect. If a non-zero named buffer object is
///     bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer ) while a texture image is
///     specified, pixels is treated as a byte offset into the buffer object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='width'>Specifies the width of the texture
/// subimage.</param> <param name='height'>Specifies the height of the texture subimage.</param>
/// <param name='format'>Specifies the format of the pixel data. The following symbolic values are
/// accepted:</param> <param name='type'>Specifies the data type of the pixel data. The following
/// symbolic values are accepted:</param> <param name='pixels'>Specifies a pointer to the image data
/// in memory.</param>
#define glTexSubImage2D glad_debug_glTexSubImage2D
    GLAD_API_CALL PFNGLTEXSUBIMAGE2DEXTPROC glad_glTexSubImage2DEXT;
    GLAD_API_CALL PFNGLTEXSUBIMAGE2DEXTPROC glad_debug_glTexSubImage2DEXT;
#define glTexSubImage2DEXT glad_debug_glTexSubImage2DEXT
    GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
    GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_debug_glTexSubImage3D;

/// <summary>
///   specify a three-dimensional texture subimage
///   <para>
///     Texturing maps a portion of a specified texture image onto each graphical primitive for
///     which texturing is enabled. glTexSubImage3D and glTextureSubImage3D redefine a contiguous
///     subregion of an existing three-dimensional or two-dimensioanl array texture image. The
///     texels referenced by pixels replace the portion of the existing texture array with x indices
///     xoffset and xoffset + width - 1 , inclusive, y indices yoffset and yoffset + height - 1 ,
///     inclusive, and z indices zoffset and zoffset + depth - 1 , inclusive. For three-dimensional
///     textures, the z index refers to the third dimension. For two-dimensional array textures, the
///     z index refers to the slice index. This region may not include any texels outside the range
///     of the texture array as it was originally specified. It is not an error to specify a
///     subtexture with zero width, height, or depth but such a specification has no effect. If a
///     non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer
///     ) while a texture image is specified, pixels is treated as a byte offset into the buffer
///     object's data store.
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the texture is bound for</param>
/// <param name='texture'>Specifies the texture object name for</param>
/// <param name='level'>Specifies the level-of-detail number. Level 0 is the base image level.
/// Level</param> <param name='xoffset'>Specifies a texel offset in the x direction within the
/// texture array.</param> <param name='yoffset'>Specifies a texel offset in the y direction within
/// the texture array.</param> <param name='zoffset'>Specifies a texel offset in the z direction
/// within the texture array.</param> <param name='width'>Specifies the width of the texture
/// subimage.</param> <param name='height'>Specifies the height of the texture subimage.</param>
/// <param name='depth'>Specifies the depth of the texture subimage.</param>
/// <param name='format'>Specifies the format of the pixel data. The following symbolic values are
/// accepted:</param> <param name='type'>Specifies the data type of the pixel data. The following
/// symbolic values are accepted:</param> <param name='pixels'>Specifies a pointer to the image data
/// in memory.</param>
#define glTexSubImage3D glad_debug_glTexSubImage3D
    GLAD_API_CALL PFNGLTEXSUBIMAGE3DEXTPROC glad_glTexSubImage3DEXT;
    GLAD_API_CALL PFNGLTEXSUBIMAGE3DEXTPROC glad_debug_glTexSubImage3DEXT;
#define glTexSubImage3DEXT glad_debug_glTexSubImage3DEXT
    GLAD_API_CALL PFNGLTEXSUBIMAGE4DSGISPROC glad_glTexSubImage4DSGIS;
    GLAD_API_CALL PFNGLTEXSUBIMAGE4DSGISPROC glad_debug_glTexSubImage4DSGIS;
#define glTexSubImage4DSGIS glad_debug_glTexSubImage4DSGIS
    GLAD_API_CALL PFNGLTEXTUREATTACHMEMORYNVPROC glad_glTextureAttachMemoryNV;
    GLAD_API_CALL PFNGLTEXTUREATTACHMEMORYNVPROC glad_debug_glTextureAttachMemoryNV;
#define glTextureAttachMemoryNV glad_debug_glTextureAttachMemoryNV
    GLAD_API_CALL PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;
    GLAD_API_CALL PFNGLTEXTUREBARRIERPROC glad_debug_glTextureBarrier;

/// <summary>
///   controls the ordering of reads and writes to rendered fragments across drawing commands
///   <para>
///     The values of rendered fragments are undefined when a shader stage fetches texels and the
///     same texels are written via fragment shader outputs, even if the reads and writes are not in
///     the same drawing command. To safely read the result of a written texel via a texel fetch in
///     a subsequent drawing command, call glTextureBarrier between the two drawing commands to
///     guarantee that writes have completed and caches have been invalidated before subsequent
///     drawing commands are executed.
///   </para>
/// </summary>
#define glTextureBarrier glad_debug_glTextureBarrier
    GLAD_API_CALL PFNGLTEXTUREBARRIERNVPROC glad_glTextureBarrierNV;
    GLAD_API_CALL PFNGLTEXTUREBARRIERNVPROC glad_debug_glTextureBarrierNV;
#define glTextureBarrierNV glad_debug_glTextureBarrierNV
    GLAD_API_CALL PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;
    GLAD_API_CALL PFNGLTEXTUREBUFFERPROC glad_debug_glTextureBuffer;
#define glTextureBuffer glad_debug_glTextureBuffer
    GLAD_API_CALL PFNGLTEXTUREBUFFEREXTPROC glad_glTextureBufferEXT;
    GLAD_API_CALL PFNGLTEXTUREBUFFEREXTPROC glad_debug_glTextureBufferEXT;
#define glTextureBufferEXT glad_debug_glTextureBufferEXT
    GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;
    GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEPROC glad_debug_glTextureBufferRange;
#define glTextureBufferRange glad_debug_glTextureBufferRange
    GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEEXTPROC glad_glTextureBufferRangeEXT;
    GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEEXTPROC glad_debug_glTextureBufferRangeEXT;
#define glTextureBufferRangeEXT glad_debug_glTextureBufferRangeEXT
    GLAD_API_CALL PFNGLTEXTURECOLORMASKSGISPROC glad_glTextureColorMaskSGIS;
    GLAD_API_CALL PFNGLTEXTURECOLORMASKSGISPROC glad_debug_glTextureColorMaskSGIS;
#define glTextureColorMaskSGIS glad_debug_glTextureColorMaskSGIS
    GLAD_API_CALL PFNGLTEXTUREIMAGE1DEXTPROC glad_glTextureImage1DEXT;
    GLAD_API_CALL PFNGLTEXTUREIMAGE1DEXTPROC glad_debug_glTextureImage1DEXT;
#define glTextureImage1DEXT glad_debug_glTextureImage1DEXT
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DEXTPROC glad_glTextureImage2DEXT;
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DEXTPROC glad_debug_glTextureImage2DEXT;
#define glTextureImage2DEXT glad_debug_glTextureImage2DEXT
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC
        glad_glTextureImage2DMultisampleCoverageNV;
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC
        glad_debug_glTextureImage2DMultisampleCoverageNV;
#define glTextureImage2DMultisampleCoverageNV glad_debug_glTextureImage2DMultisampleCoverageNV
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_glTextureImage2DMultisampleNV;
    GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_debug_glTextureImage2DMultisampleNV;
#define glTextureImage2DMultisampleNV glad_debug_glTextureImage2DMultisampleNV
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DEXTPROC glad_glTextureImage3DEXT;
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DEXTPROC glad_debug_glTextureImage3DEXT;
#define glTextureImage3DEXT glad_debug_glTextureImage3DEXT
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC
        glad_glTextureImage3DMultisampleCoverageNV;
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC
        glad_debug_glTextureImage3DMultisampleCoverageNV;
#define glTextureImage3DMultisampleCoverageNV glad_debug_glTextureImage3DMultisampleCoverageNV
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_glTextureImage3DMultisampleNV;
    GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_debug_glTextureImage3DMultisampleNV;
#define glTextureImage3DMultisampleNV glad_debug_glTextureImage3DMultisampleNV
    GLAD_API_CALL PFNGLTEXTURELIGHTEXTPROC glad_glTextureLightEXT;
    GLAD_API_CALL PFNGLTEXTURELIGHTEXTPROC glad_debug_glTextureLightEXT;
#define glTextureLightEXT glad_debug_glTextureLightEXT
    GLAD_API_CALL PFNGLTEXTUREMATERIALEXTPROC glad_glTextureMaterialEXT;
    GLAD_API_CALL PFNGLTEXTUREMATERIALEXTPROC glad_debug_glTextureMaterialEXT;
#define glTextureMaterialEXT glad_debug_glTextureMaterialEXT
    GLAD_API_CALL PFNGLTEXTURENORMALEXTPROC glad_glTextureNormalEXT;
    GLAD_API_CALL PFNGLTEXTURENORMALEXTPROC glad_debug_glTextureNormalEXT;
#define glTextureNormalEXT glad_debug_glTextureNormalEXT
    GLAD_API_CALL PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_glTexturePageCommitmentEXT;
    GLAD_API_CALL PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_debug_glTexturePageCommitmentEXT;
#define glTexturePageCommitmentEXT glad_debug_glTexturePageCommitmentEXT
    GLAD_API_CALL PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC glad_glTexturePageCommitmentMemNV;
    GLAD_API_CALL PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC glad_debug_glTexturePageCommitmentMemNV;
#define glTexturePageCommitmentMemNV glad_debug_glTexturePageCommitmentMemNV
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVPROC glad_debug_glTextureParameterIiv;
#define glTextureParameterIiv glad_debug_glTextureParameterIiv
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVEXTPROC glad_glTextureParameterIivEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVEXTPROC glad_debug_glTextureParameterIivEXT;
#define glTextureParameterIivEXT glad_debug_glTextureParameterIivEXT
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVPROC glad_debug_glTextureParameterIuiv;
#define glTextureParameterIuiv glad_debug_glTextureParameterIuiv
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_glTextureParameterIuivEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_debug_glTextureParameterIuivEXT;
#define glTextureParameterIuivEXT glad_debug_glTextureParameterIuivEXT
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFPROC glad_debug_glTextureParameterf;
#define glTextureParameterf glad_debug_glTextureParameterf
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFEXTPROC glad_glTextureParameterfEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFEXTPROC glad_debug_glTextureParameterfEXT;
#define glTextureParameterfEXT glad_debug_glTextureParameterfEXT
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFVPROC glad_debug_glTextureParameterfv;
#define glTextureParameterfv glad_debug_glTextureParameterfv
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFVEXTPROC glad_glTextureParameterfvEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERFVEXTPROC glad_debug_glTextureParameterfvEXT;
#define glTextureParameterfvEXT glad_debug_glTextureParameterfvEXT
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIPROC glad_debug_glTextureParameteri;
#define glTextureParameteri glad_debug_glTextureParameteri
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIEXTPROC glad_glTextureParameteriEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIEXTPROC glad_debug_glTextureParameteriEXT;
#define glTextureParameteriEXT glad_debug_glTextureParameteriEXT
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIVPROC glad_debug_glTextureParameteriv;
#define glTextureParameteriv glad_debug_glTextureParameteriv
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIVEXTPROC glad_glTextureParameterivEXT;
    GLAD_API_CALL PFNGLTEXTUREPARAMETERIVEXTPROC glad_debug_glTextureParameterivEXT;
#define glTextureParameterivEXT glad_debug_glTextureParameterivEXT
    GLAD_API_CALL PFNGLTEXTURERANGEAPPLEPROC glad_glTextureRangeAPPLE;
    GLAD_API_CALL PFNGLTEXTURERANGEAPPLEPROC glad_debug_glTextureRangeAPPLE;
#define glTextureRangeAPPLE glad_debug_glTextureRangeAPPLE
    GLAD_API_CALL PFNGLTEXTURERENDERBUFFEREXTPROC glad_glTextureRenderbufferEXT;
    GLAD_API_CALL PFNGLTEXTURERENDERBUFFEREXTPROC glad_debug_glTextureRenderbufferEXT;
#define glTextureRenderbufferEXT glad_debug_glTextureRenderbufferEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;
    GLAD_API_CALL PFNGLTEXTURESTORAGE1DPROC glad_debug_glTextureStorage1D;
#define glTextureStorage1D glad_debug_glTextureStorage1D
    GLAD_API_CALL PFNGLTEXTURESTORAGE1DEXTPROC glad_glTextureStorage1DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGE1DEXTPROC glad_debug_glTextureStorage1DEXT;
#define glTextureStorage1DEXT glad_debug_glTextureStorage1DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DPROC glad_debug_glTextureStorage2D;
#define glTextureStorage2D glad_debug_glTextureStorage2D
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DEXTPROC glad_glTextureStorage2DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DEXTPROC glad_debug_glTextureStorage2DEXT;
#define glTextureStorage2DEXT glad_debug_glTextureStorage2DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_debug_glTextureStorage2DMultisample;
#define glTextureStorage2DMultisample glad_debug_glTextureStorage2DMultisample
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glad_glTextureStorage2DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC
        glad_debug_glTextureStorage2DMultisampleEXT;
#define glTextureStorage2DMultisampleEXT glad_debug_glTextureStorage2DMultisampleEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DPROC glad_debug_glTextureStorage3D;
#define glTextureStorage3D glad_debug_glTextureStorage3D
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DEXTPROC glad_glTextureStorage3DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DEXTPROC glad_debug_glTextureStorage3DEXT;
#define glTextureStorage3DEXT glad_debug_glTextureStorage3DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_debug_glTextureStorage3DMultisample;
#define glTextureStorage3DMultisample glad_debug_glTextureStorage3DMultisample
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glad_glTextureStorage3DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC
        glad_debug_glTextureStorage3DMultisampleEXT;
#define glTextureStorage3DMultisampleEXT glad_debug_glTextureStorage3DMultisampleEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_glTextureStorageMem1DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_debug_glTextureStorageMem1DEXT;
#define glTextureStorageMem1DEXT glad_debug_glTextureStorageMem1DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_glTextureStorageMem2DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_debug_glTextureStorageMem2DEXT;
#define glTextureStorageMem2DEXT glad_debug_glTextureStorageMem2DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC
        glad_glTextureStorageMem2DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC
        glad_debug_glTextureStorageMem2DMultisampleEXT;
#define glTextureStorageMem2DMultisampleEXT glad_debug_glTextureStorageMem2DMultisampleEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_glTextureStorageMem3DEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_debug_glTextureStorageMem3DEXT;
#define glTextureStorageMem3DEXT glad_debug_glTextureStorageMem3DEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC
        glad_glTextureStorageMem3DMultisampleEXT;
    GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC
        glad_debug_glTextureStorageMem3DMultisampleEXT;
#define glTextureStorageMem3DMultisampleEXT glad_debug_glTextureStorageMem3DMultisampleEXT
    GLAD_API_CALL PFNGLTEXTURESTORAGESPARSEAMDPROC glad_glTextureStorageSparseAMD;
    GLAD_API_CALL PFNGLTEXTURESTORAGESPARSEAMDPROC glad_debug_glTextureStorageSparseAMD;
#define glTextureStorageSparseAMD glad_debug_glTextureStorageSparseAMD
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DPROC glad_debug_glTextureSubImage1D;
#define glTextureSubImage1D glad_debug_glTextureSubImage1D
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DEXTPROC glad_glTextureSubImage1DEXT;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DEXTPROC glad_debug_glTextureSubImage1DEXT;
#define glTextureSubImage1DEXT glad_debug_glTextureSubImage1DEXT
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DPROC glad_debug_glTextureSubImage2D;
#define glTextureSubImage2D glad_debug_glTextureSubImage2D
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DEXTPROC glad_glTextureSubImage2DEXT;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DEXTPROC glad_debug_glTextureSubImage2DEXT;
#define glTextureSubImage2DEXT glad_debug_glTextureSubImage2DEXT
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DPROC glad_debug_glTextureSubImage3D;
#define glTextureSubImage3D glad_debug_glTextureSubImage3D
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DEXTPROC glad_glTextureSubImage3DEXT;
    GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DEXTPROC glad_debug_glTextureSubImage3DEXT;
#define glTextureSubImage3DEXT glad_debug_glTextureSubImage3DEXT
    GLAD_API_CALL PFNGLTEXTUREVIEWPROC glad_glTextureView;
    GLAD_API_CALL PFNGLTEXTUREVIEWPROC glad_debug_glTextureView;

/// <summary>
///   initialize a texture as a data alias of another texture's data store
///   <para>
///     glTextureView initializes a texture object as an alias, or view of another texture object,
///     sharing some or all of the parent texture's data store with the initialized texture. texture
///     specifies a name previously reserved by a successful call to glGenTextures but that has not
///     yet been bound or given a target. target specifies the target for the newly initialized
///     texture and must be compatible with the target of the parent texture, given in origtexture
///     as specified in the following table: The value of GL_TEXTURE_IMMUTABLE_FORMAT for
///     origtexture must be GL_TRUE. After initialization, texture inherits the data store of the
///     parent texture, origtexture and is usable as a normal texture object with target target.
///     Data in the shared store is reinterpreted with the new internal format specified by
///     internalformat. internalformat must be compatible with the internal format of the parent
///     texture as specified in the following table: If the original texture is an array or has
///     multiple mipmap levels, the parameters minlayer , numlayers , minlevel , and numlevels
///     control which of those slices and levels are considered part of the texture. The minlevel
///     and minlayer parameters are relative to the view of the original texture. If numlayers or
///     numlevels extend beyond the original texture, they are clamped to the max extent of the
///     original texture. If the new texture's target is GL_TEXTURE_CUBE_MAP , the clamped numlayers
///     must be equal to 6. If the new texture's target is GL_TEXTURE_CUBE_MAP_ARRAY , then
///     numlayers counts layer-faces rather than layers, and the clamped numlayers must be a
///     multiple of 6. If the new texture's target is GL_TEXTURE_CUBE_MAP or
///     GL_TEXTURE_CUBE_MAP_ARRAY , the width and height of the original texture's levels must be
///     equal. When the original texture's target is GL_TEXTURE_CUBE_MAP , the layer parameters are
///     interpreted in the same order as if it were a GL_TEXTURE_CUBE_MAP_ARRAY with 6 layer-faces.
///     If target is GL_TEXTURE_1D , GL_TEXTURE_2D , GL_TEXTURE_3D , GL_TEXTURE_RECTANGLE , or
///     GL_TEXTURE_2D_MULTISAMPLE , numlayers must equal 1. The dimensions of the original texture
///     must be less than or equal to the maximum supported dimensions of the new target. For
///     example, if the original texture has a GL_TEXTURE_2D_ARRAY target and its width is greater
///     than GL_MAX_CUBE_MAP_TEXTURE_SIZE , an error will be generated if glTextureView is called to
///     create a GL_TEXTURE_CUBE_MAP view. Texture commands that take a level or layer parameter,
///     such as glTexSubImage2D , interpret that parameter to be relative to the view of the
///     texture. i.e. the mipmap level of the data store that would be updated via TexSubImage2D
///     would be the sum of level and the value of GL_TEXTURE_VIEW_MIN_LEVEL.
///   </para>
/// </summary>
/// <param name='texture'>Specifies the texture object to be initialized as a view.</param>
/// <param name='target'>Specifies the target to be used for the newly initialized texture.</param>
/// <param name='origtexture'>Specifies the name of a texture object of which to make a
/// view.</param> <param name='internalFormat'>Specifies the internal format for the newly created
/// view.</param> <param name='minlevel'>Specifies lowest level of detail of the view.</param>
/// <param name='numlevels'>Specifies the number of levels of detail to include in the view.</param>
/// <param name='minlayer'>Specifies the index of the first layer to include in the view.</param>
/// <param name='numlayers'>Specifies the number of layers to include in the view.</param>
#define glTextureView glad_debug_glTextureView
    GLAD_API_CALL PFNGLTRACKMATRIXNVPROC glad_glTrackMatrixNV;
    GLAD_API_CALL PFNGLTRACKMATRIXNVPROC glad_debug_glTrackMatrixNV;
#define glTrackMatrixNV glad_debug_glTrackMatrixNV
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_glTransformFeedbackAttribsNV;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_debug_glTransformFeedbackAttribsNV;
#define glTransformFeedbackAttribsNV glad_debug_glTransformFeedbackAttribsNV
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_debug_glTransformFeedbackBufferBase;

/// <summary>
///   bind a buffer object to a transform feedback buffer object
///   <para>
///     glTransformFeedbackBufferBase binds the buffer object buffer to the binding point at index
///     index of the transform feedback object xfb.
///   </para>
/// </summary>
/// <param name='xfb'>Name of the transform feedback buffer object.</param>
/// <param name='index'>Index of the binding point within</param>
/// <param name='buffer'>Name of the buffer object to bind to the specified binding point.</param>
#define glTransformFeedbackBufferBase glad_debug_glTransformFeedbackBufferBase
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_debug_glTransformFeedbackBufferRange;

/// <summary>
///   bind a range within a buffer object to a transform feedback buffer object
///   <para>
///     glTransformFeedbackBufferRange binds a range of the buffer object buffer represented by
///     offset and size to the binding point at index index of the transform feedback object xfb.
///     offset specifies the offset in basic machine units into the buffer object buffer and size
///     specifies the amount of data that can be read from the buffer object while used as an
///     indexed target.
///   </para>
/// </summary>
/// <param name='xfb'>Name of the transform feedback buffer object.</param>
/// <param name='index'>Index of the binding point within</param>
/// <param name='buffer'>Name of the buffer object to bind to the specified binding point.</param>
/// <param name='offset'>The starting offset in basic machine units into the buffer object.</param>
/// <param name='size'>The amount of data in basic machine units that can be read from or written to
/// the buffer object while used as an indexed target.</param>
#define glTransformFeedbackBufferRange glad_debug_glTransformFeedbackBufferRange
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC glad_glTransformFeedbackStreamAttribsNV;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC
        glad_debug_glTransformFeedbackStreamAttribsNV;
#define glTransformFeedbackStreamAttribsNV glad_debug_glTransformFeedbackStreamAttribsNV
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_debug_glTransformFeedbackVaryings;

/// <summary>
///   specify values to record in transform feedback buffers
///   <para>
///     The names of the vertex or geometry shader outputs to be recorded in transform feedback mode
///     are specified using glTransformFeedbackVaryings. When a geometry shader is active, transform
///     feedback records the values of selected geometry shader output variables from the emitted
///     vertices. Otherwise, the values of the selected vertex shader outputs are recorded. The
///     state set by glTranformFeedbackVaryings is stored and takes effect next time glLinkProgram
///     is called on program. When glLinkProgram is called, program is linked so that the values of
///     the specified varying variables for the vertices of each primitive generated by the GL are
///     written to a single buffer object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple buffer
///     objects if bufferMode is GL_SEPARATE_ATTRIBS. In addition to the errors generated by
///     glTransformFeedbackVaryings , the program program will fail to link if: The count specified
///     by glTransformFeedbackVaryings is non-zero, but the program object has no vertex or geometry
///     shader. Any variable name specified in the varyings array is not declared as an output in
///     the vertex shader (or the geometry shader, if active). Any two entries in the varyings array
///     specify the same varying variable. The total number of components to capture in any varying
///     variable in varyings is greater than the constant
///     GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS and the buffer mode is GL_SEPARATE_ATTRIBS.
///     The total number of components to capture is greater than the constant
///     GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer mode is
///     GL_INTERLEAVED_ATTRIBS.
///   </para>
/// </summary>
/// <param name='program'>The name of the target program object.</param>
/// <param name='count'>The number of varying variables used for transform feedback.</param>
/// <param name='varyings'>An array of</param>
/// <param name='bufferMode'>Identifies the mode used to capture the varying variables when
/// transform feedback is active.</param>
#define glTransformFeedbackVaryings glad_debug_glTransformFeedbackVaryings
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_glTransformFeedbackVaryingsEXT;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_debug_glTransformFeedbackVaryingsEXT;
#define glTransformFeedbackVaryingsEXT glad_debug_glTransformFeedbackVaryingsEXT
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_glTransformFeedbackVaryingsNV;
    GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_debug_glTransformFeedbackVaryingsNV;
#define glTransformFeedbackVaryingsNV glad_debug_glTransformFeedbackVaryingsNV
    GLAD_API_CALL PFNGLTRANSFORMPATHNVPROC glad_glTransformPathNV;
    GLAD_API_CALL PFNGLTRANSFORMPATHNVPROC glad_debug_glTransformPathNV;
#define glTransformPathNV glad_debug_glTransformPathNV
    GLAD_API_CALL PFNGLTRANSLATEXOESPROC glad_glTranslatexOES;
    GLAD_API_CALL PFNGLTRANSLATEXOESPROC glad_debug_glTranslatexOES;
#define glTranslatexOES glad_debug_glTranslatexOES
    GLAD_API_CALL PFNGLUNIFORM1DPROC glad_glUniform1d;
    GLAD_API_CALL PFNGLUNIFORM1DPROC glad_debug_glUniform1d;
#define glUniform1d glad_debug_glUniform1d
    GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_glUniform1dv;
    GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_debug_glUniform1dv;
#define glUniform1dv glad_debug_glUniform1dv
    GLAD_API_CALL PFNGLUNIFORM1FPROC glad_glUniform1f;
    GLAD_API_CALL PFNGLUNIFORM1FPROC glad_debug_glUniform1f;
#define glUniform1f glad_debug_glUniform1f
    GLAD_API_CALL PFNGLUNIFORM1FARBPROC glad_glUniform1fARB;
    GLAD_API_CALL PFNGLUNIFORM1FARBPROC glad_debug_glUniform1fARB;
#define glUniform1fARB glad_debug_glUniform1fARB
    GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_glUniform1fv;
    GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_debug_glUniform1fv;
#define glUniform1fv glad_debug_glUniform1fv
    GLAD_API_CALL PFNGLUNIFORM1FVARBPROC glad_glUniform1fvARB;
    GLAD_API_CALL PFNGLUNIFORM1FVARBPROC glad_debug_glUniform1fvARB;
#define glUniform1fvARB glad_debug_glUniform1fvARB
    GLAD_API_CALL PFNGLUNIFORM1IPROC glad_glUniform1i;
    GLAD_API_CALL PFNGLUNIFORM1IPROC glad_debug_glUniform1i;
#define glUniform1i glad_debug_glUniform1i
    GLAD_API_CALL PFNGLUNIFORM1I64ARBPROC glad_glUniform1i64ARB;
    GLAD_API_CALL PFNGLUNIFORM1I64ARBPROC glad_debug_glUniform1i64ARB;
#define glUniform1i64ARB glad_debug_glUniform1i64ARB
    GLAD_API_CALL PFNGLUNIFORM1I64NVPROC glad_glUniform1i64NV;
    GLAD_API_CALL PFNGLUNIFORM1I64NVPROC glad_debug_glUniform1i64NV;
#define glUniform1i64NV glad_debug_glUniform1i64NV
    GLAD_API_CALL PFNGLUNIFORM1I64VARBPROC glad_glUniform1i64vARB;
    GLAD_API_CALL PFNGLUNIFORM1I64VARBPROC glad_debug_glUniform1i64vARB;
#define glUniform1i64vARB glad_debug_glUniform1i64vARB
    GLAD_API_CALL PFNGLUNIFORM1I64VNVPROC glad_glUniform1i64vNV;
    GLAD_API_CALL PFNGLUNIFORM1I64VNVPROC glad_debug_glUniform1i64vNV;
#define glUniform1i64vNV glad_debug_glUniform1i64vNV
    GLAD_API_CALL PFNGLUNIFORM1IARBPROC glad_glUniform1iARB;
    GLAD_API_CALL PFNGLUNIFORM1IARBPROC glad_debug_glUniform1iARB;
#define glUniform1iARB glad_debug_glUniform1iARB
    GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_glUniform1iv;
    GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_debug_glUniform1iv;
#define glUniform1iv glad_debug_glUniform1iv
    GLAD_API_CALL PFNGLUNIFORM1IVARBPROC glad_glUniform1ivARB;
    GLAD_API_CALL PFNGLUNIFORM1IVARBPROC glad_debug_glUniform1ivARB;
#define glUniform1ivARB glad_debug_glUniform1ivARB
    GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_glUniform1ui;
    GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_debug_glUniform1ui;
#define glUniform1ui glad_debug_glUniform1ui
    GLAD_API_CALL PFNGLUNIFORM1UI64ARBPROC glad_glUniform1ui64ARB;
    GLAD_API_CALL PFNGLUNIFORM1UI64ARBPROC glad_debug_glUniform1ui64ARB;
#define glUniform1ui64ARB glad_debug_glUniform1ui64ARB
    GLAD_API_CALL PFNGLUNIFORM1UI64NVPROC glad_glUniform1ui64NV;
    GLAD_API_CALL PFNGLUNIFORM1UI64NVPROC glad_debug_glUniform1ui64NV;
#define glUniform1ui64NV glad_debug_glUniform1ui64NV
    GLAD_API_CALL PFNGLUNIFORM1UI64VARBPROC glad_glUniform1ui64vARB;
    GLAD_API_CALL PFNGLUNIFORM1UI64VARBPROC glad_debug_glUniform1ui64vARB;
#define glUniform1ui64vARB glad_debug_glUniform1ui64vARB
    GLAD_API_CALL PFNGLUNIFORM1UI64VNVPROC glad_glUniform1ui64vNV;
    GLAD_API_CALL PFNGLUNIFORM1UI64VNVPROC glad_debug_glUniform1ui64vNV;
#define glUniform1ui64vNV glad_debug_glUniform1ui64vNV
    GLAD_API_CALL PFNGLUNIFORM1UIEXTPROC glad_glUniform1uiEXT;
    GLAD_API_CALL PFNGLUNIFORM1UIEXTPROC glad_debug_glUniform1uiEXT;
#define glUniform1uiEXT glad_debug_glUniform1uiEXT
    GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
    GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_debug_glUniform1uiv;
#define glUniform1uiv glad_debug_glUniform1uiv
    GLAD_API_CALL PFNGLUNIFORM1UIVEXTPROC glad_glUniform1uivEXT;
    GLAD_API_CALL PFNGLUNIFORM1UIVEXTPROC glad_debug_glUniform1uivEXT;
#define glUniform1uivEXT glad_debug_glUniform1uivEXT
    GLAD_API_CALL PFNGLUNIFORM2DPROC glad_glUniform2d;
    GLAD_API_CALL PFNGLUNIFORM2DPROC glad_debug_glUniform2d;
#define glUniform2d glad_debug_glUniform2d
    GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_glUniform2dv;
    GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_debug_glUniform2dv;
#define glUniform2dv glad_debug_glUniform2dv
    GLAD_API_CALL PFNGLUNIFORM2FPROC glad_glUniform2f;
    GLAD_API_CALL PFNGLUNIFORM2FPROC glad_debug_glUniform2f;
#define glUniform2f glad_debug_glUniform2f
    GLAD_API_CALL PFNGLUNIFORM2FARBPROC glad_glUniform2fARB;
    GLAD_API_CALL PFNGLUNIFORM2FARBPROC glad_debug_glUniform2fARB;
#define glUniform2fARB glad_debug_glUniform2fARB
    GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_glUniform2fv;
    GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_debug_glUniform2fv;
#define glUniform2fv glad_debug_glUniform2fv
    GLAD_API_CALL PFNGLUNIFORM2FVARBPROC glad_glUniform2fvARB;
    GLAD_API_CALL PFNGLUNIFORM2FVARBPROC glad_debug_glUniform2fvARB;
#define glUniform2fvARB glad_debug_glUniform2fvARB
    GLAD_API_CALL PFNGLUNIFORM2IPROC glad_glUniform2i;
    GLAD_API_CALL PFNGLUNIFORM2IPROC glad_debug_glUniform2i;
#define glUniform2i glad_debug_glUniform2i
    GLAD_API_CALL PFNGLUNIFORM2I64ARBPROC glad_glUniform2i64ARB;
    GLAD_API_CALL PFNGLUNIFORM2I64ARBPROC glad_debug_glUniform2i64ARB;
#define glUniform2i64ARB glad_debug_glUniform2i64ARB
    GLAD_API_CALL PFNGLUNIFORM2I64NVPROC glad_glUniform2i64NV;
    GLAD_API_CALL PFNGLUNIFORM2I64NVPROC glad_debug_glUniform2i64NV;
#define glUniform2i64NV glad_debug_glUniform2i64NV
    GLAD_API_CALL PFNGLUNIFORM2I64VARBPROC glad_glUniform2i64vARB;
    GLAD_API_CALL PFNGLUNIFORM2I64VARBPROC glad_debug_glUniform2i64vARB;
#define glUniform2i64vARB glad_debug_glUniform2i64vARB
    GLAD_API_CALL PFNGLUNIFORM2I64VNVPROC glad_glUniform2i64vNV;
    GLAD_API_CALL PFNGLUNIFORM2I64VNVPROC glad_debug_glUniform2i64vNV;
#define glUniform2i64vNV glad_debug_glUniform2i64vNV
    GLAD_API_CALL PFNGLUNIFORM2IARBPROC glad_glUniform2iARB;
    GLAD_API_CALL PFNGLUNIFORM2IARBPROC glad_debug_glUniform2iARB;
#define glUniform2iARB glad_debug_glUniform2iARB
    GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_glUniform2iv;
    GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_debug_glUniform2iv;
#define glUniform2iv glad_debug_glUniform2iv
    GLAD_API_CALL PFNGLUNIFORM2IVARBPROC glad_glUniform2ivARB;
    GLAD_API_CALL PFNGLUNIFORM2IVARBPROC glad_debug_glUniform2ivARB;
#define glUniform2ivARB glad_debug_glUniform2ivARB
    GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_glUniform2ui;
    GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_debug_glUniform2ui;
#define glUniform2ui glad_debug_glUniform2ui
    GLAD_API_CALL PFNGLUNIFORM2UI64ARBPROC glad_glUniform2ui64ARB;
    GLAD_API_CALL PFNGLUNIFORM2UI64ARBPROC glad_debug_glUniform2ui64ARB;
#define glUniform2ui64ARB glad_debug_glUniform2ui64ARB
    GLAD_API_CALL PFNGLUNIFORM2UI64NVPROC glad_glUniform2ui64NV;
    GLAD_API_CALL PFNGLUNIFORM2UI64NVPROC glad_debug_glUniform2ui64NV;
#define glUniform2ui64NV glad_debug_glUniform2ui64NV
    GLAD_API_CALL PFNGLUNIFORM2UI64VARBPROC glad_glUniform2ui64vARB;
    GLAD_API_CALL PFNGLUNIFORM2UI64VARBPROC glad_debug_glUniform2ui64vARB;
#define glUniform2ui64vARB glad_debug_glUniform2ui64vARB
    GLAD_API_CALL PFNGLUNIFORM2UI64VNVPROC glad_glUniform2ui64vNV;
    GLAD_API_CALL PFNGLUNIFORM2UI64VNVPROC glad_debug_glUniform2ui64vNV;
#define glUniform2ui64vNV glad_debug_glUniform2ui64vNV
    GLAD_API_CALL PFNGLUNIFORM2UIEXTPROC glad_glUniform2uiEXT;
    GLAD_API_CALL PFNGLUNIFORM2UIEXTPROC glad_debug_glUniform2uiEXT;
#define glUniform2uiEXT glad_debug_glUniform2uiEXT
    GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
    GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_debug_glUniform2uiv;
#define glUniform2uiv glad_debug_glUniform2uiv
    GLAD_API_CALL PFNGLUNIFORM2UIVEXTPROC glad_glUniform2uivEXT;
    GLAD_API_CALL PFNGLUNIFORM2UIVEXTPROC glad_debug_glUniform2uivEXT;
#define glUniform2uivEXT glad_debug_glUniform2uivEXT
    GLAD_API_CALL PFNGLUNIFORM3DPROC glad_glUniform3d;
    GLAD_API_CALL PFNGLUNIFORM3DPROC glad_debug_glUniform3d;
#define glUniform3d glad_debug_glUniform3d
    GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_glUniform3dv;
    GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_debug_glUniform3dv;
#define glUniform3dv glad_debug_glUniform3dv
    GLAD_API_CALL PFNGLUNIFORM3FPROC glad_glUniform3f;
    GLAD_API_CALL PFNGLUNIFORM3FPROC glad_debug_glUniform3f;
#define glUniform3f glad_debug_glUniform3f
    GLAD_API_CALL PFNGLUNIFORM3FARBPROC glad_glUniform3fARB;
    GLAD_API_CALL PFNGLUNIFORM3FARBPROC glad_debug_glUniform3fARB;
#define glUniform3fARB glad_debug_glUniform3fARB
    GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_glUniform3fv;
    GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_debug_glUniform3fv;
#define glUniform3fv glad_debug_glUniform3fv
    GLAD_API_CALL PFNGLUNIFORM3FVARBPROC glad_glUniform3fvARB;
    GLAD_API_CALL PFNGLUNIFORM3FVARBPROC glad_debug_glUniform3fvARB;
#define glUniform3fvARB glad_debug_glUniform3fvARB
    GLAD_API_CALL PFNGLUNIFORM3IPROC glad_glUniform3i;
    GLAD_API_CALL PFNGLUNIFORM3IPROC glad_debug_glUniform3i;
#define glUniform3i glad_debug_glUniform3i
    GLAD_API_CALL PFNGLUNIFORM3I64ARBPROC glad_glUniform3i64ARB;
    GLAD_API_CALL PFNGLUNIFORM3I64ARBPROC glad_debug_glUniform3i64ARB;
#define glUniform3i64ARB glad_debug_glUniform3i64ARB
    GLAD_API_CALL PFNGLUNIFORM3I64NVPROC glad_glUniform3i64NV;
    GLAD_API_CALL PFNGLUNIFORM3I64NVPROC glad_debug_glUniform3i64NV;
#define glUniform3i64NV glad_debug_glUniform3i64NV
    GLAD_API_CALL PFNGLUNIFORM3I64VARBPROC glad_glUniform3i64vARB;
    GLAD_API_CALL PFNGLUNIFORM3I64VARBPROC glad_debug_glUniform3i64vARB;
#define glUniform3i64vARB glad_debug_glUniform3i64vARB
    GLAD_API_CALL PFNGLUNIFORM3I64VNVPROC glad_glUniform3i64vNV;
    GLAD_API_CALL PFNGLUNIFORM3I64VNVPROC glad_debug_glUniform3i64vNV;
#define glUniform3i64vNV glad_debug_glUniform3i64vNV
    GLAD_API_CALL PFNGLUNIFORM3IARBPROC glad_glUniform3iARB;
    GLAD_API_CALL PFNGLUNIFORM3IARBPROC glad_debug_glUniform3iARB;
#define glUniform3iARB glad_debug_glUniform3iARB
    GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_glUniform3iv;
    GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_debug_glUniform3iv;
#define glUniform3iv glad_debug_glUniform3iv
    GLAD_API_CALL PFNGLUNIFORM3IVARBPROC glad_glUniform3ivARB;
    GLAD_API_CALL PFNGLUNIFORM3IVARBPROC glad_debug_glUniform3ivARB;
#define glUniform3ivARB glad_debug_glUniform3ivARB
    GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_glUniform3ui;
    GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_debug_glUniform3ui;
#define glUniform3ui glad_debug_glUniform3ui
    GLAD_API_CALL PFNGLUNIFORM3UI64ARBPROC glad_glUniform3ui64ARB;
    GLAD_API_CALL PFNGLUNIFORM3UI64ARBPROC glad_debug_glUniform3ui64ARB;
#define glUniform3ui64ARB glad_debug_glUniform3ui64ARB
    GLAD_API_CALL PFNGLUNIFORM3UI64NVPROC glad_glUniform3ui64NV;
    GLAD_API_CALL PFNGLUNIFORM3UI64NVPROC glad_debug_glUniform3ui64NV;
#define glUniform3ui64NV glad_debug_glUniform3ui64NV
    GLAD_API_CALL PFNGLUNIFORM3UI64VARBPROC glad_glUniform3ui64vARB;
    GLAD_API_CALL PFNGLUNIFORM3UI64VARBPROC glad_debug_glUniform3ui64vARB;
#define glUniform3ui64vARB glad_debug_glUniform3ui64vARB
    GLAD_API_CALL PFNGLUNIFORM3UI64VNVPROC glad_glUniform3ui64vNV;
    GLAD_API_CALL PFNGLUNIFORM3UI64VNVPROC glad_debug_glUniform3ui64vNV;
#define glUniform3ui64vNV glad_debug_glUniform3ui64vNV
    GLAD_API_CALL PFNGLUNIFORM3UIEXTPROC glad_glUniform3uiEXT;
    GLAD_API_CALL PFNGLUNIFORM3UIEXTPROC glad_debug_glUniform3uiEXT;
#define glUniform3uiEXT glad_debug_glUniform3uiEXT
    GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
    GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_debug_glUniform3uiv;
#define glUniform3uiv glad_debug_glUniform3uiv
    GLAD_API_CALL PFNGLUNIFORM3UIVEXTPROC glad_glUniform3uivEXT;
    GLAD_API_CALL PFNGLUNIFORM3UIVEXTPROC glad_debug_glUniform3uivEXT;
#define glUniform3uivEXT glad_debug_glUniform3uivEXT
    GLAD_API_CALL PFNGLUNIFORM4DPROC glad_glUniform4d;
    GLAD_API_CALL PFNGLUNIFORM4DPROC glad_debug_glUniform4d;
#define glUniform4d glad_debug_glUniform4d
    GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_glUniform4dv;
    GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_debug_glUniform4dv;
#define glUniform4dv glad_debug_glUniform4dv
    GLAD_API_CALL PFNGLUNIFORM4FPROC glad_glUniform4f;
    GLAD_API_CALL PFNGLUNIFORM4FPROC glad_debug_glUniform4f;
#define glUniform4f glad_debug_glUniform4f
    GLAD_API_CALL PFNGLUNIFORM4FARBPROC glad_glUniform4fARB;
    GLAD_API_CALL PFNGLUNIFORM4FARBPROC glad_debug_glUniform4fARB;
#define glUniform4fARB glad_debug_glUniform4fARB
    GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_glUniform4fv;
    GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_debug_glUniform4fv;
#define glUniform4fv glad_debug_glUniform4fv
    GLAD_API_CALL PFNGLUNIFORM4FVARBPROC glad_glUniform4fvARB;
    GLAD_API_CALL PFNGLUNIFORM4FVARBPROC glad_debug_glUniform4fvARB;
#define glUniform4fvARB glad_debug_glUniform4fvARB
    GLAD_API_CALL PFNGLUNIFORM4IPROC glad_glUniform4i;
    GLAD_API_CALL PFNGLUNIFORM4IPROC glad_debug_glUniform4i;
#define glUniform4i glad_debug_glUniform4i
    GLAD_API_CALL PFNGLUNIFORM4I64ARBPROC glad_glUniform4i64ARB;
    GLAD_API_CALL PFNGLUNIFORM4I64ARBPROC glad_debug_glUniform4i64ARB;
#define glUniform4i64ARB glad_debug_glUniform4i64ARB
    GLAD_API_CALL PFNGLUNIFORM4I64NVPROC glad_glUniform4i64NV;
    GLAD_API_CALL PFNGLUNIFORM4I64NVPROC glad_debug_glUniform4i64NV;
#define glUniform4i64NV glad_debug_glUniform4i64NV
    GLAD_API_CALL PFNGLUNIFORM4I64VARBPROC glad_glUniform4i64vARB;
    GLAD_API_CALL PFNGLUNIFORM4I64VARBPROC glad_debug_glUniform4i64vARB;
#define glUniform4i64vARB glad_debug_glUniform4i64vARB
    GLAD_API_CALL PFNGLUNIFORM4I64VNVPROC glad_glUniform4i64vNV;
    GLAD_API_CALL PFNGLUNIFORM4I64VNVPROC glad_debug_glUniform4i64vNV;
#define glUniform4i64vNV glad_debug_glUniform4i64vNV
    GLAD_API_CALL PFNGLUNIFORM4IARBPROC glad_glUniform4iARB;
    GLAD_API_CALL PFNGLUNIFORM4IARBPROC glad_debug_glUniform4iARB;
#define glUniform4iARB glad_debug_glUniform4iARB
    GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_glUniform4iv;
    GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_debug_glUniform4iv;
#define glUniform4iv glad_debug_glUniform4iv
    GLAD_API_CALL PFNGLUNIFORM4IVARBPROC glad_glUniform4ivARB;
    GLAD_API_CALL PFNGLUNIFORM4IVARBPROC glad_debug_glUniform4ivARB;
#define glUniform4ivARB glad_debug_glUniform4ivARB
    GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_glUniform4ui;
    GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_debug_glUniform4ui;
#define glUniform4ui glad_debug_glUniform4ui
    GLAD_API_CALL PFNGLUNIFORM4UI64ARBPROC glad_glUniform4ui64ARB;
    GLAD_API_CALL PFNGLUNIFORM4UI64ARBPROC glad_debug_glUniform4ui64ARB;
#define glUniform4ui64ARB glad_debug_glUniform4ui64ARB
    GLAD_API_CALL PFNGLUNIFORM4UI64NVPROC glad_glUniform4ui64NV;
    GLAD_API_CALL PFNGLUNIFORM4UI64NVPROC glad_debug_glUniform4ui64NV;
#define glUniform4ui64NV glad_debug_glUniform4ui64NV
    GLAD_API_CALL PFNGLUNIFORM4UI64VARBPROC glad_glUniform4ui64vARB;
    GLAD_API_CALL PFNGLUNIFORM4UI64VARBPROC glad_debug_glUniform4ui64vARB;
#define glUniform4ui64vARB glad_debug_glUniform4ui64vARB
    GLAD_API_CALL PFNGLUNIFORM4UI64VNVPROC glad_glUniform4ui64vNV;
    GLAD_API_CALL PFNGLUNIFORM4UI64VNVPROC glad_debug_glUniform4ui64vNV;
#define glUniform4ui64vNV glad_debug_glUniform4ui64vNV
    GLAD_API_CALL PFNGLUNIFORM4UIEXTPROC glad_glUniform4uiEXT;
    GLAD_API_CALL PFNGLUNIFORM4UIEXTPROC glad_debug_glUniform4uiEXT;
#define glUniform4uiEXT glad_debug_glUniform4uiEXT
    GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
    GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_debug_glUniform4uiv;
#define glUniform4uiv glad_debug_glUniform4uiv
    GLAD_API_CALL PFNGLUNIFORM4UIVEXTPROC glad_glUniform4uivEXT;
    GLAD_API_CALL PFNGLUNIFORM4UIVEXTPROC glad_debug_glUniform4uivEXT;
#define glUniform4uivEXT glad_debug_glUniform4uivEXT
    GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
    GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_debug_glUniformBlockBinding;

/// <summary>
///   assign a binding point to an active uniform block
///   <para>
///     Binding points for active uniform blocks are assigned using glUniformBlockBinding. Each of a
///     program's active uniform blocks has a corresponding uniform buffer binding point. program is
///     the name of a program object for which the command glLinkProgram has been issued in the
///     past. If successful, glUniformBlockBinding specifies that program will use the data store of
///     the buffer object bound to the binding point uniformBlockBinding to extract the values of
///     the uniforms in the uniform block identified by uniformBlockIndex. When a program object is
///     linked or re-linked, the uniform buffer object binding point assigned to each of its active
///     uniform blocks is reset to zero.
///   </para>
/// </summary>
/// <param name='program'>The name of a program object containing the active uniform block whose
/// binding to assign.</param> <param name='uniformBlockIndex'>The index of the active uniform block
/// within</param> <param name='uniformBlockBinding'>Specifies the binding point to which to bind
/// the uniform block with index</param>
#define glUniformBlockBinding glad_debug_glUniformBlockBinding
    GLAD_API_CALL PFNGLUNIFORMBUFFEREXTPROC glad_glUniformBufferEXT;
    GLAD_API_CALL PFNGLUNIFORMBUFFEREXTPROC glad_debug_glUniformBufferEXT;
#define glUniformBufferEXT glad_debug_glUniformBufferEXT
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64ARBPROC glad_glUniformHandleui64ARB;
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64ARBPROC glad_debug_glUniformHandleui64ARB;
#define glUniformHandleui64ARB glad_debug_glUniformHandleui64ARB
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64NVPROC glad_glUniformHandleui64NV;
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64NVPROC glad_debug_glUniformHandleui64NV;
#define glUniformHandleui64NV glad_debug_glUniformHandleui64NV
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VARBPROC glad_glUniformHandleui64vARB;
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VARBPROC glad_debug_glUniformHandleui64vARB;
#define glUniformHandleui64vARB glad_debug_glUniformHandleui64vARB
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VNVPROC glad_glUniformHandleui64vNV;
    GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VNVPROC glad_debug_glUniformHandleui64vNV;
#define glUniformHandleui64vNV glad_debug_glUniformHandleui64vNV
    GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_debug_glUniformMatrix2dv;
#define glUniformMatrix2dv glad_debug_glUniformMatrix2dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_debug_glUniformMatrix2fv;
#define glUniformMatrix2fv glad_debug_glUniformMatrix2fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX2FVARBPROC glad_glUniformMatrix2fvARB;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2FVARBPROC glad_debug_glUniformMatrix2fvARB;
#define glUniformMatrix2fvARB glad_debug_glUniformMatrix2fvARB
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_debug_glUniformMatrix2x3dv;
#define glUniformMatrix2x3dv glad_debug_glUniformMatrix2x3dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_debug_glUniformMatrix2x3fv;
#define glUniformMatrix2x3fv glad_debug_glUniformMatrix2x3fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_debug_glUniformMatrix2x4dv;
#define glUniformMatrix2x4dv glad_debug_glUniformMatrix2x4dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_debug_glUniformMatrix2x4fv;
#define glUniformMatrix2x4fv glad_debug_glUniformMatrix2x4fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_debug_glUniformMatrix3dv;
#define glUniformMatrix3dv glad_debug_glUniformMatrix3dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_debug_glUniformMatrix3fv;
#define glUniformMatrix3fv glad_debug_glUniformMatrix3fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3FVARBPROC glad_glUniformMatrix3fvARB;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3FVARBPROC glad_debug_glUniformMatrix3fvARB;
#define glUniformMatrix3fvARB glad_debug_glUniformMatrix3fvARB
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_debug_glUniformMatrix3x2dv;
#define glUniformMatrix3x2dv glad_debug_glUniformMatrix3x2dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_debug_glUniformMatrix3x2fv;
#define glUniformMatrix3x2fv glad_debug_glUniformMatrix3x2fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_debug_glUniformMatrix3x4dv;
#define glUniformMatrix3x4dv glad_debug_glUniformMatrix3x4dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_debug_glUniformMatrix3x4fv;
#define glUniformMatrix3x4fv glad_debug_glUniformMatrix3x4fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_debug_glUniformMatrix4dv;
#define glUniformMatrix4dv glad_debug_glUniformMatrix4dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_debug_glUniformMatrix4fv;
#define glUniformMatrix4fv glad_debug_glUniformMatrix4fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4FVARBPROC glad_glUniformMatrix4fvARB;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4FVARBPROC glad_debug_glUniformMatrix4fvARB;
#define glUniformMatrix4fvARB glad_debug_glUniformMatrix4fvARB
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_debug_glUniformMatrix4x2dv;
#define glUniformMatrix4x2dv glad_debug_glUniformMatrix4x2dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_debug_glUniformMatrix4x2fv;
#define glUniformMatrix4x2fv glad_debug_glUniformMatrix4x2fv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_debug_glUniformMatrix4x3dv;
#define glUniformMatrix4x3dv glad_debug_glUniformMatrix4x3dv
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
    GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_debug_glUniformMatrix4x3fv;
#define glUniformMatrix4x3fv glad_debug_glUniformMatrix4x3fv
    GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
    GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_debug_glUniformSubroutinesuiv;
#define glUniformSubroutinesuiv glad_debug_glUniformSubroutinesuiv
    GLAD_API_CALL PFNGLUNIFORMUI64NVPROC glad_glUniformui64NV;
    GLAD_API_CALL PFNGLUNIFORMUI64NVPROC glad_debug_glUniformui64NV;
#define glUniformui64NV glad_debug_glUniformui64NV
    GLAD_API_CALL PFNGLUNIFORMUI64VNVPROC glad_glUniformui64vNV;
    GLAD_API_CALL PFNGLUNIFORMUI64VNVPROC glad_debug_glUniformui64vNV;
#define glUniformui64vNV glad_debug_glUniformui64vNV
    GLAD_API_CALL PFNGLUNLOCKARRAYSEXTPROC glad_glUnlockArraysEXT;
    GLAD_API_CALL PFNGLUNLOCKARRAYSEXTPROC glad_debug_glUnlockArraysEXT;
#define glUnlockArraysEXT glad_debug_glUnlockArraysEXT
    GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
    GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_debug_glUnmapBuffer;

/// <summary>
///   release the mapping of a buffer object's data store into the client's address space
///   <para>
///     glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer
///     object into the client's address space (see glMapBufferRange and glMapBuffer ). If a mapping
///     is not unmapped before the corresponding buffer object's data store is used by the GL, an
///     error will be generated by any GL command that attempts to dereference the buffer object's
///     data store, unless the buffer was successfully mapped with GL_MAP_PERSISTENT_BIT (see
///     glMapBufferRange ). When a data store is unmapped, the mapped pointer becomes invalid.
///     glUnmapBuffer returns GL_TRUE unless the data store contents have become corrupt during the
///     time the data store was mapped. This can occur for system-specific reasons that affect the
///     availability of graphics memory, such as screen mode changes. In such situations, GL_FALSE
///     is returned and the data store contents are undefined. An application must detect this rare
///     condition and reinitialize the data store. A buffer object's mapped data store is
///     automatically unmapped when the buffer object is deleted or its data store is recreated with
///     glBufferData ).
///   </para>
/// </summary>
/// <param name='target'>Specifies the target to which the buffer object is bound for</param>
/// <param name='buffer'>Specifies the name of the buffer object for</param>
#define glUnmapBuffer glad_debug_glUnmapBuffer
    GLAD_API_CALL PFNGLUNMAPBUFFERARBPROC glad_glUnmapBufferARB;
    GLAD_API_CALL PFNGLUNMAPBUFFERARBPROC glad_debug_glUnmapBufferARB;
#define glUnmapBufferARB glad_debug_glUnmapBufferARB
    GLAD_API_CALL PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;
    GLAD_API_CALL PFNGLUNMAPNAMEDBUFFERPROC glad_debug_glUnmapNamedBuffer;
#define glUnmapNamedBuffer glad_debug_glUnmapNamedBuffer
    GLAD_API_CALL PFNGLUNMAPNAMEDBUFFEREXTPROC glad_glUnmapNamedBufferEXT;
    GLAD_API_CALL PFNGLUNMAPNAMEDBUFFEREXTPROC glad_debug_glUnmapNamedBufferEXT;
#define glUnmapNamedBufferEXT glad_debug_glUnmapNamedBufferEXT
    GLAD_API_CALL PFNGLUNMAPOBJECTBUFFERATIPROC glad_glUnmapObjectBufferATI;
    GLAD_API_CALL PFNGLUNMAPOBJECTBUFFERATIPROC glad_debug_glUnmapObjectBufferATI;
#define glUnmapObjectBufferATI glad_debug_glUnmapObjectBufferATI
    GLAD_API_CALL PFNGLUNMAPTEXTURE2DINTELPROC glad_glUnmapTexture2DINTEL;
    GLAD_API_CALL PFNGLUNMAPTEXTURE2DINTELPROC glad_debug_glUnmapTexture2DINTEL;
#define glUnmapTexture2DINTEL glad_debug_glUnmapTexture2DINTEL
    GLAD_API_CALL PFNGLUPDATEOBJECTBUFFERATIPROC glad_glUpdateObjectBufferATI;
    GLAD_API_CALL PFNGLUPDATEOBJECTBUFFERATIPROC glad_debug_glUpdateObjectBufferATI;
#define glUpdateObjectBufferATI glad_debug_glUpdateObjectBufferATI
    GLAD_API_CALL PFNGLUPLOADGPUMASKNVXPROC glad_glUploadGpuMaskNVX;
    GLAD_API_CALL PFNGLUPLOADGPUMASKNVXPROC glad_debug_glUploadGpuMaskNVX;
#define glUploadGpuMaskNVX glad_debug_glUploadGpuMaskNVX
    GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_glUseProgram;
    GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_debug_glUseProgram;

/// <summary>
///   Installs a program object as part of current rendering state
///   <para>
///     glUseProgram installs the program object specified by program as part of current rendering
///     state. One or more executables are created in a program object by successfully attaching
///     shader objects to it with glAttachShader , successfully compiling the shader objects with
///     glCompileShader , and successfully linking the program object with glLinkProgram. A program
///     object will contain an executable that will run on the vertex processor if it contains one
///     or more shader objects of type GL_VERTEX_SHADER that have been successfully compiled and
///     linked. A program object will contain an executable that will run on the geometry processor
///     if it contains one or more shader objects of type GL_GEOMETRY_SHADER that have been
///     successfully compiled and linked. Similarly, a program object will contain an executable
///     that will run on the fragment processor if it contains one or more shader objects of type
///     GL_FRAGMENT_SHADER that have been successfully compiled and linked. While a program object
///     is in use, applications are free to modify attached shader objects, compile attached shader
///     objects, attach additional shader objects, and detach or delete shader objects. None of
///     these operations will affect the executables that are part of the current state. However,
///     relinking the program object that is currently in use will install the program object as
///     part of the current rendering state if the link operation was successful (see glLinkProgram
///     ). If the program object currently in use is relinked unsuccessfully, its link status will
///     be set to GL_FALSE , but the executables and associated state will remain part of the
///     current state until a subsequent call to glUseProgram removes it from use. After it is
///     removed from use, it cannot be made part of current state until it has been successfully
///     relinked. If program is zero, then the current rendering state refers to an invalid program
///     object and the results of shader execution are undefined. However, this is not an error. If
///     program does not contain shader objects of type GL_FRAGMENT_SHADER , an executable will be
///     installed on the vertex, and possibly geometry processors, but the results of fragment
///     shader execution will be undefined.
///   </para>
/// </summary>
/// <param name='program'>Specifies the handle of the program object whose executables are to be
/// used as part of current rendering state.</param>
#define glUseProgram glad_debug_glUseProgram
    GLAD_API_CALL PFNGLUSEPROGRAMOBJECTARBPROC glad_glUseProgramObjectARB;
    GLAD_API_CALL PFNGLUSEPROGRAMOBJECTARBPROC glad_debug_glUseProgramObjectARB;
#define glUseProgramObjectARB glad_debug_glUseProgramObjectARB
    GLAD_API_CALL PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;
    GLAD_API_CALL PFNGLUSEPROGRAMSTAGESPROC glad_debug_glUseProgramStages;

/// <summary>
///   bind stages of a program object to a program pipeline
///   <para>
///     glUseProgramStages binds executables from a program object associated with a specified set
///     of shader stages to the program pipeline object given by pipeline. pipeline specifies the
///     program pipeline object to which to bind the executables. stages contains a logical
///     combination of bits indicating the shader stages to use within program with the program
///     pipeline object pipeline. stages must be a logical combination of GL_VERTEX_SHADER_BIT ,
///     GL_TESS_CONTROL_SHADER_BIT , GL_TESS_EVALUATION_SHADER_BIT , GL_GEOMETRY_SHADER_BIT ,
///     GL_FRAGMENT_SHADER_BIT and GL_COMPUTE_SHADER_BIT. Additionally, the special value
///     GL_ALL_SHADER_BITS may be specified to indicate that all executables contained in program
///     should be installed in pipeline. If program refers to a program object with a valid shader
///     attached for an indicated shader stage, glUseProgramStages installs the executable code for
///     that stage in the indicated program pipeline object pipeline. If program is zero, or refers
///     to a program object with no valid shader executable for a given stage, it is as if the
///     pipeline object has no programmable stage configured for the indicated shader stages. If
///     stages contains bits other than those listed above, and is not equal to GL_ALL_SHADER_BITS ,
///     an error is generated.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies the program pipeline object to which to bind stages
/// from</param> <param name='stages'>Specifies a set of program stages to bind to the program
/// pipeline object.</param> <param name='program'>Specifies the program object containing the
/// shader executables to use in</param>
#define glUseProgramStages glad_debug_glUseProgramStages
    GLAD_API_CALL PFNGLUSESHADERPROGRAMEXTPROC glad_glUseShaderProgramEXT;
    GLAD_API_CALL PFNGLUSESHADERPROGRAMEXTPROC glad_debug_glUseShaderProgramEXT;
#define glUseShaderProgramEXT glad_debug_glUseShaderProgramEXT
    GLAD_API_CALL PFNGLVDPAUFININVPROC glad_glVDPAUFiniNV;
    GLAD_API_CALL PFNGLVDPAUFININVPROC glad_debug_glVDPAUFiniNV;
#define glVDPAUFiniNV glad_debug_glVDPAUFiniNV
    GLAD_API_CALL PFNGLVDPAUGETSURFACEIVNVPROC glad_glVDPAUGetSurfaceivNV;
    GLAD_API_CALL PFNGLVDPAUGETSURFACEIVNVPROC glad_debug_glVDPAUGetSurfaceivNV;
#define glVDPAUGetSurfaceivNV glad_debug_glVDPAUGetSurfaceivNV
    GLAD_API_CALL PFNGLVDPAUINITNVPROC glad_glVDPAUInitNV;
    GLAD_API_CALL PFNGLVDPAUINITNVPROC glad_debug_glVDPAUInitNV;
#define glVDPAUInitNV glad_debug_glVDPAUInitNV
    GLAD_API_CALL PFNGLVDPAUISSURFACENVPROC glad_glVDPAUIsSurfaceNV;
    GLAD_API_CALL PFNGLVDPAUISSURFACENVPROC glad_debug_glVDPAUIsSurfaceNV;
#define glVDPAUIsSurfaceNV glad_debug_glVDPAUIsSurfaceNV
    GLAD_API_CALL PFNGLVDPAUMAPSURFACESNVPROC glad_glVDPAUMapSurfacesNV;
    GLAD_API_CALL PFNGLVDPAUMAPSURFACESNVPROC glad_debug_glVDPAUMapSurfacesNV;
#define glVDPAUMapSurfacesNV glad_debug_glVDPAUMapSurfacesNV
    GLAD_API_CALL PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_glVDPAURegisterOutputSurfaceNV;
    GLAD_API_CALL PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_debug_glVDPAURegisterOutputSurfaceNV;
#define glVDPAURegisterOutputSurfaceNV glad_debug_glVDPAURegisterOutputSurfaceNV
    GLAD_API_CALL PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_glVDPAURegisterVideoSurfaceNV;
    GLAD_API_CALL PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_debug_glVDPAURegisterVideoSurfaceNV;
#define glVDPAURegisterVideoSurfaceNV glad_debug_glVDPAURegisterVideoSurfaceNV
    GLAD_API_CALL PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC
        glad_glVDPAURegisterVideoSurfaceWithPictureStructureNV;
    GLAD_API_CALL PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC
        glad_debug_glVDPAURegisterVideoSurfaceWithPictureStructureNV;
#define glVDPAURegisterVideoSurfaceWithPictureStructureNV \
    glad_debug_glVDPAURegisterVideoSurfaceWithPictureStructureNV
    GLAD_API_CALL PFNGLVDPAUSURFACEACCESSNVPROC glad_glVDPAUSurfaceAccessNV;
    GLAD_API_CALL PFNGLVDPAUSURFACEACCESSNVPROC glad_debug_glVDPAUSurfaceAccessNV;
#define glVDPAUSurfaceAccessNV glad_debug_glVDPAUSurfaceAccessNV
    GLAD_API_CALL PFNGLVDPAUUNMAPSURFACESNVPROC glad_glVDPAUUnmapSurfacesNV;
    GLAD_API_CALL PFNGLVDPAUUNMAPSURFACESNVPROC glad_debug_glVDPAUUnmapSurfacesNV;
#define glVDPAUUnmapSurfacesNV glad_debug_glVDPAUUnmapSurfacesNV
    GLAD_API_CALL PFNGLVDPAUUNREGISTERSURFACENVPROC glad_glVDPAUUnregisterSurfaceNV;
    GLAD_API_CALL PFNGLVDPAUUNREGISTERSURFACENVPROC glad_debug_glVDPAUUnregisterSurfaceNV;
#define glVDPAUUnregisterSurfaceNV glad_debug_glVDPAUUnregisterSurfaceNV
    GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
    GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_debug_glValidateProgram;

/// <summary>
///   Validates a program object
///   <para>
///     glValidateProgram checks to see whether the executables contained in program can execute
///     given the current OpenGL state. The information generated by the validation process will be
///     stored in program 's information log. The validation information may consist of an empty
///     string, or it may be a string containing information about how the current program object
///     interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers
///     to convey more information about why the current program is inefficient, suboptimal, failing
///     to execute, and so on. The status of the validation operation will be stored as part of the
///     program object's state. This value will be set to GL_TRUE if the validation succeeded, and
///     GL_FALSE otherwise. It can be queried by calling glGetProgram with arguments program and
///     GL_VALIDATE_STATUS. If validation is successful, program is guaranteed to execute given the
///     current state. Otherwise, program is guaranteed to not execute. This function is typically
///     useful only during application development. The informational string stored in the
///     information log is completely implementation dependent; therefore, an application should not
///     expect different OpenGL implementations to produce identical information strings.
///   </para>
/// </summary>
/// <param name='program'>Specifies the handle of the program object to be validated.</param>
#define glValidateProgram glad_debug_glValidateProgram
    GLAD_API_CALL PFNGLVALIDATEPROGRAMARBPROC glad_glValidateProgramARB;
    GLAD_API_CALL PFNGLVALIDATEPROGRAMARBPROC glad_debug_glValidateProgramARB;
#define glValidateProgramARB glad_debug_glValidateProgramARB
    GLAD_API_CALL PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;
    GLAD_API_CALL PFNGLVALIDATEPROGRAMPIPELINEPROC glad_debug_glValidateProgramPipeline;

/// <summary>
///   validate a program pipeline object against current GL state
///   <para>
///     glValidateProgramPipeline instructs the implementation to validate the shader executables
///     contained in pipeline against the current GL state. The implementation may use this as an
///     opportunity to perform any internal shader modifications that may be required to ensure
///     correct operation of the installed shaders given the current GL state. After a program
///     pipeline has been validated, its validation status is set to GL_TRUE. The validation status
///     of a program pipeline object may be queried by calling glGetProgramPipeline with parameter
///     GL_VALIDATE_STATUS. If pipeline is a name previously returned from a call to
///     glGenProgramPipelines but that has not yet been bound by a call to glBindProgramPipeline , a
///     new program pipeline object is created with name pipeline and the default state vector.
///   </para>
/// </summary>
/// <param name='pipeline'>Specifies the name of a program pipeline object to validate.</param>
#define glValidateProgramPipeline glad_debug_glValidateProgramPipeline
    GLAD_API_CALL PFNGLVARIANTARRAYOBJECTATIPROC glad_glVariantArrayObjectATI;
    GLAD_API_CALL PFNGLVARIANTARRAYOBJECTATIPROC glad_debug_glVariantArrayObjectATI;
#define glVariantArrayObjectATI glad_debug_glVariantArrayObjectATI
    GLAD_API_CALL PFNGLVARIANTPOINTEREXTPROC glad_glVariantPointerEXT;
    GLAD_API_CALL PFNGLVARIANTPOINTEREXTPROC glad_debug_glVariantPointerEXT;
#define glVariantPointerEXT glad_debug_glVariantPointerEXT
    GLAD_API_CALL PFNGLVARIANTBVEXTPROC glad_glVariantbvEXT;
    GLAD_API_CALL PFNGLVARIANTBVEXTPROC glad_debug_glVariantbvEXT;
#define glVariantbvEXT glad_debug_glVariantbvEXT
    GLAD_API_CALL PFNGLVARIANTDVEXTPROC glad_glVariantdvEXT;
    GLAD_API_CALL PFNGLVARIANTDVEXTPROC glad_debug_glVariantdvEXT;
#define glVariantdvEXT glad_debug_glVariantdvEXT
    GLAD_API_CALL PFNGLVARIANTFVEXTPROC glad_glVariantfvEXT;
    GLAD_API_CALL PFNGLVARIANTFVEXTPROC glad_debug_glVariantfvEXT;
#define glVariantfvEXT glad_debug_glVariantfvEXT
    GLAD_API_CALL PFNGLVARIANTIVEXTPROC glad_glVariantivEXT;
    GLAD_API_CALL PFNGLVARIANTIVEXTPROC glad_debug_glVariantivEXT;
#define glVariantivEXT glad_debug_glVariantivEXT
    GLAD_API_CALL PFNGLVARIANTSVEXTPROC glad_glVariantsvEXT;
    GLAD_API_CALL PFNGLVARIANTSVEXTPROC glad_debug_glVariantsvEXT;
#define glVariantsvEXT glad_debug_glVariantsvEXT
    GLAD_API_CALL PFNGLVARIANTUBVEXTPROC glad_glVariantubvEXT;
    GLAD_API_CALL PFNGLVARIANTUBVEXTPROC glad_debug_glVariantubvEXT;
#define glVariantubvEXT glad_debug_glVariantubvEXT
    GLAD_API_CALL PFNGLVARIANTUIVEXTPROC glad_glVariantuivEXT;
    GLAD_API_CALL PFNGLVARIANTUIVEXTPROC glad_debug_glVariantuivEXT;
#define glVariantuivEXT glad_debug_glVariantuivEXT
    GLAD_API_CALL PFNGLVARIANTUSVEXTPROC glad_glVariantusvEXT;
    GLAD_API_CALL PFNGLVARIANTUSVEXTPROC glad_debug_glVariantusvEXT;
#define glVariantusvEXT glad_debug_glVariantusvEXT
    GLAD_API_CALL PFNGLVERTEX2BOESPROC glad_glVertex2bOES;
    GLAD_API_CALL PFNGLVERTEX2BOESPROC glad_debug_glVertex2bOES;
#define glVertex2bOES glad_debug_glVertex2bOES
    GLAD_API_CALL PFNGLVERTEX2BVOESPROC glad_glVertex2bvOES;
    GLAD_API_CALL PFNGLVERTEX2BVOESPROC glad_debug_glVertex2bvOES;
#define glVertex2bvOES glad_debug_glVertex2bvOES
    GLAD_API_CALL PFNGLVERTEX2HNVPROC glad_glVertex2hNV;
    GLAD_API_CALL PFNGLVERTEX2HNVPROC glad_debug_glVertex2hNV;
#define glVertex2hNV glad_debug_glVertex2hNV
    GLAD_API_CALL PFNGLVERTEX2HVNVPROC glad_glVertex2hvNV;
    GLAD_API_CALL PFNGLVERTEX2HVNVPROC glad_debug_glVertex2hvNV;
#define glVertex2hvNV glad_debug_glVertex2hvNV
    GLAD_API_CALL PFNGLVERTEX2XOESPROC glad_glVertex2xOES;
    GLAD_API_CALL PFNGLVERTEX2XOESPROC glad_debug_glVertex2xOES;
#define glVertex2xOES glad_debug_glVertex2xOES
    GLAD_API_CALL PFNGLVERTEX2XVOESPROC glad_glVertex2xvOES;
    GLAD_API_CALL PFNGLVERTEX2XVOESPROC glad_debug_glVertex2xvOES;
#define glVertex2xvOES glad_debug_glVertex2xvOES
    GLAD_API_CALL PFNGLVERTEX3BOESPROC glad_glVertex3bOES;
    GLAD_API_CALL PFNGLVERTEX3BOESPROC glad_debug_glVertex3bOES;
#define glVertex3bOES glad_debug_glVertex3bOES
    GLAD_API_CALL PFNGLVERTEX3BVOESPROC glad_glVertex3bvOES;
    GLAD_API_CALL PFNGLVERTEX3BVOESPROC glad_debug_glVertex3bvOES;
#define glVertex3bvOES glad_debug_glVertex3bvOES
    GLAD_API_CALL PFNGLVERTEX3HNVPROC glad_glVertex3hNV;
    GLAD_API_CALL PFNGLVERTEX3HNVPROC glad_debug_glVertex3hNV;
#define glVertex3hNV glad_debug_glVertex3hNV
    GLAD_API_CALL PFNGLVERTEX3HVNVPROC glad_glVertex3hvNV;
    GLAD_API_CALL PFNGLVERTEX3HVNVPROC glad_debug_glVertex3hvNV;
#define glVertex3hvNV glad_debug_glVertex3hvNV
    GLAD_API_CALL PFNGLVERTEX3XOESPROC glad_glVertex3xOES;
    GLAD_API_CALL PFNGLVERTEX3XOESPROC glad_debug_glVertex3xOES;
#define glVertex3xOES glad_debug_glVertex3xOES
    GLAD_API_CALL PFNGLVERTEX3XVOESPROC glad_glVertex3xvOES;
    GLAD_API_CALL PFNGLVERTEX3XVOESPROC glad_debug_glVertex3xvOES;
#define glVertex3xvOES glad_debug_glVertex3xvOES
    GLAD_API_CALL PFNGLVERTEX4BOESPROC glad_glVertex4bOES;
    GLAD_API_CALL PFNGLVERTEX4BOESPROC glad_debug_glVertex4bOES;
#define glVertex4bOES glad_debug_glVertex4bOES
    GLAD_API_CALL PFNGLVERTEX4BVOESPROC glad_glVertex4bvOES;
    GLAD_API_CALL PFNGLVERTEX4BVOESPROC glad_debug_glVertex4bvOES;
#define glVertex4bvOES glad_debug_glVertex4bvOES
    GLAD_API_CALL PFNGLVERTEX4HNVPROC glad_glVertex4hNV;
    GLAD_API_CALL PFNGLVERTEX4HNVPROC glad_debug_glVertex4hNV;
#define glVertex4hNV glad_debug_glVertex4hNV
    GLAD_API_CALL PFNGLVERTEX4HVNVPROC glad_glVertex4hvNV;
    GLAD_API_CALL PFNGLVERTEX4HVNVPROC glad_debug_glVertex4hvNV;
#define glVertex4hvNV glad_debug_glVertex4hvNV
    GLAD_API_CALL PFNGLVERTEX4XOESPROC glad_glVertex4xOES;
    GLAD_API_CALL PFNGLVERTEX4XOESPROC glad_debug_glVertex4xOES;
#define glVertex4xOES glad_debug_glVertex4xOES
    GLAD_API_CALL PFNGLVERTEX4XVOESPROC glad_glVertex4xvOES;
    GLAD_API_CALL PFNGLVERTEX4XVOESPROC glad_debug_glVertex4xvOES;
#define glVertex4xvOES glad_debug_glVertex4xvOES
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_debug_glVertexArrayAttribBinding;
#define glVertexArrayAttribBinding glad_debug_glVertexArrayAttribBinding
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBFORMATPROC glad_debug_glVertexArrayAttribFormat;
#define glVertexArrayAttribFormat glad_debug_glVertexArrayAttribFormat
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_debug_glVertexArrayAttribIFormat;
#define glVertexArrayAttribIFormat glad_debug_glVertexArrayAttribIFormat
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;
    GLAD_API_CALL PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_debug_glVertexArrayAttribLFormat;
#define glVertexArrayAttribLFormat glad_debug_glVertexArrayAttribLFormat
    GLAD_API_CALL PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glad_glVertexArrayBindVertexBufferEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC
        glad_debug_glVertexArrayBindVertexBufferEXT;
#define glVertexArrayBindVertexBufferEXT glad_debug_glVertexArrayBindVertexBufferEXT
    GLAD_API_CALL PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;
    GLAD_API_CALL PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_debug_glVertexArrayBindingDivisor;
#define glVertexArrayBindingDivisor glad_debug_glVertexArrayBindingDivisor
    GLAD_API_CALL PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_glVertexArrayColorOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_debug_glVertexArrayColorOffsetEXT;
#define glVertexArrayColorOffsetEXT glad_debug_glVertexArrayColorOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_glVertexArrayEdgeFlagOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_debug_glVertexArrayEdgeFlagOffsetEXT;
#define glVertexArrayEdgeFlagOffsetEXT glad_debug_glVertexArrayEdgeFlagOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;
    GLAD_API_CALL PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_debug_glVertexArrayElementBuffer;

/// <summary>
///   configures element array buffer binding of a vertex array object
///   <para>
///     glVertexArrayElementBuffer binds a buffer object with id buffer to the element array buffer
///     bind point of a vertex array object with id vaobj. If buffer is zero, any existing element
///     array buffer binding to vaobj is removed.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object.</param>
/// <param name='buffer'>Specifies the name of the buffer object to use for the element array buffer
/// binding.</param>
#define glVertexArrayElementBuffer glad_debug_glVertexArrayElementBuffer
    GLAD_API_CALL PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_glVertexArrayFogCoordOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_debug_glVertexArrayFogCoordOffsetEXT;
#define glVertexArrayFogCoordOffsetEXT glad_debug_glVertexArrayFogCoordOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_glVertexArrayIndexOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_debug_glVertexArrayIndexOffsetEXT;
#define glVertexArrayIndexOffsetEXT glad_debug_glVertexArrayIndexOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC
        glad_glVertexArrayMultiTexCoordOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC
        glad_debug_glVertexArrayMultiTexCoordOffsetEXT;
#define glVertexArrayMultiTexCoordOffsetEXT glad_debug_glVertexArrayMultiTexCoordOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_glVertexArrayNormalOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_debug_glVertexArrayNormalOffsetEXT;
#define glVertexArrayNormalOffsetEXT glad_debug_glVertexArrayNormalOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_glVertexArrayParameteriAPPLE;
    GLAD_API_CALL PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_debug_glVertexArrayParameteriAPPLE;
#define glVertexArrayParameteriAPPLE glad_debug_glVertexArrayParameteriAPPLE
    GLAD_API_CALL PFNGLVERTEXARRAYRANGEAPPLEPROC glad_glVertexArrayRangeAPPLE;
    GLAD_API_CALL PFNGLVERTEXARRAYRANGEAPPLEPROC glad_debug_glVertexArrayRangeAPPLE;
#define glVertexArrayRangeAPPLE glad_debug_glVertexArrayRangeAPPLE
    GLAD_API_CALL PFNGLVERTEXARRAYRANGENVPROC glad_glVertexArrayRangeNV;
    GLAD_API_CALL PFNGLVERTEXARRAYRANGENVPROC glad_debug_glVertexArrayRangeNV;
#define glVertexArrayRangeNV glad_debug_glVertexArrayRangeNV
    GLAD_API_CALL PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC
        glad_glVertexArraySecondaryColorOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC
        glad_debug_glVertexArraySecondaryColorOffsetEXT;
#define glVertexArraySecondaryColorOffsetEXT glad_debug_glVertexArraySecondaryColorOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_glVertexArrayTexCoordOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_debug_glVertexArrayTexCoordOffsetEXT;
#define glVertexArrayTexCoordOffsetEXT glad_debug_glVertexArrayTexCoordOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC
        glad_glVertexArrayVertexAttribBindingEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC
        glad_debug_glVertexArrayVertexAttribBindingEXT;
#define glVertexArrayVertexAttribBindingEXT glad_debug_glVertexArrayVertexAttribBindingEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC
        glad_glVertexArrayVertexAttribDivisorEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC
        glad_debug_glVertexArrayVertexAttribDivisorEXT;
#define glVertexArrayVertexAttribDivisorEXT glad_debug_glVertexArrayVertexAttribDivisorEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glad_glVertexArrayVertexAttribFormatEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC
        glad_debug_glVertexArrayVertexAttribFormatEXT;
#define glVertexArrayVertexAttribFormatEXT glad_debug_glVertexArrayVertexAttribFormatEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC
        glad_glVertexArrayVertexAttribIFormatEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC
        glad_debug_glVertexArrayVertexAttribIFormatEXT;
#define glVertexArrayVertexAttribIFormatEXT glad_debug_glVertexArrayVertexAttribIFormatEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC
        glad_glVertexArrayVertexAttribIOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC
        glad_debug_glVertexArrayVertexAttribIOffsetEXT;
#define glVertexArrayVertexAttribIOffsetEXT glad_debug_glVertexArrayVertexAttribIOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC
        glad_glVertexArrayVertexAttribLFormatEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC
        glad_debug_glVertexArrayVertexAttribLFormatEXT;
#define glVertexArrayVertexAttribLFormatEXT glad_debug_glVertexArrayVertexAttribLFormatEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC
        glad_glVertexArrayVertexAttribLOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC
        glad_debug_glVertexArrayVertexAttribLOffsetEXT;
#define glVertexArrayVertexAttribLOffsetEXT glad_debug_glVertexArrayVertexAttribLOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glad_glVertexArrayVertexAttribOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC
        glad_debug_glVertexArrayVertexAttribOffsetEXT;
#define glVertexArrayVertexAttribOffsetEXT glad_debug_glVertexArrayVertexAttribOffsetEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC
        glad_glVertexArrayVertexBindingDivisorEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC
        glad_debug_glVertexArrayVertexBindingDivisorEXT;
#define glVertexArrayVertexBindingDivisorEXT glad_debug_glVertexArrayVertexBindingDivisorEXT
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_debug_glVertexArrayVertexBuffer;
#define glVertexArrayVertexBuffer glad_debug_glVertexArrayVertexBuffer
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_debug_glVertexArrayVertexBuffers;
#define glVertexArrayVertexBuffers glad_debug_glVertexArrayVertexBuffers
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_glVertexArrayVertexOffsetEXT;
    GLAD_API_CALL PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_debug_glVertexArrayVertexOffsetEXT;
#define glVertexArrayVertexOffsetEXT glad_debug_glVertexArrayVertexOffsetEXT
    GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_debug_glVertexAttrib1d;
#define glVertexAttrib1d glad_debug_glVertexAttrib1d
    GLAD_API_CALL PFNGLVERTEXATTRIB1DARBPROC glad_glVertexAttrib1dARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DARBPROC glad_debug_glVertexAttrib1dARB;
#define glVertexAttrib1dARB glad_debug_glVertexAttrib1dARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1DNVPROC glad_glVertexAttrib1dNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DNVPROC glad_debug_glVertexAttrib1dNV;
#define glVertexAttrib1dNV glad_debug_glVertexAttrib1dNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_debug_glVertexAttrib1dv;
#define glVertexAttrib1dv glad_debug_glVertexAttrib1dv
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVARBPROC glad_glVertexAttrib1dvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVARBPROC glad_debug_glVertexAttrib1dvARB;
#define glVertexAttrib1dvARB glad_debug_glVertexAttrib1dvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVNVPROC glad_glVertexAttrib1dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1DVNVPROC glad_debug_glVertexAttrib1dvNV;
#define glVertexAttrib1dvNV glad_debug_glVertexAttrib1dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_debug_glVertexAttrib1f;
#define glVertexAttrib1f glad_debug_glVertexAttrib1f
    GLAD_API_CALL PFNGLVERTEXATTRIB1FARBPROC glad_glVertexAttrib1fARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FARBPROC glad_debug_glVertexAttrib1fARB;
#define glVertexAttrib1fARB glad_debug_glVertexAttrib1fARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1FNVPROC glad_glVertexAttrib1fNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FNVPROC glad_debug_glVertexAttrib1fNV;
#define glVertexAttrib1fNV glad_debug_glVertexAttrib1fNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_debug_glVertexAttrib1fv;
#define glVertexAttrib1fv glad_debug_glVertexAttrib1fv
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVARBPROC glad_glVertexAttrib1fvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVARBPROC glad_debug_glVertexAttrib1fvARB;
#define glVertexAttrib1fvARB glad_debug_glVertexAttrib1fvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVNVPROC glad_glVertexAttrib1fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1FVNVPROC glad_debug_glVertexAttrib1fvNV;
#define glVertexAttrib1fvNV glad_debug_glVertexAttrib1fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1HNVPROC glad_glVertexAttrib1hNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1HNVPROC glad_debug_glVertexAttrib1hNV;
#define glVertexAttrib1hNV glad_debug_glVertexAttrib1hNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1HVNVPROC glad_glVertexAttrib1hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1HVNVPROC glad_debug_glVertexAttrib1hvNV;
#define glVertexAttrib1hvNV glad_debug_glVertexAttrib1hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_debug_glVertexAttrib1s;
#define glVertexAttrib1s glad_debug_glVertexAttrib1s
    GLAD_API_CALL PFNGLVERTEXATTRIB1SARBPROC glad_glVertexAttrib1sARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SARBPROC glad_debug_glVertexAttrib1sARB;
#define glVertexAttrib1sARB glad_debug_glVertexAttrib1sARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1SNVPROC glad_glVertexAttrib1sNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SNVPROC glad_debug_glVertexAttrib1sNV;
#define glVertexAttrib1sNV glad_debug_glVertexAttrib1sNV
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_debug_glVertexAttrib1sv;
#define glVertexAttrib1sv glad_debug_glVertexAttrib1sv
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVARBPROC glad_glVertexAttrib1svARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVARBPROC glad_debug_glVertexAttrib1svARB;
#define glVertexAttrib1svARB glad_debug_glVertexAttrib1svARB
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVNVPROC glad_glVertexAttrib1svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB1SVNVPROC glad_debug_glVertexAttrib1svNV;
#define glVertexAttrib1svNV glad_debug_glVertexAttrib1svNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_debug_glVertexAttrib2d;
#define glVertexAttrib2d glad_debug_glVertexAttrib2d
    GLAD_API_CALL PFNGLVERTEXATTRIB2DARBPROC glad_glVertexAttrib2dARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DARBPROC glad_debug_glVertexAttrib2dARB;
#define glVertexAttrib2dARB glad_debug_glVertexAttrib2dARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2DNVPROC glad_glVertexAttrib2dNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DNVPROC glad_debug_glVertexAttrib2dNV;
#define glVertexAttrib2dNV glad_debug_glVertexAttrib2dNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_debug_glVertexAttrib2dv;
#define glVertexAttrib2dv glad_debug_glVertexAttrib2dv
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVARBPROC glad_glVertexAttrib2dvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVARBPROC glad_debug_glVertexAttrib2dvARB;
#define glVertexAttrib2dvARB glad_debug_glVertexAttrib2dvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVNVPROC glad_glVertexAttrib2dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2DVNVPROC glad_debug_glVertexAttrib2dvNV;
#define glVertexAttrib2dvNV glad_debug_glVertexAttrib2dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_debug_glVertexAttrib2f;
#define glVertexAttrib2f glad_debug_glVertexAttrib2f
    GLAD_API_CALL PFNGLVERTEXATTRIB2FARBPROC glad_glVertexAttrib2fARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FARBPROC glad_debug_glVertexAttrib2fARB;
#define glVertexAttrib2fARB glad_debug_glVertexAttrib2fARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2FNVPROC glad_glVertexAttrib2fNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FNVPROC glad_debug_glVertexAttrib2fNV;
#define glVertexAttrib2fNV glad_debug_glVertexAttrib2fNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_debug_glVertexAttrib2fv;
#define glVertexAttrib2fv glad_debug_glVertexAttrib2fv
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVARBPROC glad_glVertexAttrib2fvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVARBPROC glad_debug_glVertexAttrib2fvARB;
#define glVertexAttrib2fvARB glad_debug_glVertexAttrib2fvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVNVPROC glad_glVertexAttrib2fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2FVNVPROC glad_debug_glVertexAttrib2fvNV;
#define glVertexAttrib2fvNV glad_debug_glVertexAttrib2fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2HNVPROC glad_glVertexAttrib2hNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2HNVPROC glad_debug_glVertexAttrib2hNV;
#define glVertexAttrib2hNV glad_debug_glVertexAttrib2hNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2HVNVPROC glad_glVertexAttrib2hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2HVNVPROC glad_debug_glVertexAttrib2hvNV;
#define glVertexAttrib2hvNV glad_debug_glVertexAttrib2hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_debug_glVertexAttrib2s;
#define glVertexAttrib2s glad_debug_glVertexAttrib2s
    GLAD_API_CALL PFNGLVERTEXATTRIB2SARBPROC glad_glVertexAttrib2sARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SARBPROC glad_debug_glVertexAttrib2sARB;
#define glVertexAttrib2sARB glad_debug_glVertexAttrib2sARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2SNVPROC glad_glVertexAttrib2sNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SNVPROC glad_debug_glVertexAttrib2sNV;
#define glVertexAttrib2sNV glad_debug_glVertexAttrib2sNV
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_debug_glVertexAttrib2sv;
#define glVertexAttrib2sv glad_debug_glVertexAttrib2sv
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVARBPROC glad_glVertexAttrib2svARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVARBPROC glad_debug_glVertexAttrib2svARB;
#define glVertexAttrib2svARB glad_debug_glVertexAttrib2svARB
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVNVPROC glad_glVertexAttrib2svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB2SVNVPROC glad_debug_glVertexAttrib2svNV;
#define glVertexAttrib2svNV glad_debug_glVertexAttrib2svNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_debug_glVertexAttrib3d;
#define glVertexAttrib3d glad_debug_glVertexAttrib3d
    GLAD_API_CALL PFNGLVERTEXATTRIB3DARBPROC glad_glVertexAttrib3dARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DARBPROC glad_debug_glVertexAttrib3dARB;
#define glVertexAttrib3dARB glad_debug_glVertexAttrib3dARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3DNVPROC glad_glVertexAttrib3dNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DNVPROC glad_debug_glVertexAttrib3dNV;
#define glVertexAttrib3dNV glad_debug_glVertexAttrib3dNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_debug_glVertexAttrib3dv;
#define glVertexAttrib3dv glad_debug_glVertexAttrib3dv
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVARBPROC glad_glVertexAttrib3dvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVARBPROC glad_debug_glVertexAttrib3dvARB;
#define glVertexAttrib3dvARB glad_debug_glVertexAttrib3dvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVNVPROC glad_glVertexAttrib3dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3DVNVPROC glad_debug_glVertexAttrib3dvNV;
#define glVertexAttrib3dvNV glad_debug_glVertexAttrib3dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_debug_glVertexAttrib3f;
#define glVertexAttrib3f glad_debug_glVertexAttrib3f
    GLAD_API_CALL PFNGLVERTEXATTRIB3FARBPROC glad_glVertexAttrib3fARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FARBPROC glad_debug_glVertexAttrib3fARB;
#define glVertexAttrib3fARB glad_debug_glVertexAttrib3fARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3FNVPROC glad_glVertexAttrib3fNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FNVPROC glad_debug_glVertexAttrib3fNV;
#define glVertexAttrib3fNV glad_debug_glVertexAttrib3fNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_debug_glVertexAttrib3fv;
#define glVertexAttrib3fv glad_debug_glVertexAttrib3fv
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVARBPROC glad_glVertexAttrib3fvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVARBPROC glad_debug_glVertexAttrib3fvARB;
#define glVertexAttrib3fvARB glad_debug_glVertexAttrib3fvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVNVPROC glad_glVertexAttrib3fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3FVNVPROC glad_debug_glVertexAttrib3fvNV;
#define glVertexAttrib3fvNV glad_debug_glVertexAttrib3fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3HNVPROC glad_glVertexAttrib3hNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3HNVPROC glad_debug_glVertexAttrib3hNV;
#define glVertexAttrib3hNV glad_debug_glVertexAttrib3hNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3HVNVPROC glad_glVertexAttrib3hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3HVNVPROC glad_debug_glVertexAttrib3hvNV;
#define glVertexAttrib3hvNV glad_debug_glVertexAttrib3hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_debug_glVertexAttrib3s;
#define glVertexAttrib3s glad_debug_glVertexAttrib3s
    GLAD_API_CALL PFNGLVERTEXATTRIB3SARBPROC glad_glVertexAttrib3sARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SARBPROC glad_debug_glVertexAttrib3sARB;
#define glVertexAttrib3sARB glad_debug_glVertexAttrib3sARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3SNVPROC glad_glVertexAttrib3sNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SNVPROC glad_debug_glVertexAttrib3sNV;
#define glVertexAttrib3sNV glad_debug_glVertexAttrib3sNV
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_debug_glVertexAttrib3sv;
#define glVertexAttrib3sv glad_debug_glVertexAttrib3sv
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVARBPROC glad_glVertexAttrib3svARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVARBPROC glad_debug_glVertexAttrib3svARB;
#define glVertexAttrib3svARB glad_debug_glVertexAttrib3svARB
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVNVPROC glad_glVertexAttrib3svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB3SVNVPROC glad_debug_glVertexAttrib3svNV;
#define glVertexAttrib3svNV glad_debug_glVertexAttrib3svNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_debug_glVertexAttrib4Nbv;
#define glVertexAttrib4Nbv glad_debug_glVertexAttrib4Nbv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NBVARBPROC glad_glVertexAttrib4NbvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NBVARBPROC glad_debug_glVertexAttrib4NbvARB;
#define glVertexAttrib4NbvARB glad_debug_glVertexAttrib4NbvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_debug_glVertexAttrib4Niv;
#define glVertexAttrib4Niv glad_debug_glVertexAttrib4Niv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NIVARBPROC glad_glVertexAttrib4NivARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NIVARBPROC glad_debug_glVertexAttrib4NivARB;
#define glVertexAttrib4NivARB glad_debug_glVertexAttrib4NivARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_debug_glVertexAttrib4Nsv;
#define glVertexAttrib4Nsv glad_debug_glVertexAttrib4Nsv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NSVARBPROC glad_glVertexAttrib4NsvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NSVARBPROC glad_debug_glVertexAttrib4NsvARB;
#define glVertexAttrib4NsvARB glad_debug_glVertexAttrib4NsvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_debug_glVertexAttrib4Nub;
#define glVertexAttrib4Nub glad_debug_glVertexAttrib4Nub
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBARBPROC glad_glVertexAttrib4NubARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBARBPROC glad_debug_glVertexAttrib4NubARB;
#define glVertexAttrib4NubARB glad_debug_glVertexAttrib4NubARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_debug_glVertexAttrib4Nubv;
#define glVertexAttrib4Nubv glad_debug_glVertexAttrib4Nubv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVARBPROC glad_glVertexAttrib4NubvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVARBPROC glad_debug_glVertexAttrib4NubvARB;
#define glVertexAttrib4NubvARB glad_debug_glVertexAttrib4NubvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_debug_glVertexAttrib4Nuiv;
#define glVertexAttrib4Nuiv glad_debug_glVertexAttrib4Nuiv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVARBPROC glad_glVertexAttrib4NuivARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVARBPROC glad_debug_glVertexAttrib4NuivARB;
#define glVertexAttrib4NuivARB glad_debug_glVertexAttrib4NuivARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_debug_glVertexAttrib4Nusv;
#define glVertexAttrib4Nusv glad_debug_glVertexAttrib4Nusv
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVARBPROC glad_glVertexAttrib4NusvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVARBPROC glad_debug_glVertexAttrib4NusvARB;
#define glVertexAttrib4NusvARB glad_debug_glVertexAttrib4NusvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_debug_glVertexAttrib4bv;
#define glVertexAttrib4bv glad_debug_glVertexAttrib4bv
    GLAD_API_CALL PFNGLVERTEXATTRIB4BVARBPROC glad_glVertexAttrib4bvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4BVARBPROC glad_debug_glVertexAttrib4bvARB;
#define glVertexAttrib4bvARB glad_debug_glVertexAttrib4bvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_debug_glVertexAttrib4d;
#define glVertexAttrib4d glad_debug_glVertexAttrib4d
    GLAD_API_CALL PFNGLVERTEXATTRIB4DARBPROC glad_glVertexAttrib4dARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DARBPROC glad_debug_glVertexAttrib4dARB;
#define glVertexAttrib4dARB glad_debug_glVertexAttrib4dARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4DNVPROC glad_glVertexAttrib4dNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DNVPROC glad_debug_glVertexAttrib4dNV;
#define glVertexAttrib4dNV glad_debug_glVertexAttrib4dNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_debug_glVertexAttrib4dv;
#define glVertexAttrib4dv glad_debug_glVertexAttrib4dv
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVARBPROC glad_glVertexAttrib4dvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVARBPROC glad_debug_glVertexAttrib4dvARB;
#define glVertexAttrib4dvARB glad_debug_glVertexAttrib4dvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVNVPROC glad_glVertexAttrib4dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4DVNVPROC glad_debug_glVertexAttrib4dvNV;
#define glVertexAttrib4dvNV glad_debug_glVertexAttrib4dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_debug_glVertexAttrib4f;
#define glVertexAttrib4f glad_debug_glVertexAttrib4f
    GLAD_API_CALL PFNGLVERTEXATTRIB4FARBPROC glad_glVertexAttrib4fARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FARBPROC glad_debug_glVertexAttrib4fARB;
#define glVertexAttrib4fARB glad_debug_glVertexAttrib4fARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4FNVPROC glad_glVertexAttrib4fNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FNVPROC glad_debug_glVertexAttrib4fNV;
#define glVertexAttrib4fNV glad_debug_glVertexAttrib4fNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_debug_glVertexAttrib4fv;
#define glVertexAttrib4fv glad_debug_glVertexAttrib4fv
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVARBPROC glad_glVertexAttrib4fvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVARBPROC glad_debug_glVertexAttrib4fvARB;
#define glVertexAttrib4fvARB glad_debug_glVertexAttrib4fvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVNVPROC glad_glVertexAttrib4fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4FVNVPROC glad_debug_glVertexAttrib4fvNV;
#define glVertexAttrib4fvNV glad_debug_glVertexAttrib4fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4HNVPROC glad_glVertexAttrib4hNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4HNVPROC glad_debug_glVertexAttrib4hNV;
#define glVertexAttrib4hNV glad_debug_glVertexAttrib4hNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4HVNVPROC glad_glVertexAttrib4hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4HVNVPROC glad_debug_glVertexAttrib4hvNV;
#define glVertexAttrib4hvNV glad_debug_glVertexAttrib4hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_debug_glVertexAttrib4iv;
#define glVertexAttrib4iv glad_debug_glVertexAttrib4iv
    GLAD_API_CALL PFNGLVERTEXATTRIB4IVARBPROC glad_glVertexAttrib4ivARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4IVARBPROC glad_debug_glVertexAttrib4ivARB;
#define glVertexAttrib4ivARB glad_debug_glVertexAttrib4ivARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_debug_glVertexAttrib4s;
#define glVertexAttrib4s glad_debug_glVertexAttrib4s
    GLAD_API_CALL PFNGLVERTEXATTRIB4SARBPROC glad_glVertexAttrib4sARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SARBPROC glad_debug_glVertexAttrib4sARB;
#define glVertexAttrib4sARB glad_debug_glVertexAttrib4sARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4SNVPROC glad_glVertexAttrib4sNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SNVPROC glad_debug_glVertexAttrib4sNV;
#define glVertexAttrib4sNV glad_debug_glVertexAttrib4sNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_debug_glVertexAttrib4sv;
#define glVertexAttrib4sv glad_debug_glVertexAttrib4sv
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVARBPROC glad_glVertexAttrib4svARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVARBPROC glad_debug_glVertexAttrib4svARB;
#define glVertexAttrib4svARB glad_debug_glVertexAttrib4svARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVNVPROC glad_glVertexAttrib4svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4SVNVPROC glad_debug_glVertexAttrib4svNV;
#define glVertexAttrib4svNV glad_debug_glVertexAttrib4svNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBNVPROC glad_glVertexAttrib4ubNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBNVPROC glad_debug_glVertexAttrib4ubNV;
#define glVertexAttrib4ubNV glad_debug_glVertexAttrib4ubNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_debug_glVertexAttrib4ubv;
#define glVertexAttrib4ubv glad_debug_glVertexAttrib4ubv
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVARBPROC glad_glVertexAttrib4ubvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVARBPROC glad_debug_glVertexAttrib4ubvARB;
#define glVertexAttrib4ubvARB glad_debug_glVertexAttrib4ubvARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVNVPROC glad_glVertexAttrib4ubvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UBVNVPROC glad_debug_glVertexAttrib4ubvNV;
#define glVertexAttrib4ubvNV glad_debug_glVertexAttrib4ubvNV
    GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_debug_glVertexAttrib4uiv;
#define glVertexAttrib4uiv glad_debug_glVertexAttrib4uiv
    GLAD_API_CALL PFNGLVERTEXATTRIB4UIVARBPROC glad_glVertexAttrib4uivARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4UIVARBPROC glad_debug_glVertexAttrib4uivARB;
#define glVertexAttrib4uivARB glad_debug_glVertexAttrib4uivARB
    GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
    GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_debug_glVertexAttrib4usv;
#define glVertexAttrib4usv glad_debug_glVertexAttrib4usv
    GLAD_API_CALL PFNGLVERTEXATTRIB4USVARBPROC glad_glVertexAttrib4usvARB;
    GLAD_API_CALL PFNGLVERTEXATTRIB4USVARBPROC glad_debug_glVertexAttrib4usvARB;
#define glVertexAttrib4usvARB glad_debug_glVertexAttrib4usvARB
    GLAD_API_CALL PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_glVertexAttribArrayObjectATI;
    GLAD_API_CALL PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_debug_glVertexAttribArrayObjectATI;
#define glVertexAttribArrayObjectATI glad_debug_glVertexAttribArrayObjectATI
    GLAD_API_CALL PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;
    GLAD_API_CALL PFNGLVERTEXATTRIBBINDINGPROC glad_debug_glVertexAttribBinding;

/// <summary>
///   associate a vertex attribute and a vertex buffer binding for a vertex array object
///   <para>
///     glVertexAttribBinding and glVertexArrayAttribBinding establishes an association between the
///     generic vertex attribute of a vertex array object whose index is given by attribindex , and
///     a vertex buffer binding whose index is given by bindingindex. For glVertexAttribBinding ,
///     the vertex array object affected is that currently bound. For glVertexArrayAttribBinding ,
///     vaobj is the name of the vertex array object. attribindex must be less than the value of
///     GL_MAX_VERTEX_ATTRIBS and bindingindex must be less than the value of
///     GL_MAX_VERTEX_ATTRIB_BINDINGS.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object for</param>
/// <param name='attribindex'>The index of the attribute to associate with a vertex buffer
/// binding.</param> <param name='bindingindex'>The index of the vertex buffer binding with which to
/// associate the generic vertex attribute.</param>
#define glVertexAttribBinding glad_debug_glVertexAttribBinding
    GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
    GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_debug_glVertexAttribDivisor;

/// <summary>
///   modify the rate at which generic vertex attributes advance during instanced rendering
///   <para>
///     glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when
///     rendering multiple instances of primitives in a single draw call. If divisor is zero, the
///     attribute at slot index advances once per vertex. If divisor is non-zero, the attribute
///     advances once per divisor instances of the set(s) of vertices being rendered. An attribute
///     is referred to as instanced if its GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero. index
///     must be less than the value of GL_MAX_VERTEX_ATTRIBS.
///   </para>
/// </summary>
/// <param name='index'>Specify the index of the generic vertex attribute.</param>
/// <param name='divisor'>Specify the number of instances that will pass between updates of the
/// generic attribute at slot</param>
#define glVertexAttribDivisor glad_debug_glVertexAttribDivisor
    GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORARBPROC glad_glVertexAttribDivisorARB;
    GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORARBPROC glad_debug_glVertexAttribDivisorARB;
#define glVertexAttribDivisorARB glad_debug_glVertexAttribDivisorARB
    GLAD_API_CALL PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;
    GLAD_API_CALL PFNGLVERTEXATTRIBFORMATPROC glad_debug_glVertexAttribFormat;

/// <summary>
///   specify the organization of vertex arrays
///   <para>
///     glVertexAttribFormat , glVertexAttribIFormat and glVertexAttribLFormat , as well as
///     glVertexArrayAttribFormat , glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
///     specify the organization of data in vertex arrays. The first three calls operate on the
///     bound vertex array object, whereas the last three ones modify the state of a vertex array
///     object with ID vaobj. attribindex specifies the index of the generic vertex attribute array
///     whose data layout is being described, and must be less than the value of
///     GL_MAX_VERTEX_ATTRIBS. size determines the number of components per vertex are allocated to
///     the specified attribute and must be 1, 2, 3 or 4. type indicates the type of the data. If
///     type is one of GL_BYTE , GL_SHORT , GL_INT , GL_FIXED , GL_FLOAT , GL_HALF_FLOAT , and
///     GL_DOUBLE indicate types GLbyte , GLshort , GLint , GLfixed , GLfloat , GLhalf , and
///     GLdouble , respectively; the values GL_UNSIGNED_BYTE , GL_UNSIGNED_SHORT , and
///     GL_UNSIGNED_INT indicate types GLubyte , GLushort , and GLuint , respectively; the values
///     GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed
///     or unsigned elements packed into a single GLuint ; and the value
///     GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values packed into a single
///     GLuint. glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for
///     data associated with a generic attribute variable declared as 64-bit double precision
///     components. For glVertexAttribLFormat and glVertexArrayAttribLFormat , type must be
///     GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat , which will
///     cause data declared as GL_DOUBLE to be converted to 32-bit representation,
///     glVertexAttribLFormat and glVertexArrayAttribLFormat cause such data to be left in its
///     natural, 64-bit representation. For glVertexAttribFormat and glVertexArrayAttribFormat , if
///     normalized is GL_TRUE , then integer data is normalized to the range [-1, 1] or [0, 1] if it
///     is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
///     converted to floating point. relativeoffset is the offset, measured in basic machine units
///     of the first element relative to the start of the vertex buffer binding this attribute
///     fetches from. glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe
///     vertex attribute layout for floating-point vertex attributes, glVertexAttribIFormat and
///     glVertexArrayAttribIFormat should be used to describe vertex attribute layout for integer
///     vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to
///     describe the layout for 64-bit vertex attributes. Data for an array specified by
///     glVertexAttribIFormat and glVertexArrayAttribIFormat will always be left as integer values;
///     such data are referred to as pure integers.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object for</param>
/// <param name='attribindex'>The generic vertex attribute array being described.</param>
/// <param name='size'>The number of values per vertex that are stored in the array.</param>
/// <param name='type'>The type of the data stored in the array.</param>
/// <param name='normalized'>The offset, measured in basic machine units of the first element
/// relative to the start of the vertex buffer binding this attribute fetches from.</param>
#define glVertexAttribFormat glad_debug_glVertexAttribFormat
    GLAD_API_CALL PFNGLVERTEXATTRIBFORMATNVPROC glad_glVertexAttribFormatNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBFORMATNVPROC glad_debug_glVertexAttribFormatNV;
#define glVertexAttribFormatNV glad_debug_glVertexAttribFormatNV
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_debug_glVertexAttribI1i;
#define glVertexAttribI1i glad_debug_glVertexAttribI1i
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IEXTPROC glad_glVertexAttribI1iEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IEXTPROC glad_debug_glVertexAttribI1iEXT;
#define glVertexAttribI1iEXT glad_debug_glVertexAttribI1iEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_debug_glVertexAttribI1iv;
#define glVertexAttribI1iv glad_debug_glVertexAttribI1iv
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IVEXTPROC glad_glVertexAttribI1ivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1IVEXTPROC glad_debug_glVertexAttribI1ivEXT;
#define glVertexAttribI1ivEXT glad_debug_glVertexAttribI1ivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_debug_glVertexAttribI1ui;
#define glVertexAttribI1ui glad_debug_glVertexAttribI1ui
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIEXTPROC glad_glVertexAttribI1uiEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIEXTPROC glad_debug_glVertexAttribI1uiEXT;
#define glVertexAttribI1uiEXT glad_debug_glVertexAttribI1uiEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_debug_glVertexAttribI1uiv;
#define glVertexAttribI1uiv glad_debug_glVertexAttribI1uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVEXTPROC glad_glVertexAttribI1uivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVEXTPROC glad_debug_glVertexAttribI1uivEXT;
#define glVertexAttribI1uivEXT glad_debug_glVertexAttribI1uivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_debug_glVertexAttribI2i;
#define glVertexAttribI2i glad_debug_glVertexAttribI2i
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IEXTPROC glad_glVertexAttribI2iEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IEXTPROC glad_debug_glVertexAttribI2iEXT;
#define glVertexAttribI2iEXT glad_debug_glVertexAttribI2iEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_debug_glVertexAttribI2iv;
#define glVertexAttribI2iv glad_debug_glVertexAttribI2iv
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IVEXTPROC glad_glVertexAttribI2ivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2IVEXTPROC glad_debug_glVertexAttribI2ivEXT;
#define glVertexAttribI2ivEXT glad_debug_glVertexAttribI2ivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_debug_glVertexAttribI2ui;
#define glVertexAttribI2ui glad_debug_glVertexAttribI2ui
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIEXTPROC glad_glVertexAttribI2uiEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIEXTPROC glad_debug_glVertexAttribI2uiEXT;
#define glVertexAttribI2uiEXT glad_debug_glVertexAttribI2uiEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_debug_glVertexAttribI2uiv;
#define glVertexAttribI2uiv glad_debug_glVertexAttribI2uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVEXTPROC glad_glVertexAttribI2uivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVEXTPROC glad_debug_glVertexAttribI2uivEXT;
#define glVertexAttribI2uivEXT glad_debug_glVertexAttribI2uivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_debug_glVertexAttribI3i;
#define glVertexAttribI3i glad_debug_glVertexAttribI3i
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IEXTPROC glad_glVertexAttribI3iEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IEXTPROC glad_debug_glVertexAttribI3iEXT;
#define glVertexAttribI3iEXT glad_debug_glVertexAttribI3iEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_debug_glVertexAttribI3iv;
#define glVertexAttribI3iv glad_debug_glVertexAttribI3iv
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IVEXTPROC glad_glVertexAttribI3ivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3IVEXTPROC glad_debug_glVertexAttribI3ivEXT;
#define glVertexAttribI3ivEXT glad_debug_glVertexAttribI3ivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_debug_glVertexAttribI3ui;
#define glVertexAttribI3ui glad_debug_glVertexAttribI3ui
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIEXTPROC glad_glVertexAttribI3uiEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIEXTPROC glad_debug_glVertexAttribI3uiEXT;
#define glVertexAttribI3uiEXT glad_debug_glVertexAttribI3uiEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_debug_glVertexAttribI3uiv;
#define glVertexAttribI3uiv glad_debug_glVertexAttribI3uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVEXTPROC glad_glVertexAttribI3uivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVEXTPROC glad_debug_glVertexAttribI3uivEXT;
#define glVertexAttribI3uivEXT glad_debug_glVertexAttribI3uivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_debug_glVertexAttribI4bv;
#define glVertexAttribI4bv glad_debug_glVertexAttribI4bv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4BVEXTPROC glad_glVertexAttribI4bvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4BVEXTPROC glad_debug_glVertexAttribI4bvEXT;
#define glVertexAttribI4bvEXT glad_debug_glVertexAttribI4bvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_debug_glVertexAttribI4i;
#define glVertexAttribI4i glad_debug_glVertexAttribI4i
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IEXTPROC glad_glVertexAttribI4iEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IEXTPROC glad_debug_glVertexAttribI4iEXT;
#define glVertexAttribI4iEXT glad_debug_glVertexAttribI4iEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_debug_glVertexAttribI4iv;
#define glVertexAttribI4iv glad_debug_glVertexAttribI4iv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IVEXTPROC glad_glVertexAttribI4ivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4IVEXTPROC glad_debug_glVertexAttribI4ivEXT;
#define glVertexAttribI4ivEXT glad_debug_glVertexAttribI4ivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_debug_glVertexAttribI4sv;
#define glVertexAttribI4sv glad_debug_glVertexAttribI4sv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4SVEXTPROC glad_glVertexAttribI4svEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4SVEXTPROC glad_debug_glVertexAttribI4svEXT;
#define glVertexAttribI4svEXT glad_debug_glVertexAttribI4svEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_debug_glVertexAttribI4ubv;
#define glVertexAttribI4ubv glad_debug_glVertexAttribI4ubv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVEXTPROC glad_glVertexAttribI4ubvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVEXTPROC glad_debug_glVertexAttribI4ubvEXT;
#define glVertexAttribI4ubvEXT glad_debug_glVertexAttribI4ubvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_debug_glVertexAttribI4ui;
#define glVertexAttribI4ui glad_debug_glVertexAttribI4ui
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIEXTPROC glad_glVertexAttribI4uiEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIEXTPROC glad_debug_glVertexAttribI4uiEXT;
#define glVertexAttribI4uiEXT glad_debug_glVertexAttribI4uiEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_debug_glVertexAttribI4uiv;
#define glVertexAttribI4uiv glad_debug_glVertexAttribI4uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVEXTPROC glad_glVertexAttribI4uivEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVEXTPROC glad_debug_glVertexAttribI4uivEXT;
#define glVertexAttribI4uivEXT glad_debug_glVertexAttribI4uivEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_debug_glVertexAttribI4usv;
#define glVertexAttribI4usv glad_debug_glVertexAttribI4usv
    GLAD_API_CALL PFNGLVERTEXATTRIBI4USVEXTPROC glad_glVertexAttribI4usvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBI4USVEXTPROC glad_debug_glVertexAttribI4usvEXT;
#define glVertexAttribI4usvEXT glad_debug_glVertexAttribI4usvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;
    GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATPROC glad_debug_glVertexAttribIFormat;
#define glVertexAttribIFormat glad_debug_glVertexAttribIFormat
    GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATNVPROC glad_glVertexAttribIFormatNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATNVPROC glad_debug_glVertexAttribIFormatNV;
#define glVertexAttribIFormatNV glad_debug_glVertexAttribIFormatNV
    GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
    GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_debug_glVertexAttribIPointer;
#define glVertexAttribIPointer glad_debug_glVertexAttribIPointer
    GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_glVertexAttribIPointerEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_debug_glVertexAttribIPointerEXT;
#define glVertexAttribIPointerEXT glad_debug_glVertexAttribIPointerEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DPROC glad_debug_glVertexAttribL1d;
#define glVertexAttribL1d glad_debug_glVertexAttribL1d
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DEXTPROC glad_glVertexAttribL1dEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DEXTPROC glad_debug_glVertexAttribL1dEXT;
#define glVertexAttribL1dEXT glad_debug_glVertexAttribL1dEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DVPROC glad_debug_glVertexAttribL1dv;
#define glVertexAttribL1dv glad_debug_glVertexAttribL1dv
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DVEXTPROC glad_glVertexAttribL1dvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1DVEXTPROC glad_debug_glVertexAttribL1dvEXT;
#define glVertexAttribL1dvEXT glad_debug_glVertexAttribL1dvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL1I64NVPROC glad_glVertexAttribL1i64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1I64NVPROC glad_debug_glVertexAttribL1i64NV;
#define glVertexAttribL1i64NV glad_debug_glVertexAttribL1i64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL1I64VNVPROC glad_glVertexAttribL1i64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1I64VNVPROC glad_debug_glVertexAttribL1i64vNV;
#define glVertexAttribL1i64vNV glad_debug_glVertexAttribL1i64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64ARBPROC glad_glVertexAttribL1ui64ARB;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64ARBPROC glad_debug_glVertexAttribL1ui64ARB;
#define glVertexAttribL1ui64ARB glad_debug_glVertexAttribL1ui64ARB
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64NVPROC glad_glVertexAttribL1ui64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64NVPROC glad_debug_glVertexAttribL1ui64NV;
#define glVertexAttribL1ui64NV glad_debug_glVertexAttribL1ui64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VARBPROC glad_glVertexAttribL1ui64vARB;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VARBPROC glad_debug_glVertexAttribL1ui64vARB;
#define glVertexAttribL1ui64vARB glad_debug_glVertexAttribL1ui64vARB
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VNVPROC glad_glVertexAttribL1ui64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VNVPROC glad_debug_glVertexAttribL1ui64vNV;
#define glVertexAttribL1ui64vNV glad_debug_glVertexAttribL1ui64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DPROC glad_debug_glVertexAttribL2d;
#define glVertexAttribL2d glad_debug_glVertexAttribL2d
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DEXTPROC glad_glVertexAttribL2dEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DEXTPROC glad_debug_glVertexAttribL2dEXT;
#define glVertexAttribL2dEXT glad_debug_glVertexAttribL2dEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DVPROC glad_debug_glVertexAttribL2dv;
#define glVertexAttribL2dv glad_debug_glVertexAttribL2dv
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DVEXTPROC glad_glVertexAttribL2dvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2DVEXTPROC glad_debug_glVertexAttribL2dvEXT;
#define glVertexAttribL2dvEXT glad_debug_glVertexAttribL2dvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL2I64NVPROC glad_glVertexAttribL2i64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2I64NVPROC glad_debug_glVertexAttribL2i64NV;
#define glVertexAttribL2i64NV glad_debug_glVertexAttribL2i64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL2I64VNVPROC glad_glVertexAttribL2i64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2I64VNVPROC glad_debug_glVertexAttribL2i64vNV;
#define glVertexAttribL2i64vNV glad_debug_glVertexAttribL2i64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64NVPROC glad_glVertexAttribL2ui64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64NVPROC glad_debug_glVertexAttribL2ui64NV;
#define glVertexAttribL2ui64NV glad_debug_glVertexAttribL2ui64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64VNVPROC glad_glVertexAttribL2ui64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64VNVPROC glad_debug_glVertexAttribL2ui64vNV;
#define glVertexAttribL2ui64vNV glad_debug_glVertexAttribL2ui64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DPROC glad_debug_glVertexAttribL3d;
#define glVertexAttribL3d glad_debug_glVertexAttribL3d
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DEXTPROC glad_glVertexAttribL3dEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DEXTPROC glad_debug_glVertexAttribL3dEXT;
#define glVertexAttribL3dEXT glad_debug_glVertexAttribL3dEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DVPROC glad_debug_glVertexAttribL3dv;
#define glVertexAttribL3dv glad_debug_glVertexAttribL3dv
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DVEXTPROC glad_glVertexAttribL3dvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3DVEXTPROC glad_debug_glVertexAttribL3dvEXT;
#define glVertexAttribL3dvEXT glad_debug_glVertexAttribL3dvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL3I64NVPROC glad_glVertexAttribL3i64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3I64NVPROC glad_debug_glVertexAttribL3i64NV;
#define glVertexAttribL3i64NV glad_debug_glVertexAttribL3i64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL3I64VNVPROC glad_glVertexAttribL3i64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3I64VNVPROC glad_debug_glVertexAttribL3i64vNV;
#define glVertexAttribL3i64vNV glad_debug_glVertexAttribL3i64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64NVPROC glad_glVertexAttribL3ui64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64NVPROC glad_debug_glVertexAttribL3ui64NV;
#define glVertexAttribL3ui64NV glad_debug_glVertexAttribL3ui64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64VNVPROC glad_glVertexAttribL3ui64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64VNVPROC glad_debug_glVertexAttribL3ui64vNV;
#define glVertexAttribL3ui64vNV glad_debug_glVertexAttribL3ui64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DPROC glad_debug_glVertexAttribL4d;
#define glVertexAttribL4d glad_debug_glVertexAttribL4d
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DEXTPROC glad_glVertexAttribL4dEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DEXTPROC glad_debug_glVertexAttribL4dEXT;
#define glVertexAttribL4dEXT glad_debug_glVertexAttribL4dEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DVPROC glad_debug_glVertexAttribL4dv;
#define glVertexAttribL4dv glad_debug_glVertexAttribL4dv
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DVEXTPROC glad_glVertexAttribL4dvEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4DVEXTPROC glad_debug_glVertexAttribL4dvEXT;
#define glVertexAttribL4dvEXT glad_debug_glVertexAttribL4dvEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBL4I64NVPROC glad_glVertexAttribL4i64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4I64NVPROC glad_debug_glVertexAttribL4i64NV;
#define glVertexAttribL4i64NV glad_debug_glVertexAttribL4i64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL4I64VNVPROC glad_glVertexAttribL4i64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4I64VNVPROC glad_debug_glVertexAttribL4i64vNV;
#define glVertexAttribL4i64vNV glad_debug_glVertexAttribL4i64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64NVPROC glad_glVertexAttribL4ui64NV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64NVPROC glad_debug_glVertexAttribL4ui64NV;
#define glVertexAttribL4ui64NV glad_debug_glVertexAttribL4ui64NV
    GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64VNVPROC glad_glVertexAttribL4ui64vNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64VNVPROC glad_debug_glVertexAttribL4ui64vNV;
#define glVertexAttribL4ui64vNV glad_debug_glVertexAttribL4ui64vNV
    GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;
    GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATPROC glad_debug_glVertexAttribLFormat;
#define glVertexAttribLFormat glad_debug_glVertexAttribLFormat
    GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATNVPROC glad_glVertexAttribLFormatNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATNVPROC glad_debug_glVertexAttribLFormatNV;
#define glVertexAttribLFormatNV glad_debug_glVertexAttribLFormatNV
    GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;
    GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTERPROC glad_debug_glVertexAttribLPointer;
#define glVertexAttribLPointer glad_debug_glVertexAttribLPointer
    GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_glVertexAttribLPointerEXT;
    GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_debug_glVertexAttribLPointerEXT;
#define glVertexAttribLPointerEXT glad_debug_glVertexAttribLPointerEXT
    GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_debug_glVertexAttribP1ui;
#define glVertexAttribP1ui glad_debug_glVertexAttribP1ui
    GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_debug_glVertexAttribP1uiv;
#define glVertexAttribP1uiv glad_debug_glVertexAttribP1uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_debug_glVertexAttribP2ui;
#define glVertexAttribP2ui glad_debug_glVertexAttribP2ui
    GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_debug_glVertexAttribP2uiv;
#define glVertexAttribP2uiv glad_debug_glVertexAttribP2uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_debug_glVertexAttribP3ui;
#define glVertexAttribP3ui glad_debug_glVertexAttribP3ui
    GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_debug_glVertexAttribP3uiv;
#define glVertexAttribP3uiv glad_debug_glVertexAttribP3uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
    GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_debug_glVertexAttribP4ui;
#define glVertexAttribP4ui glad_debug_glVertexAttribP4ui
    GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
    GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_debug_glVertexAttribP4uiv;
#define glVertexAttribP4uiv glad_debug_glVertexAttribP4uiv
    GLAD_API_CALL PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_glVertexAttribParameteriAMD;
    GLAD_API_CALL PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_debug_glVertexAttribParameteriAMD;
#define glVertexAttribParameteriAMD glad_debug_glVertexAttribParameteriAMD
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_debug_glVertexAttribPointer;

/// <summary>
///   define an array of generic vertex attribute data
///   <para>
///     glVertexAttribPointer , glVertexAttribIPointer and glVertexAttribLPointer specify the
///     location and data format of the array of generic vertex attributes at index index to use
///     when rendering. size specifies the number of components per attribute and must be 1, 2, 3,
///     4, or GL_BGRA. type specifies the data type of each component, and stride specifies the byte
///     stride from one attribute to the next, allowing vertices and attributes to be packed into a
///     single array or stored in separate arrays. For glVertexAttribPointer , if normalized is set
///     to GL_TRUE , it indicates that values stored in an integer format are to be mapped to the
///     range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and
///     converted to floating point. Otherwise, values will be converted to floats directly without
///     normalization. For glVertexAttribIPointer , only the integer types GL_BYTE ,
///     GL_UNSIGNED_BYTE , GL_SHORT , GL_UNSIGNED_SHORT , GL_INT , GL_UNSIGNED_INT are accepted.
///     Values are always left as integer values. glVertexAttribLPointer specifies state for a
///     generic vertex attribute array associated with a shader attribute variable declared with
///     64-bit double precision components. type must be GL_DOUBLE. index , size , and stride behave
///     as described for glVertexAttribPointer and glVertexAttribIPointer. If pointer is not NULL ,
///     a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target (see glBindBuffer
///     ), otherwise an error is generated. pointer is treated as a byte offset into the buffer
///     object's data store. The buffer object binding ( GL_ARRAY_BUFFER_BINDING ) is saved as
///     generic vertex attribute array state ( GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING ) for index
///     index. When a generic vertex attribute array is specified, size , type , normalized , stride
///     , and pointer are saved as vertex array state, in addition to the current vertex array
///     buffer object binding. To enable and disable a generic vertex attribute array, call
///     glEnableVertexAttribArray and glDisableVertexAttribArray with index. If enabled, the generic
///     vertex attribute array is used when glDrawArrays , glMultiDrawArrays , glDrawElements ,
///     glMultiDrawElements , or glDrawRangeElements is called.
///   </para>
/// </summary>
/// <param name='index'>Specifies the index of the generic vertex attribute to be modified.</param>
/// <param name='size'>Specifies the number of components per generic vertex attribute. Must be 1,
/// 2, 3, 4. Additionally, the symbolic constant</param> <param name='type'>Specifies the data type
/// of each component in the array. The symbolic constants</param> <param
/// name='normalized'>For</param> <param name='stride'>Specifies the byte offset between consecutive
/// generic vertex attributes. If</param> <param name='pointer'>Specifies a offset of the first
/// component of the first generic vertex attribute in the array in the data store of the buffer
/// currently bound to the</param>
#define glVertexAttribPointer glad_debug_glVertexAttribPointer
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERARBPROC glad_glVertexAttribPointerARB;
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERARBPROC glad_debug_glVertexAttribPointerARB;
#define glVertexAttribPointerARB glad_debug_glVertexAttribPointerARB
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERNVPROC glad_glVertexAttribPointerNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERNVPROC glad_debug_glVertexAttribPointerNV;
#define glVertexAttribPointerNV glad_debug_glVertexAttribPointerNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS1DVNVPROC glad_glVertexAttribs1dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS1DVNVPROC glad_debug_glVertexAttribs1dvNV;
#define glVertexAttribs1dvNV glad_debug_glVertexAttribs1dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS1FVNVPROC glad_glVertexAttribs1fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS1FVNVPROC glad_debug_glVertexAttribs1fvNV;
#define glVertexAttribs1fvNV glad_debug_glVertexAttribs1fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS1HVNVPROC glad_glVertexAttribs1hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS1HVNVPROC glad_debug_glVertexAttribs1hvNV;
#define glVertexAttribs1hvNV glad_debug_glVertexAttribs1hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS1SVNVPROC glad_glVertexAttribs1svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS1SVNVPROC glad_debug_glVertexAttribs1svNV;
#define glVertexAttribs1svNV glad_debug_glVertexAttribs1svNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS2DVNVPROC glad_glVertexAttribs2dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS2DVNVPROC glad_debug_glVertexAttribs2dvNV;
#define glVertexAttribs2dvNV glad_debug_glVertexAttribs2dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS2FVNVPROC glad_glVertexAttribs2fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS2FVNVPROC glad_debug_glVertexAttribs2fvNV;
#define glVertexAttribs2fvNV glad_debug_glVertexAttribs2fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS2HVNVPROC glad_glVertexAttribs2hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS2HVNVPROC glad_debug_glVertexAttribs2hvNV;
#define glVertexAttribs2hvNV glad_debug_glVertexAttribs2hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS2SVNVPROC glad_glVertexAttribs2svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS2SVNVPROC glad_debug_glVertexAttribs2svNV;
#define glVertexAttribs2svNV glad_debug_glVertexAttribs2svNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS3DVNVPROC glad_glVertexAttribs3dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS3DVNVPROC glad_debug_glVertexAttribs3dvNV;
#define glVertexAttribs3dvNV glad_debug_glVertexAttribs3dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS3FVNVPROC glad_glVertexAttribs3fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS3FVNVPROC glad_debug_glVertexAttribs3fvNV;
#define glVertexAttribs3fvNV glad_debug_glVertexAttribs3fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS3HVNVPROC glad_glVertexAttribs3hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS3HVNVPROC glad_debug_glVertexAttribs3hvNV;
#define glVertexAttribs3hvNV glad_debug_glVertexAttribs3hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS3SVNVPROC glad_glVertexAttribs3svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS3SVNVPROC glad_debug_glVertexAttribs3svNV;
#define glVertexAttribs3svNV glad_debug_glVertexAttribs3svNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS4DVNVPROC glad_glVertexAttribs4dvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS4DVNVPROC glad_debug_glVertexAttribs4dvNV;
#define glVertexAttribs4dvNV glad_debug_glVertexAttribs4dvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS4FVNVPROC glad_glVertexAttribs4fvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS4FVNVPROC glad_debug_glVertexAttribs4fvNV;
#define glVertexAttribs4fvNV glad_debug_glVertexAttribs4fvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS4HVNVPROC glad_glVertexAttribs4hvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS4HVNVPROC glad_debug_glVertexAttribs4hvNV;
#define glVertexAttribs4hvNV glad_debug_glVertexAttribs4hvNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS4SVNVPROC glad_glVertexAttribs4svNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS4SVNVPROC glad_debug_glVertexAttribs4svNV;
#define glVertexAttribs4svNV glad_debug_glVertexAttribs4svNV
    GLAD_API_CALL PFNGLVERTEXATTRIBS4UBVNVPROC glad_glVertexAttribs4ubvNV;
    GLAD_API_CALL PFNGLVERTEXATTRIBS4UBVNVPROC glad_debug_glVertexAttribs4ubvNV;
#define glVertexAttribs4ubvNV glad_debug_glVertexAttribs4ubvNV
    GLAD_API_CALL PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;
    GLAD_API_CALL PFNGLVERTEXBINDINGDIVISORPROC glad_debug_glVertexBindingDivisor;

/// <summary>
///   modify the rate at which generic vertex attributes advance
///   <para>
///     glVertexBindingDivisor and glVertexArrayBindingDivisor modify the rate at which generic
///     vertex attributes advance when rendering multiple instances of primitives in a single draw
///     command. If divisor is zero, the attributes using the buffer bound to bindingindex advance
///     once per vertex. If divisor is non-zero, the attributes advance once per divisor instances
///     of the set(s) of vertices being rendered. An attribute is referred to as instanced if the
///     corresponding divisor value is non-zero. glVertexBindingDivisor uses currently bound vertex
///     array object , whereas glVertexArrayBindingDivisor updates state of the vertex array object
///     with ID vaobj.
///   </para>
/// </summary>
/// <param name='vaobj'>Specifies the name of the vertex array object for</param>
/// <param name='bindingindex'>The index of the binding whose divisor to modify.</param>
/// <param name='divisor'>The new value for the instance step rate to apply.</param>
#define glVertexBindingDivisor glad_debug_glVertexBindingDivisor
    GLAD_API_CALL PFNGLVERTEXBLENDARBPROC glad_glVertexBlendARB;
    GLAD_API_CALL PFNGLVERTEXBLENDARBPROC glad_debug_glVertexBlendARB;
#define glVertexBlendARB glad_debug_glVertexBlendARB
    GLAD_API_CALL PFNGLVERTEXBLENDENVFATIPROC glad_glVertexBlendEnvfATI;
    GLAD_API_CALL PFNGLVERTEXBLENDENVFATIPROC glad_debug_glVertexBlendEnvfATI;
#define glVertexBlendEnvfATI glad_debug_glVertexBlendEnvfATI
    GLAD_API_CALL PFNGLVERTEXBLENDENVIATIPROC glad_glVertexBlendEnviATI;
    GLAD_API_CALL PFNGLVERTEXBLENDENVIATIPROC glad_debug_glVertexBlendEnviATI;
#define glVertexBlendEnviATI glad_debug_glVertexBlendEnviATI
    GLAD_API_CALL PFNGLVERTEXFORMATNVPROC glad_glVertexFormatNV;
    GLAD_API_CALL PFNGLVERTEXFORMATNVPROC glad_debug_glVertexFormatNV;
#define glVertexFormatNV glad_debug_glVertexFormatNV
    GLAD_API_CALL PFNGLVERTEXPOINTEREXTPROC glad_glVertexPointerEXT;
    GLAD_API_CALL PFNGLVERTEXPOINTEREXTPROC glad_debug_glVertexPointerEXT;
#define glVertexPointerEXT glad_debug_glVertexPointerEXT
    GLAD_API_CALL PFNGLVERTEXPOINTERLISTIBMPROC glad_glVertexPointerListIBM;
    GLAD_API_CALL PFNGLVERTEXPOINTERLISTIBMPROC glad_debug_glVertexPointerListIBM;
#define glVertexPointerListIBM glad_debug_glVertexPointerListIBM
    GLAD_API_CALL PFNGLVERTEXPOINTERVINTELPROC glad_glVertexPointervINTEL;
    GLAD_API_CALL PFNGLVERTEXPOINTERVINTELPROC glad_debug_glVertexPointervINTEL;
#define glVertexPointervINTEL glad_debug_glVertexPointervINTEL
    GLAD_API_CALL PFNGLVERTEXSTREAM1DATIPROC glad_glVertexStream1dATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1DATIPROC glad_debug_glVertexStream1dATI;
#define glVertexStream1dATI glad_debug_glVertexStream1dATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1DVATIPROC glad_glVertexStream1dvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1DVATIPROC glad_debug_glVertexStream1dvATI;
#define glVertexStream1dvATI glad_debug_glVertexStream1dvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1FATIPROC glad_glVertexStream1fATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1FATIPROC glad_debug_glVertexStream1fATI;
#define glVertexStream1fATI glad_debug_glVertexStream1fATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1FVATIPROC glad_glVertexStream1fvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1FVATIPROC glad_debug_glVertexStream1fvATI;
#define glVertexStream1fvATI glad_debug_glVertexStream1fvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1IATIPROC glad_glVertexStream1iATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1IATIPROC glad_debug_glVertexStream1iATI;
#define glVertexStream1iATI glad_debug_glVertexStream1iATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1IVATIPROC glad_glVertexStream1ivATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1IVATIPROC glad_debug_glVertexStream1ivATI;
#define glVertexStream1ivATI glad_debug_glVertexStream1ivATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1SATIPROC glad_glVertexStream1sATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1SATIPROC glad_debug_glVertexStream1sATI;
#define glVertexStream1sATI glad_debug_glVertexStream1sATI
    GLAD_API_CALL PFNGLVERTEXSTREAM1SVATIPROC glad_glVertexStream1svATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM1SVATIPROC glad_debug_glVertexStream1svATI;
#define glVertexStream1svATI glad_debug_glVertexStream1svATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2DATIPROC glad_glVertexStream2dATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2DATIPROC glad_debug_glVertexStream2dATI;
#define glVertexStream2dATI glad_debug_glVertexStream2dATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2DVATIPROC glad_glVertexStream2dvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2DVATIPROC glad_debug_glVertexStream2dvATI;
#define glVertexStream2dvATI glad_debug_glVertexStream2dvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2FATIPROC glad_glVertexStream2fATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2FATIPROC glad_debug_glVertexStream2fATI;
#define glVertexStream2fATI glad_debug_glVertexStream2fATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2FVATIPROC glad_glVertexStream2fvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2FVATIPROC glad_debug_glVertexStream2fvATI;
#define glVertexStream2fvATI glad_debug_glVertexStream2fvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2IATIPROC glad_glVertexStream2iATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2IATIPROC glad_debug_glVertexStream2iATI;
#define glVertexStream2iATI glad_debug_glVertexStream2iATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2IVATIPROC glad_glVertexStream2ivATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2IVATIPROC glad_debug_glVertexStream2ivATI;
#define glVertexStream2ivATI glad_debug_glVertexStream2ivATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2SATIPROC glad_glVertexStream2sATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2SATIPROC glad_debug_glVertexStream2sATI;
#define glVertexStream2sATI glad_debug_glVertexStream2sATI
    GLAD_API_CALL PFNGLVERTEXSTREAM2SVATIPROC glad_glVertexStream2svATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM2SVATIPROC glad_debug_glVertexStream2svATI;
#define glVertexStream2svATI glad_debug_glVertexStream2svATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3DATIPROC glad_glVertexStream3dATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3DATIPROC glad_debug_glVertexStream3dATI;
#define glVertexStream3dATI glad_debug_glVertexStream3dATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3DVATIPROC glad_glVertexStream3dvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3DVATIPROC glad_debug_glVertexStream3dvATI;
#define glVertexStream3dvATI glad_debug_glVertexStream3dvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3FATIPROC glad_glVertexStream3fATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3FATIPROC glad_debug_glVertexStream3fATI;
#define glVertexStream3fATI glad_debug_glVertexStream3fATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3FVATIPROC glad_glVertexStream3fvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3FVATIPROC glad_debug_glVertexStream3fvATI;
#define glVertexStream3fvATI glad_debug_glVertexStream3fvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3IATIPROC glad_glVertexStream3iATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3IATIPROC glad_debug_glVertexStream3iATI;
#define glVertexStream3iATI glad_debug_glVertexStream3iATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3IVATIPROC glad_glVertexStream3ivATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3IVATIPROC glad_debug_glVertexStream3ivATI;
#define glVertexStream3ivATI glad_debug_glVertexStream3ivATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3SATIPROC glad_glVertexStream3sATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3SATIPROC glad_debug_glVertexStream3sATI;
#define glVertexStream3sATI glad_debug_glVertexStream3sATI
    GLAD_API_CALL PFNGLVERTEXSTREAM3SVATIPROC glad_glVertexStream3svATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM3SVATIPROC glad_debug_glVertexStream3svATI;
#define glVertexStream3svATI glad_debug_glVertexStream3svATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4DATIPROC glad_glVertexStream4dATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4DATIPROC glad_debug_glVertexStream4dATI;
#define glVertexStream4dATI glad_debug_glVertexStream4dATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4DVATIPROC glad_glVertexStream4dvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4DVATIPROC glad_debug_glVertexStream4dvATI;
#define glVertexStream4dvATI glad_debug_glVertexStream4dvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4FATIPROC glad_glVertexStream4fATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4FATIPROC glad_debug_glVertexStream4fATI;
#define glVertexStream4fATI glad_debug_glVertexStream4fATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4FVATIPROC glad_glVertexStream4fvATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4FVATIPROC glad_debug_glVertexStream4fvATI;
#define glVertexStream4fvATI glad_debug_glVertexStream4fvATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4IATIPROC glad_glVertexStream4iATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4IATIPROC glad_debug_glVertexStream4iATI;
#define glVertexStream4iATI glad_debug_glVertexStream4iATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4IVATIPROC glad_glVertexStream4ivATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4IVATIPROC glad_debug_glVertexStream4ivATI;
#define glVertexStream4ivATI glad_debug_glVertexStream4ivATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4SATIPROC glad_glVertexStream4sATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4SATIPROC glad_debug_glVertexStream4sATI;
#define glVertexStream4sATI glad_debug_glVertexStream4sATI
    GLAD_API_CALL PFNGLVERTEXSTREAM4SVATIPROC glad_glVertexStream4svATI;
    GLAD_API_CALL PFNGLVERTEXSTREAM4SVATIPROC glad_debug_glVertexStream4svATI;
#define glVertexStream4svATI glad_debug_glVertexStream4svATI
    GLAD_API_CALL PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_glVertexWeightPointerEXT;
    GLAD_API_CALL PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_debug_glVertexWeightPointerEXT;
#define glVertexWeightPointerEXT glad_debug_glVertexWeightPointerEXT
    GLAD_API_CALL PFNGLVERTEXWEIGHTFEXTPROC glad_glVertexWeightfEXT;
    GLAD_API_CALL PFNGLVERTEXWEIGHTFEXTPROC glad_debug_glVertexWeightfEXT;
#define glVertexWeightfEXT glad_debug_glVertexWeightfEXT
    GLAD_API_CALL PFNGLVERTEXWEIGHTFVEXTPROC glad_glVertexWeightfvEXT;
    GLAD_API_CALL PFNGLVERTEXWEIGHTFVEXTPROC glad_debug_glVertexWeightfvEXT;
#define glVertexWeightfvEXT glad_debug_glVertexWeightfvEXT
    GLAD_API_CALL PFNGLVERTEXWEIGHTHNVPROC glad_glVertexWeighthNV;
    GLAD_API_CALL PFNGLVERTEXWEIGHTHNVPROC glad_debug_glVertexWeighthNV;
#define glVertexWeighthNV glad_debug_glVertexWeighthNV
    GLAD_API_CALL PFNGLVERTEXWEIGHTHVNVPROC glad_glVertexWeighthvNV;
    GLAD_API_CALL PFNGLVERTEXWEIGHTHVNVPROC glad_debug_glVertexWeighthvNV;
#define glVertexWeighthvNV glad_debug_glVertexWeighthvNV
    GLAD_API_CALL PFNGLVIDEOCAPTURENVPROC glad_glVideoCaptureNV;
    GLAD_API_CALL PFNGLVIDEOCAPTURENVPROC glad_debug_glVideoCaptureNV;
#define glVideoCaptureNV glad_debug_glVideoCaptureNV
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC glad_glVideoCaptureStreamParameterdvNV;
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC
        glad_debug_glVideoCaptureStreamParameterdvNV;
#define glVideoCaptureStreamParameterdvNV glad_debug_glVideoCaptureStreamParameterdvNV
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC glad_glVideoCaptureStreamParameterfvNV;
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC
        glad_debug_glVideoCaptureStreamParameterfvNV;
#define glVideoCaptureStreamParameterfvNV glad_debug_glVideoCaptureStreamParameterfvNV
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC glad_glVideoCaptureStreamParameterivNV;
    GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC
        glad_debug_glVideoCaptureStreamParameterivNV;
#define glVideoCaptureStreamParameterivNV glad_debug_glVideoCaptureStreamParameterivNV
    GLAD_API_CALL PFNGLVIEWPORTPROC glad_glViewport;
    GLAD_API_CALL PFNGLVIEWPORTPROC glad_debug_glViewport;

/// <summary>
///   set the viewport
///   <para>
///     glViewport specifies the affine transformation of x and y from normalized device coordinates
///     to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
///     coordinates x w y w are computed as follows: Viewport width and height are silently clamped
///     to a range that depends on the implementation. To query this range, call glGet with argument
///     GL_MAX_VIEWPORT_DIMS.
///   </para>
/// </summary>
/// <param name='x'>Specify the lower left corner of the viewport rectangle, in pixels. The initial
/// value is (0,0).</param> <param name='y'>Specify the width and height of the viewport. When a GL
/// context is first attached to a window,</param>
#define glViewport glad_debug_glViewport
    GLAD_API_CALL PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;
    GLAD_API_CALL PFNGLVIEWPORTARRAYVPROC glad_debug_glViewportArrayv;
#define glViewportArrayv glad_debug_glViewportArrayv
    GLAD_API_CALL PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;
    GLAD_API_CALL PFNGLVIEWPORTINDEXEDFPROC glad_debug_glViewportIndexedf;
#define glViewportIndexedf glad_debug_glViewportIndexedf
    GLAD_API_CALL PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;
    GLAD_API_CALL PFNGLVIEWPORTINDEXEDFVPROC glad_debug_glViewportIndexedfv;
#define glViewportIndexedfv glad_debug_glViewportIndexedfv
    GLAD_API_CALL PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_glViewportPositionWScaleNV;
    GLAD_API_CALL PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_debug_glViewportPositionWScaleNV;
#define glViewportPositionWScaleNV glad_debug_glViewportPositionWScaleNV
    GLAD_API_CALL PFNGLVIEWPORTSWIZZLENVPROC glad_glViewportSwizzleNV;
    GLAD_API_CALL PFNGLVIEWPORTSWIZZLENVPROC glad_debug_glViewportSwizzleNV;
#define glViewportSwizzleNV glad_debug_glViewportSwizzleNV
    GLAD_API_CALL PFNGLWAITSEMAPHOREEXTPROC glad_glWaitSemaphoreEXT;
    GLAD_API_CALL PFNGLWAITSEMAPHOREEXTPROC glad_debug_glWaitSemaphoreEXT;
#define glWaitSemaphoreEXT glad_debug_glWaitSemaphoreEXT
    GLAD_API_CALL PFNGLWAITSEMAPHOREUI64NVXPROC glad_glWaitSemaphoreui64NVX;
    GLAD_API_CALL PFNGLWAITSEMAPHOREUI64NVXPROC glad_debug_glWaitSemaphoreui64NVX;
#define glWaitSemaphoreui64NVX glad_debug_glWaitSemaphoreui64NVX
    GLAD_API_CALL PFNGLWAITSYNCPROC glad_glWaitSync;
    GLAD_API_CALL PFNGLWAITSYNCPROC glad_debug_glWaitSync;

/// <summary>
///   instruct the GL server to block until the specified sync object becomes signaled
///   <para>
///     glWaitSync causes the GL server to block and wait until sync becomes signaled. sync is the
///     name of an existing sync object upon which to wait. flags and timeout are currently not used
///     and must be set to zero and the special value GL_TIMEOUT_IGNORED , respectively [1].
///     glWaitSync will always wait no longer than an implementation-dependent timeout. The duration
///     of this timeout in nanoseconds may be queried by calling glGet with the parameter
///     GL_MAX_SERVER_WAIT_TIMEOUT. There is currently no way to determine whether glWaitSync
///     unblocked because the timeout expired or because the sync object being waited on was
///     signaled. If an error occurs, glWaitSync does not cause the GL server to block.
///   </para>
/// </summary>
/// <param name='sync'>Specifies the sync object whose status to wait on.</param>
/// <param name='flags'>A bitfield controlling the command flushing behavior.</param>
/// <param name='timeout'>Specifies the timeout that the server should wait before
/// continuing.</param>
#define glWaitSync glad_debug_glWaitSync
    GLAD_API_CALL PFNGLWAITVKSEMAPHORENVPROC glad_glWaitVkSemaphoreNV;
    GLAD_API_CALL PFNGLWAITVKSEMAPHORENVPROC glad_debug_glWaitVkSemaphoreNV;
#define glWaitVkSemaphoreNV glad_debug_glWaitVkSemaphoreNV
    GLAD_API_CALL PFNGLWEIGHTPATHSNVPROC glad_glWeightPathsNV;
    GLAD_API_CALL PFNGLWEIGHTPATHSNVPROC glad_debug_glWeightPathsNV;
#define glWeightPathsNV glad_debug_glWeightPathsNV
    GLAD_API_CALL PFNGLWEIGHTPOINTERARBPROC glad_glWeightPointerARB;
    GLAD_API_CALL PFNGLWEIGHTPOINTERARBPROC glad_debug_glWeightPointerARB;
#define glWeightPointerARB glad_debug_glWeightPointerARB
    GLAD_API_CALL PFNGLWEIGHTBVARBPROC glad_glWeightbvARB;
    GLAD_API_CALL PFNGLWEIGHTBVARBPROC glad_debug_glWeightbvARB;
#define glWeightbvARB glad_debug_glWeightbvARB
    GLAD_API_CALL PFNGLWEIGHTDVARBPROC glad_glWeightdvARB;
    GLAD_API_CALL PFNGLWEIGHTDVARBPROC glad_debug_glWeightdvARB;
#define glWeightdvARB glad_debug_glWeightdvARB
    GLAD_API_CALL PFNGLWEIGHTFVARBPROC glad_glWeightfvARB;
    GLAD_API_CALL PFNGLWEIGHTFVARBPROC glad_debug_glWeightfvARB;
#define glWeightfvARB glad_debug_glWeightfvARB
    GLAD_API_CALL PFNGLWEIGHTIVARBPROC glad_glWeightivARB;
    GLAD_API_CALL PFNGLWEIGHTIVARBPROC glad_debug_glWeightivARB;
#define glWeightivARB glad_debug_glWeightivARB
    GLAD_API_CALL PFNGLWEIGHTSVARBPROC glad_glWeightsvARB;
    GLAD_API_CALL PFNGLWEIGHTSVARBPROC glad_debug_glWeightsvARB;
#define glWeightsvARB glad_debug_glWeightsvARB
    GLAD_API_CALL PFNGLWEIGHTUBVARBPROC glad_glWeightubvARB;
    GLAD_API_CALL PFNGLWEIGHTUBVARBPROC glad_debug_glWeightubvARB;
#define glWeightubvARB glad_debug_glWeightubvARB
    GLAD_API_CALL PFNGLWEIGHTUIVARBPROC glad_glWeightuivARB;
    GLAD_API_CALL PFNGLWEIGHTUIVARBPROC glad_debug_glWeightuivARB;
#define glWeightuivARB glad_debug_glWeightuivARB
    GLAD_API_CALL PFNGLWEIGHTUSVARBPROC glad_glWeightusvARB;
    GLAD_API_CALL PFNGLWEIGHTUSVARBPROC glad_debug_glWeightusvARB;
#define glWeightusvARB glad_debug_glWeightusvARB
    GLAD_API_CALL PFNGLWINDOWPOS2DARBPROC glad_glWindowPos2dARB;
    GLAD_API_CALL PFNGLWINDOWPOS2DARBPROC glad_debug_glWindowPos2dARB;
#define glWindowPos2dARB glad_debug_glWindowPos2dARB
    GLAD_API_CALL PFNGLWINDOWPOS2DMESAPROC glad_glWindowPos2dMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2DMESAPROC glad_debug_glWindowPos2dMESA;
#define glWindowPos2dMESA glad_debug_glWindowPos2dMESA
    GLAD_API_CALL PFNGLWINDOWPOS2DVARBPROC glad_glWindowPos2dvARB;
    GLAD_API_CALL PFNGLWINDOWPOS2DVARBPROC glad_debug_glWindowPos2dvARB;
#define glWindowPos2dvARB glad_debug_glWindowPos2dvARB
    GLAD_API_CALL PFNGLWINDOWPOS2DVMESAPROC glad_glWindowPos2dvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2DVMESAPROC glad_debug_glWindowPos2dvMESA;
#define glWindowPos2dvMESA glad_debug_glWindowPos2dvMESA
    GLAD_API_CALL PFNGLWINDOWPOS2FARBPROC glad_glWindowPos2fARB;
    GLAD_API_CALL PFNGLWINDOWPOS2FARBPROC glad_debug_glWindowPos2fARB;
#define glWindowPos2fARB glad_debug_glWindowPos2fARB
    GLAD_API_CALL PFNGLWINDOWPOS2FMESAPROC glad_glWindowPos2fMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2FMESAPROC glad_debug_glWindowPos2fMESA;
#define glWindowPos2fMESA glad_debug_glWindowPos2fMESA
    GLAD_API_CALL PFNGLWINDOWPOS2FVARBPROC glad_glWindowPos2fvARB;
    GLAD_API_CALL PFNGLWINDOWPOS2FVARBPROC glad_debug_glWindowPos2fvARB;
#define glWindowPos2fvARB glad_debug_glWindowPos2fvARB
    GLAD_API_CALL PFNGLWINDOWPOS2FVMESAPROC glad_glWindowPos2fvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2FVMESAPROC glad_debug_glWindowPos2fvMESA;
#define glWindowPos2fvMESA glad_debug_glWindowPos2fvMESA
    GLAD_API_CALL PFNGLWINDOWPOS2IARBPROC glad_glWindowPos2iARB;
    GLAD_API_CALL PFNGLWINDOWPOS2IARBPROC glad_debug_glWindowPos2iARB;
#define glWindowPos2iARB glad_debug_glWindowPos2iARB
    GLAD_API_CALL PFNGLWINDOWPOS2IMESAPROC glad_glWindowPos2iMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2IMESAPROC glad_debug_glWindowPos2iMESA;
#define glWindowPos2iMESA glad_debug_glWindowPos2iMESA
    GLAD_API_CALL PFNGLWINDOWPOS2IVARBPROC glad_glWindowPos2ivARB;
    GLAD_API_CALL PFNGLWINDOWPOS2IVARBPROC glad_debug_glWindowPos2ivARB;
#define glWindowPos2ivARB glad_debug_glWindowPos2ivARB
    GLAD_API_CALL PFNGLWINDOWPOS2IVMESAPROC glad_glWindowPos2ivMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2IVMESAPROC glad_debug_glWindowPos2ivMESA;
#define glWindowPos2ivMESA glad_debug_glWindowPos2ivMESA
    GLAD_API_CALL PFNGLWINDOWPOS2SARBPROC glad_glWindowPos2sARB;
    GLAD_API_CALL PFNGLWINDOWPOS2SARBPROC glad_debug_glWindowPos2sARB;
#define glWindowPos2sARB glad_debug_glWindowPos2sARB
    GLAD_API_CALL PFNGLWINDOWPOS2SMESAPROC glad_glWindowPos2sMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2SMESAPROC glad_debug_glWindowPos2sMESA;
#define glWindowPos2sMESA glad_debug_glWindowPos2sMESA
    GLAD_API_CALL PFNGLWINDOWPOS2SVARBPROC glad_glWindowPos2svARB;
    GLAD_API_CALL PFNGLWINDOWPOS2SVARBPROC glad_debug_glWindowPos2svARB;
#define glWindowPos2svARB glad_debug_glWindowPos2svARB
    GLAD_API_CALL PFNGLWINDOWPOS2SVMESAPROC glad_glWindowPos2svMESA;
    GLAD_API_CALL PFNGLWINDOWPOS2SVMESAPROC glad_debug_glWindowPos2svMESA;
#define glWindowPos2svMESA glad_debug_glWindowPos2svMESA
    GLAD_API_CALL PFNGLWINDOWPOS3DARBPROC glad_glWindowPos3dARB;
    GLAD_API_CALL PFNGLWINDOWPOS3DARBPROC glad_debug_glWindowPos3dARB;
#define glWindowPos3dARB glad_debug_glWindowPos3dARB
    GLAD_API_CALL PFNGLWINDOWPOS3DMESAPROC glad_glWindowPos3dMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3DMESAPROC glad_debug_glWindowPos3dMESA;
#define glWindowPos3dMESA glad_debug_glWindowPos3dMESA
    GLAD_API_CALL PFNGLWINDOWPOS3DVARBPROC glad_glWindowPos3dvARB;
    GLAD_API_CALL PFNGLWINDOWPOS3DVARBPROC glad_debug_glWindowPos3dvARB;
#define glWindowPos3dvARB glad_debug_glWindowPos3dvARB
    GLAD_API_CALL PFNGLWINDOWPOS3DVMESAPROC glad_glWindowPos3dvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3DVMESAPROC glad_debug_glWindowPos3dvMESA;
#define glWindowPos3dvMESA glad_debug_glWindowPos3dvMESA
    GLAD_API_CALL PFNGLWINDOWPOS3FARBPROC glad_glWindowPos3fARB;
    GLAD_API_CALL PFNGLWINDOWPOS3FARBPROC glad_debug_glWindowPos3fARB;
#define glWindowPos3fARB glad_debug_glWindowPos3fARB
    GLAD_API_CALL PFNGLWINDOWPOS3FMESAPROC glad_glWindowPos3fMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3FMESAPROC glad_debug_glWindowPos3fMESA;
#define glWindowPos3fMESA glad_debug_glWindowPos3fMESA
    GLAD_API_CALL PFNGLWINDOWPOS3FVARBPROC glad_glWindowPos3fvARB;
    GLAD_API_CALL PFNGLWINDOWPOS3FVARBPROC glad_debug_glWindowPos3fvARB;
#define glWindowPos3fvARB glad_debug_glWindowPos3fvARB
    GLAD_API_CALL PFNGLWINDOWPOS3FVMESAPROC glad_glWindowPos3fvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3FVMESAPROC glad_debug_glWindowPos3fvMESA;
#define glWindowPos3fvMESA glad_debug_glWindowPos3fvMESA
    GLAD_API_CALL PFNGLWINDOWPOS3IARBPROC glad_glWindowPos3iARB;
    GLAD_API_CALL PFNGLWINDOWPOS3IARBPROC glad_debug_glWindowPos3iARB;
#define glWindowPos3iARB glad_debug_glWindowPos3iARB
    GLAD_API_CALL PFNGLWINDOWPOS3IMESAPROC glad_glWindowPos3iMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3IMESAPROC glad_debug_glWindowPos3iMESA;
#define glWindowPos3iMESA glad_debug_glWindowPos3iMESA
    GLAD_API_CALL PFNGLWINDOWPOS3IVARBPROC glad_glWindowPos3ivARB;
    GLAD_API_CALL PFNGLWINDOWPOS3IVARBPROC glad_debug_glWindowPos3ivARB;
#define glWindowPos3ivARB glad_debug_glWindowPos3ivARB
    GLAD_API_CALL PFNGLWINDOWPOS3IVMESAPROC glad_glWindowPos3ivMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3IVMESAPROC glad_debug_glWindowPos3ivMESA;
#define glWindowPos3ivMESA glad_debug_glWindowPos3ivMESA
    GLAD_API_CALL PFNGLWINDOWPOS3SARBPROC glad_glWindowPos3sARB;
    GLAD_API_CALL PFNGLWINDOWPOS3SARBPROC glad_debug_glWindowPos3sARB;
#define glWindowPos3sARB glad_debug_glWindowPos3sARB
    GLAD_API_CALL PFNGLWINDOWPOS3SMESAPROC glad_glWindowPos3sMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3SMESAPROC glad_debug_glWindowPos3sMESA;
#define glWindowPos3sMESA glad_debug_glWindowPos3sMESA
    GLAD_API_CALL PFNGLWINDOWPOS3SVARBPROC glad_glWindowPos3svARB;
    GLAD_API_CALL PFNGLWINDOWPOS3SVARBPROC glad_debug_glWindowPos3svARB;
#define glWindowPos3svARB glad_debug_glWindowPos3svARB
    GLAD_API_CALL PFNGLWINDOWPOS3SVMESAPROC glad_glWindowPos3svMESA;
    GLAD_API_CALL PFNGLWINDOWPOS3SVMESAPROC glad_debug_glWindowPos3svMESA;
#define glWindowPos3svMESA glad_debug_glWindowPos3svMESA
    GLAD_API_CALL PFNGLWINDOWPOS4DMESAPROC glad_glWindowPos4dMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4DMESAPROC glad_debug_glWindowPos4dMESA;
#define glWindowPos4dMESA glad_debug_glWindowPos4dMESA
    GLAD_API_CALL PFNGLWINDOWPOS4DVMESAPROC glad_glWindowPos4dvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4DVMESAPROC glad_debug_glWindowPos4dvMESA;
#define glWindowPos4dvMESA glad_debug_glWindowPos4dvMESA
    GLAD_API_CALL PFNGLWINDOWPOS4FMESAPROC glad_glWindowPos4fMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4FMESAPROC glad_debug_glWindowPos4fMESA;
#define glWindowPos4fMESA glad_debug_glWindowPos4fMESA
    GLAD_API_CALL PFNGLWINDOWPOS4FVMESAPROC glad_glWindowPos4fvMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4FVMESAPROC glad_debug_glWindowPos4fvMESA;
#define glWindowPos4fvMESA glad_debug_glWindowPos4fvMESA
    GLAD_API_CALL PFNGLWINDOWPOS4IMESAPROC glad_glWindowPos4iMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4IMESAPROC glad_debug_glWindowPos4iMESA;
#define glWindowPos4iMESA glad_debug_glWindowPos4iMESA
    GLAD_API_CALL PFNGLWINDOWPOS4IVMESAPROC glad_glWindowPos4ivMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4IVMESAPROC glad_debug_glWindowPos4ivMESA;
#define glWindowPos4ivMESA glad_debug_glWindowPos4ivMESA
    GLAD_API_CALL PFNGLWINDOWPOS4SMESAPROC glad_glWindowPos4sMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4SMESAPROC glad_debug_glWindowPos4sMESA;
#define glWindowPos4sMESA glad_debug_glWindowPos4sMESA
    GLAD_API_CALL PFNGLWINDOWPOS4SVMESAPROC glad_glWindowPos4svMESA;
    GLAD_API_CALL PFNGLWINDOWPOS4SVMESAPROC glad_debug_glWindowPos4svMESA;
#define glWindowPos4svMESA glad_debug_glWindowPos4svMESA
    GLAD_API_CALL PFNGLWINDOWRECTANGLESEXTPROC glad_glWindowRectanglesEXT;
    GLAD_API_CALL PFNGLWINDOWRECTANGLESEXTPROC glad_debug_glWindowRectanglesEXT;
#define glWindowRectanglesEXT glad_debug_glWindowRectanglesEXT
    GLAD_API_CALL PFNGLWRITEMASKEXTPROC glad_glWriteMaskEXT;
    GLAD_API_CALL PFNGLWRITEMASKEXTPROC glad_debug_glWriteMaskEXT;
#define glWriteMaskEXT glad_debug_glWriteMaskEXT

    GLAD_API_CALL void gladSetGLPreCallback(GLADprecallback cb);
    GLAD_API_CALL void gladSetGLPostCallback(GLADpostcallback cb);

    GLAD_API_CALL void gladInstallGLDebug(void);
    GLAD_API_CALL void gladUninstallGLDebug(void);

    GLAD_API_CALL int gladLoadGLUserPtr(GLADuserptrloadfunc load, void* userptr);
    GLAD_API_CALL int gladLoadGL(GLADloadfunc load);

#ifdef __cplusplus
}
#endif
#endif
